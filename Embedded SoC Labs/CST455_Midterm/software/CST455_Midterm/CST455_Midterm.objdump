
CST455_Midterm.elf:     file format elf32-littlenios2
CST455_Midterm.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x04000364

Program Header:
    LOAD off    0x00001000 vaddr 0x04000000 paddr 0x04000000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x04000020 paddr 0x04000020 align 2**12
         filesz 0x0000cc5c memsz 0x0000cc5c flags r-x
    LOAD off    0x0000dc7c vaddr 0x0400cc7c paddr 0x0400e6ec align 2**12
         filesz 0x00001a70 memsz 0x00001a70 flags rw-
    LOAD off    0x0000015c vaddr 0x0401015c paddr 0x0401015c align 2**12
         filesz 0x00000000 memsz 0x0080026c flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  04000000  04000000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000344  04000020  04000020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         0000c884  04000364  04000364  00001364  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00000094  0400cbe8  0400cbe8  0000dbe8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00001a70  0400cc7c  0400e6ec  0000dc7c  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          008002ed  0401015c  0401015c  0001015c  2**2
                  ALLOC, SMALL_DATA
  6 .SDRAM        00000000  048103c8  048103c8  0000f6ec  2**0
                  CONTENTS
  7 .comment      0000002d  00000000  00000000  0000f6ec  2**0
                  CONTENTS, READONLY
  8 .debug_aranges 00000b90  00000000  00000000  0000f720  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  9 .debug_info   0001c40b  00000000  00000000  000102b0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 10 .debug_abbrev 00007f3b  00000000  00000000  0002c6bb  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 11 .debug_line   000085a0  00000000  00000000  000345f6  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_frame  00002b10  00000000  00000000  0003cb98  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_str    0000354f  00000000  00000000  0003f6a8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_alt_sim_info 00000010  00000000  00000000  00042bf8  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_ranges 00000098  00000000  00000000  00042c08  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_line_str 000017b8  00000000  00000000  00042ca0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_loclists 000041c3  00000000  00000000  00044458  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_rnglists 000005db  00000000  00000000  0004861b  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .thread_model 00000003  00000000  00000000  0004ca31  2**0
                  CONTENTS, READONLY
 20 .cpu          0000000e  00000000  00000000  0004ca34  2**0
                  CONTENTS, READONLY
 21 .qsys         00000001  00000000  00000000  0004ca42  2**0
                  CONTENTS, READONLY
 22 .simulation_enabled 00000001  00000000  00000000  0004ca43  2**0
                  CONTENTS, READONLY
 23 .stderr_dev   00000005  00000000  00000000  0004ca44  2**0
                  CONTENTS, READONLY
 24 .stdin_dev    00000005  00000000  00000000  0004ca49  2**0
                  CONTENTS, READONLY
 25 .stdout_dev   00000005  00000000  00000000  0004ca4e  2**0
                  CONTENTS, READONLY
 26 .sopc_system_name 0000000e  00000000  00000000  0004ca53  2**0
                  CONTENTS, READONLY
 27 .quartus_project_dir 00000041  00000000  00000000  0004ca61  2**0
                  CONTENTS, READONLY
 28 .sopcinfo     0005c41c  00000000  00000000  0004caa2  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
04000000 l    d  .entry	00000000 .entry
04000020 l    d  .exceptions	00000000 .exceptions
04000364 l    d  .text	00000000 .text
0400cbe8 l    d  .rodata	00000000 .rodata
0400cc7c l    d  .rwdata	00000000 .rwdata
0401015c l    d  .bss	00000000 .bss
048103c8 l    d  .SDRAM	00000000 .SDRAM
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_line_str	00000000 .debug_line_str
00000000 l    d  .debug_loclists	00000000 .debug_loclists
00000000 l    d  .debug_rnglists	00000000 .debug_rnglists
00000000 l    df *ABS*	00000000 crt0.o
0400039c l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 port_asm.o
04000020 l       .exceptions	00000000 save_context
0400009c l       .exceptions	00000000 save_sp_to_pxCurrentTCB
04000104 l       .exceptions	00000000 irq_test_user
0400016c l       .exceptions	00000000 restore_context
04000124 l       .exceptions	00000000 soft_exceptions
04000134 l       .exceptions	00000000 call_scheduler
04000148 l       .exceptions	00000000 exceptions_unknown_user
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_instruction_exception_entry.c
00000000 l    df *ABS*	00000000 croutine.c
00000000 l    df *ABS*	00000000 event_groups.c
04000a30 l     F .text	00000070 prvTestWaitCondition
00000000 l    df *ABS*	00000000 list.c
00000000 l    df *ABS*	00000000 port.c
04000d30 l     F .text	0000002c prvReadGp
04000e94 l     F .text	00000090 prvSetupTimerInterrupt
00000000 l    df *ABS*	00000000 heap_1.c
040101d8 l     O .bss	00800000 ucHeap
0401015c l     O .bss	00000004 xNextFreeByte
04010160 l     O .bss	00000004 pucAlignedHeap.0
00000000 l    df *ABS*	00000000 queue.c
0400157c l     F .text	00000084 prvInitialiseNewQueue
04001600 l     F .text	00000060 prvInitialiseMutex
04002438 l     F .text	0000018c prvCopyDataToQueue
040027ec l     F .text	00000058 prvIsQueueFull
04002660 l     F .text	000000f4 prvUnlockQueue
040025c4 l     F .text	0000009c prvCopyDataFromQueue
04002754 l     F .text	00000050 prvIsQueueEmpty
040023e8 l     F .text	00000050 prvGetDisinheritPriorityAfterTimeout
00000000 l    df *ABS*	00000000 stream_buffer.c
04003734 l     F .text	00000080 prvInitialiseNewStreamBuffer
040036c0 l     F .text	00000074 prvBytesInBuffer
04002e94 l     F .text	000000d0 prvWriteMessageToBuffer
04003500 l     F .text	000000e0 prvWriteBytesToBuffer
0400323c l     F .text	000000e0 prvReadMessageFromBuffer
040035e0 l     F .text	000000e0 prvReadBytesFromBuffer
00000000 l    df *ABS*	00000000 tasks.c
048101d8 l     O .bss	00000064 pxReadyTasksLists
0481023c l     O .bss	00000014 xDelayedTaskList1
04810250 l     O .bss	00000014 xDelayedTaskList2
04010168 l     O .bss	00000004 pxDelayedTaskList
0401016c l     O .bss	00000004 pxOverflowDelayedTaskList
04810264 l     O .bss	00000014 xPendingReadyList
04810278 l     O .bss	00000014 xTasksWaitingTermination
04010170 l     O .bss	00000004 uxDeletedTasksWaitingCleanUp
0481028c l     O .bss	00000014 xSuspendedTaskList
04010174 l     O .bss	00000004 uxCurrentNumberOfTasks
04010178 l     O .bss	00000004 xTickCount
0401017c l     O .bss	00000004 uxTopReadyPriority
04010180 l     O .bss	00000004 xSchedulerRunning
04010184 l     O .bss	00000004 xPendedTicks
04010188 l     O .bss	00000004 xYieldPending
0401018c l     O .bss	00000004 xNumOfOverflows
04010190 l     O .bss	00000004 uxTaskNumber
04010194 l     O .bss	00000004 xNextTaskUnblockTime
04010198 l     O .bss	00000004 xIdleTaskHandle
0401019c l     O .bss	00000004 uxSchedulerSuspended
040038a8 l     F .text	000001ac prvInitialiseNewTask
04003a54 l     F .text	000001b8 prvAddNewTaskToReadyList
04005700 l     F .text	000000c0 prvInitialiseTaskLists
04005948 l     F .text	00000048 prvResetNextTaskUnblockTime
04005904 l     F .text	00000044 prvDeleteTCB
04006e3c l     F .text	00000144 prvAddCurrentTaskToDelayedList
0400427c l     F .text	0000006c prvTaskIsTaskSuspended
040056e4 l     F .text	0000001c prvIdleTask
040057c0 l     F .text	00000080 prvCheckTasksWaitingTermination
04005840 l     F .text	00000064 prvTaskCheckFreeStackSpace
00000000 l    df *ABS*	00000000 timers.c
00000000 l    df *ABS*	00000000 main.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 lib2-mul.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 findfp.c
04007c38 l     F .text	00000008 __fp_lock
04007c4c l     F .text	00000008 __fp_unlock
04007c54 l     F .text	00000168 __sinit.part.0
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 impure.c
0400cc7c l     O .rwdata	00000424 impure_data
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 closer.c
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 lseekr.c
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 readr.c
00000000 l    df *ABS*	00000000 fstatr.c
00000000 l    df *ABS*	00000000 isattyr.c
00000000 l    df *ABS*	00000000 alt_close.c
0400a4e4 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_dev.c
0400a5fc l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_fstat.c
0400a628 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_isatty.c
0400a9b8 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_load.c
0400aaa4 l     F .text	00000068 alt_load_section
00000000 l    df *ABS*	00000000 alt_lseek.c
0400ab90 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
00000000 l    df *ABS*	00000000 alt_read.c
0400ad70 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
0400e6e0 l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_write.c
0400afdc l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_sys_init.c
0400b11c l     F .text	00000034 alt_dev_reg
0400d650 l     O .rwdata	00001060 DEBUG
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
0400b410 l     F .text	00000214 altera_avalon_jtag_uart_irq
0400b624 l     F .text	000000a8 altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
0400bc70 l     F .text	0000007c alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
0400bef0 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_do_ctors.c
00000000 l    df *ABS*	00000000 alt_do_dtors.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
0400c130 l     F .text	000000d4 alt_open_fd
00000000 l    df *ABS*	00000000 alt_open.c
0400c280 l     F .text	0000003c alt_get_errno
0400c2bc l     F .text	000000dc alt_file_locked
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 alt_exit.c
040101c8 g     O .bss	00000004 alt_instruction_exception_handler
0400a48c g     F .text	00000058 _isatty_r
0400acac g     F .text	0000007c alt_main
04007ac0 g     F .text	000000d0 _puts_r
048102c8 g     O .bss	00000100 alt_irq
0400a138 g     F .text	00000064 _lseek_r
0400015c g       .exceptions	00000000 restore_sp_from_pxCurrentTCB
04004f70 g     F .text	000000bc vTaskPlaceOnUnorderedEventList
0400116c g     F .text	0000002c xPortGetFreeHeapSize
04000788 g     F .text	0000003c xEventGroupGetBitsFromISR
0400e6ec g       *ABS*	00000000 __flash_rwdata_start
0400724c g     F .text	00000120 taskReadSWs
048103c8 g       *ABS*	00000000 __alt_heap_start
04003e4c g     F .text	00000058 uxTaskPriorityGet
040101a0 g     O .bss	00000004 pushbutton_queue
040096ac g     F .text	0000005c __sseek
04007f7c g     F .text	00000010 __sinit
0400736c g     F .text	00000084 taskReadPBs
04007dbc g     F .text	00000078 __sfmoreglue
04002f64 g     F .text	00000160 xStreamBufferReceive
0400ad4c g     F .text	00000024 __malloc_unlock
04003d00 g     F .text	000000f0 xTaskDelayUntil
040003f4 g     F .text	00000184 xEventGroupSync
04008e5c g     F .text	00000128 memmove
04006d90 g     F .text	000000ac ulTaskGenericNotifyValueClear
04005f7c g     F .text	00000054 vTaskEnterCritical
04007f68 g     F .text	00000014 _cleanup
04001a0c g     F .text	00000108 xQueueGenericSendFromISR
04004a64 g     F .text	00000040 pcTaskGetName
04002aec g     F .text	000000a4 xStreamBufferSpacesAvailable
0400c6c8 g     F .text	00000024 altera_nios2_gen2_irq_init
040029cc g     F .text	000000b4 xStreamBufferReset
04000000 g     F .entry	0000000c __reset
040016bc g     F .text	00000090 xQueueGiveMutexRecursive
04010164 g     O .bss	00000004 pxCurrentTCB
04000020 g       *ABS*	00000000 __flash_exceptions_start
0400a42c g     F .text	00000060 _fstat_r
040101b4 g     O .bss	00000004 errno
04009624 g     F .text	00000008 __seofread
04002da0 g     F .text	000000f4 xStreamBufferSendFromISR
040101c0 g     O .bss	00000004 alt_argv
040166b0 g       *ABS*	00000000 _gp
04003ef0 g     F .text	00000268 vTaskPrioritySet
04005598 g     F .text	0000003c vTaskInternalSetTimeOutState
04000578 g     F .text	000001a8 xEventGroupWaitBits
04000f68 g     F .text	000000d4 _alt_ic_isr_register
0400d4d0 g     O .rwdata	00000180 alt_fd_list
04000e3c g     F .text	00000038 xPortStartScheduler
040046a8 g     F .text	00000048 vTaskEndScheduler
0400c6ec g     F .text	00000090 alt_find_dev
04007880 g     F .text	00000100 memcpy
04004f20 g     F .text	00000050 vTaskPlaceOnEventList
040052fc g     F .text	00000250 vTaskRemoveFromUnorderedEventList
04007c40 g     F .text	0000000c _cleanup_r
0400c204 g     F .text	0000007c alt_io_redirect
04002264 g     F .text	0000007c xQueuePeekFromISR
0400cbe8 g       *ABS*	00000000 __DTOR_END__
04007b90 g     F .text	00000010 puts
0400c0bc g     F .text	00000074 alt_exception_cause_generated_bad_addr
04001124 g     F .text	00000024 vPortFree
04001dac g     F .text	00000210 xQueueSemaphoreTake
0400b828 g     F .text	00000220 altera_avalon_jtag_uart_read
04007798 g     F .text	00000064 .hidden __udivsi3
0400a9f4 g     F .text	000000b0 isatty
040058a4 g     F .text	00000060 uxTaskGetStackHighWaterMark
04000b34 g     F .text	0000008c vListInsertEnd
040101b0 g     O .bss	00000004 __malloc_top_pad
040060b0 g     F .text	00000104 ulTaskGenericNotifyTake
040003a0 g     F .text	00000054 xEventGroupCreate
04007fc4 g     F .text	000004a8 __sfvwrite_r
04009578 g     F .text	00000058 _sbrk_r
040009b8 g     F .text	0000003c vEventGroupSetBitsCallback
04004470 g     F .text	000001a4 xTaskResumeFromISR
0400a3c8 g     F .text	00000064 _read_r
04000b08 g     F .text	0000002c vListInitialiseItem
0400e6d4 g     O .rwdata	00000004 alt_max_fd
04000f24 g     F .text	00000044 vPortSysTickHandler
04009918 g     F .text	000000f8 _fclose_r
04001c04 g     F .text	000001a8 xQueueReceive
04009c88 g     F .text	00000084 fflush
040101ac g     O .bss	00000004 __malloc_max_sbrked_mem
04003ea4 g     F .text	0000004c uxTaskPriorityGetFromISR
0400abcc g     F .text	000000e0 lseek
0400e6b4 g     O .rwdata	00000004 _global_impure_ptr
040007c4 g     F .text	00000180 xEventGroupSetBits
04008f84 g     F .text	000005f4 _realloc_r
048103c8 g       *ABS*	00000000 __bss_end
0400a8d0 g     F .text	000000e8 alt_iic_isr_register
0400c59c g     F .text	0000012c alt_tick
0400103c g     F .text	000000e8 pvPortMalloc
04007f9c g     F .text	00000014 __fp_lock_all
0400a884 g     F .text	0000004c alt_ic_irq_enabled
040023ac g     F .text	0000003c vQueueDelete
04000e74 g     F .text	00000020 vPortEndScheduler
04000aa0 g     F .text	00000068 vListInitialise
0400331c g     F .text	00000058 xStreamBufferIsEmpty
0400c4f8 g     F .text	000000a4 alt_alarm_stop
040101b8 g     O .bss	00000004 alt_irq_active
0400023c g     F .exceptions	000000c8 alt_irq_handler
0400d4a8 g     O .rwdata	00000028 alt_dev_null
040049f0 g     F .text	00000028 xTaskGetTickCount
04001858 g     F .text	000001b4 xQueueGenericSend
04002bd0 g     F .text	000001d0 xStreamBufferSend
04003478 g     F .text	00000088 xStreamBufferReceiveCompletedFromISR
0400bed0 g     F .text	00000020 alt_dcache_flush_all
04006a38 g     F .text	000002cc vTaskGenericNotifyGiveFromISR
040030c4 g     F .text	00000098 xStreamBufferNextMessageLengthBytes
04005bc0 g     F .text	000001b8 xTaskPriorityDisinherit
0400e6ec g       *ABS*	00000000 __ram_rwdata_end
0400e6cc g     O .rwdata	00000008 alt_dev_list
0400b018 g     F .text	00000104 write
0400502c g     F .text	000002d0 xTaskRemoveFromEventList
0400cc7c g       *ABS*	00000000 __ram_rodata_end
0400a664 g     F .text	000000bc fstat
04000720 g     F .text	00000068 xEventGroupClearBits
04000000 g       *ABS*	00000000 __alt_mem_SDRAM
04001fbc g     F .text	000001b0 xQueuePeek
040077fc g     F .text	0000005c .hidden __umodsi3
048103c8 g       *ABS*	00000000 end
0400315c g     F .text	000000e0 xStreamBufferReceiveFromISR
04003c0c g     F .text	000000f4 vTaskDelete
0400b350 g     F .text	000000c0 altera_avalon_jtag_uart_init
04000304 g     F .exceptions	00000060 alt_instruction_exception_entry
04006078 g     F .text	00000038 pvTaskIncrementMutexHeldCount
0400cbe8 g       *ABS*	00000000 __CTOR_LIST__
08000000 g       *ABS*	00000000 __alt_stack_pointer
0400bcec g     F .text	00000084 alt_avalon_timer_sc_init
0400ba48 g     F .text	00000228 altera_avalon_jtag_uart_write
04007f8c g     F .text	00000004 __sfp_lock_acquire
04008d60 g     F .text	000000fc memchr
040055d4 g     F .text	000000e8 xTaskCheckForTimeOut
04009e30 g     F .text	00000308 _free_r
040059b8 g     F .text	00000208 xTaskPriorityInherit
0400ca8c g     F .text	00000120 __call_exitprocs
040061b4 g     F .text	00000164 xTaskGenericNotifyWait
04002968 g     F .text	00000064 vStreamBufferDelete
0400e6bc g     O .rwdata	00000004 __malloc_sbrk_base
04000364 g     F .text	0000003c _start
040101cc g     O .bss	00000004 _alt_tick_rate
040046f0 g     F .text	0000002c vTaskSuspendAll
04003374 g     F .text	0000007c xStreamBufferIsFull
04004a18 g     F .text	0000002c xTaskGetTickCountFromISR
040101d0 g     O .bss	00000008 _alt_nticks
0400adac g     F .text	00000108 read
0400b18c g     F .text	00000060 alt_sys_init
04000c98 g     F .text	00000098 uxListRemove
0400c9fc g     F .text	00000090 __register_exitproc
04002894 g     F .text	000000d4 xStreamBufferGenericCreate
0400b6cc g     F .text	00000068 altera_avalon_jtag_uart_close
04007858 g     F .text	00000028 .hidden __mulsi3
0400cc7c g       *ABS*	00000000 __ram_rwdata_start
0400cbe8 g       *ABS*	00000000 __ram_rodata_start
048102a0 g     O .bss	00000028 __malloc_current_mallinfo
040042e8 g     F .text	00000188 vTaskResume
04004e30 g     F .text	000000f0 vTaskSwitchContext
0400b1ec g     F .text	00000060 altera_avalon_jtag_uart_read_fd
0400c884 g     F .text	000000b8 alt_get_fd
040098c0 g     F .text	00000058 _close_r
0400c984 g     F .text	00000078 memcmp
0400b2ac g     F .text	00000050 altera_avalon_jtag_uart_close_fd
048103c8 g       *ABS*	00000000 __alt_stack_base
0400b2fc g     F .text	00000054 altera_avalon_jtag_uart_ioctl_fd
04009774 g     F .text	0000014c __swsetup_r
04004158 g     F .text	00000124 vTaskSuspend
04007e34 g     F .text	00000134 __sfp
04004aa4 g     F .text	00000050 xTaskCatchUpTicks
04004a44 g     F .text	00000020 uxTaskGetNumberOfTasks
0400d0a0 g     O .rwdata	00000408 __malloc_av_
04007f98 g     F .text	00000004 __sinit_lock_release
040095d0 g     F .text	00000054 __sread
0400c77c g     F .text	00000108 alt_find_file
0400bf2c g     F .text	000000a8 alt_dev_llist_insert
0400ad28 g     F .text	00000024 __malloc_lock
0400af24 g     F .text	000000b8 sbrk
0400174c g     F .text	0000009c xQueueTakeMutexRecursive
04009c28 g     F .text	00000060 _fflush_r
04000944 g     F .text	00000074 vEventGroupDelete
04006318 g     F .text	00000348 xTaskGenericNotify
0401015c g       *ABS*	00000000 __bss_start
040101a4 g     O .bss	00000004 switch_queue
04007980 g     F .text	00000140 memset
04006f80 g     F .text	000000f0 main
040101c4 g     O .bss	00000004 alt_envp
040101a8 g     O .bss	00000004 __malloc_max_total_mem
0400b24c g     F .text	00000060 altera_avalon_jtag_uart_write_fd
04000bc0 g     F .text	000000d8 vListInsert
04009708 g     F .text	00000008 __sclose
08000000 g       *ABS*	00000000 __alt_heap_limit
04009a10 g     F .text	00000010 fclose
040085ac g     F .text	000007b4 _malloc_r
0400e6d8 g     O .rwdata	00000004 alt_errno
0400846c g     F .text	00000098 _fwalk
0400216c g     F .text	000000f8 xQueueReceiveFromISR
04005990 g     F .text	00000028 xTaskGetCurrentTaskHandle
040076a4 g     F .text	00000080 .hidden __divsi3
040013d8 g     F .text	000001a4 xQueueGenericCreate
04009d0c g     F .text	00000124 _malloc_trim_r
0400cbe8 g       *ABS*	00000000 __CTOR_END__
040017e8 g     F .text	00000070 xQueueCreateCountingSemaphore
0400cbe8 g       *ABS*	00000000 __flash_rodata_start
0400cbe8 g       *ABS*	00000000 __DTOR_LIST__
04002a80 g     F .text	0000006c xStreamBufferSetTriggerLevel
04006660 g     F .text	000003d8 xTaskGenericNotifyFromISR
0400b150 g     F .text	0000003c alt_irq_init
0400aeb4 g     F .text	00000070 alt_release_fd
0400471c g     F .text	000002d4 xTaskResumeAll
0400e6b0 g     O .rwdata	00000004 uxTopUsedPriority
04002320 g     F .text	00000054 uxQueueSpacesAvailable
04004614 g     F .text	00000094 vTaskStartScheduler
0400c93c g     F .text	00000014 atexit
04009710 g     F .text	00000064 _write_r
04002844 g     F .text	00000050 xQueueIsQueueFullFromISR
0400e6b8 g     O .rwdata	00000004 _impure_ptr
040101bc g     O .bss	00000004 alt_argc
04009a20 g     F .text	00000208 __sflush_r
0400c038 g     F .text	00000064 _do_dtors
04000020 g       .exceptions	00000000 alt_irq_entry
04007fb0 g     F .text	00000014 __fp_unlock_all
040056bc g     F .text	00000028 vTaskMissedYield
0400e6c4 g     O .rwdata	00000008 alt_fs_list
040022e0 g     F .text	00000040 uxQueueMessagesWaiting
04004af4 g     F .text	0000033c xTaskIncrementTick
04000020 g       *ABS*	00000000 __ram_exceptions_start
0400a33c g     F .text	0000008c __swhatbuf_r
0400a720 g     F .text	00000050 alt_ic_isr_register
04001198 g     F .text	00000240 xQueueGenericReset
0400e6ec g       *ABS*	00000000 _edata
048103c8 g       *ABS*	00000000 _end
04000364 g       *ABS*	00000000 __ram_exceptions_end
0400b734 g     F .text	000000f4 altera_avalon_jtag_uart_ioctl
040037b4 g     F .text	000000f4 xTaskCreate
04001148 g     F .text	00000024 vPortInitialiseBlocks
04006d04 g     F .text	0000008c xTaskGenericNotifyStateClear
0400a7f8 g     F .text	0000008c alt_ic_irq_disable
0400962c g     F .text	00000080 __swrite
0400e6c0 g     O .rwdata	00000004 __malloc_trim_threshold
0400c950 g     F .text	00000034 exit
04008504 g     F .text	000000a8 _fwalk_reent
040073f0 g     F .text	000002b4 taskLEDControl
04007724 g     F .text	00000074 .hidden __modsi3
04003df0 g     F .text	0000005c vTaskDelay
08000000 g       *ABS*	00000000 __alt_data_end
04000020 g     F .exceptions	00000000 alt_exception
04007f90 g     F .text	00000004 __sfp_lock_release
04005d78 g     F .text	00000204 vTaskPriorityDisinheritAfterTimeout
0400cbac g     F .text	0000003c _exit
0400bd70 g     F .text	00000160 alt_alarm_start
0400a19c g     F .text	000001a0 __smakebuf_r
04005fd0 g     F .text	00000064 vTaskExitCritical
04007ba0 g     F .text	00000098 strlen
04000d5c g     F .text	000000e0 pxPortInitialiseStack
0400c398 g     F .text	00000160 open
0400c09c g     F .text	00000020 alt_icache_flush_all
0400554c g     F .text	0000004c vTaskSetTimeOutState
0400e6dc g     O .rwdata	00000004 alt_priority_mask
0400a770 g     F .text	00000088 alt_ic_irq_enable
04002374 g     F .text	00000038 uxQueueMessagesWaitingFromISR
040027a4 g     F .text	00000048 xQueueIsQueueEmptyFromISR
04002b90 g     F .text	00000040 xStreamBufferBytesAvailable
0400e6e4 g     O .rwdata	00000008 alt_alarm_list
0400bfd4 g     F .text	00000064 _do_ctors
04006034 g     F .text	00000044 uxTaskResetEventItemValue
04001660 g     F .text	0000005c xQueueCreateMutex
0400a520 g     F .text	000000dc close
0400ab0c g     F .text	00000084 alt_load
04007070 g     F .text	000001dc taskDisplaySevenSeg
040009f4 g     F .text	0000003c vEventGroupClearBitsCallback
040033f0 g     F .text	00000088 xStreamBufferSendCompletedFromISR
04001b14 g     F .text	000000f0 xQueueGiveFromISR
04007f94 g     F .text	00000004 __sinit_lock_acquire



Disassembly of section .entry:

04000000 <__reset>:
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
 4000000:	00410034 	movhi	at,1024
    ori r1, r1, %lo(_start)
 4000004:	0840d914 	ori	at,at,868
    jmp r1
 4000008:	0800683a 	jmp	at
	...

Disassembly of section .exceptions:

04000020 <alt_exception>:
# Entry point for exceptions.
.section .exceptions.entry.user, "xa"

# Save the entire context of a task.
save_context:
	addi	sp,	sp, -116		# Create space on the stack.
 4000020:	deffe304 	addi	sp,sp,-116
	stw		ra, 0(sp)
 4000024:	dfc00015 	stw	ra,0(sp)
								# Leave a gap for muldiv 0
	stw		at, 8(sp)
 4000028:	d8400215 	stw	at,8(sp)
	stw		r2, 12(sp)
 400002c:	d8800315 	stw	r2,12(sp)
	stw		r3, 16(sp)
 4000030:	d8c00415 	stw	r3,16(sp)
	stw		r4, 20(sp)
 4000034:	d9000515 	stw	r4,20(sp)
	stw		r5, 24(sp)
 4000038:	d9400615 	stw	r5,24(sp)
	stw		r6, 28(sp)
 400003c:	d9800715 	stw	r6,28(sp)
	stw		r7, 32(sp)
 4000040:	d9c00815 	stw	r7,32(sp)
	stw		r8, 36(sp)
 4000044:	da000915 	stw	r8,36(sp)
	stw		r9, 40(sp)
 4000048:	da400a15 	stw	r9,40(sp)
	stw		r10, 44(sp)
 400004c:	da800b15 	stw	r10,44(sp)
	stw		r11, 48(sp)
 4000050:	dac00c15 	stw	r11,48(sp)
	stw		r12, 52(sp)
 4000054:	db000d15 	stw	r12,52(sp)
	stw		r13, 56(sp)
 4000058:	db400e15 	stw	r13,56(sp)
	stw		r14, 60(sp)
 400005c:	db800f15 	stw	r14,60(sp)
	stw		r15, 64(sp)
 4000060:	dbc01015 	stw	r15,64(sp)
	rdctl	r5, estatus 		# Save the eStatus
 4000064:	000b307a 	rdctl	r5,estatus
	stw		r5, 68(sp)
 4000068:	d9401115 	stw	r5,68(sp)
	addi	r15, ea, -4			# Instruction that caused exception
 400006c:	ebffff04 	addi	r15,ea,-4
	stw		r15, 72(sp)			# Save as EA
 4000070:	dbc01215 	stw	r15,72(sp)
	stw		r16, 76(sp)			# Save the remaining registers
 4000074:	dc001315 	stw	r16,76(sp)
	stw		r17, 80(sp)
 4000078:	dc401415 	stw	r17,80(sp)
	stw		r18, 84(sp)
 400007c:	dc801515 	stw	r18,84(sp)
	stw		r19, 88(sp)
 4000080:	dcc01615 	stw	r19,88(sp)
	stw		r20, 92(sp)
 4000084:	dd001715 	stw	r20,92(sp)
	stw		r21, 96(sp)
 4000088:	dd401815 	stw	r21,96(sp)
	stw		r22, 100(sp)
 400008c:	dd801915 	stw	r22,100(sp)
	stw		r23, 104(sp)
 4000090:	ddc01a15 	stw	r23,104(sp)
	stw		gp, 108(sp)
 4000094:	de801b15 	stw	gp,108(sp)
	stw		fp, 112(sp)
 4000098:	df001c15 	stw	fp,112(sp)

0400009c <save_sp_to_pxCurrentTCB>:
 400009c:	06010074 	movhi	et,1025

save_sp_to_pxCurrentTCB:
	movia	et, pxCurrentTCB	# Load the address of the pxCurrentTCB pointer
 40000a0:	c6005904 	addi	et,et,356
	ldw		et, (et)			# Load the value of the pxCurrentTCB pointer
 40000a4:	c6000017 	ldw	et,0(et)
	stw		sp, (et)			# Store the stack pointer into the top of the TCB
 40000a8:	c6c00015 	stw	sp,0(et)

	br		irq_test_user		# skip the section .exceptions.entry
 40000ac:	00001506 	br	4000104 <irq_test_user>

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
 40000b0:	deffed04 	addi	sp,sp,-76
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
 40000b4:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
 40000b8:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
 40000bc:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
 40000c0:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
 40000c4:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
 40000c8:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
 40000cc:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
 40000d0:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
 40000d4:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
 40000d8:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
 40000dc:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
 40000e0:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
 40000e4:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
 40000e8:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
 40000ec:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
 40000f0:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
 40000f4:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
 40000f8:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
 40000fc:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
 4000100:	dbc01215 	stw	r15,72(sp)

04000104 <irq_test_user>:
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
 4000104:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
 4000108:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
 400010c:	10000326 	beq	r2,zero,400011c <irq_test_user+0x18>
        beq   r4, zero, .Lnot_irq
 4000110:	20000226 	beq	r4,zero,400011c <irq_test_user+0x18>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
 4000114:	400023c0 	call	400023c <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
 4000118:	00001006 	br	400015c <restore_sp_from_pxCurrentTCB>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw ea, 72(sp) /* EA is PC+4 so will skip over instruction causing exception */
 400011c:	df401215 	stw	ea,72(sp)
.Lunknown_16bit:
        addi.n r4, r4, 2 /* Need PC+2 to skip over instruction causing exception */
        stw r4, 72(sp)

#else /* CDX is not Enabled and all instructions are 32bits */
        ldw r2, -4(ea) /* Instruction value that caused exception */
 4000120:	e8bfff17 	ldw	r2,-4(ea)

04000124 <soft_exceptions>:

	eret					# Return to address ea, loading eStatus into Status.

	.section .exceptions.soft, "xa"
soft_exceptions:
	movhi	r3, 0x003b				/* upper half of trap opcode */
 4000124:	00c00ef4 	movhi	r3,59
	ori		r3, r3, 0x683a			/* lower half of trap opcode */
 4000128:	18da0e94 	ori	r3,r3,26682
	beq		r2, r3, call_scheduler
 400012c:	10c00126 	beq	r2,r3,4000134 <call_scheduler>
	br		exceptions_unknown_user			# its something else
 4000130:	00000506 	br	4000148 <exceptions_unknown_user>

04000134 <call_scheduler>:

call_scheduler:
	stw		ea, 72(sp)						# EA is PC+4 so will skip over instruction causing exception
 4000134:	df401215 	stw	ea,72(sp)
 4000138:	03c10034 	movhi	r15,1024
	movia	r15, vTaskSwitchContext			# Pick the next context - use long call version in place of "call"
 400013c:	7bd38c04 	addi	r15,r15,20016
	callr	r15
 4000140:	783ee83a 	callr	r15
	br		restore_sp_from_pxCurrentTCB	# Switch in the task context and restore.
 4000144:	00000506 	br	400015c <restore_sp_from_pxCurrentTCB>

04000148 <exceptions_unknown_user>:
 4000148:	e93fff04 	addi	r4,ea,-4
 400014c:	40003040 	call	4000304 <alt_instruction_exception_entry>
 4000150:	1000021e 	bne	r2,zero,400015c <restore_sp_from_pxCurrentTCB>
 4000154:	ebffff04 	addi	r15,ea,-4
 4000158:	dbc01215 	stw	r15,72(sp)

0400015c <restore_sp_from_pxCurrentTCB>:
 400015c:	06010074 	movhi	et,1025
	movia	et, pxCurrentTCB		# Load the address of the pxCurrentTCB pointer
 4000160:	c6005904 	addi	et,et,356
	ldw		et, (et)				# Load the value of the pxCurrentTCB pointer
 4000164:	c6000017 	ldw	et,0(et)
	ldw		sp, (et)				# Load the stack pointer with the top value of the TCB
 4000168:	c6c00017 	ldw	sp,0(et)

0400016c <restore_context>:
	ldw		ra, 0(sp)		# Restore the registers.
 400016c:	dfc00017 	ldw	ra,0(sp)
	ldw		at, 8(sp)
 4000170:	d8400217 	ldw	at,8(sp)
	ldw		r2, 12(sp)
 4000174:	d8800317 	ldw	r2,12(sp)
	ldw		r3, 16(sp)
 4000178:	d8c00417 	ldw	r3,16(sp)
	ldw		r4, 20(sp)
 400017c:	d9000517 	ldw	r4,20(sp)
	ldw		r5, 24(sp)
 4000180:	d9400617 	ldw	r5,24(sp)
	ldw		r6, 28(sp)
 4000184:	d9800717 	ldw	r6,28(sp)
	ldw		r7, 32(sp)
 4000188:	d9c00817 	ldw	r7,32(sp)
	ldw		r8, 36(sp)
 400018c:	da000917 	ldw	r8,36(sp)
	ldw		r9, 40(sp)
 4000190:	da400a17 	ldw	r9,40(sp)
	ldw		r10, 44(sp)
 4000194:	da800b17 	ldw	r10,44(sp)
	ldw		r11, 48(sp)
 4000198:	dac00c17 	ldw	r11,48(sp)
	ldw		r12, 52(sp)
 400019c:	db000d17 	ldw	r12,52(sp)
	ldw		r13, 56(sp)
 40001a0:	db400e17 	ldw	r13,56(sp)
	ldw		r14, 60(sp)
 40001a4:	db800f17 	ldw	r14,60(sp)
	ldw		r15, 64(sp)
 40001a8:	dbc01017 	ldw	r15,64(sp)
	ldw		et, 68(sp)		# Load the eStatus
 40001ac:	de001117 	ldw	et,68(sp)
	wrctl	estatus, et 	# Write the eStatus
 40001b0:	c001707a 	wrctl	estatus,et
	ldw		ea, 72(sp)		# Load the Program Counter
 40001b4:	df401217 	ldw	ea,72(sp)
	ldw		r16, 76(sp)
 40001b8:	dc001317 	ldw	r16,76(sp)
	ldw		r17, 80(sp)
 40001bc:	dc401417 	ldw	r17,80(sp)
	ldw		r18, 84(sp)
 40001c0:	dc801517 	ldw	r18,84(sp)
	ldw		r19, 88(sp)
 40001c4:	dcc01617 	ldw	r19,88(sp)
	ldw		r20, 92(sp)
 40001c8:	dd001717 	ldw	r20,92(sp)
	ldw		r21, 96(sp)
 40001cc:	dd401817 	ldw	r21,96(sp)
	ldw		r22, 100(sp)
 40001d0:	dd801917 	ldw	r22,100(sp)
	ldw		r23, 104(sp)
 40001d4:	ddc01a17 	ldw	r23,104(sp)
	ldw		gp, 108(sp)
 40001d8:	de801b17 	ldw	gp,108(sp)
	ldw		fp, 112(sp)
 40001dc:	df001c17 	ldw	fp,112(sp)
	addi	sp,	sp, 116		# Release stack space
 40001e0:	dec01d04 	addi	sp,sp,116
	eret					# Return to address ea, loading eStatus into Status.
 40001e4:	ef80083a 	eret
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
 40001e8:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
 40001ec:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
 40001f0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
 40001f4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
 40001f8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
 40001fc:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
 4000200:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
 4000204:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
 4000208:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
 400020c:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
 4000210:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
 4000214:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
 4000218:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
 400021c:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
 4000220:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
 4000224:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
 4000228:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
 400022c:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
 4000230:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
 4000234:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
 4000238:	ef80083a 	eret

0400023c <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
 400023c:	defff904 	addi	sp,sp,-28
 4000240:	dfc00615 	stw	ra,24(sp)
 4000244:	df000515 	stw	fp,20(sp)
 4000248:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
 400024c:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
 4000250:	0005313a 	rdctl	r2,ipending
 4000254:	e0bffc15 	stw	r2,-16(fp)

  return active;
 4000258:	e0bffc17 	ldw	r2,-16(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
 400025c:	e0bfff15 	stw	r2,-4(fp)

  do
  {
    i = 0;
 4000260:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
 4000264:	00800044 	movi	r2,1
 4000268:	e0bffe15 	stw	r2,-8(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
 400026c:	e0ffff17 	ldw	r3,-4(fp)
 4000270:	e0bffe17 	ldw	r2,-8(fp)
 4000274:	1884703a 	and	r2,r3,r2
 4000278:	10001126 	beq	r2,zero,40002c0 <alt_irq_handler+0x84>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
 400027c:	e0bffd17 	ldw	r2,-12(fp)
 4000280:	100690fa 	slli	r3,r2,3
 4000284:	00812074 	movhi	r2,1153
 4000288:	1885883a 	add	r2,r3,r2
 400028c:	10c0b217 	ldw	r3,712(r2)
 4000290:	e0bffd17 	ldw	r2,-12(fp)
 4000294:	100890fa 	slli	r4,r2,3
 4000298:	00812074 	movhi	r2,1153
 400029c:	2085883a 	add	r2,r4,r2
 40002a0:	1080b317 	ldw	r2,716(r2)
 40002a4:	1009883a 	mov	r4,r2
 40002a8:	183ee83a 	callr	r3
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
 40002ac:	0001883a 	nop
  NIOS2_READ_IPENDING (active);
 40002b0:	0005313a 	rdctl	r2,ipending
 40002b4:	e0bffb15 	stw	r2,-20(fp)
  return active;
 40002b8:	e0bffb17 	ldw	r2,-20(fp)
 40002bc:	00000706 	br	40002dc <alt_irq_handler+0xa0>
      }
      mask <<= 1;
 40002c0:	e0bffe17 	ldw	r2,-8(fp)
 40002c4:	1085883a 	add	r2,r2,r2
 40002c8:	e0bffe15 	stw	r2,-8(fp)
      i++;
 40002cc:	e0bffd17 	ldw	r2,-12(fp)
 40002d0:	10800044 	addi	r2,r2,1
 40002d4:	e0bffd15 	stw	r2,-12(fp)
      if (active & mask)
 40002d8:	003fe406 	br	400026c <alt_irq_handler+0x30>

    } while (1);

    active = alt_irq_pending ();
 40002dc:	e0bfff15 	stw	r2,-4(fp)
    
  } while (active);
 40002e0:	e0bfff17 	ldw	r2,-4(fp)
 40002e4:	103fde1e 	bne	r2,zero,4000260 <alt_irq_handler+0x24>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
 40002e8:	0001883a 	nop
}
 40002ec:	0001883a 	nop
 40002f0:	e037883a 	mov	sp,fp
 40002f4:	dfc00117 	ldw	ra,4(sp)
 40002f8:	df000017 	ldw	fp,0(sp)
 40002fc:	dec00204 	addi	sp,sp,8
 4000300:	f800283a 	ret

04000304 <alt_instruction_exception_entry>:
 * that handler if it has been registered. Absent a handler, it will
 * break break or hang as discussed below.
 */
int 
alt_instruction_exception_entry (alt_u32 exception_pc)
{
 4000304:	defffb04 	addi	sp,sp,-20
 4000308:	dfc00415 	stw	ra,16(sp)
 400030c:	df000315 	stw	fp,12(sp)
 4000310:	df000304 	addi	fp,sp,12
 4000314:	e13ffd15 	stw	r4,-12(fp)
  cause = ( (cause & NIOS2_EXCEPTION_REG_CAUSE_MASK) >>
              NIOS2_EXCEPTION_REG_CAUSE_OFST );

  NIOS2_READ_BADADDR(badaddr);
#else
  cause = NIOS2_EXCEPTION_CAUSE_NOT_PRESENT;
 4000318:	00bfffc4 	movi	r2,-1
 400031c:	e0bfff15 	stw	r2,-4(fp)
  badaddr = 0;
 4000320:	e03ffe15 	stw	zero,-8(fp)
#endif /* NIOS2_HAS_EXTRA_EXCEPTION_INFO */

  if(alt_instruction_exception_handler) {
 4000324:	d0a6c617 	ldw	r2,-25832(gp)
 4000328:	10000726 	beq	r2,zero,4000348 <alt_instruction_exception_entry+0x44>
     * Call handler. Its return value indicates whether the exception-causing
     * instruction should be re-issued. The code that called us,
     * alt_eceptions_entry.S, will look at this value and adjust the ea
     * register as necessary
     */
    return alt_instruction_exception_handler(cause, exception_pc, badaddr);
 400032c:	d0a6c617 	ldw	r2,-25832(gp)
 4000330:	e0ffff17 	ldw	r3,-4(fp)
 4000334:	e1bffe17 	ldw	r6,-8(fp)
 4000338:	e17ffd17 	ldw	r5,-12(fp)
 400033c:	1809883a 	mov	r4,r3
 4000340:	103ee83a 	callr	r2
 4000344:	00000206 	br	4000350 <alt_instruction_exception_entry+0x4c>
   *    (a peripheral which negates its interrupt output before its
   *    interrupt handler has been executed will cause spurious interrupts)
   */
  else {
#ifdef NIOS2_HAS_DEBUG_STUB
    NIOS2_BREAK();
 4000348:	003da03a 	break	0
      ;
#endif /* NIOS2_HAS_DEBUG_STUB */
  }

  /* We should not get here. Remove compiler warning. */
  return NIOS2_EXCEPTION_RETURN_REISSUE_INST;
 400034c:	0005883a 	mov	r2,zero
}
 4000350:	e037883a 	mov	sp,fp
 4000354:	dfc00117 	ldw	ra,4(sp)
 4000358:	df000017 	ldw	fp,0(sp)
 400035c:	dec00204 	addi	sp,sp,8
 4000360:	f800283a 	ret

Disassembly of section .text:

04000364 <_start>:

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
 4000364:	06c20034 	movhi	sp,2048
    ori sp, sp, %lo(__alt_stack_pointer)
 4000368:	dec00014 	ori	sp,sp,0
    movhi gp, %hi(_gp)
 400036c:	06810074 	movhi	gp,1025
    ori gp, gp, %lo(_gp)
 4000370:	d699ac14 	ori	gp,gp,26288
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
 4000374:	00810074 	movhi	r2,1025
    ori r2, r2, %lo(__bss_start)
 4000378:	10805714 	ori	r2,r2,348

    movhi r3, %hi(__bss_end)
 400037c:	00c12074 	movhi	r3,1153
    ori r3, r3, %lo(__bss_end)
 4000380:	18c0f214 	ori	r3,r3,968

    beq r2, r3, 1f
 4000384:	10c00326 	beq	r2,r3,4000394 <_start+0x30>

0:
    stw zero, (r2)
 4000388:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
 400038c:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
 4000390:	10fffd36 	bltu	r2,r3,4000388 <_start+0x24>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
 4000394:	400ab0c0 	call	400ab0c <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
 4000398:	400acac0 	call	400acac <alt_main>

0400039c <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
 400039c:	003fff06 	br	400039c <alt_after_alt_main>

040003a0 <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    EventGroupHandle_t xEventGroupCreate( void )
    {
 40003a0:	defffd04 	addi	sp,sp,-12
 40003a4:	dfc00215 	stw	ra,8(sp)
 40003a8:	df000115 	stw	fp,4(sp)
 40003ac:	df000104 	addi	fp,sp,4
         * TickType_t alignment requirements the cast is safe.  In other cases,
         * where the natural word size of the architecture is less than
         * sizeof( TickType_t ), the TickType_t variables will be accessed in two
         * or more reads operations, and the alignment requirements is only that
         * of each individual read. */
        pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
 40003b0:	01000604 	movi	r4,24
 40003b4:	400103c0 	call	400103c <pvPortMalloc>
 40003b8:	e0bfff15 	stw	r2,-4(fp)

        if( pxEventBits != NULL )
 40003bc:	e0bfff17 	ldw	r2,-4(fp)
 40003c0:	10000626 	beq	r2,zero,40003dc <xEventGroupCreate+0x3c>
        {
            pxEventBits->uxEventBits = 0;
 40003c4:	e0bfff17 	ldw	r2,-4(fp)
 40003c8:	10000015 	stw	zero,0(r2)
            vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
 40003cc:	e0bfff17 	ldw	r2,-4(fp)
 40003d0:	10800104 	addi	r2,r2,4
 40003d4:	1009883a 	mov	r4,r2
 40003d8:	4000aa00 	call	4000aa0 <vListInitialise>
        else
        {
            traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
        }

        return pxEventBits;
 40003dc:	e0bfff17 	ldw	r2,-4(fp)
    }
 40003e0:	e037883a 	mov	sp,fp
 40003e4:	dfc00117 	ldw	ra,4(sp)
 40003e8:	df000017 	ldw	fp,0(sp)
 40003ec:	dec00204 	addi	sp,sp,8
 40003f0:	f800283a 	ret

040003f4 <xEventGroupSync>:

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup,
                             const EventBits_t uxBitsToSet,
                             const EventBits_t uxBitsToWaitFor,
                             TickType_t xTicksToWait )
{
 40003f4:	defff504 	addi	sp,sp,-44
 40003f8:	dfc00a15 	stw	ra,40(sp)
 40003fc:	df000915 	stw	fp,36(sp)
 4000400:	df000904 	addi	fp,sp,36
 4000404:	e13ffa15 	stw	r4,-24(fp)
 4000408:	e17ff915 	stw	r5,-28(fp)
 400040c:	e1bff815 	stw	r6,-32(fp)
 4000410:	e1fff715 	stw	r7,-36(fp)
    EventBits_t uxOriginalBitValue, uxReturn;
    EventGroup_t * pxEventBits = xEventGroup;
 4000414:	e0bffa17 	ldw	r2,-24(fp)
 4000418:	e0bffe15 	stw	r2,-8(fp)
    BaseType_t xAlreadyYielded;
    BaseType_t xTimeoutOccurred = pdFALSE;
 400041c:	e03ffd15 	stw	zero,-12(fp)
    {
        configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    }
    #endif

    vTaskSuspendAll();
 4000420:	40046f00 	call	40046f0 <vTaskSuspendAll>
    {
        uxOriginalBitValue = pxEventBits->uxEventBits;
 4000424:	e0bffe17 	ldw	r2,-8(fp)
 4000428:	10800017 	ldw	r2,0(r2)
 400042c:	e0bffc15 	stw	r2,-16(fp)

        ( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
 4000430:	e17ff917 	ldw	r5,-28(fp)
 4000434:	e13ffa17 	ldw	r4,-24(fp)
 4000438:	40007c40 	call	40007c4 <xEventGroupSetBits>

        if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
 400043c:	e0fffc17 	ldw	r3,-16(fp)
 4000440:	e0bff917 	ldw	r2,-28(fp)
 4000444:	1886b03a 	or	r3,r3,r2
 4000448:	e0bff817 	ldw	r2,-32(fp)
 400044c:	1884703a 	and	r2,r3,r2
 4000450:	e0fff817 	ldw	r3,-32(fp)
 4000454:	18800d1e 	bne	r3,r2,400048c <xEventGroupSync+0x98>
        {
            /* All the rendezvous bits are now set - no need to block. */
            uxReturn = ( uxOriginalBitValue | uxBitsToSet );
 4000458:	e0fffc17 	ldw	r3,-16(fp)
 400045c:	e0bff917 	ldw	r2,-28(fp)
 4000460:	1884b03a 	or	r2,r3,r2
 4000464:	e0bfff15 	stw	r2,-4(fp)

            /* Rendezvous always clear the bits.  They will have been cleared
             * already unless this is the only task in the rendezvous. */
            pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
 4000468:	e0bffe17 	ldw	r2,-8(fp)
 400046c:	10c00017 	ldw	r3,0(r2)
 4000470:	e0bff817 	ldw	r2,-32(fp)
 4000474:	0084303a 	nor	r2,zero,r2
 4000478:	1886703a 	and	r3,r3,r2
 400047c:	e0bffe17 	ldw	r2,-8(fp)
 4000480:	10c00015 	stw	r3,0(r2)

            xTicksToWait = 0;
 4000484:	e03ff715 	stw	zero,-36(fp)
 4000488:	00001106 	br	40004d0 <xEventGroupSync+0xdc>
        }
        else
        {
            if( xTicksToWait != ( TickType_t ) 0 )
 400048c:	e0bff717 	ldw	r2,-36(fp)
 4000490:	10000a26 	beq	r2,zero,40004bc <xEventGroupSync+0xc8>
                traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

                /* Store the bits that the calling task is waiting for in the
                 * task's event list item so the kernel knows when a match is
                 * found.  Then enter the blocked state. */
                vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
 4000494:	e0bffe17 	ldw	r2,-8(fp)
 4000498:	10c00104 	addi	r3,r2,4
 400049c:	e0bff817 	ldw	r2,-32(fp)
 40004a0:	10814034 	orhi	r2,r2,1280
 40004a4:	e1bff717 	ldw	r6,-36(fp)
 40004a8:	100b883a 	mov	r5,r2
 40004ac:	1809883a 	mov	r4,r3
 40004b0:	4004f700 	call	4004f70 <vTaskPlaceOnUnorderedEventList>

                /* This assignment is obsolete as uxReturn will get set after
                 * the task unblocks, but some compilers mistakenly generate a
                 * warning about uxReturn being returned without being set if the
                 * assignment is omitted. */
                uxReturn = 0;
 40004b4:	e03fff15 	stw	zero,-4(fp)
 40004b8:	00000506 	br	40004d0 <xEventGroupSync+0xdc>
            }
            else
            {
                /* The rendezvous bits were not set, but no block time was
                 * specified - just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
 40004bc:	e0bffe17 	ldw	r2,-8(fp)
 40004c0:	10800017 	ldw	r2,0(r2)
 40004c4:	e0bfff15 	stw	r2,-4(fp)
                xTimeoutOccurred = pdTRUE;
 40004c8:	00800044 	movi	r2,1
 40004cc:	e0bffd15 	stw	r2,-12(fp)
            }
        }
    }
    xAlreadyYielded = xTaskResumeAll();
 40004d0:	400471c0 	call	400471c <xTaskResumeAll>
 40004d4:	e0bffb15 	stw	r2,-20(fp)

    if( xTicksToWait != ( TickType_t ) 0 )
 40004d8:	e0bff717 	ldw	r2,-36(fp)
 40004dc:	10002026 	beq	r2,zero,4000560 <xEventGroupSync+0x16c>
    {
        if( xAlreadyYielded == pdFALSE )
 40004e0:	e0bffb17 	ldw	r2,-20(fp)
 40004e4:	1000011e 	bne	r2,zero,40004ec <xEventGroupSync+0xf8>
        {
            portYIELD_WITHIN_API();
 40004e8:	003b683a 	trap	0

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
 40004ec:	40060340 	call	4006034 <uxTaskResetEventItemValue>
 40004f0:	e0bfff15 	stw	r2,-4(fp)

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
 40004f4:	e0bfff17 	ldw	r2,-4(fp)
 40004f8:	1080802c 	andhi	r2,r2,512
 40004fc:	1000131e 	bne	r2,zero,400054c <xEventGroupSync+0x158>
        {
            /* The task timed out, just return the current event bit value. */
            taskENTER_CRITICAL();
 4000500:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
            {
                uxReturn = pxEventBits->uxEventBits;
 4000504:	e0bffe17 	ldw	r2,-8(fp)
 4000508:	10800017 	ldw	r2,0(r2)
 400050c:	e0bfff15 	stw	r2,-4(fp)

                /* Although the task got here because it timed out before the
                 * bits it was waiting for were set, it is possible that since it
                 * unblocked another task has set the bits.  If this is the case
                 * then it needs to clear the bits before exiting. */
                if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
 4000510:	e0ffff17 	ldw	r3,-4(fp)
 4000514:	e0bff817 	ldw	r2,-32(fp)
 4000518:	1884703a 	and	r2,r3,r2
 400051c:	e0fff817 	ldw	r3,-32(fp)
 4000520:	1880071e 	bne	r3,r2,4000540 <xEventGroupSync+0x14c>
                {
                    pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
 4000524:	e0bffe17 	ldw	r2,-8(fp)
 4000528:	10c00017 	ldw	r3,0(r2)
 400052c:	e0bff817 	ldw	r2,-32(fp)
 4000530:	0084303a 	nor	r2,zero,r2
 4000534:	1886703a 	and	r3,r3,r2
 4000538:	e0bffe17 	ldw	r2,-8(fp)
 400053c:	10c00015 	stw	r3,0(r2)
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            taskEXIT_CRITICAL();
 4000540:	4005fd00 	call	4005fd0 <vTaskExitCritical>

            xTimeoutOccurred = pdTRUE;
 4000544:	00800044 	movi	r2,1
 4000548:	e0bffd15 	stw	r2,-12(fp)
            /* The task unblocked because the bits were set. */
        }

        /* Control bits might be set as the task had blocked should not be
         * returned. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
 400054c:	e0ffff17 	ldw	r3,-4(fp)
 4000550:	00804034 	movhi	r2,256
 4000554:	10bfffc4 	addi	r2,r2,-1
 4000558:	1884703a 	and	r2,r3,r2
 400055c:	e0bfff15 	stw	r2,-4(fp)
    traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
 4000560:	e0bfff17 	ldw	r2,-4(fp)
}
 4000564:	e037883a 	mov	sp,fp
 4000568:	dfc00117 	ldw	ra,4(sp)
 400056c:	df000017 	ldw	fp,0(sp)
 4000570:	dec00204 	addi	sp,sp,8
 4000574:	f800283a 	ret

04000578 <xEventGroupWaitBits>:
EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup,
                                 const EventBits_t uxBitsToWaitFor,
                                 const BaseType_t xClearOnExit,
                                 const BaseType_t xWaitForAllBits,
                                 TickType_t xTicksToWait )
{
 4000578:	defff304 	addi	sp,sp,-52
 400057c:	dfc00c15 	stw	ra,48(sp)
 4000580:	df000b15 	stw	fp,44(sp)
 4000584:	df000b04 	addi	fp,sp,44
 4000588:	e13ff815 	stw	r4,-32(fp)
 400058c:	e17ff715 	stw	r5,-36(fp)
 4000590:	e1bff615 	stw	r6,-40(fp)
 4000594:	e1fff515 	stw	r7,-44(fp)
    EventGroup_t * pxEventBits = xEventGroup;
 4000598:	e0bff817 	ldw	r2,-32(fp)
 400059c:	e0bffd15 	stw	r2,-12(fp)
    EventBits_t uxReturn, uxControlBits = 0;
 40005a0:	e03ffe15 	stw	zero,-8(fp)
    BaseType_t xWaitConditionMet, xAlreadyYielded;
    BaseType_t xTimeoutOccurred = pdFALSE;
 40005a4:	e03ffc15 	stw	zero,-16(fp)
    {
        configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    }
    #endif

    vTaskSuspendAll();
 40005a8:	40046f00 	call	40046f0 <vTaskSuspendAll>
    {
        const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
 40005ac:	e0bffd17 	ldw	r2,-12(fp)
 40005b0:	10800017 	ldw	r2,0(r2)
 40005b4:	e0bffb15 	stw	r2,-20(fp)

        /* Check to see if the wait condition is already met or not. */
        xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
 40005b8:	e1bff517 	ldw	r6,-44(fp)
 40005bc:	e17ff717 	ldw	r5,-36(fp)
 40005c0:	e13ffb17 	ldw	r4,-20(fp)
 40005c4:	4000a300 	call	4000a30 <prvTestWaitCondition>
 40005c8:	e0bffa15 	stw	r2,-24(fp)

        if( xWaitConditionMet != pdFALSE )
 40005cc:	e0bffa17 	ldw	r2,-24(fp)
 40005d0:	10000d26 	beq	r2,zero,4000608 <xEventGroupWaitBits+0x90>
        {
            /* The wait condition has already been met so there is no need to
             * block. */
            uxReturn = uxCurrentEventBits;
 40005d4:	e0bffb17 	ldw	r2,-20(fp)
 40005d8:	e0bfff15 	stw	r2,-4(fp)
            xTicksToWait = ( TickType_t ) 0;
 40005dc:	e0000215 	stw	zero,8(fp)

            /* Clear the wait bits if requested to do so. */
            if( xClearOnExit != pdFALSE )
 40005e0:	e0bff617 	ldw	r2,-40(fp)
 40005e4:	10002226 	beq	r2,zero,4000670 <xEventGroupWaitBits+0xf8>
            {
                pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
 40005e8:	e0bffd17 	ldw	r2,-12(fp)
 40005ec:	10c00017 	ldw	r3,0(r2)
 40005f0:	e0bff717 	ldw	r2,-36(fp)
 40005f4:	0084303a 	nor	r2,zero,r2
 40005f8:	1886703a 	and	r3,r3,r2
 40005fc:	e0bffd17 	ldw	r2,-12(fp)
 4000600:	10c00015 	stw	r3,0(r2)
 4000604:	00001a06 	br	4000670 <xEventGroupWaitBits+0xf8>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else if( xTicksToWait == ( TickType_t ) 0 )
 4000608:	e0800217 	ldw	r2,8(fp)
 400060c:	1000051e 	bne	r2,zero,4000624 <xEventGroupWaitBits+0xac>
        {
            /* The wait condition has not been met, but no block time was
             * specified, so just return the current value. */
            uxReturn = uxCurrentEventBits;
 4000610:	e0bffb17 	ldw	r2,-20(fp)
 4000614:	e0bfff15 	stw	r2,-4(fp)
            xTimeoutOccurred = pdTRUE;
 4000618:	00800044 	movi	r2,1
 400061c:	e0bffc15 	stw	r2,-16(fp)
 4000620:	00001306 	br	4000670 <xEventGroupWaitBits+0xf8>
        {
            /* The task is going to block to wait for its required bits to be
             * set.  uxControlBits are used to remember the specified behaviour of
             * this call to xEventGroupWaitBits() - for use when the event bits
             * unblock the task. */
            if( xClearOnExit != pdFALSE )
 4000624:	e0bff617 	ldw	r2,-40(fp)
 4000628:	10000326 	beq	r2,zero,4000638 <xEventGroupWaitBits+0xc0>
            {
                uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
 400062c:	e0bffe17 	ldw	r2,-8(fp)
 4000630:	10804034 	orhi	r2,r2,256
 4000634:	e0bffe15 	stw	r2,-8(fp)
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            if( xWaitForAllBits != pdFALSE )
 4000638:	e0bff517 	ldw	r2,-44(fp)
 400063c:	10000326 	beq	r2,zero,400064c <xEventGroupWaitBits+0xd4>
            {
                uxControlBits |= eventWAIT_FOR_ALL_BITS;
 4000640:	e0bffe17 	ldw	r2,-8(fp)
 4000644:	10810034 	orhi	r2,r2,1024
 4000648:	e0bffe15 	stw	r2,-8(fp)
            }

            /* Store the bits that the calling task is waiting for in the
             * task's event list item so the kernel knows when a match is
             * found.  Then enter the blocked state. */
            vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
 400064c:	e0bffd17 	ldw	r2,-12(fp)
 4000650:	11000104 	addi	r4,r2,4
 4000654:	e0fff717 	ldw	r3,-36(fp)
 4000658:	e0bffe17 	ldw	r2,-8(fp)
 400065c:	1884b03a 	or	r2,r3,r2
 4000660:	e1800217 	ldw	r6,8(fp)
 4000664:	100b883a 	mov	r5,r2
 4000668:	4004f700 	call	4004f70 <vTaskPlaceOnUnorderedEventList>

            /* This is obsolete as it will get set after the task unblocks, but
             * some compilers mistakenly generate a warning about the variable
             * being returned without being set if it is not done. */
            uxReturn = 0;
 400066c:	e03fff15 	stw	zero,-4(fp)

            traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
        }
    }
    xAlreadyYielded = xTaskResumeAll();
 4000670:	400471c0 	call	400471c <xTaskResumeAll>
 4000674:	e0bff915 	stw	r2,-28(fp)

    if( xTicksToWait != ( TickType_t ) 0 )
 4000678:	e0800217 	ldw	r2,8(fp)
 400067c:	10002226 	beq	r2,zero,4000708 <xEventGroupWaitBits+0x190>
    {
        if( xAlreadyYielded == pdFALSE )
 4000680:	e0bff917 	ldw	r2,-28(fp)
 4000684:	1000011e 	bne	r2,zero,400068c <xEventGroupWaitBits+0x114>
        {
            portYIELD_WITHIN_API();
 4000688:	003b683a 	trap	0

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
 400068c:	40060340 	call	4006034 <uxTaskResetEventItemValue>
 4000690:	e0bfff15 	stw	r2,-4(fp)

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
 4000694:	e0bfff17 	ldw	r2,-4(fp)
 4000698:	1080802c 	andhi	r2,r2,512
 400069c:	1000151e 	bne	r2,zero,40006f4 <xEventGroupWaitBits+0x17c>
        {
            taskENTER_CRITICAL();
 40006a0:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
            {
                /* The task timed out, just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
 40006a4:	e0bffd17 	ldw	r2,-12(fp)
 40006a8:	10800017 	ldw	r2,0(r2)
 40006ac:	e0bfff15 	stw	r2,-4(fp)

                /* It is possible that the event bits were updated between this
                 * task leaving the Blocked state and running again. */
                if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
 40006b0:	e1bff517 	ldw	r6,-44(fp)
 40006b4:	e17ff717 	ldw	r5,-36(fp)
 40006b8:	e13fff17 	ldw	r4,-4(fp)
 40006bc:	4000a300 	call	4000a30 <prvTestWaitCondition>
 40006c0:	10000926 	beq	r2,zero,40006e8 <xEventGroupWaitBits+0x170>
                {
                    if( xClearOnExit != pdFALSE )
 40006c4:	e0bff617 	ldw	r2,-40(fp)
 40006c8:	10000726 	beq	r2,zero,40006e8 <xEventGroupWaitBits+0x170>
                    {
                        pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
 40006cc:	e0bffd17 	ldw	r2,-12(fp)
 40006d0:	10c00017 	ldw	r3,0(r2)
 40006d4:	e0bff717 	ldw	r2,-36(fp)
 40006d8:	0084303a 	nor	r2,zero,r2
 40006dc:	1886703a 	and	r3,r3,r2
 40006e0:	e0bffd17 	ldw	r2,-12(fp)
 40006e4:	10c00015 	stw	r3,0(r2)
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                xTimeoutOccurred = pdTRUE;
 40006e8:	00800044 	movi	r2,1
 40006ec:	e0bffc15 	stw	r2,-16(fp)
            }
            taskEXIT_CRITICAL();
 40006f0:	4005fd00 	call	4005fd0 <vTaskExitCritical>
        {
            /* The task unblocked because the bits were set. */
        }

        /* The task blocked so control bits may have been set. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
 40006f4:	e0ffff17 	ldw	r3,-4(fp)
 40006f8:	00804034 	movhi	r2,256
 40006fc:	10bfffc4 	addi	r2,r2,-1
 4000700:	1884703a 	and	r2,r3,r2
 4000704:	e0bfff15 	stw	r2,-4(fp)
    traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
 4000708:	e0bfff17 	ldw	r2,-4(fp)
}
 400070c:	e037883a 	mov	sp,fp
 4000710:	dfc00117 	ldw	ra,4(sp)
 4000714:	df000017 	ldw	fp,0(sp)
 4000718:	dec00204 	addi	sp,sp,8
 400071c:	f800283a 	ret

04000720 <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup,
                                  const EventBits_t uxBitsToClear )
{
 4000720:	defffa04 	addi	sp,sp,-24
 4000724:	dfc00515 	stw	ra,20(sp)
 4000728:	df000415 	stw	fp,16(sp)
 400072c:	df000404 	addi	fp,sp,16
 4000730:	e13ffd15 	stw	r4,-12(fp)
 4000734:	e17ffc15 	stw	r5,-16(fp)
    EventGroup_t * pxEventBits = xEventGroup;
 4000738:	e0bffd17 	ldw	r2,-12(fp)
 400073c:	e0bfff15 	stw	r2,-4(fp)
    /* Check the user is not attempting to clear the bits used by the kernel
     * itself. */
    configASSERT( xEventGroup );
    configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

    taskENTER_CRITICAL();
 4000740:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
    {
        traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

        /* The value returned is the event group value prior to the bits being
         * cleared. */
        uxReturn = pxEventBits->uxEventBits;
 4000744:	e0bfff17 	ldw	r2,-4(fp)
 4000748:	10800017 	ldw	r2,0(r2)
 400074c:	e0bffe15 	stw	r2,-8(fp)

        /* Clear the bits. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
 4000750:	e0bfff17 	ldw	r2,-4(fp)
 4000754:	10c00017 	ldw	r3,0(r2)
 4000758:	e0bffc17 	ldw	r2,-16(fp)
 400075c:	0084303a 	nor	r2,zero,r2
 4000760:	1886703a 	and	r3,r3,r2
 4000764:	e0bfff17 	ldw	r2,-4(fp)
 4000768:	10c00015 	stw	r3,0(r2)
    }
    taskEXIT_CRITICAL();
 400076c:	4005fd00 	call	4005fd0 <vTaskExitCritical>

    return uxReturn;
 4000770:	e0bffe17 	ldw	r2,-8(fp)
}
 4000774:	e037883a 	mov	sp,fp
 4000778:	dfc00117 	ldw	ra,4(sp)
 400077c:	df000017 	ldw	fp,0(sp)
 4000780:	dec00204 	addi	sp,sp,8
 4000784:	f800283a 	ret

04000788 <xEventGroupGetBitsFromISR>:

#endif /* if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) ) */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
 4000788:	defffb04 	addi	sp,sp,-20
 400078c:	df000415 	stw	fp,16(sp)
 4000790:	df000404 	addi	fp,sp,16
 4000794:	e13ffc15 	stw	r4,-16(fp)
    UBaseType_t uxSavedInterruptStatus;
    EventGroup_t const * const pxEventBits = xEventGroup;
 4000798:	e0bffc17 	ldw	r2,-16(fp)
 400079c:	e0bfff15 	stw	r2,-4(fp)
    EventBits_t uxReturn;

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 40007a0:	e03ffe15 	stw	zero,-8(fp)
    {
        uxReturn = pxEventBits->uxEventBits;
 40007a4:	e0bfff17 	ldw	r2,-4(fp)
 40007a8:	10800017 	ldw	r2,0(r2)
 40007ac:	e0bffd15 	stw	r2,-12(fp)
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return uxReturn;
 40007b0:	e0bffd17 	ldw	r2,-12(fp)
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
 40007b4:	e037883a 	mov	sp,fp
 40007b8:	df000017 	ldw	fp,0(sp)
 40007bc:	dec00104 	addi	sp,sp,4
 40007c0:	f800283a 	ret

040007c4 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup,
                                const EventBits_t uxBitsToSet )
{
 40007c4:	defff304 	addi	sp,sp,-52
 40007c8:	dfc00c15 	stw	ra,48(sp)
 40007cc:	df000b15 	stw	fp,44(sp)
 40007d0:	df000b04 	addi	fp,sp,44
 40007d4:	e13ff615 	stw	r4,-40(fp)
 40007d8:	e17ff515 	stw	r5,-44(fp)
    ListItem_t * pxListItem;
    ListItem_t * pxNext;
    ListItem_t const * pxListEnd;
    List_t const * pxList;
    EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
 40007dc:	e03ffe15 	stw	zero,-8(fp)
    EventGroup_t * pxEventBits = xEventGroup;
 40007e0:	e0bff617 	ldw	r2,-40(fp)
 40007e4:	e0bffc15 	stw	r2,-16(fp)
    BaseType_t xMatchFound = pdFALSE;
 40007e8:	e03ffd15 	stw	zero,-12(fp)
    /* Check the user is not attempting to set the bits used by the kernel
     * itself. */
    configASSERT( xEventGroup );
    configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

    pxList = &( pxEventBits->xTasksWaitingForBits );
 40007ec:	e0bffc17 	ldw	r2,-16(fp)
 40007f0:	10800104 	addi	r2,r2,4
 40007f4:	e0bffb15 	stw	r2,-20(fp)
    pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 40007f8:	e0bffb17 	ldw	r2,-20(fp)
 40007fc:	10800204 	addi	r2,r2,8
 4000800:	e0bffa15 	stw	r2,-24(fp)
    vTaskSuspendAll();
 4000804:	40046f00 	call	40046f0 <vTaskSuspendAll>
    {
        traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

        pxListItem = listGET_HEAD_ENTRY( pxList );
 4000808:	e0bffb17 	ldw	r2,-20(fp)
 400080c:	10800317 	ldw	r2,12(r2)
 4000810:	e0bfff15 	stw	r2,-4(fp)

        /* Set the bits. */
        pxEventBits->uxEventBits |= uxBitsToSet;
 4000814:	e0bffc17 	ldw	r2,-16(fp)
 4000818:	10c00017 	ldw	r3,0(r2)
 400081c:	e0bff517 	ldw	r2,-44(fp)
 4000820:	1886b03a 	or	r3,r3,r2
 4000824:	e0bffc17 	ldw	r2,-16(fp)
 4000828:	10c00015 	stw	r3,0(r2)

        /* See if the new bit value should unblock any tasks. */
        while( pxListItem != pxListEnd )
 400082c:	00003306 	br	40008fc <xEventGroupSetBits+0x138>
        {
            pxNext = listGET_NEXT( pxListItem );
 4000830:	e0bfff17 	ldw	r2,-4(fp)
 4000834:	10800117 	ldw	r2,4(r2)
 4000838:	e0bff915 	stw	r2,-28(fp)
            uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
 400083c:	e0bfff17 	ldw	r2,-4(fp)
 4000840:	10800017 	ldw	r2,0(r2)
 4000844:	e0bff815 	stw	r2,-32(fp)
            xMatchFound = pdFALSE;
 4000848:	e03ffd15 	stw	zero,-12(fp)

            /* Split the bits waited for from the control bits. */
            uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
 400084c:	e0bff817 	ldw	r2,-32(fp)
 4000850:	10bfc02c 	andhi	r2,r2,65280
 4000854:	e0bff715 	stw	r2,-36(fp)
            uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
 4000858:	e0fff817 	ldw	r3,-32(fp)
 400085c:	00804034 	movhi	r2,256
 4000860:	10bfffc4 	addi	r2,r2,-1
 4000864:	1884703a 	and	r2,r3,r2
 4000868:	e0bff815 	stw	r2,-32(fp)

            if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
 400086c:	e0bff717 	ldw	r2,-36(fp)
 4000870:	1081002c 	andhi	r2,r2,1024
 4000874:	1000081e 	bne	r2,zero,4000898 <xEventGroupSetBits+0xd4>
            {
                /* Just looking for single bit being set. */
                if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
 4000878:	e0bffc17 	ldw	r2,-16(fp)
 400087c:	10c00017 	ldw	r3,0(r2)
 4000880:	e0bff817 	ldw	r2,-32(fp)
 4000884:	1884703a 	and	r2,r3,r2
 4000888:	10000b26 	beq	r2,zero,40008b8 <xEventGroupSetBits+0xf4>
                {
                    xMatchFound = pdTRUE;
 400088c:	00800044 	movi	r2,1
 4000890:	e0bffd15 	stw	r2,-12(fp)
 4000894:	00000806 	br	40008b8 <xEventGroupSetBits+0xf4>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
 4000898:	e0bffc17 	ldw	r2,-16(fp)
 400089c:	10c00017 	ldw	r3,0(r2)
 40008a0:	e0bff817 	ldw	r2,-32(fp)
 40008a4:	1884703a 	and	r2,r3,r2
 40008a8:	e0fff817 	ldw	r3,-32(fp)
 40008ac:	1880021e 	bne	r3,r2,40008b8 <xEventGroupSetBits+0xf4>
            {
                /* All bits are set. */
                xMatchFound = pdTRUE;
 40008b0:	00800044 	movi	r2,1
 40008b4:	e0bffd15 	stw	r2,-12(fp)
            else
            {
                /* Need all bits to be set, but not all the bits were set. */
            }

            if( xMatchFound != pdFALSE )
 40008b8:	e0bffd17 	ldw	r2,-12(fp)
 40008bc:	10000d26 	beq	r2,zero,40008f4 <xEventGroupSetBits+0x130>
            {
                /* The bits match.  Should the bits be cleared on exit? */
                if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
 40008c0:	e0bff717 	ldw	r2,-36(fp)
 40008c4:	1080402c 	andhi	r2,r2,256
 40008c8:	10000426 	beq	r2,zero,40008dc <xEventGroupSetBits+0x118>
                {
                    uxBitsToClear |= uxBitsWaitedFor;
 40008cc:	e0fffe17 	ldw	r3,-8(fp)
 40008d0:	e0bff817 	ldw	r2,-32(fp)
 40008d4:	1884b03a 	or	r2,r3,r2
 40008d8:	e0bffe15 	stw	r2,-8(fp)
                /* Store the actual event flag value in the task's event list
                 * item before removing the task from the event list.  The
                 * eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
                 * that is was unblocked due to its required bits matching, rather
                 * than because it timed out. */
                vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
 40008dc:	e0bffc17 	ldw	r2,-16(fp)
 40008e0:	10800017 	ldw	r2,0(r2)
 40008e4:	10808034 	orhi	r2,r2,512
 40008e8:	100b883a 	mov	r5,r2
 40008ec:	e13fff17 	ldw	r4,-4(fp)
 40008f0:	40052fc0 	call	40052fc <vTaskRemoveFromUnorderedEventList>
            }

            /* Move onto the next list item.  Note pxListItem->pxNext is not
             * used here as the list item may have been removed from the event list
             * and inserted into the ready/pending reading list. */
            pxListItem = pxNext;
 40008f4:	e0bff917 	ldw	r2,-28(fp)
 40008f8:	e0bfff15 	stw	r2,-4(fp)
        while( pxListItem != pxListEnd )
 40008fc:	e0ffff17 	ldw	r3,-4(fp)
 4000900:	e0bffa17 	ldw	r2,-24(fp)
 4000904:	18bfca1e 	bne	r3,r2,4000830 <xEventGroupSetBits+0x6c>
        }

        /* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
         * bit was set in the control word. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
 4000908:	e0bffc17 	ldw	r2,-16(fp)
 400090c:	10c00017 	ldw	r3,0(r2)
 4000910:	e0bffe17 	ldw	r2,-8(fp)
 4000914:	0084303a 	nor	r2,zero,r2
 4000918:	1886703a 	and	r3,r3,r2
 400091c:	e0bffc17 	ldw	r2,-16(fp)
 4000920:	10c00015 	stw	r3,0(r2)
    }
    ( void ) xTaskResumeAll();
 4000924:	400471c0 	call	400471c <xTaskResumeAll>

    return pxEventBits->uxEventBits;
 4000928:	e0bffc17 	ldw	r2,-16(fp)
 400092c:	10800017 	ldw	r2,0(r2)
}
 4000930:	e037883a 	mov	sp,fp
 4000934:	dfc00117 	ldw	ra,4(sp)
 4000938:	df000017 	ldw	fp,0(sp)
 400093c:	dec00204 	addi	sp,sp,8
 4000940:	f800283a 	ret

04000944 <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
 4000944:	defffb04 	addi	sp,sp,-20
 4000948:	dfc00415 	stw	ra,16(sp)
 400094c:	df000315 	stw	fp,12(sp)
 4000950:	df000304 	addi	fp,sp,12
 4000954:	e13ffd15 	stw	r4,-12(fp)
    EventGroup_t * pxEventBits = xEventGroup;
 4000958:	e0bffd17 	ldw	r2,-12(fp)
 400095c:	e0bfff15 	stw	r2,-4(fp)
    const List_t * pxTasksWaitingForBits;

    configASSERT( pxEventBits );

    pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
 4000960:	e0bfff17 	ldw	r2,-4(fp)
 4000964:	10800104 	addi	r2,r2,4
 4000968:	e0bffe15 	stw	r2,-8(fp)

    vTaskSuspendAll();
 400096c:	40046f00 	call	40046f0 <vTaskSuspendAll>
    {
        traceEVENT_GROUP_DELETE( xEventGroup );

        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
 4000970:	00000506 	br	4000988 <vEventGroupDelete+0x44>
        {
            /* Unblock the task, returning 0 as the event list is being deleted
             * and cannot therefore have any bits set. */
            configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
            vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
 4000974:	e0bffe17 	ldw	r2,-8(fp)
 4000978:	10800317 	ldw	r2,12(r2)
 400097c:	01408034 	movhi	r5,512
 4000980:	1009883a 	mov	r4,r2
 4000984:	40052fc0 	call	40052fc <vTaskRemoveFromUnorderedEventList>
        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
 4000988:	e0bffe17 	ldw	r2,-8(fp)
 400098c:	10800017 	ldw	r2,0(r2)
 4000990:	103ff81e 	bne	r2,zero,4000974 <vEventGroupDelete+0x30>
        }
    }
    ( void ) xTaskResumeAll();
 4000994:	400471c0 	call	400471c <xTaskResumeAll>

    #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
    {
        /* The event group can only have been allocated dynamically - free
         * it again. */
        vPortFree( pxEventBits );
 4000998:	e13fff17 	ldw	r4,-4(fp)
 400099c:	40011240 	call	4001124 <vPortFree>
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
 40009a0:	0001883a 	nop
 40009a4:	e037883a 	mov	sp,fp
 40009a8:	dfc00117 	ldw	ra,4(sp)
 40009ac:	df000017 	ldw	fp,0(sp)
 40009b0:	dec00204 	addi	sp,sp,8
 40009b4:	f800283a 	ret

040009b8 <vEventGroupSetBitsCallback>:

/* For internal use only - execute a 'set bits' command that was pended from
 * an interrupt. */
void vEventGroupSetBitsCallback( void * pvEventGroup,
                                 const uint32_t ulBitsToSet )
{
 40009b8:	defffc04 	addi	sp,sp,-16
 40009bc:	dfc00315 	stw	ra,12(sp)
 40009c0:	df000215 	stw	fp,8(sp)
 40009c4:	df000204 	addi	fp,sp,8
 40009c8:	e13fff15 	stw	r4,-4(fp)
 40009cc:	e17ffe15 	stw	r5,-8(fp)
    ( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
 40009d0:	e17ffe17 	ldw	r5,-8(fp)
 40009d4:	e13fff17 	ldw	r4,-4(fp)
 40009d8:	40007c40 	call	40007c4 <xEventGroupSetBits>
}
 40009dc:	0001883a 	nop
 40009e0:	e037883a 	mov	sp,fp
 40009e4:	dfc00117 	ldw	ra,4(sp)
 40009e8:	df000017 	ldw	fp,0(sp)
 40009ec:	dec00204 	addi	sp,sp,8
 40009f0:	f800283a 	ret

040009f4 <vEventGroupClearBitsCallback>:

/* For internal use only - execute a 'clear bits' command that was pended from
 * an interrupt. */
void vEventGroupClearBitsCallback( void * pvEventGroup,
                                   const uint32_t ulBitsToClear )
{
 40009f4:	defffc04 	addi	sp,sp,-16
 40009f8:	dfc00315 	stw	ra,12(sp)
 40009fc:	df000215 	stw	fp,8(sp)
 4000a00:	df000204 	addi	fp,sp,8
 4000a04:	e13fff15 	stw	r4,-4(fp)
 4000a08:	e17ffe15 	stw	r5,-8(fp)
    ( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
 4000a0c:	e17ffe17 	ldw	r5,-8(fp)
 4000a10:	e13fff17 	ldw	r4,-4(fp)
 4000a14:	40007200 	call	4000720 <xEventGroupClearBits>
}
 4000a18:	0001883a 	nop
 4000a1c:	e037883a 	mov	sp,fp
 4000a20:	dfc00117 	ldw	ra,4(sp)
 4000a24:	df000017 	ldw	fp,0(sp)
 4000a28:	dec00204 	addi	sp,sp,8
 4000a2c:	f800283a 	ret

04000a30 <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits,
                                        const EventBits_t uxBitsToWaitFor,
                                        const BaseType_t xWaitForAllBits )
{
 4000a30:	defffb04 	addi	sp,sp,-20
 4000a34:	df000415 	stw	fp,16(sp)
 4000a38:	df000404 	addi	fp,sp,16
 4000a3c:	e13ffe15 	stw	r4,-8(fp)
 4000a40:	e17ffd15 	stw	r5,-12(fp)
 4000a44:	e1bffc15 	stw	r6,-16(fp)
    BaseType_t xWaitConditionMet = pdFALSE;
 4000a48:	e03fff15 	stw	zero,-4(fp)

    if( xWaitForAllBits == pdFALSE )
 4000a4c:	e0bffc17 	ldw	r2,-16(fp)
 4000a50:	1000071e 	bne	r2,zero,4000a70 <prvTestWaitCondition+0x40>
    {
        /* Task only has to wait for one bit within uxBitsToWaitFor to be
         * set.  Is one already set? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
 4000a54:	e0fffe17 	ldw	r3,-8(fp)
 4000a58:	e0bffd17 	ldw	r2,-12(fp)
 4000a5c:	1884703a 	and	r2,r3,r2
 4000a60:	10000a26 	beq	r2,zero,4000a8c <prvTestWaitCondition+0x5c>
        {
            xWaitConditionMet = pdTRUE;
 4000a64:	00800044 	movi	r2,1
 4000a68:	e0bfff15 	stw	r2,-4(fp)
 4000a6c:	00000706 	br	4000a8c <prvTestWaitCondition+0x5c>
    }
    else
    {
        /* Task has to wait for all the bits in uxBitsToWaitFor to be set.
         * Are they set already? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
 4000a70:	e0fffe17 	ldw	r3,-8(fp)
 4000a74:	e0bffd17 	ldw	r2,-12(fp)
 4000a78:	1884703a 	and	r2,r3,r2
 4000a7c:	e0fffd17 	ldw	r3,-12(fp)
 4000a80:	1880021e 	bne	r3,r2,4000a8c <prvTestWaitCondition+0x5c>
        {
            xWaitConditionMet = pdTRUE;
 4000a84:	00800044 	movi	r2,1
 4000a88:	e0bfff15 	stw	r2,-4(fp)
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    return xWaitConditionMet;
 4000a8c:	e0bfff17 	ldw	r2,-4(fp)
}
 4000a90:	e037883a 	mov	sp,fp
 4000a94:	df000017 	ldw	fp,0(sp)
 4000a98:	dec00104 	addi	sp,sp,4
 4000a9c:	f800283a 	ret

04000aa0 <vListInitialise>:
/*-----------------------------------------------------------
* PUBLIC LIST API documented in list.h
*----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
 4000aa0:	defffe04 	addi	sp,sp,-8
 4000aa4:	df000115 	stw	fp,4(sp)
 4000aa8:	df000104 	addi	fp,sp,4
 4000aac:	e13fff15 	stw	r4,-4(fp)
    /* The list structure contains a list item which is used to mark the
     * end of the list.  To initialise the list the list end is inserted
     * as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 4000ab0:	e0bfff17 	ldw	r2,-4(fp)
 4000ab4:	10c00204 	addi	r3,r2,8
 4000ab8:	e0bfff17 	ldw	r2,-4(fp)
 4000abc:	10c00115 	stw	r3,4(r2)

    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( &( pxList->xListEnd ) );

    /* The list end value is the highest possible value in the list to
     * ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
 4000ac0:	e0bfff17 	ldw	r2,-4(fp)
 4000ac4:	00ffffc4 	movi	r3,-1
 4000ac8:	10c00215 	stw	r3,8(r2)

    /* The list end next and previous pointers point to itself so we know
     * when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 4000acc:	e0bfff17 	ldw	r2,-4(fp)
 4000ad0:	10c00204 	addi	r3,r2,8
 4000ad4:	e0bfff17 	ldw	r2,-4(fp)
 4000ad8:	10c00315 	stw	r3,12(r2)
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 4000adc:	e0bfff17 	ldw	r2,-4(fp)
 4000ae0:	10c00204 	addi	r3,r2,8
 4000ae4:	e0bfff17 	ldw	r2,-4(fp)
 4000ae8:	10c00415 	stw	r3,16(r2)
        pxList->xListEnd.pxContainer = NULL;
        listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( &( pxList->xListEnd ) );
    }
    #endif

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 4000aec:	e0bfff17 	ldw	r2,-4(fp)
 4000af0:	10000015 	stw	zero,0(r2)

    /* Write known values into the list if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
    listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
 4000af4:	0001883a 	nop
 4000af8:	e037883a 	mov	sp,fp
 4000afc:	df000017 	ldw	fp,0(sp)
 4000b00:	dec00104 	addi	sp,sp,4
 4000b04:	f800283a 	ret

04000b08 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
 4000b08:	defffe04 	addi	sp,sp,-8
 4000b0c:	df000115 	stw	fp,4(sp)
 4000b10:	df000104 	addi	fp,sp,4
 4000b14:	e13fff15 	stw	r4,-4(fp)
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
 4000b18:	e0bfff17 	ldw	r2,-4(fp)
 4000b1c:	10000415 	stw	zero,16(r2)

    /* Write known values into the list item if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
 4000b20:	0001883a 	nop
 4000b24:	e037883a 	mov	sp,fp
 4000b28:	df000017 	ldw	fp,0(sp)
 4000b2c:	dec00104 	addi	sp,sp,4
 4000b30:	f800283a 	ret

04000b34 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList,
                     ListItem_t * const pxNewListItem )
{
 4000b34:	defffc04 	addi	sp,sp,-16
 4000b38:	df000315 	stw	fp,12(sp)
 4000b3c:	df000304 	addi	fp,sp,12
 4000b40:	e13ffe15 	stw	r4,-8(fp)
 4000b44:	e17ffd15 	stw	r5,-12(fp)
    ListItem_t * const pxIndex = pxList->pxIndex;
 4000b48:	e0bffe17 	ldw	r2,-8(fp)
 4000b4c:	10800117 	ldw	r2,4(r2)
 4000b50:	e0bfff15 	stw	r2,-4(fp)
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
     * makes the new list item the last item to be removed by a call to
     * listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
 4000b54:	e0bffd17 	ldw	r2,-12(fp)
 4000b58:	e0ffff17 	ldw	r3,-4(fp)
 4000b5c:	10c00115 	stw	r3,4(r2)
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 4000b60:	e0bfff17 	ldw	r2,-4(fp)
 4000b64:	10c00217 	ldw	r3,8(r2)
 4000b68:	e0bffd17 	ldw	r2,-12(fp)
 4000b6c:	10c00215 	stw	r3,8(r2)

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
 4000b70:	e0bfff17 	ldw	r2,-4(fp)
 4000b74:	10800217 	ldw	r2,8(r2)
 4000b78:	e0fffd17 	ldw	r3,-12(fp)
 4000b7c:	10c00115 	stw	r3,4(r2)
    pxIndex->pxPrevious = pxNewListItem;
 4000b80:	e0bfff17 	ldw	r2,-4(fp)
 4000b84:	e0fffd17 	ldw	r3,-12(fp)
 4000b88:	10c00215 	stw	r3,8(r2)

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
 4000b8c:	e0bffd17 	ldw	r2,-12(fp)
 4000b90:	e0fffe17 	ldw	r3,-8(fp)
 4000b94:	10c00415 	stw	r3,16(r2)

    ( pxList->uxNumberOfItems )++;
 4000b98:	e0bffe17 	ldw	r2,-8(fp)
 4000b9c:	10800017 	ldw	r2,0(r2)
 4000ba0:	10c00044 	addi	r3,r2,1
 4000ba4:	e0bffe17 	ldw	r2,-8(fp)
 4000ba8:	10c00015 	stw	r3,0(r2)
}
 4000bac:	0001883a 	nop
 4000bb0:	e037883a 	mov	sp,fp
 4000bb4:	df000017 	ldw	fp,0(sp)
 4000bb8:	dec00104 	addi	sp,sp,4
 4000bbc:	f800283a 	ret

04000bc0 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList,
                  ListItem_t * const pxNewListItem )
{
 4000bc0:	defffb04 	addi	sp,sp,-20
 4000bc4:	df000415 	stw	fp,16(sp)
 4000bc8:	df000404 	addi	fp,sp,16
 4000bcc:	e13ffd15 	stw	r4,-12(fp)
 4000bd0:	e17ffc15 	stw	r5,-16(fp)
    ListItem_t * pxIterator;
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 4000bd4:	e0bffc17 	ldw	r2,-16(fp)
 4000bd8:	10800017 	ldw	r2,0(r2)
 4000bdc:	e0bffe15 	stw	r2,-8(fp)
     * new list item should be placed after it.  This ensures that TCBs which are
     * stored in ready lists (all of which have the same xItemValue value) get a
     * share of the CPU.  However, if the xItemValue is the same as the back marker
     * the iteration loop below will not end.  Therefore the value is checked
     * first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
 4000be0:	e0bffe17 	ldw	r2,-8(fp)
 4000be4:	10bfffd8 	cmpnei	r2,r2,-1
 4000be8:	1000041e 	bne	r2,zero,4000bfc <vListInsert+0x3c>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
 4000bec:	e0bffd17 	ldw	r2,-12(fp)
 4000bf0:	10800417 	ldw	r2,16(r2)
 4000bf4:	e0bfff15 	stw	r2,-4(fp)
 4000bf8:	00000c06 	br	4000c2c <vListInsert+0x6c>
        *   5) If the FreeRTOS port supports interrupt nesting then ensure that
        *      the priority of the tick interrupt is at or below
        *      configMAX_SYSCALL_INTERRUPT_PRIORITY.
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
 4000bfc:	e0bffd17 	ldw	r2,-12(fp)
 4000c00:	10800204 	addi	r2,r2,8
 4000c04:	e0bfff15 	stw	r2,-4(fp)
 4000c08:	00000306 	br	4000c18 <vListInsert+0x58>
 4000c0c:	e0bfff17 	ldw	r2,-4(fp)
 4000c10:	10800117 	ldw	r2,4(r2)
 4000c14:	e0bfff15 	stw	r2,-4(fp)
 4000c18:	e0bfff17 	ldw	r2,-4(fp)
 4000c1c:	10800117 	ldw	r2,4(r2)
 4000c20:	10800017 	ldw	r2,0(r2)
 4000c24:	e0fffe17 	ldw	r3,-8(fp)
 4000c28:	18bff82e 	bgeu	r3,r2,4000c0c <vListInsert+0x4c>
            /* There is nothing to do here, just iterating to the wanted
             * insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
 4000c2c:	e0bfff17 	ldw	r2,-4(fp)
 4000c30:	10c00117 	ldw	r3,4(r2)
 4000c34:	e0bffc17 	ldw	r2,-16(fp)
 4000c38:	10c00115 	stw	r3,4(r2)
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 4000c3c:	e0bffc17 	ldw	r2,-16(fp)
 4000c40:	10800117 	ldw	r2,4(r2)
 4000c44:	e0fffc17 	ldw	r3,-16(fp)
 4000c48:	10c00215 	stw	r3,8(r2)
    pxNewListItem->pxPrevious = pxIterator;
 4000c4c:	e0bffc17 	ldw	r2,-16(fp)
 4000c50:	e0ffff17 	ldw	r3,-4(fp)
 4000c54:	10c00215 	stw	r3,8(r2)
    pxIterator->pxNext = pxNewListItem;
 4000c58:	e0bfff17 	ldw	r2,-4(fp)
 4000c5c:	e0fffc17 	ldw	r3,-16(fp)
 4000c60:	10c00115 	stw	r3,4(r2)

    /* Remember which list the item is in.  This allows fast removal of the
     * item later. */
    pxNewListItem->pxContainer = pxList;
 4000c64:	e0bffc17 	ldw	r2,-16(fp)
 4000c68:	e0fffd17 	ldw	r3,-12(fp)
 4000c6c:	10c00415 	stw	r3,16(r2)

    ( pxList->uxNumberOfItems )++;
 4000c70:	e0bffd17 	ldw	r2,-12(fp)
 4000c74:	10800017 	ldw	r2,0(r2)
 4000c78:	10c00044 	addi	r3,r2,1
 4000c7c:	e0bffd17 	ldw	r2,-12(fp)
 4000c80:	10c00015 	stw	r3,0(r2)
}
 4000c84:	0001883a 	nop
 4000c88:	e037883a 	mov	sp,fp
 4000c8c:	df000017 	ldw	fp,0(sp)
 4000c90:	dec00104 	addi	sp,sp,4
 4000c94:	f800283a 	ret

04000c98 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
 4000c98:	defffd04 	addi	sp,sp,-12
 4000c9c:	df000215 	stw	fp,8(sp)
 4000ca0:	df000204 	addi	fp,sp,8
 4000ca4:	e13ffe15 	stw	r4,-8(fp)
/* The list item knows which list it is in.  Obtain the list from the list
 * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
 4000ca8:	e0bffe17 	ldw	r2,-8(fp)
 4000cac:	10800417 	ldw	r2,16(r2)
 4000cb0:	e0bfff15 	stw	r2,-4(fp)

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 4000cb4:	e0bffe17 	ldw	r2,-8(fp)
 4000cb8:	10800117 	ldw	r2,4(r2)
 4000cbc:	e0fffe17 	ldw	r3,-8(fp)
 4000cc0:	18c00217 	ldw	r3,8(r3)
 4000cc4:	10c00215 	stw	r3,8(r2)
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 4000cc8:	e0bffe17 	ldw	r2,-8(fp)
 4000ccc:	10800217 	ldw	r2,8(r2)
 4000cd0:	e0fffe17 	ldw	r3,-8(fp)
 4000cd4:	18c00117 	ldw	r3,4(r3)
 4000cd8:	10c00115 	stw	r3,4(r2)

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
 4000cdc:	e0bfff17 	ldw	r2,-4(fp)
 4000ce0:	10800117 	ldw	r2,4(r2)
 4000ce4:	e0fffe17 	ldw	r3,-8(fp)
 4000ce8:	1880041e 	bne	r3,r2,4000cfc <uxListRemove+0x64>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
 4000cec:	e0bffe17 	ldw	r2,-8(fp)
 4000cf0:	10c00217 	ldw	r3,8(r2)
 4000cf4:	e0bfff17 	ldw	r2,-4(fp)
 4000cf8:	10c00115 	stw	r3,4(r2)
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
 4000cfc:	e0bffe17 	ldw	r2,-8(fp)
 4000d00:	10000415 	stw	zero,16(r2)
    ( pxList->uxNumberOfItems )--;
 4000d04:	e0bfff17 	ldw	r2,-4(fp)
 4000d08:	10800017 	ldw	r2,0(r2)
 4000d0c:	10ffffc4 	addi	r3,r2,-1
 4000d10:	e0bfff17 	ldw	r2,-4(fp)
 4000d14:	10c00015 	stw	r3,0(r2)

    return pxList->uxNumberOfItems;
 4000d18:	e0bfff17 	ldw	r2,-4(fp)
 4000d1c:	10800017 	ldw	r2,0(r2)
}
 4000d20:	e037883a 	mov	sp,fp
 4000d24:	df000017 	ldw	fp,0(sp)
 4000d28:	dec00104 	addi	sp,sp,4
 4000d2c:	f800283a 	ret

04000d30 <prvReadGp>:
void vPortSysTickHandler( void * context);

/*-----------------------------------------------------------*/

static void prvReadGp( uint32_t *ulValue )
{
 4000d30:	defffe04 	addi	sp,sp,-8
 4000d34:	df000115 	stw	fp,4(sp)
 4000d38:	df000104 	addi	fp,sp,4
 4000d3c:	e13fff15 	stw	r4,-4(fp)
	asm( "stw gp, (%0)" :: "r"(ulValue) );
 4000d40:	e0bfff17 	ldw	r2,-4(fp)
 4000d44:	16800015 	stw	gp,0(r2)
}
 4000d48:	0001883a 	nop
 4000d4c:	e037883a 	mov	sp,fp
 4000d50:	df000017 	ldw	fp,0(sp)
 4000d54:	dec00104 	addi	sp,sp,4
 4000d58:	f800283a 	ret

04000d5c <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{    
 4000d5c:	defff904 	addi	sp,sp,-28
 4000d60:	dfc00615 	stw	ra,24(sp)
 4000d64:	df000515 	stw	fp,20(sp)
 4000d68:	df000504 	addi	fp,sp,20
 4000d6c:	e13ffd15 	stw	r4,-12(fp)
 4000d70:	e17ffc15 	stw	r5,-16(fp)
 4000d74:	e1bffb15 	stw	r6,-20(fp)
StackType_t *pxFramePointer = pxTopOfStack - 1;
 4000d78:	e0bffd17 	ldw	r2,-12(fp)
 4000d7c:	10bfff04 	addi	r2,r2,-4
 4000d80:	e0bfff15 	stw	r2,-4(fp)
StackType_t xGlobalPointer;

    prvReadGp( &xGlobalPointer ); 
 4000d84:	e0bffe04 	addi	r2,fp,-8
 4000d88:	1009883a 	mov	r4,r2
 4000d8c:	4000d300 	call	4000d30 <prvReadGp>

    /* End of stack marker. */
    *pxTopOfStack = 0xdeadbeef;
 4000d90:	e0fffd17 	ldw	r3,-12(fp)
 4000d94:	00b7abb4 	movhi	r2,57006
 4000d98:	10afbbc4 	addi	r2,r2,-16657
 4000d9c:	18800015 	stw	r2,0(r3)
    pxTopOfStack--;
 4000da0:	e0bffd17 	ldw	r2,-12(fp)
 4000da4:	10bfff04 	addi	r2,r2,-4
 4000da8:	e0bffd15 	stw	r2,-12(fp)
    
    *pxTopOfStack = ( StackType_t ) pxFramePointer; 
 4000dac:	e0ffff17 	ldw	r3,-4(fp)
 4000db0:	e0bffd17 	ldw	r2,-12(fp)
 4000db4:	10c00015 	stw	r3,0(r2)
    pxTopOfStack--;
 4000db8:	e0bffd17 	ldw	r2,-12(fp)
 4000dbc:	10bfff04 	addi	r2,r2,-4
 4000dc0:	e0bffd15 	stw	r2,-12(fp)
    
    *pxTopOfStack = xGlobalPointer; 
 4000dc4:	e0fffe17 	ldw	r3,-8(fp)
 4000dc8:	e0bffd17 	ldw	r2,-12(fp)
 4000dcc:	10c00015 	stw	r3,0(r2)
    
    /* Space for R23 to R16. */
    pxTopOfStack -= 9;
 4000dd0:	e0bffd17 	ldw	r2,-12(fp)
 4000dd4:	10bff704 	addi	r2,r2,-36
 4000dd8:	e0bffd15 	stw	r2,-12(fp)

    *pxTopOfStack = ( StackType_t ) pxCode; 
 4000ddc:	e0fffc17 	ldw	r3,-16(fp)
 4000de0:	e0bffd17 	ldw	r2,-12(fp)
 4000de4:	10c00015 	stw	r3,0(r2)
    pxTopOfStack--;
 4000de8:	e0bffd17 	ldw	r2,-12(fp)
 4000dec:	10bfff04 	addi	r2,r2,-4
 4000df0:	e0bffd15 	stw	r2,-12(fp)

    *pxTopOfStack = portINITIAL_ESTATUS; 
 4000df4:	e0bffd17 	ldw	r2,-12(fp)
 4000df8:	00c00044 	movi	r3,1
 4000dfc:	10c00015 	stw	r3,0(r2)

    /* Space for R15 to R5. */    
    pxTopOfStack -= 12;
 4000e00:	e0bffd17 	ldw	r2,-12(fp)
 4000e04:	10bff404 	addi	r2,r2,-48
 4000e08:	e0bffd15 	stw	r2,-12(fp)
    
    *pxTopOfStack = ( StackType_t ) pvParameters; 
 4000e0c:	e0fffb17 	ldw	r3,-20(fp)
 4000e10:	e0bffd17 	ldw	r2,-12(fp)
 4000e14:	10c00015 	stw	r3,0(r2)

    /* Space for R3 to R1, muldiv and RA. */
    pxTopOfStack -= 5;
 4000e18:	e0bffd17 	ldw	r2,-12(fp)
 4000e1c:	10bffb04 	addi	r2,r2,-20
 4000e20:	e0bffd15 	stw	r2,-12(fp)
    
    return pxTopOfStack;
 4000e24:	e0bffd17 	ldw	r2,-12(fp)
}
 4000e28:	e037883a 	mov	sp,fp
 4000e2c:	dfc00117 	ldw	ra,4(sp)
 4000e30:	df000017 	ldw	fp,0(sp)
 4000e34:	dec00204 	addi	sp,sp,8
 4000e38:	f800283a 	ret

04000e3c <xPortStartScheduler>:

/* 
 * See header file for description. 
 */
BaseType_t xPortStartScheduler( void )
{
 4000e3c:	defffe04 	addi	sp,sp,-8
 4000e40:	dfc00115 	stw	ra,4(sp)
 4000e44:	df000015 	stw	fp,0(sp)
 4000e48:	d839883a 	mov	fp,sp
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();
 4000e4c:	4000e940 	call	4000e94 <prvSetupTimerInterrupt>
 4000e50:	00810034 	movhi	r2,1024
	
	/* Start the first task. */
    asm volatile (  " movia r2, restore_sp_from_pxCurrentTCB        \n"
 4000e54:	10805704 	addi	r2,r2,348
 4000e58:	1000683a 	jmp	r2
                    " jmp r2                                          " );

	/* Should not get here! */
	return 0;
 4000e5c:	0005883a 	mov	r2,zero
}
 4000e60:	e037883a 	mov	sp,fp
 4000e64:	dfc00117 	ldw	ra,4(sp)
 4000e68:	df000017 	ldw	fp,0(sp)
 4000e6c:	dec00204 	addi	sp,sp,8
 4000e70:	f800283a 	ret

04000e74 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
 4000e74:	deffff04 	addi	sp,sp,-4
 4000e78:	df000015 	stw	fp,0(sp)
 4000e7c:	d839883a 	mov	fp,sp
	/* It is unlikely that the NIOS2 port will require this function as there
	is nothing to return to.  */
}
 4000e80:	0001883a 	nop
 4000e84:	e037883a 	mov	sp,fp
 4000e88:	df000017 	ldw	fp,0(sp)
 4000e8c:	dec00104 	addi	sp,sp,4
 4000e90:	f800283a 	ret

04000e94 <prvSetupTimerInterrupt>:
/*
 * Setup the systick timer to generate the tick interrupts at the required
 * frequency.
 */
void prvSetupTimerInterrupt( void )
{
 4000e94:	defffd04 	addi	sp,sp,-12
 4000e98:	dfc00215 	stw	ra,8(sp)
 4000e9c:	df000115 	stw	fp,4(sp)
 4000ea0:	df000104 	addi	fp,sp,4
	/* Try to register the interrupt handler. */
	if ( -EINVAL == _alt_ic_isr_register( SYS_CLK_IRQ_INTERRUPT_CONTROLLER_ID, SYS_CLK_IRQ, vPortSysTickHandler, 0x0, 0x0 ) )
 4000ea4:	d8000015 	stw	zero,0(sp)
 4000ea8:	000f883a 	mov	r7,zero
 4000eac:	01810034 	movhi	r6,1024
 4000eb0:	3183c904 	addi	r6,r6,3876
 4000eb4:	000b883a 	mov	r5,zero
 4000eb8:	0009883a 	mov	r4,zero
 4000ebc:	4000f680 	call	4000f68 <_alt_ic_isr_register>
 4000ec0:	10bffa98 	cmpnei	r2,r2,-22
 4000ec4:	1000021e 	bne	r2,zero,4000ed0 <prvSetupTimerInterrupt+0x3c>
	{ 
		/* Failed to install the Interrupt Handler. */
		asm( "break" );
 4000ec8:	003da03a 	break	0
 4000ecc:	00000c06 	br	4000f00 <prvSetupTimerInterrupt+0x6c>
	}
	else
	{
		/* Configure SysTick to interrupt at the requested rate. */
		IOWR_ALTERA_AVALON_TIMER_CONTROL( SYS_CLK_BASE, ALTERA_AVALON_TIMER_CONTROL_STOP_MSK );
 4000ed0:	00c00204 	movi	r3,8
 4000ed4:	00820034 	movhi	r2,2048
 4000ed8:	10c40135 	stwio	r3,4100(r2)
		IOWR_ALTERA_AVALON_TIMER_PERIODL( SYS_CLK_BASE, ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) & 0xFFFF );
 4000edc:	00f0d414 	movui	r3,50000
 4000ee0:	00820034 	movhi	r2,2048
 4000ee4:	10c40235 	stwio	r3,4104(r2)
		IOWR_ALTERA_AVALON_TIMER_PERIODH( SYS_CLK_BASE, ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) >> 16 );
 4000ee8:	0007883a 	mov	r3,zero
 4000eec:	00820034 	movhi	r2,2048
 4000ef0:	10c40335 	stwio	r3,4108(r2)
		IOWR_ALTERA_AVALON_TIMER_CONTROL( SYS_CLK_BASE, ALTERA_AVALON_TIMER_CONTROL_CONT_MSK | ALTERA_AVALON_TIMER_CONTROL_START_MSK | ALTERA_AVALON_TIMER_CONTROL_ITO_MSK );	
 4000ef4:	00c001c4 	movi	r3,7
 4000ef8:	00820034 	movhi	r2,2048
 4000efc:	10c40135 	stwio	r3,4100(r2)
	} 

	/* Clear any already pending interrupts generated by the Timer. */
	IOWR_ALTERA_AVALON_TIMER_STATUS( SYS_CLK_BASE, ~ALTERA_AVALON_TIMER_STATUS_TO_MSK );
 4000f00:	00ffff84 	movi	r3,-2
 4000f04:	00820034 	movhi	r2,2048
 4000f08:	10c40035 	stwio	r3,4096(r2)
}
 4000f0c:	0001883a 	nop
 4000f10:	e037883a 	mov	sp,fp
 4000f14:	dfc00117 	ldw	ra,4(sp)
 4000f18:	df000017 	ldw	fp,0(sp)
 4000f1c:	dec00204 	addi	sp,sp,8
 4000f20:	f800283a 	ret

04000f24 <vPortSysTickHandler>:
/*-----------------------------------------------------------*/

void vPortSysTickHandler( void * context)
{
 4000f24:	defffd04 	addi	sp,sp,-12
 4000f28:	dfc00215 	stw	ra,8(sp)
 4000f2c:	df000115 	stw	fp,4(sp)
 4000f30:	df000104 	addi	fp,sp,4
 4000f34:	e13fff15 	stw	r4,-4(fp)
	/* Increment the kernel tick. */
	if( xTaskIncrementTick() != pdFALSE )
 4000f38:	4004af40 	call	4004af4 <xTaskIncrementTick>
 4000f3c:	10000126 	beq	r2,zero,4000f44 <vPortSysTickHandler+0x20>
	{
        vTaskSwitchContext();
 4000f40:	4004e300 	call	4004e30 <vTaskSwitchContext>
	}
		
	/* Clear the interrupt. */
	IOWR_ALTERA_AVALON_TIMER_STATUS( SYS_CLK_BASE, ~ALTERA_AVALON_TIMER_STATUS_TO_MSK );
 4000f44:	00ffff84 	movi	r3,-2
 4000f48:	00820034 	movhi	r2,2048
 4000f4c:	10c40035 	stwio	r3,4096(r2)
}
 4000f50:	0001883a 	nop
 4000f54:	e037883a 	mov	sp,fp
 4000f58:	dfc00117 	ldw	ra,4(sp)
 4000f5c:	df000017 	ldw	fp,0(sp)
 4000f60:	dec00204 	addi	sp,sp,8
 4000f64:	f800283a 	ret

04000f68 <_alt_ic_isr_register>:
 * kernel has its scheduler started so that contexts are saved and switched 
 * correctly.
 */
int _alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr,
  void *isr_context, void *flags)
{
 4000f68:	defff604 	addi	sp,sp,-40
 4000f6c:	dfc00915 	stw	ra,36(sp)
 4000f70:	df000815 	stw	fp,32(sp)
 4000f74:	df000804 	addi	fp,sp,32
 4000f78:	e13ffb15 	stw	r4,-20(fp)
 4000f7c:	e17ffa15 	stw	r5,-24(fp)
 4000f80:	e1bff915 	stw	r6,-28(fp)
 4000f84:	e1fff815 	stw	r7,-32(fp)
	int rc = -EINVAL;  
 4000f88:	00bffa84 	movi	r2,-22
 4000f8c:	e0bfff15 	stw	r2,-4(fp)
	alt_irq_context status;
	int id = irq;             /* IRQ interpreted as the interrupt ID. */
 4000f90:	e0bffa17 	ldw	r2,-24(fp)
 4000f94:	e0bffe15 	stw	r2,-8(fp)

	if (id < ALT_NIRQ)
 4000f98:	e0bffe17 	ldw	r2,-8(fp)
 4000f9c:	10800808 	cmpgei	r2,r2,32
 4000fa0:	1000201e 	bne	r2,zero,4001024 <_alt_ic_isr_register+0xbc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 4000fa4:	0005303a 	rdctl	r2,status
 4000fa8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 4000fac:	e0fffc17 	ldw	r3,-16(fp)
 4000fb0:	00bfff84 	movi	r2,-2
 4000fb4:	1884703a 	and	r2,r3,r2
 4000fb8:	1001703a 	wrctl	status,r2
  
  return context;
 4000fbc:	e0bffc17 	ldw	r2,-16(fp)
		 * interrupts are disabled while the handler tables are updated to ensure
		 * that an interrupt doesn't occur while the tables are in an inconsistant
		 * state.
		 */
	
		status = alt_irq_disable_all ();
 4000fc0:	e0bffd15 	stw	r2,-12(fp)
	
		alt_irq[id].handler = isr;
 4000fc4:	e0bffe17 	ldw	r2,-8(fp)
 4000fc8:	100890fa 	slli	r4,r2,3
 4000fcc:	e0fff917 	ldw	r3,-28(fp)
 4000fd0:	00812074 	movhi	r2,1153
 4000fd4:	2085883a 	add	r2,r4,r2
 4000fd8:	10c0b215 	stw	r3,712(r2)
		alt_irq[id].context = isr_context;
 4000fdc:	e0bffe17 	ldw	r2,-8(fp)
 4000fe0:	100890fa 	slli	r4,r2,3
 4000fe4:	e0fff817 	ldw	r3,-32(fp)
 4000fe8:	00812074 	movhi	r2,1153
 4000fec:	2085883a 	add	r2,r4,r2
 4000ff0:	10c0b315 	stw	r3,716(r2)
	
		rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
 4000ff4:	e0bff917 	ldw	r2,-28(fp)
 4000ff8:	10000526 	beq	r2,zero,4001010 <_alt_ic_isr_register+0xa8>
 4000ffc:	e0bffe17 	ldw	r2,-8(fp)
 4001000:	100b883a 	mov	r5,r2
 4001004:	e13ffb17 	ldw	r4,-20(fp)
 4001008:	400a7700 	call	400a770 <alt_ic_irq_enable>
 400100c:	00000406 	br	4001020 <_alt_ic_isr_register+0xb8>
 4001010:	e0bffe17 	ldw	r2,-8(fp)
 4001014:	100b883a 	mov	r5,r2
 4001018:	e13ffb17 	ldw	r4,-20(fp)
 400101c:	400a7f80 	call	400a7f8 <alt_ic_irq_disable>
 4001020:	e0bfff15 	stw	r2,-4(fp)
	
		/* alt_irq_enable_all(status); This line is removed to prevent the interrupt from being immediately enabled. */
	}
    
	return rc; 
 4001024:	e0bfff17 	ldw	r2,-4(fp)
}
 4001028:	e037883a 	mov	sp,fp
 400102c:	dfc00117 	ldw	ra,4(sp)
 4001030:	df000017 	ldw	fp,0(sp)
 4001034:	dec00204 	addi	sp,sp,8
 4001038:	f800283a 	ret

0400103c <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void * pvPortMalloc( size_t xWantedSize )
{
 400103c:	defffc04 	addi	sp,sp,-16
 4001040:	dfc00315 	stw	ra,12(sp)
 4001044:	df000215 	stw	fp,8(sp)
 4001048:	df000204 	addi	fp,sp,8
 400104c:	e13ffe15 	stw	r4,-8(fp)
    void * pvReturn = NULL;
 4001050:	e03fff15 	stw	zero,-4(fp)
    static uint8_t * pucAlignedHeap = NULL;

    /* Ensure that blocks are always aligned. */
    #if ( portBYTE_ALIGNMENT != 1 )
    {
        if( xWantedSize & portBYTE_ALIGNMENT_MASK )
 4001054:	e0bffe17 	ldw	r2,-8(fp)
 4001058:	108000cc 	andi	r2,r2,3
 400105c:	10000d26 	beq	r2,zero,4001094 <pvPortMalloc+0x58>
        {
            /* Byte alignment required. Check for overflow. */
            if( ( xWantedSize + ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ) > xWantedSize )
 4001060:	e0fffe17 	ldw	r3,-8(fp)
 4001064:	00bfff04 	movi	r2,-4
 4001068:	1884703a 	and	r2,r3,r2
 400106c:	10800104 	addi	r2,r2,4
 4001070:	e0fffe17 	ldw	r3,-8(fp)
 4001074:	1880062e 	bgeu	r3,r2,4001090 <pvPortMalloc+0x54>
            {
                xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 4001078:	e0fffe17 	ldw	r3,-8(fp)
 400107c:	00bfff04 	movi	r2,-4
 4001080:	1884703a 	and	r2,r3,r2
 4001084:	10800104 	addi	r2,r2,4
 4001088:	e0bffe15 	stw	r2,-8(fp)
 400108c:	00000106 	br	4001094 <pvPortMalloc+0x58>
            }
            else
            {
                xWantedSize = 0;
 4001090:	e03ffe15 	stw	zero,-8(fp)
            }
        }
    }
    #endif /* if ( portBYTE_ALIGNMENT != 1 ) */

    vTaskSuspendAll();
 4001094:	40046f00 	call	40046f0 <vTaskSuspendAll>
    {
        if( pucAlignedHeap == NULL )
 4001098:	d0a6ac17 	ldw	r2,-25936(gp)
 400109c:	1000051e 	bne	r2,zero,40010b4 <pvPortMalloc+0x78>
        {
            /* Ensure the heap starts on a correctly aligned boundary. */
            pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) & ucHeap[ portBYTE_ALIGNMENT - 1 ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
 40010a0:	00810074 	movhi	r2,1025
 40010a4:	108076c4 	addi	r2,r2,475
 40010a8:	00ffff04 	movi	r3,-4
 40010ac:	10c4703a 	and	r2,r2,r3
 40010b0:	d0a6ac15 	stw	r2,-25936(gp)
        }

        /* Check there is enough room left for the allocation and. */
        if( ( xWantedSize > 0 ) &&                                /* valid size */
 40010b4:	e0bffe17 	ldw	r2,-8(fp)
 40010b8:	10001326 	beq	r2,zero,4001108 <pvPortMalloc+0xcc>
            ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
 40010bc:	d0e6ab17 	ldw	r3,-25940(gp)
 40010c0:	e0bffe17 	ldw	r2,-8(fp)
 40010c4:	1887883a 	add	r3,r3,r2
        if( ( xWantedSize > 0 ) &&                                /* valid size */
 40010c8:	00802034 	movhi	r2,128
 40010cc:	10bffec4 	addi	r2,r2,-5
 40010d0:	10c00d36 	bltu	r2,r3,4001108 <pvPortMalloc+0xcc>
            ( ( xNextFreeByte + xWantedSize ) > xNextFreeByte ) ) /* Check for overflow. */
 40010d4:	d0e6ab17 	ldw	r3,-25940(gp)
 40010d8:	e0bffe17 	ldw	r2,-8(fp)
 40010dc:	1885883a 	add	r2,r3,r2
 40010e0:	d0e6ab17 	ldw	r3,-25940(gp)
            ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
 40010e4:	1880082e 	bgeu	r3,r2,4001108 <pvPortMalloc+0xcc>
        {
            /* Return the next free byte then increment the index past this
             * block. */
            pvReturn = pucAlignedHeap + xNextFreeByte;
 40010e8:	d0e6ac17 	ldw	r3,-25936(gp)
 40010ec:	d0a6ab17 	ldw	r2,-25940(gp)
 40010f0:	1885883a 	add	r2,r3,r2
 40010f4:	e0bfff15 	stw	r2,-4(fp)
            xNextFreeByte += xWantedSize;
 40010f8:	d0e6ab17 	ldw	r3,-25940(gp)
 40010fc:	e0bffe17 	ldw	r2,-8(fp)
 4001100:	1885883a 	add	r2,r3,r2
 4001104:	d0a6ab15 	stw	r2,-25940(gp)
        }

        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();
 4001108:	400471c0 	call	400471c <xTaskResumeAll>
            vApplicationMallocFailedHook();
        }
    }
    #endif

    return pvReturn;
 400110c:	e0bfff17 	ldw	r2,-4(fp)
}
 4001110:	e037883a 	mov	sp,fp
 4001114:	dfc00117 	ldw	ra,4(sp)
 4001118:	df000017 	ldw	fp,0(sp)
 400111c:	dec00204 	addi	sp,sp,8
 4001120:	f800283a 	ret

04001124 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void * pv )
{
 4001124:	defffe04 	addi	sp,sp,-8
 4001128:	df000115 	stw	fp,4(sp)
 400112c:	df000104 	addi	fp,sp,4
 4001130:	e13fff15 	stw	r4,-4(fp)
     * https://www.FreeRTOS.org for more information. */
    ( void ) pv;

    /* Force an assert as it is invalid to call this function. */
    configASSERT( pv == NULL );
}
 4001134:	0001883a 	nop
 4001138:	e037883a 	mov	sp,fp
 400113c:	df000017 	ldw	fp,0(sp)
 4001140:	dec00104 	addi	sp,sp,4
 4001144:	f800283a 	ret

04001148 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
 4001148:	deffff04 	addi	sp,sp,-4
 400114c:	df000015 	stw	fp,0(sp)
 4001150:	d839883a 	mov	fp,sp
    /* Only required when static memory is not cleared. */
    xNextFreeByte = ( size_t ) 0;
 4001154:	d026ab15 	stw	zero,-25940(gp)
}
 4001158:	0001883a 	nop
 400115c:	e037883a 	mov	sp,fp
 4001160:	df000017 	ldw	fp,0(sp)
 4001164:	dec00104 	addi	sp,sp,4
 4001168:	f800283a 	ret

0400116c <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
 400116c:	deffff04 	addi	sp,sp,-4
 4001170:	df000015 	stw	fp,0(sp)
 4001174:	d839883a 	mov	fp,sp
    return( configADJUSTED_HEAP_SIZE - xNextFreeByte );
 4001178:	d0e6ab17 	ldw	r3,-25940(gp)
 400117c:	00802034 	movhi	r2,128
 4001180:	10bfff04 	addi	r2,r2,-4
 4001184:	10c5c83a 	sub	r2,r2,r3
}
 4001188:	e037883a 	mov	sp,fp
 400118c:	df000017 	ldw	fp,0(sp)
 4001190:	dec00104 	addi	sp,sp,4
 4001194:	f800283a 	ret

04001198 <xQueueGenericReset>:
    }
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue,
                               BaseType_t xNewQueue )
{
 4001198:	defff404 	addi	sp,sp,-48
 400119c:	dfc00b15 	stw	ra,44(sp)
 40011a0:	df000a15 	stw	fp,40(sp)
 40011a4:	dd400915 	stw	r21,36(sp)
 40011a8:	dd000815 	stw	r20,32(sp)
 40011ac:	dcc00715 	stw	r19,28(sp)
 40011b0:	dc800615 	stw	r18,24(sp)
 40011b4:	dc400515 	stw	r17,20(sp)
 40011b8:	dc000415 	stw	r16,16(sp)
 40011bc:	df000a04 	addi	fp,sp,40
 40011c0:	e13ff715 	stw	r4,-36(fp)
 40011c4:	e17ff615 	stw	r5,-40(fp)
    BaseType_t xReturn = pdPASS;
 40011c8:	00800044 	movi	r2,1
 40011cc:	e0bff915 	stw	r2,-28(fp)
    Queue_t * const pxQueue = xQueue;
 40011d0:	e0bff717 	ldw	r2,-36(fp)
 40011d4:	e0bff815 	stw	r2,-32(fp)

    configASSERT( pxQueue );

    if( ( pxQueue != NULL ) &&
 40011d8:	e0bff817 	ldw	r2,-32(fp)
 40011dc:	10007126 	beq	r2,zero,40013a4 <xQueueGenericReset+0x20c>
        ( pxQueue->uxLength >= 1U ) &&
 40011e0:	e0bff817 	ldw	r2,-32(fp)
 40011e4:	10800f17 	ldw	r2,60(r2)
    if( ( pxQueue != NULL ) &&
 40011e8:	10006e26 	beq	r2,zero,40013a4 <xQueueGenericReset+0x20c>
        /* Check for multiplication overflow. */
        ( ( SIZE_MAX / pxQueue->uxLength ) >= pxQueue->uxItemSize ) )
 40011ec:	e0bff817 	ldw	r2,-32(fp)
 40011f0:	14001017 	ldw	r16,64(r2)
 40011f4:	e0bff817 	ldw	r2,-32(fp)
 40011f8:	14400f17 	ldw	r17,60(r2)
 40011fc:	0025883a 	mov	r18,zero
 4001200:	8008d43a 	srli	r4,r16,16
 4001204:	8804d43a 	srli	r2,r17,16
 4001208:	20ffffcc 	andi	r3,r4,65535
 400120c:	18000b1e 	bne	r3,zero,400123c <xQueueGenericReset+0xa4>
 4001210:	10ffffcc 	andi	r3,r2,65535
 4001214:	1800061e 	bne	r3,zero,4001230 <xQueueGenericReset+0x98>
 4001218:	80bfffcc 	andi	r2,r16,65535
 400121c:	88ffffcc 	andi	r3,r17,65535
 4001220:	180b883a 	mov	r5,r3
 4001224:	1009883a 	mov	r4,r2
 4001228:	40078580 	call	4007858 <__mulsi3>
 400122c:	00001f06 	br	40012ac <xQueueGenericReset+0x114>
 4001230:	1029883a 	mov	r20,r2
 4001234:	802b883a 	mov	r21,r16
 4001238:	00000406 	br	400124c <xQueueGenericReset+0xb4>
 400123c:	10bfffcc 	andi	r2,r2,65535
 4001240:	1000131e 	bne	r2,zero,4001290 <xQueueGenericReset+0xf8>
 4001244:	2029883a 	mov	r20,r4
 4001248:	882b883a 	mov	r21,r17
 400124c:	80bfffcc 	andi	r2,r16,65535
 4001250:	88ffffcc 	andi	r3,r17,65535
 4001254:	180b883a 	mov	r5,r3
 4001258:	1009883a 	mov	r4,r2
 400125c:	40078580 	call	4007858 <__mulsi3>
 4001260:	1027883a 	mov	r19,r2
 4001264:	a8bfffcc 	andi	r2,r21,65535
 4001268:	a0ffffcc 	andi	r3,r20,65535
 400126c:	180b883a 	mov	r5,r3
 4001270:	1009883a 	mov	r4,r2
 4001274:	40078580 	call	4007858 <__mulsi3>
 4001278:	9806d43a 	srli	r3,r19,16
 400127c:	10c5883a 	add	r2,r2,r3
 4001280:	1005d43a 	srai	r2,r2,16
 4001284:	10bfffcc 	andi	r2,r2,65535
 4001288:	1000041e 	bne	r2,zero,400129c <xQueueGenericReset+0x104>
 400128c:	00000706 	br	40012ac <xQueueGenericReset+0x114>
 4001290:	880b883a 	mov	r5,r17
 4001294:	8009883a 	mov	r4,r16
 4001298:	40078580 	call	4007858 <__mulsi3>
 400129c:	880b883a 	mov	r5,r17
 40012a0:	8009883a 	mov	r4,r16
 40012a4:	40078580 	call	4007858 <__mulsi3>
 40012a8:	04800044 	movi	r18,1
 40012ac:	9005883a 	mov	r2,r18
        ( pxQueue->uxLength >= 1U ) &&
 40012b0:	10003c1e 	bne	r2,zero,40013a4 <xQueueGenericReset+0x20c>
    {
        taskENTER_CRITICAL();
 40012b4:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
        {
            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 40012b8:	e0bff817 	ldw	r2,-32(fp)
 40012bc:	14000017 	ldw	r16,0(r2)
 40012c0:	e0bff817 	ldw	r2,-32(fp)
 40012c4:	10c00f17 	ldw	r3,60(r2)
 40012c8:	e0bff817 	ldw	r2,-32(fp)
 40012cc:	10801017 	ldw	r2,64(r2)
 40012d0:	100b883a 	mov	r5,r2
 40012d4:	1809883a 	mov	r4,r3
 40012d8:	40078580 	call	4007858 <__mulsi3>
 40012dc:	8087883a 	add	r3,r16,r2
 40012e0:	e0bff817 	ldw	r2,-32(fp)
 40012e4:	10c00215 	stw	r3,8(r2)
            pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 40012e8:	e0bff817 	ldw	r2,-32(fp)
 40012ec:	10000e15 	stw	zero,56(r2)
            pxQueue->pcWriteTo = pxQueue->pcHead;
 40012f0:	e0bff817 	ldw	r2,-32(fp)
 40012f4:	10c00017 	ldw	r3,0(r2)
 40012f8:	e0bff817 	ldw	r2,-32(fp)
 40012fc:	10c00115 	stw	r3,4(r2)
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 4001300:	e0bff817 	ldw	r2,-32(fp)
 4001304:	14000017 	ldw	r16,0(r2)
 4001308:	e0bff817 	ldw	r2,-32(fp)
 400130c:	10800f17 	ldw	r2,60(r2)
 4001310:	10ffffc4 	addi	r3,r2,-1
 4001314:	e0bff817 	ldw	r2,-32(fp)
 4001318:	10801017 	ldw	r2,64(r2)
 400131c:	100b883a 	mov	r5,r2
 4001320:	1809883a 	mov	r4,r3
 4001324:	40078580 	call	4007858 <__mulsi3>
 4001328:	8087883a 	add	r3,r16,r2
 400132c:	e0bff817 	ldw	r2,-32(fp)
 4001330:	10c00315 	stw	r3,12(r2)
            pxQueue->cRxLock = queueUNLOCKED;
 4001334:	e0bff817 	ldw	r2,-32(fp)
 4001338:	00ffffc4 	movi	r3,-1
 400133c:	10c01105 	stb	r3,68(r2)
            pxQueue->cTxLock = queueUNLOCKED;
 4001340:	e0bff817 	ldw	r2,-32(fp)
 4001344:	00ffffc4 	movi	r3,-1
 4001348:	10c01145 	stb	r3,69(r2)

            if( xNewQueue == pdFALSE )
 400134c:	e0bff617 	ldw	r2,-40(fp)
 4001350:	10000a1e 	bne	r2,zero,400137c <xQueueGenericReset+0x1e4>
                /* If there are tasks blocked waiting to read from the queue, then
                 * the tasks will remain blocked as after this function exits the queue
                 * will still be empty.  If there are tasks blocked waiting to write to
                 * the queue, then one should be unblocked as after this function exits
                 * it will be possible to write to it. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 4001354:	e0bff817 	ldw	r2,-32(fp)
 4001358:	10800417 	ldw	r2,16(r2)
 400135c:	10000f26 	beq	r2,zero,400139c <xQueueGenericReset+0x204>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 4001360:	e0bff817 	ldw	r2,-32(fp)
 4001364:	10800404 	addi	r2,r2,16
 4001368:	1009883a 	mov	r4,r2
 400136c:	400502c0 	call	400502c <xTaskRemoveFromEventList>
 4001370:	10000a26 	beq	r2,zero,400139c <xQueueGenericReset+0x204>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
 4001374:	003b683a 	trap	0
 4001378:	00000806 	br	400139c <xQueueGenericReset+0x204>
                }
            }
            else
            {
                /* Ensure the event queues start in the correct state. */
                vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 400137c:	e0bff817 	ldw	r2,-32(fp)
 4001380:	10800404 	addi	r2,r2,16
 4001384:	1009883a 	mov	r4,r2
 4001388:	4000aa00 	call	4000aa0 <vListInitialise>
                vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 400138c:	e0bff817 	ldw	r2,-32(fp)
 4001390:	10800904 	addi	r2,r2,36
 4001394:	1009883a 	mov	r4,r2
 4001398:	4000aa00 	call	4000aa0 <vListInitialise>
            }
        }
        taskEXIT_CRITICAL();
 400139c:	4005fd00 	call	4005fd0 <vTaskExitCritical>
 40013a0:	00000106 	br	40013a8 <xQueueGenericReset+0x210>
    }
    else
    {
        xReturn = pdFAIL;
 40013a4:	e03ff915 	stw	zero,-28(fp)

    configASSERT( xReturn != pdFAIL );

    /* A value is returned for calling semantic consistency with previous
     * versions. */
    return xReturn;
 40013a8:	e0bff917 	ldw	r2,-28(fp)
}
 40013ac:	e6fffa04 	addi	sp,fp,-24
 40013b0:	dfc00717 	ldw	ra,28(sp)
 40013b4:	df000617 	ldw	fp,24(sp)
 40013b8:	dd400517 	ldw	r21,20(sp)
 40013bc:	dd000417 	ldw	r20,16(sp)
 40013c0:	dcc00317 	ldw	r19,12(sp)
 40013c4:	dc800217 	ldw	r18,8(sp)
 40013c8:	dc400117 	ldw	r17,4(sp)
 40013cc:	dc000017 	ldw	r16,0(sp)
 40013d0:	dec00804 	addi	sp,sp,32
 40013d4:	f800283a 	ret

040013d8 <xQueueGenericCreate>:
#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,
                                       const UBaseType_t uxItemSize,
                                       const uint8_t ucQueueType )
    {
 40013d8:	defff304 	addi	sp,sp,-52
 40013dc:	dfc00c15 	stw	ra,48(sp)
 40013e0:	df000b15 	stw	fp,44(sp)
 40013e4:	dcc00a15 	stw	r19,40(sp)
 40013e8:	dc800915 	stw	r18,36(sp)
 40013ec:	dc400815 	stw	r17,32(sp)
 40013f0:	dc000715 	stw	r16,28(sp)
 40013f4:	df000b04 	addi	fp,sp,44
 40013f8:	e13ff815 	stw	r4,-32(fp)
 40013fc:	e17ff715 	stw	r5,-36(fp)
 4001400:	3005883a 	mov	r2,r6
 4001404:	e0bff605 	stb	r2,-40(fp)
        Queue_t * pxNewQueue = NULL;
 4001408:	e03ffb15 	stw	zero,-20(fp)
        size_t xQueueSizeInBytes;
        uint8_t * pucQueueStorage;

        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
 400140c:	e0bff817 	ldw	r2,-32(fp)
 4001410:	10005026 	beq	r2,zero,4001554 <xQueueGenericCreate+0x17c>
            /* Check for multiplication overflow. */
            ( ( SIZE_MAX / uxQueueLength ) >= uxItemSize ) &&
 4001414:	0021883a 	mov	r16,zero
 4001418:	e0bff717 	ldw	r2,-36(fp)
 400141c:	100cd43a 	srli	r6,r2,16
 4001420:	e0fff717 	ldw	r3,-36(fp)
 4001424:	e0bff817 	ldw	r2,-32(fp)
 4001428:	1008d43a 	srli	r4,r2,16
 400142c:	e0bff817 	ldw	r2,-32(fp)
 4001430:	317fffcc 	andi	r5,r6,65535
 4001434:	28000b1e 	bne	r5,zero,4001464 <xQueueGenericCreate+0x8c>
 4001438:	217fffcc 	andi	r5,r4,65535
 400143c:	2800061e 	bne	r5,zero,4001458 <xQueueGenericCreate+0x80>
 4001440:	18ffffcc 	andi	r3,r3,65535
 4001444:	10bfffcc 	andi	r2,r2,65535
 4001448:	100b883a 	mov	r5,r2
 400144c:	1809883a 	mov	r4,r3
 4001450:	40078580 	call	4007858 <__mulsi3>
 4001454:	00001f06 	br	40014d4 <xQueueGenericCreate+0xfc>
 4001458:	2025883a 	mov	r18,r4
 400145c:	1827883a 	mov	r19,r3
 4001460:	00000406 	br	4001474 <xQueueGenericCreate+0x9c>
 4001464:	213fffcc 	andi	r4,r4,65535
 4001468:	2000131e 	bne	r4,zero,40014b8 <xQueueGenericCreate+0xe0>
 400146c:	3025883a 	mov	r18,r6
 4001470:	1027883a 	mov	r19,r2
 4001474:	18ffffcc 	andi	r3,r3,65535
 4001478:	10bfffcc 	andi	r2,r2,65535
 400147c:	100b883a 	mov	r5,r2
 4001480:	1809883a 	mov	r4,r3
 4001484:	40078580 	call	4007858 <__mulsi3>
 4001488:	1023883a 	mov	r17,r2
 400148c:	98bfffcc 	andi	r2,r19,65535
 4001490:	90ffffcc 	andi	r3,r18,65535
 4001494:	180b883a 	mov	r5,r3
 4001498:	1009883a 	mov	r4,r2
 400149c:	40078580 	call	4007858 <__mulsi3>
 40014a0:	8806d43a 	srli	r3,r17,16
 40014a4:	10c5883a 	add	r2,r2,r3
 40014a8:	1005d43a 	srai	r2,r2,16
 40014ac:	10bfffcc 	andi	r2,r2,65535
 40014b0:	1000041e 	bne	r2,zero,40014c4 <xQueueGenericCreate+0xec>
 40014b4:	00000706 	br	40014d4 <xQueueGenericCreate+0xfc>
 40014b8:	e17ff817 	ldw	r5,-32(fp)
 40014bc:	e13ff717 	ldw	r4,-36(fp)
 40014c0:	40078580 	call	4007858 <__mulsi3>
 40014c4:	e17ff817 	ldw	r5,-32(fp)
 40014c8:	e13ff717 	ldw	r4,-36(fp)
 40014cc:	40078580 	call	4007858 <__mulsi3>
 40014d0:	04000044 	movi	r16,1
 40014d4:	8005883a 	mov	r2,r16
        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
 40014d8:	10001e1e 	bne	r2,zero,4001554 <xQueueGenericCreate+0x17c>
            /* Check for addition overflow. */
            ( ( SIZE_MAX - sizeof( Queue_t ) ) >= ( uxQueueLength * uxItemSize ) ) )
 40014dc:	e17ff717 	ldw	r5,-36(fp)
 40014e0:	e13ff817 	ldw	r4,-32(fp)
 40014e4:	40078580 	call	4007858 <__mulsi3>
 40014e8:	1007883a 	mov	r3,r2
            ( ( SIZE_MAX / uxQueueLength ) >= uxItemSize ) &&
 40014ec:	00bfedc4 	movi	r2,-73
 40014f0:	10c01836 	bltu	r2,r3,4001554 <xQueueGenericCreate+0x17c>
        {
            /* Allocate enough space to hold the maximum number of items that
             * can be in the queue at any time.  It is valid for uxItemSize to be
             * zero in the case the queue is used as a semaphore. */
            xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 40014f4:	e17ff717 	ldw	r5,-36(fp)
 40014f8:	e13ff817 	ldw	r4,-32(fp)
 40014fc:	40078580 	call	4007858 <__mulsi3>
 4001500:	e0bffa15 	stw	r2,-24(fp)
             * alignment requirements of the Queue_t structure - which in this case
             * is an int8_t *.  Therefore, whenever the stack alignment requirements
             * are greater than or equal to the pointer to char requirements the cast
             * is safe.  In other cases alignment requirements are not strict (one or
             * two bytes). */
            pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
 4001504:	e0bffa17 	ldw	r2,-24(fp)
 4001508:	10801204 	addi	r2,r2,72
 400150c:	1009883a 	mov	r4,r2
 4001510:	400103c0 	call	400103c <pvPortMalloc>
 4001514:	e0bffb15 	stw	r2,-20(fp)

            if( pxNewQueue != NULL )
 4001518:	e0bffb17 	ldw	r2,-20(fp)
 400151c:	10000d26 	beq	r2,zero,4001554 <xQueueGenericCreate+0x17c>
            {
                /* Jump past the queue structure to find the location of the queue
                 * storage area. */
                pucQueueStorage = ( uint8_t * ) pxNewQueue;
 4001520:	e0bffb17 	ldw	r2,-20(fp)
 4001524:	e0bff915 	stw	r2,-28(fp)
                pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 4001528:	e0bff917 	ldw	r2,-28(fp)
 400152c:	10801204 	addi	r2,r2,72
 4001530:	e0bff915 	stw	r2,-28(fp)
                     * deleted. */
                    pxNewQueue->ucStaticallyAllocated = pdFALSE;
                }
                #endif /* configSUPPORT_STATIC_ALLOCATION */

                prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
 4001534:	e0fff603 	ldbu	r3,-40(fp)
 4001538:	e0bffb17 	ldw	r2,-20(fp)
 400153c:	d8800015 	stw	r2,0(sp)
 4001540:	180f883a 	mov	r7,r3
 4001544:	e1bff917 	ldw	r6,-28(fp)
 4001548:	e17ff717 	ldw	r5,-36(fp)
 400154c:	e13ff817 	ldw	r4,-32(fp)
 4001550:	400157c0 	call	400157c <prvInitialiseNewQueue>
        {
            configASSERT( pxNewQueue );
            mtCOVERAGE_TEST_MARKER();
        }

        return pxNewQueue;
 4001554:	e0bffb17 	ldw	r2,-20(fp)
    }
 4001558:	e6fffc04 	addi	sp,fp,-16
 400155c:	dfc00517 	ldw	ra,20(sp)
 4001560:	df000417 	ldw	fp,16(sp)
 4001564:	dcc00317 	ldw	r19,12(sp)
 4001568:	dc800217 	ldw	r18,8(sp)
 400156c:	dc400117 	ldw	r17,4(sp)
 4001570:	dc000017 	ldw	r16,0(sp)
 4001574:	dec00604 	addi	sp,sp,24
 4001578:	f800283a 	ret

0400157c <prvInitialiseNewQueue>:
static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength,
                                   const UBaseType_t uxItemSize,
                                   uint8_t * pucQueueStorage,
                                   const uint8_t ucQueueType,
                                   Queue_t * pxNewQueue )
{
 400157c:	defffa04 	addi	sp,sp,-24
 4001580:	dfc00515 	stw	ra,20(sp)
 4001584:	df000415 	stw	fp,16(sp)
 4001588:	df000404 	addi	fp,sp,16
 400158c:	e13fff15 	stw	r4,-4(fp)
 4001590:	e17ffe15 	stw	r5,-8(fp)
 4001594:	e1bffd15 	stw	r6,-12(fp)
 4001598:	3805883a 	mov	r2,r7
 400159c:	e0bffc05 	stb	r2,-16(fp)
    /* Remove compiler warnings about unused parameters should
     * configUSE_TRACE_FACILITY not be set to 1. */
    ( void ) ucQueueType;

    if( uxItemSize == ( UBaseType_t ) 0 )
 40015a0:	e0bffe17 	ldw	r2,-8(fp)
 40015a4:	1000041e 	bne	r2,zero,40015b8 <prvInitialiseNewQueue+0x3c>
    {
        /* No RAM was allocated for the queue storage area, but PC head cannot
         * be set to NULL because NULL is used as a key to say the queue is used as
         * a mutex.  Therefore just set pcHead to point to the queue as a benign
         * value that is known to be within the memory map. */
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 40015a8:	e0800217 	ldw	r2,8(fp)
 40015ac:	e0c00217 	ldw	r3,8(fp)
 40015b0:	10c00015 	stw	r3,0(r2)
 40015b4:	00000306 	br	40015c4 <prvInitialiseNewQueue+0x48>
    }
    else
    {
        /* Set the head to the start of the queue storage area. */
        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 40015b8:	e0800217 	ldw	r2,8(fp)
 40015bc:	e0fffd17 	ldw	r3,-12(fp)
 40015c0:	10c00015 	stw	r3,0(r2)
    }

    /* Initialise the queue members as described where the queue type is
     * defined. */
    pxNewQueue->uxLength = uxQueueLength;
 40015c4:	e0800217 	ldw	r2,8(fp)
 40015c8:	e0ffff17 	ldw	r3,-4(fp)
 40015cc:	10c00f15 	stw	r3,60(r2)
    pxNewQueue->uxItemSize = uxItemSize;
 40015d0:	e0800217 	ldw	r2,8(fp)
 40015d4:	e0fffe17 	ldw	r3,-8(fp)
 40015d8:	10c01015 	stw	r3,64(r2)
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 40015dc:	01400044 	movi	r5,1
 40015e0:	e1000217 	ldw	r4,8(fp)
 40015e4:	40011980 	call	4001198 <xQueueGenericReset>
        pxNewQueue->pxQueueSetContainer = NULL;
    }
    #endif /* configUSE_QUEUE_SETS */

    traceQUEUE_CREATE( pxNewQueue );
}
 40015e8:	0001883a 	nop
 40015ec:	e037883a 	mov	sp,fp
 40015f0:	dfc00117 	ldw	ra,4(sp)
 40015f4:	df000017 	ldw	fp,0(sp)
 40015f8:	dec00204 	addi	sp,sp,8
 40015fc:	f800283a 	ret

04001600 <prvInitialiseMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    static void prvInitialiseMutex( Queue_t * pxNewQueue )
    {
 4001600:	defffd04 	addi	sp,sp,-12
 4001604:	dfc00215 	stw	ra,8(sp)
 4001608:	df000115 	stw	fp,4(sp)
 400160c:	df000104 	addi	fp,sp,4
 4001610:	e13fff15 	stw	r4,-4(fp)
        if( pxNewQueue != NULL )
 4001614:	e0bfff17 	ldw	r2,-4(fp)
 4001618:	10000b26 	beq	r2,zero,4001648 <prvInitialiseMutex+0x48>
        {
            /* The queue create function will set all the queue structure members
            * correctly for a generic queue, but this function is creating a
            * mutex.  Overwrite those members that need to be set differently -
            * in particular the information required for priority inheritance. */
            pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
 400161c:	e0bfff17 	ldw	r2,-4(fp)
 4001620:	10000215 	stw	zero,8(r2)
            pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 4001624:	e0bfff17 	ldw	r2,-4(fp)
 4001628:	10000015 	stw	zero,0(r2)

            /* In case this is a recursive mutex. */
            pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
 400162c:	e0bfff17 	ldw	r2,-4(fp)
 4001630:	10000315 	stw	zero,12(r2)

            traceCREATE_MUTEX( pxNewQueue );

            /* Start with the semaphore in the expected state. */
            ( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 4001634:	000f883a 	mov	r7,zero
 4001638:	000d883a 	mov	r6,zero
 400163c:	000b883a 	mov	r5,zero
 4001640:	e13fff17 	ldw	r4,-4(fp)
 4001644:	40018580 	call	4001858 <xQueueGenericSend>
        }
        else
        {
            traceCREATE_MUTEX_FAILED();
        }
    }
 4001648:	0001883a 	nop
 400164c:	e037883a 	mov	sp,fp
 4001650:	dfc00117 	ldw	ra,4(sp)
 4001654:	df000017 	ldw	fp,0(sp)
 4001658:	dec00204 	addi	sp,sp,8
 400165c:	f800283a 	ret

04001660 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

    QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
    {
 4001660:	defffa04 	addi	sp,sp,-24
 4001664:	dfc00515 	stw	ra,20(sp)
 4001668:	df000415 	stw	fp,16(sp)
 400166c:	df000404 	addi	fp,sp,16
 4001670:	2005883a 	mov	r2,r4
 4001674:	e0bffc05 	stb	r2,-16(fp)
        QueueHandle_t xNewQueue;
        const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
 4001678:	00800044 	movi	r2,1
 400167c:	e0bfff15 	stw	r2,-4(fp)
 4001680:	e03ffe15 	stw	zero,-8(fp)

        xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
 4001684:	e0bffc03 	ldbu	r2,-16(fp)
 4001688:	100d883a 	mov	r6,r2
 400168c:	e17ffe17 	ldw	r5,-8(fp)
 4001690:	e13fff17 	ldw	r4,-4(fp)
 4001694:	40013d80 	call	40013d8 <xQueueGenericCreate>
 4001698:	e0bffd15 	stw	r2,-12(fp)
        prvInitialiseMutex( ( Queue_t * ) xNewQueue );
 400169c:	e13ffd17 	ldw	r4,-12(fp)
 40016a0:	40016000 	call	4001600 <prvInitialiseMutex>

        return xNewQueue;
 40016a4:	e0bffd17 	ldw	r2,-12(fp)
    }
 40016a8:	e037883a 	mov	sp,fp
 40016ac:	dfc00117 	ldw	ra,4(sp)
 40016b0:	df000017 	ldw	fp,0(sp)
 40016b4:	dec00204 	addi	sp,sp,8
 40016b8:	f800283a 	ret

040016bc <xQueueGiveMutexRecursive>:
/*-----------------------------------------------------------*/

#if ( configUSE_RECURSIVE_MUTEXES == 1 )

    BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
    {
 40016bc:	defffa04 	addi	sp,sp,-24
 40016c0:	dfc00515 	stw	ra,20(sp)
 40016c4:	df000415 	stw	fp,16(sp)
 40016c8:	dc000315 	stw	r16,12(sp)
 40016cc:	df000404 	addi	fp,sp,16
 40016d0:	e13ffc15 	stw	r4,-16(fp)
        BaseType_t xReturn;
        Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 40016d4:	e0bffc17 	ldw	r2,-16(fp)
 40016d8:	e0bffd15 	stw	r2,-12(fp)
         * change outside of this task.  If this task does not hold the mutex then
         * pxMutexHolder can never coincidentally equal the tasks handle, and as
         * this is the only condition we are interested in it does not matter if
         * pxMutexHolder is accessed simultaneously by another task.  Therefore no
         * mutual exclusion is required to test the pxMutexHolder variable. */
        if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
 40016dc:	e0bffd17 	ldw	r2,-12(fp)
 40016e0:	14000217 	ldw	r16,8(r2)
 40016e4:	40059900 	call	4005990 <xTaskGetCurrentTaskHandle>
 40016e8:	8080101e 	bne	r16,r2,400172c <xQueueGiveMutexRecursive+0x70>
            /* uxRecursiveCallCount cannot be zero if xMutexHolder is equal to
             * the task handle, therefore no underflow check is required.  Also,
             * uxRecursiveCallCount is only modified by the mutex holder, and as
             * there can only be one, no mutual exclusion is required to modify the
             * uxRecursiveCallCount member. */
            ( pxMutex->u.xSemaphore.uxRecursiveCallCount )--;
 40016ec:	e0bffd17 	ldw	r2,-12(fp)
 40016f0:	10800317 	ldw	r2,12(r2)
 40016f4:	10ffffc4 	addi	r3,r2,-1
 40016f8:	e0bffd17 	ldw	r2,-12(fp)
 40016fc:	10c00315 	stw	r3,12(r2)

            /* Has the recursive call count unwound to 0? */
            if( pxMutex->u.xSemaphore.uxRecursiveCallCount == ( UBaseType_t ) 0 )
 4001700:	e0bffd17 	ldw	r2,-12(fp)
 4001704:	10800317 	ldw	r2,12(r2)
 4001708:	1000051e 	bne	r2,zero,4001720 <xQueueGiveMutexRecursive+0x64>
            {
                /* Return the mutex.  This will automatically unblock any other
                 * task that might be waiting to access the mutex. */
                ( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
 400170c:	000f883a 	mov	r7,zero
 4001710:	000d883a 	mov	r6,zero
 4001714:	000b883a 	mov	r5,zero
 4001718:	e13ffd17 	ldw	r4,-12(fp)
 400171c:	40018580 	call	4001858 <xQueueGenericSend>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            xReturn = pdPASS;
 4001720:	00800044 	movi	r2,1
 4001724:	e0bffe15 	stw	r2,-8(fp)
 4001728:	00000106 	br	4001730 <xQueueGiveMutexRecursive+0x74>
        }
        else
        {
            /* The mutex cannot be given because the calling task is not the
             * holder. */
            xReturn = pdFAIL;
 400172c:	e03ffe15 	stw	zero,-8(fp)

            traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
        }

        return xReturn;
 4001730:	e0bffe17 	ldw	r2,-8(fp)
    }
 4001734:	e6ffff04 	addi	sp,fp,-4
 4001738:	dfc00217 	ldw	ra,8(sp)
 400173c:	df000117 	ldw	fp,4(sp)
 4001740:	dc000017 	ldw	r16,0(sp)
 4001744:	dec00304 	addi	sp,sp,12
 4001748:	f800283a 	ret

0400174c <xQueueTakeMutexRecursive>:

#if ( configUSE_RECURSIVE_MUTEXES == 1 )

    BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex,
                                         TickType_t xTicksToWait )
    {
 400174c:	defff904 	addi	sp,sp,-28
 4001750:	dfc00615 	stw	ra,24(sp)
 4001754:	df000515 	stw	fp,20(sp)
 4001758:	dc000415 	stw	r16,16(sp)
 400175c:	df000504 	addi	fp,sp,20
 4001760:	e13ffc15 	stw	r4,-16(fp)
 4001764:	e17ffb15 	stw	r5,-20(fp)
        BaseType_t xReturn;
        Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 4001768:	e0bffc17 	ldw	r2,-16(fp)
 400176c:	e0bffd15 	stw	r2,-12(fp)
        /* Comments regarding mutual exclusion as per those within
         * xQueueGiveMutexRecursive(). */

        traceTAKE_MUTEX_RECURSIVE( pxMutex );

        if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
 4001770:	e0bffd17 	ldw	r2,-12(fp)
 4001774:	14000217 	ldw	r16,8(r2)
 4001778:	40059900 	call	4005990 <xTaskGetCurrentTaskHandle>
 400177c:	8080081e 	bne	r16,r2,40017a0 <xQueueTakeMutexRecursive+0x54>
        {
            ( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
 4001780:	e0bffd17 	ldw	r2,-12(fp)
 4001784:	10800317 	ldw	r2,12(r2)
 4001788:	10c00044 	addi	r3,r2,1
 400178c:	e0bffd17 	ldw	r2,-12(fp)
 4001790:	10c00315 	stw	r3,12(r2)
            xReturn = pdPASS;
 4001794:	00800044 	movi	r2,1
 4001798:	e0bffe15 	stw	r2,-8(fp)
 400179c:	00000b06 	br	40017cc <xQueueTakeMutexRecursive+0x80>
        }
        else
        {
            xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );
 40017a0:	e17ffb17 	ldw	r5,-20(fp)
 40017a4:	e13ffd17 	ldw	r4,-12(fp)
 40017a8:	4001dac0 	call	4001dac <xQueueSemaphoreTake>
 40017ac:	e0bffe15 	stw	r2,-8(fp)

            /* pdPASS will only be returned if the mutex was successfully
             * obtained.  The calling task may have entered the Blocked state
             * before reaching here. */
            if( xReturn != pdFAIL )
 40017b0:	e0bffe17 	ldw	r2,-8(fp)
 40017b4:	10000526 	beq	r2,zero,40017cc <xQueueTakeMutexRecursive+0x80>
            {
                ( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
 40017b8:	e0bffd17 	ldw	r2,-12(fp)
 40017bc:	10800317 	ldw	r2,12(r2)
 40017c0:	10c00044 	addi	r3,r2,1
 40017c4:	e0bffd17 	ldw	r2,-12(fp)
 40017c8:	10c00315 	stw	r3,12(r2)
            {
                traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
            }
        }

        return xReturn;
 40017cc:	e0bffe17 	ldw	r2,-8(fp)
    }
 40017d0:	e6ffff04 	addi	sp,fp,-4
 40017d4:	dfc00217 	ldw	ra,8(sp)
 40017d8:	df000117 	ldw	fp,4(sp)
 40017dc:	dc000017 	ldw	r16,0(sp)
 40017e0:	dec00304 	addi	sp,sp,12
 40017e4:	f800283a 	ret

040017e8 <xQueueCreateCountingSemaphore>:

#if ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

    QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount,
                                                 const UBaseType_t uxInitialCount )
    {
 40017e8:	defffb04 	addi	sp,sp,-20
 40017ec:	dfc00415 	stw	ra,16(sp)
 40017f0:	df000315 	stw	fp,12(sp)
 40017f4:	df000304 	addi	fp,sp,12
 40017f8:	e13ffe15 	stw	r4,-8(fp)
 40017fc:	e17ffd15 	stw	r5,-12(fp)
        QueueHandle_t xHandle = NULL;
 4001800:	e03fff15 	stw	zero,-4(fp)

        if( ( uxMaxCount != 0 ) &&
 4001804:	e0bffe17 	ldw	r2,-8(fp)
 4001808:	10000d26 	beq	r2,zero,4001840 <xQueueCreateCountingSemaphore+0x58>
 400180c:	e0bffd17 	ldw	r2,-12(fp)
 4001810:	e0fffe17 	ldw	r3,-8(fp)
 4001814:	18800a36 	bltu	r3,r2,4001840 <xQueueCreateCountingSemaphore+0x58>
            ( uxInitialCount <= uxMaxCount ) )
        {
            xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
 4001818:	01800084 	movi	r6,2
 400181c:	000b883a 	mov	r5,zero
 4001820:	e13ffe17 	ldw	r4,-8(fp)
 4001824:	40013d80 	call	40013d8 <xQueueGenericCreate>
 4001828:	e0bfff15 	stw	r2,-4(fp)

            if( xHandle != NULL )
 400182c:	e0bfff17 	ldw	r2,-4(fp)
 4001830:	10000326 	beq	r2,zero,4001840 <xQueueCreateCountingSemaphore+0x58>
            {
                ( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 4001834:	e0bfff17 	ldw	r2,-4(fp)
 4001838:	e0fffd17 	ldw	r3,-12(fp)
 400183c:	10c00e15 	stw	r3,56(r2)
        {
            configASSERT( xHandle );
            mtCOVERAGE_TEST_MARKER();
        }

        return xHandle;
 4001840:	e0bfff17 	ldw	r2,-4(fp)
    }
 4001844:	e037883a 	mov	sp,fp
 4001848:	dfc00117 	ldw	ra,4(sp)
 400184c:	df000017 	ldw	fp,0(sp)
 4001850:	dec00204 	addi	sp,sp,8
 4001854:	f800283a 	ret

04001858 <xQueueGenericSend>:

BaseType_t xQueueGenericSend( QueueHandle_t xQueue,
                              const void * const pvItemToQueue,
                              TickType_t xTicksToWait,
                              const BaseType_t xCopyPosition )
{
 4001858:	defff504 	addi	sp,sp,-44
 400185c:	dfc00a15 	stw	ra,40(sp)
 4001860:	df000915 	stw	fp,36(sp)
 4001864:	df000904 	addi	fp,sp,36
 4001868:	e13ffa15 	stw	r4,-24(fp)
 400186c:	e17ff915 	stw	r5,-28(fp)
 4001870:	e1bff815 	stw	r6,-32(fp)
 4001874:	e1fff715 	stw	r7,-36(fp)
    BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 4001878:	e03fff15 	stw	zero,-4(fp)
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
 400187c:	e0bffa17 	ldw	r2,-24(fp)
 4001880:	e0bffe15 	stw	r2,-8(fp)
    /*lint -save -e904 This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
 4001884:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
        {
            /* Is there room on the queue now?  The running task must be the
             * highest priority task wanting to access the queue.  If the head item
             * in the queue is to be overwritten then it does not matter if the
             * queue is full. */
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 4001888:	e0bffe17 	ldw	r2,-8(fp)
 400188c:	10c00e17 	ldw	r3,56(r2)
 4001890:	e0bffe17 	ldw	r2,-8(fp)
 4001894:	10800f17 	ldw	r2,60(r2)
 4001898:	18800336 	bltu	r3,r2,40018a8 <xQueueGenericSend+0x50>
 400189c:	e0bff717 	ldw	r2,-36(fp)
 40018a0:	10800098 	cmpnei	r2,r2,2
 40018a4:	1000151e 	bne	r2,zero,40018fc <xQueueGenericSend+0xa4>
                        }
                    }
                }
                #else /* configUSE_QUEUE_SETS */
                {
                    xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 40018a8:	e1bff717 	ldw	r6,-36(fp)
 40018ac:	e17ff917 	ldw	r5,-28(fp)
 40018b0:	e13ffe17 	ldw	r4,-8(fp)
 40018b4:	40024380 	call	4002438 <prvCopyDataToQueue>
 40018b8:	e0bffd15 	stw	r2,-12(fp)

                    /* If there was a task waiting for data to arrive on the
                     * queue then unblock it now. */
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 40018bc:	e0bffe17 	ldw	r2,-8(fp)
 40018c0:	10800917 	ldw	r2,36(r2)
 40018c4:	10000726 	beq	r2,zero,40018e4 <xQueueGenericSend+0x8c>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 40018c8:	e0bffe17 	ldw	r2,-8(fp)
 40018cc:	10800904 	addi	r2,r2,36
 40018d0:	1009883a 	mov	r4,r2
 40018d4:	400502c0 	call	400502c <xTaskRemoveFromEventList>
 40018d8:	10000526 	beq	r2,zero,40018f0 <xQueueGenericSend+0x98>
                        {
                            /* The unblocked task has a priority higher than
                             * our own so yield immediately.  Yes it is ok to do
                             * this from within the critical section - the kernel
                             * takes care of that. */
                            queueYIELD_IF_USING_PREEMPTION();
 40018dc:	003b683a 	trap	0
 40018e0:	00000306 	br	40018f0 <xQueueGenericSend+0x98>
                        else
                        {
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                    else if( xYieldRequired != pdFALSE )
 40018e4:	e0bffd17 	ldw	r2,-12(fp)
 40018e8:	10000126 	beq	r2,zero,40018f0 <xQueueGenericSend+0x98>
                    {
                        /* This path is a special case that will only get
                         * executed if the task was holding multiple mutexes and
                         * the mutexes were given back in an order that is
                         * different to that in which they were taken. */
                        queueYIELD_IF_USING_PREEMPTION();
 40018ec:	003b683a 	trap	0
                        mtCOVERAGE_TEST_MARKER();
                    }
                }
                #endif /* configUSE_QUEUE_SETS */

                taskEXIT_CRITICAL();
 40018f0:	4005fd00 	call	4005fd0 <vTaskExitCritical>
                return pdPASS;
 40018f4:	00800044 	movi	r2,1
 40018f8:	00003f06 	br	40019f8 <xQueueGenericSend+0x1a0>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
 40018fc:	e0bff817 	ldw	r2,-32(fp)
 4001900:	1000031e 	bne	r2,zero,4001910 <xQueueGenericSend+0xb8>
                {
                    /* The queue was full and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
 4001904:	4005fd00 	call	4005fd0 <vTaskExitCritical>

                    /* Return to the original privilege level before exiting
                     * the function. */
                    traceQUEUE_SEND_FAILED( pxQueue );
                    return errQUEUE_FULL;
 4001908:	0005883a 	mov	r2,zero
 400190c:	00003a06 	br	40019f8 <xQueueGenericSend+0x1a0>
                }
                else if( xEntryTimeSet == pdFALSE )
 4001910:	e0bfff17 	ldw	r2,-4(fp)
 4001914:	1000051e 	bne	r2,zero,400192c <xQueueGenericSend+0xd4>
                {
                    /* The queue was full and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
 4001918:	e0bffb04 	addi	r2,fp,-20
 400191c:	1009883a 	mov	r4,r2
 4001920:	40055980 	call	4005598 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
 4001924:	00800044 	movi	r2,1
 4001928:	e0bfff15 	stw	r2,-4(fp)
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
 400192c:	4005fd00 	call	4005fd0 <vTaskExitCritical>

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
 4001930:	40046f00 	call	40046f0 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
 4001934:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
 4001938:	e0bffe17 	ldw	r2,-8(fp)
 400193c:	10801103 	ldbu	r2,68(r2)
 4001940:	10803fcc 	andi	r2,r2,255
 4001944:	1080201c 	xori	r2,r2,128
 4001948:	10bfe004 	addi	r2,r2,-128
 400194c:	10bfffd8 	cmpnei	r2,r2,-1
 4001950:	1000021e 	bne	r2,zero,400195c <xQueueGenericSend+0x104>
 4001954:	e0bffe17 	ldw	r2,-8(fp)
 4001958:	10001105 	stb	zero,68(r2)
 400195c:	e0bffe17 	ldw	r2,-8(fp)
 4001960:	10801143 	ldbu	r2,69(r2)
 4001964:	10803fcc 	andi	r2,r2,255
 4001968:	1080201c 	xori	r2,r2,128
 400196c:	10bfe004 	addi	r2,r2,-128
 4001970:	10bfffd8 	cmpnei	r2,r2,-1
 4001974:	1000021e 	bne	r2,zero,4001980 <xQueueGenericSend+0x128>
 4001978:	e0bffe17 	ldw	r2,-8(fp)
 400197c:	10001145 	stb	zero,69(r2)
 4001980:	4005fd00 	call	4005fd0 <vTaskExitCritical>

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 4001984:	e0fff804 	addi	r3,fp,-32
 4001988:	e0bffb04 	addi	r2,fp,-20
 400198c:	180b883a 	mov	r5,r3
 4001990:	1009883a 	mov	r4,r2
 4001994:	40055d40 	call	40055d4 <xTaskCheckForTimeOut>
 4001998:	1000131e 	bne	r2,zero,40019e8 <xQueueGenericSend+0x190>
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
 400199c:	e13ffe17 	ldw	r4,-8(fp)
 40019a0:	40027ec0 	call	40027ec <prvIsQueueFull>
 40019a4:	10000c26 	beq	r2,zero,40019d8 <xQueueGenericSend+0x180>
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 40019a8:	e0bffe17 	ldw	r2,-8(fp)
 40019ac:	10800404 	addi	r2,r2,16
 40019b0:	e0fff817 	ldw	r3,-32(fp)
 40019b4:	180b883a 	mov	r5,r3
 40019b8:	1009883a 	mov	r4,r2
 40019bc:	4004f200 	call	4004f20 <vTaskPlaceOnEventList>
                /* Unlocking the queue means queue events can effect the
                 * event list. It is possible that interrupts occurring now
                 * remove this task from the event list again - but as the
                 * scheduler is suspended the task will go onto the pending
                 * ready list instead of the actual ready list. */
                prvUnlockQueue( pxQueue );
 40019c0:	e13ffe17 	ldw	r4,-8(fp)
 40019c4:	40026600 	call	4002660 <prvUnlockQueue>
                /* Resuming the scheduler will move tasks from the pending
                 * ready list into the ready list - so it is feasible that this
                 * task is already in the ready list before it yields - in which
                 * case the yield will not cause a context switch unless there
                 * is also a higher priority task in the pending ready list. */
                if( xTaskResumeAll() == pdFALSE )
 40019c8:	400471c0 	call	400471c <xTaskResumeAll>
 40019cc:	103fad1e 	bne	r2,zero,4001884 <xQueueGenericSend+0x2c>
                {
                    portYIELD_WITHIN_API();
 40019d0:	003b683a 	trap	0
 40019d4:	003fab06 	br	4001884 <xQueueGenericSend+0x2c>
                }
            }
            else
            {
                /* Try again. */
                prvUnlockQueue( pxQueue );
 40019d8:	e13ffe17 	ldw	r4,-8(fp)
 40019dc:	40026600 	call	4002660 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
 40019e0:	400471c0 	call	400471c <xTaskResumeAll>
 40019e4:	003fa706 	br	4001884 <xQueueGenericSend+0x2c>
            }
        }
        else
        {
            /* The timeout has expired. */
            prvUnlockQueue( pxQueue );
 40019e8:	e13ffe17 	ldw	r4,-8(fp)
 40019ec:	40026600 	call	4002660 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
 40019f0:	400471c0 	call	400471c <xTaskResumeAll>

            traceQUEUE_SEND_FAILED( pxQueue );
            return errQUEUE_FULL;
 40019f4:	0005883a 	mov	r2,zero
        }
    } /*lint -restore */
}
 40019f8:	e037883a 	mov	sp,fp
 40019fc:	dfc00117 	ldw	ra,4(sp)
 4001a00:	df000017 	ldw	fp,0(sp)
 4001a04:	dec00204 	addi	sp,sp,8
 4001a08:	f800283a 	ret

04001a0c <xQueueGenericSendFromISR>:

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue,
                                     const void * const pvItemToQueue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const BaseType_t xCopyPosition )
{
 4001a0c:	defff404 	addi	sp,sp,-48
 4001a10:	dfc00b15 	stw	ra,44(sp)
 4001a14:	df000a15 	stw	fp,40(sp)
 4001a18:	df000a04 	addi	fp,sp,40
 4001a1c:	e13ff915 	stw	r4,-28(fp)
 4001a20:	e17ff815 	stw	r5,-32(fp)
 4001a24:	e1bff715 	stw	r6,-36(fp)
 4001a28:	e1fff615 	stw	r7,-40(fp)
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
 4001a2c:	e0bff917 	ldw	r2,-28(fp)
 4001a30:	e0bffe15 	stw	r2,-8(fp)
    /* Similar to xQueueGenericSend, except without blocking if there is no room
     * in the queue.  Also don't directly wake a task that was blocked on a queue
     * read, instead return a flag to say whether a context switch is required or
     * not (i.e. has a task with a higher priority than us been woken by this
     * post). */
    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 4001a34:	e03ffd15 	stw	zero,-12(fp)
    {
        if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 4001a38:	e0bffe17 	ldw	r2,-8(fp)
 4001a3c:	10c00e17 	ldw	r3,56(r2)
 4001a40:	e0bffe17 	ldw	r2,-8(fp)
 4001a44:	10800f17 	ldw	r2,60(r2)
 4001a48:	18800336 	bltu	r3,r2,4001a58 <xQueueGenericSendFromISR+0x4c>
 4001a4c:	e0bff617 	ldw	r2,-40(fp)
 4001a50:	10800098 	cmpnei	r2,r2,2
 4001a54:	1000281e 	bne	r2,zero,4001af8 <xQueueGenericSendFromISR+0xec>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
 4001a58:	e0bffe17 	ldw	r2,-8(fp)
 4001a5c:	10801143 	ldbu	r2,69(r2)
 4001a60:	e0bffcc5 	stb	r2,-13(fp)
            const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
 4001a64:	e0bffe17 	ldw	r2,-8(fp)
 4001a68:	10800e17 	ldw	r2,56(r2)
 4001a6c:	e0bffb15 	stw	r2,-20(fp)
            /* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
             *  semaphore or mutex.  That means prvCopyDataToQueue() cannot result
             *  in a task disinheriting a priority and prvCopyDataToQueue() can be
             *  called here even though the disinherit function does not check if
             *  the scheduler is suspended before accessing the ready lists. */
            ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 4001a70:	e1bff617 	ldw	r6,-40(fp)
 4001a74:	e17ff817 	ldw	r5,-32(fp)
 4001a78:	e13ffe17 	ldw	r4,-8(fp)
 4001a7c:	40024380 	call	4002438 <prvCopyDataToQueue>

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
 4001a80:	e0bffcc7 	ldb	r2,-13(fp)
 4001a84:	10bfffd8 	cmpnei	r2,r2,-1
 4001a88:	10000e1e 	bne	r2,zero,4001ac4 <xQueueGenericSendFromISR+0xb8>
                        }
                    }
                }
                #else /* configUSE_QUEUE_SETS */
                {
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 4001a8c:	e0bffe17 	ldw	r2,-8(fp)
 4001a90:	10800917 	ldw	r2,36(r2)
 4001a94:	10001526 	beq	r2,zero,4001aec <xQueueGenericSendFromISR+0xe0>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 4001a98:	e0bffe17 	ldw	r2,-8(fp)
 4001a9c:	10800904 	addi	r2,r2,36
 4001aa0:	1009883a 	mov	r4,r2
 4001aa4:	400502c0 	call	400502c <xTaskRemoveFromEventList>
 4001aa8:	10001026 	beq	r2,zero,4001aec <xQueueGenericSendFromISR+0xe0>
                        {
                            /* The task waiting has a higher priority so record that a
                             * context switch is required. */
                            if( pxHigherPriorityTaskWoken != NULL )
 4001aac:	e0bff717 	ldw	r2,-36(fp)
 4001ab0:	10000e26 	beq	r2,zero,4001aec <xQueueGenericSendFromISR+0xe0>
                            {
                                *pxHigherPriorityTaskWoken = pdTRUE;
 4001ab4:	e0bff717 	ldw	r2,-36(fp)
 4001ab8:	00c00044 	movi	r3,1
 4001abc:	10c00015 	stw	r3,0(r2)
 4001ac0:	00000a06 	br	4001aec <xQueueGenericSendFromISR+0xe0>
            }
            else
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                prvIncrementQueueTxLock( pxQueue, cTxLock );
 4001ac4:	4004a440 	call	4004a44 <uxTaskGetNumberOfTasks>
 4001ac8:	e0bffa15 	stw	r2,-24(fp)
 4001acc:	e0fffcc7 	ldb	r3,-13(fp)
 4001ad0:	e0bffa17 	ldw	r2,-24(fp)
 4001ad4:	1880052e 	bgeu	r3,r2,4001aec <xQueueGenericSendFromISR+0xe0>
 4001ad8:	e0bffcc3 	ldbu	r2,-13(fp)
 4001adc:	10800044 	addi	r2,r2,1
 4001ae0:	1007883a 	mov	r3,r2
 4001ae4:	e0bffe17 	ldw	r2,-8(fp)
 4001ae8:	10c01145 	stb	r3,69(r2)
            }

            xReturn = pdPASS;
 4001aec:	00800044 	movi	r2,1
 4001af0:	e0bfff15 	stw	r2,-4(fp)
        {
 4001af4:	00000106 	br	4001afc <xQueueGenericSendFromISR+0xf0>
        }
        else
        {
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
            xReturn = errQUEUE_FULL;
 4001af8:	e03fff15 	stw	zero,-4(fp)
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
 4001afc:	e0bfff17 	ldw	r2,-4(fp)
}
 4001b00:	e037883a 	mov	sp,fp
 4001b04:	dfc00117 	ldw	ra,4(sp)
 4001b08:	df000017 	ldw	fp,0(sp)
 4001b0c:	dec00204 	addi	sp,sp,8
 4001b10:	f800283a 	ret

04001b14 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue,
                              BaseType_t * const pxHigherPriorityTaskWoken )
{
 4001b14:	defff604 	addi	sp,sp,-40
 4001b18:	dfc00915 	stw	ra,36(sp)
 4001b1c:	df000815 	stw	fp,32(sp)
 4001b20:	df000804 	addi	fp,sp,32
 4001b24:	e13ff915 	stw	r4,-28(fp)
 4001b28:	e17ff815 	stw	r5,-32(fp)
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
 4001b2c:	e0bff917 	ldw	r2,-28(fp)
 4001b30:	e0bffe15 	stw	r2,-8(fp)
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 4001b34:	e03ffd15 	stw	zero,-12(fp)
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 4001b38:	e0bffe17 	ldw	r2,-8(fp)
 4001b3c:	10800e17 	ldw	r2,56(r2)
 4001b40:	e0bffc15 	stw	r2,-16(fp)

        /* When the queue is used to implement a semaphore no data is ever
         * moved through the queue but it is still valid to see if the queue 'has
         * space'. */
        if( uxMessagesWaiting < pxQueue->uxLength )
 4001b44:	e0bffe17 	ldw	r2,-8(fp)
 4001b48:	10800f17 	ldw	r2,60(r2)
 4001b4c:	e0fffc17 	ldw	r3,-16(fp)
 4001b50:	1880252e 	bgeu	r3,r2,4001be8 <xQueueGiveFromISR+0xd4>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
 4001b54:	e0bffe17 	ldw	r2,-8(fp)
 4001b58:	10801143 	ldbu	r2,69(r2)
 4001b5c:	e0bffbc5 	stb	r2,-17(fp)
             * holder - and if there is a mutex holder then the mutex cannot be
             * given from an ISR.  As this is the ISR version of the function it
             * can be assumed there is no mutex holder and no need to determine if
             * priority disinheritance is needed.  Simply increase the count of
             * messages (semaphores) available. */
            pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 4001b60:	e0bffc17 	ldw	r2,-16(fp)
 4001b64:	10c00044 	addi	r3,r2,1
 4001b68:	e0bffe17 	ldw	r2,-8(fp)
 4001b6c:	10c00e15 	stw	r3,56(r2)

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
 4001b70:	e0bffbc7 	ldb	r2,-17(fp)
 4001b74:	10bfffd8 	cmpnei	r2,r2,-1
 4001b78:	10000e1e 	bne	r2,zero,4001bb4 <xQueueGiveFromISR+0xa0>
                        }
                    }
                }
                #else /* configUSE_QUEUE_SETS */
                {
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 4001b7c:	e0bffe17 	ldw	r2,-8(fp)
 4001b80:	10800917 	ldw	r2,36(r2)
 4001b84:	10001526 	beq	r2,zero,4001bdc <xQueueGiveFromISR+0xc8>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 4001b88:	e0bffe17 	ldw	r2,-8(fp)
 4001b8c:	10800904 	addi	r2,r2,36
 4001b90:	1009883a 	mov	r4,r2
 4001b94:	400502c0 	call	400502c <xTaskRemoveFromEventList>
 4001b98:	10001026 	beq	r2,zero,4001bdc <xQueueGiveFromISR+0xc8>
                        {
                            /* The task waiting has a higher priority so record that a
                             * context switch is required. */
                            if( pxHigherPriorityTaskWoken != NULL )
 4001b9c:	e0bff817 	ldw	r2,-32(fp)
 4001ba0:	10000e26 	beq	r2,zero,4001bdc <xQueueGiveFromISR+0xc8>
                            {
                                *pxHigherPriorityTaskWoken = pdTRUE;
 4001ba4:	e0bff817 	ldw	r2,-32(fp)
 4001ba8:	00c00044 	movi	r3,1
 4001bac:	10c00015 	stw	r3,0(r2)
 4001bb0:	00000a06 	br	4001bdc <xQueueGiveFromISR+0xc8>
            }
            else
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                prvIncrementQueueTxLock( pxQueue, cTxLock );
 4001bb4:	4004a440 	call	4004a44 <uxTaskGetNumberOfTasks>
 4001bb8:	e0bffa15 	stw	r2,-24(fp)
 4001bbc:	e0fffbc7 	ldb	r3,-17(fp)
 4001bc0:	e0bffa17 	ldw	r2,-24(fp)
 4001bc4:	1880052e 	bgeu	r3,r2,4001bdc <xQueueGiveFromISR+0xc8>
 4001bc8:	e0bffbc3 	ldbu	r2,-17(fp)
 4001bcc:	10800044 	addi	r2,r2,1
 4001bd0:	1007883a 	mov	r3,r2
 4001bd4:	e0bffe17 	ldw	r2,-8(fp)
 4001bd8:	10c01145 	stb	r3,69(r2)
            }

            xReturn = pdPASS;
 4001bdc:	00800044 	movi	r2,1
 4001be0:	e0bfff15 	stw	r2,-4(fp)
 4001be4:	00000106 	br	4001bec <xQueueGiveFromISR+0xd8>
        }
        else
        {
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
            xReturn = errQUEUE_FULL;
 4001be8:	e03fff15 	stw	zero,-4(fp)
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
 4001bec:	e0bfff17 	ldw	r2,-4(fp)
}
 4001bf0:	e037883a 	mov	sp,fp
 4001bf4:	dfc00117 	ldw	ra,4(sp)
 4001bf8:	df000017 	ldw	fp,0(sp)
 4001bfc:	dec00204 	addi	sp,sp,8
 4001c00:	f800283a 	ret

04001c04 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue,
                          void * const pvBuffer,
                          TickType_t xTicksToWait )
{
 4001c04:	defff604 	addi	sp,sp,-40
 4001c08:	dfc00915 	stw	ra,36(sp)
 4001c0c:	df000815 	stw	fp,32(sp)
 4001c10:	df000804 	addi	fp,sp,32
 4001c14:	e13ffa15 	stw	r4,-24(fp)
 4001c18:	e17ff915 	stw	r5,-28(fp)
 4001c1c:	e1bff815 	stw	r6,-32(fp)
    BaseType_t xEntryTimeSet = pdFALSE;
 4001c20:	e03fff15 	stw	zero,-4(fp)
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
 4001c24:	e0bffa17 	ldw	r2,-24(fp)
 4001c28:	e0bffe15 	stw	r2,-8(fp)
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
 4001c2c:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 4001c30:	e0bffe17 	ldw	r2,-8(fp)
 4001c34:	10800e17 	ldw	r2,56(r2)
 4001c38:	e0bffd15 	stw	r2,-12(fp)

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 4001c3c:	e0bffd17 	ldw	r2,-12(fp)
 4001c40:	10001326 	beq	r2,zero,4001c90 <xQueueReceive+0x8c>
            {
                /* Data available, remove one item. */
                prvCopyDataFromQueue( pxQueue, pvBuffer );
 4001c44:	e17ff917 	ldw	r5,-28(fp)
 4001c48:	e13ffe17 	ldw	r4,-8(fp)
 4001c4c:	40025c40 	call	40025c4 <prvCopyDataFromQueue>
                traceQUEUE_RECEIVE( pxQueue );
                pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 4001c50:	e0bffd17 	ldw	r2,-12(fp)
 4001c54:	10ffffc4 	addi	r3,r2,-1
 4001c58:	e0bffe17 	ldw	r2,-8(fp)
 4001c5c:	10c00e15 	stw	r3,56(r2)

                /* There is now space in the queue, were any tasks waiting to
                 * post to the queue?  If so, unblock the highest priority waiting
                 * task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 4001c60:	e0bffe17 	ldw	r2,-8(fp)
 4001c64:	10800417 	ldw	r2,16(r2)
 4001c68:	10000626 	beq	r2,zero,4001c84 <xQueueReceive+0x80>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 4001c6c:	e0bffe17 	ldw	r2,-8(fp)
 4001c70:	10800404 	addi	r2,r2,16
 4001c74:	1009883a 	mov	r4,r2
 4001c78:	400502c0 	call	400502c <xTaskRemoveFromEventList>
 4001c7c:	10000126 	beq	r2,zero,4001c84 <xQueueReceive+0x80>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
 4001c80:	003b683a 	trap	0
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
 4001c84:	4005fd00 	call	4005fd0 <vTaskExitCritical>
                return pdPASS;
 4001c88:	00800044 	movi	r2,1
 4001c8c:	00004206 	br	4001d98 <xQueueReceive+0x194>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
 4001c90:	e0bff817 	ldw	r2,-32(fp)
 4001c94:	1000031e 	bne	r2,zero,4001ca4 <xQueueReceive+0xa0>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
 4001c98:	4005fd00 	call	4005fd0 <vTaskExitCritical>
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
 4001c9c:	0005883a 	mov	r2,zero
 4001ca0:	00003d06 	br	4001d98 <xQueueReceive+0x194>
                }
                else if( xEntryTimeSet == pdFALSE )
 4001ca4:	e0bfff17 	ldw	r2,-4(fp)
 4001ca8:	1000051e 	bne	r2,zero,4001cc0 <xQueueReceive+0xbc>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
 4001cac:	e0bffb04 	addi	r2,fp,-20
 4001cb0:	1009883a 	mov	r4,r2
 4001cb4:	40055980 	call	4005598 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
 4001cb8:	00800044 	movi	r2,1
 4001cbc:	e0bfff15 	stw	r2,-4(fp)
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
 4001cc0:	4005fd00 	call	4005fd0 <vTaskExitCritical>

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
 4001cc4:	40046f00 	call	40046f0 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
 4001cc8:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
 4001ccc:	e0bffe17 	ldw	r2,-8(fp)
 4001cd0:	10801103 	ldbu	r2,68(r2)
 4001cd4:	10803fcc 	andi	r2,r2,255
 4001cd8:	1080201c 	xori	r2,r2,128
 4001cdc:	10bfe004 	addi	r2,r2,-128
 4001ce0:	10bfffd8 	cmpnei	r2,r2,-1
 4001ce4:	1000021e 	bne	r2,zero,4001cf0 <xQueueReceive+0xec>
 4001ce8:	e0bffe17 	ldw	r2,-8(fp)
 4001cec:	10001105 	stb	zero,68(r2)
 4001cf0:	e0bffe17 	ldw	r2,-8(fp)
 4001cf4:	10801143 	ldbu	r2,69(r2)
 4001cf8:	10803fcc 	andi	r2,r2,255
 4001cfc:	1080201c 	xori	r2,r2,128
 4001d00:	10bfe004 	addi	r2,r2,-128
 4001d04:	10bfffd8 	cmpnei	r2,r2,-1
 4001d08:	1000021e 	bne	r2,zero,4001d14 <xQueueReceive+0x110>
 4001d0c:	e0bffe17 	ldw	r2,-8(fp)
 4001d10:	10001145 	stb	zero,69(r2)
 4001d14:	4005fd00 	call	4005fd0 <vTaskExitCritical>

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 4001d18:	e0fff804 	addi	r3,fp,-32
 4001d1c:	e0bffb04 	addi	r2,fp,-20
 4001d20:	180b883a 	mov	r5,r3
 4001d24:	1009883a 	mov	r4,r2
 4001d28:	40055d40 	call	40055d4 <xTaskCheckForTimeOut>
 4001d2c:	1000131e 	bne	r2,zero,4001d7c <xQueueReceive+0x178>
        {
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 4001d30:	e13ffe17 	ldw	r4,-8(fp)
 4001d34:	40027540 	call	4002754 <prvIsQueueEmpty>
 4001d38:	10000c26 	beq	r2,zero,4001d6c <xQueueReceive+0x168>
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 4001d3c:	e0bffe17 	ldw	r2,-8(fp)
 4001d40:	10800904 	addi	r2,r2,36
 4001d44:	e0fff817 	ldw	r3,-32(fp)
 4001d48:	180b883a 	mov	r5,r3
 4001d4c:	1009883a 	mov	r4,r2
 4001d50:	4004f200 	call	4004f20 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
 4001d54:	e13ffe17 	ldw	r4,-8(fp)
 4001d58:	40026600 	call	4002660 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
 4001d5c:	400471c0 	call	400471c <xTaskResumeAll>
 4001d60:	103fb21e 	bne	r2,zero,4001c2c <xQueueReceive+0x28>
                {
                    portYIELD_WITHIN_API();
 4001d64:	003b683a 	trap	0
 4001d68:	003fb006 	br	4001c2c <xQueueReceive+0x28>
            }
            else
            {
                /* The queue contains data again.  Loop back to try and read the
                 * data. */
                prvUnlockQueue( pxQueue );
 4001d6c:	e13ffe17 	ldw	r4,-8(fp)
 4001d70:	40026600 	call	4002660 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
 4001d74:	400471c0 	call	400471c <xTaskResumeAll>
 4001d78:	003fac06 	br	4001c2c <xQueueReceive+0x28>
        }
        else
        {
            /* Timed out.  If there is no data in the queue exit, otherwise loop
             * back and attempt to read the data. */
            prvUnlockQueue( pxQueue );
 4001d7c:	e13ffe17 	ldw	r4,-8(fp)
 4001d80:	40026600 	call	4002660 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
 4001d84:	400471c0 	call	400471c <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 4001d88:	e13ffe17 	ldw	r4,-8(fp)
 4001d8c:	40027540 	call	4002754 <prvIsQueueEmpty>
 4001d90:	103fa626 	beq	r2,zero,4001c2c <xQueueReceive+0x28>
            {
                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
 4001d94:	0005883a 	mov	r2,zero
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
}
 4001d98:	e037883a 	mov	sp,fp
 4001d9c:	dfc00117 	ldw	ra,4(sp)
 4001da0:	df000017 	ldw	fp,0(sp)
 4001da4:	dec00204 	addi	sp,sp,8
 4001da8:	f800283a 	ret

04001dac <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue,
                                TickType_t xTicksToWait )
{
 4001dac:	defff504 	addi	sp,sp,-44
 4001db0:	dfc00a15 	stw	ra,40(sp)
 4001db4:	df000915 	stw	fp,36(sp)
 4001db8:	df000904 	addi	fp,sp,36
 4001dbc:	e13ff815 	stw	r4,-32(fp)
 4001dc0:	e17ff715 	stw	r5,-36(fp)
    BaseType_t xEntryTimeSet = pdFALSE;
 4001dc4:	e03fff15 	stw	zero,-4(fp)
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
 4001dc8:	e0bff817 	ldw	r2,-32(fp)
 4001dcc:	e0bffd15 	stw	r2,-12(fp)

    #if ( configUSE_MUTEXES == 1 )
        BaseType_t xInheritanceOccurred = pdFALSE;
 4001dd0:	e03ffe15 	stw	zero,-8(fp)
    /*lint -save -e904 This function relaxes the coding standard somewhat to allow return
     * statements within the function itself.  This is done in the interest
     * of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
 4001dd4:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
        {
            /* Semaphores are queues with an item size of 0, and where the
             * number of messages in the queue is the semaphore's count value. */
            const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
 4001dd8:	e0bffd17 	ldw	r2,-12(fp)
 4001ddc:	10800e17 	ldw	r2,56(r2)
 4001de0:	e0bffc15 	stw	r2,-16(fp)

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxSemaphoreCount > ( UBaseType_t ) 0 )
 4001de4:	e0bffc17 	ldw	r2,-16(fp)
 4001de8:	10001726 	beq	r2,zero,4001e48 <xQueueSemaphoreTake+0x9c>
            {
                traceQUEUE_RECEIVE( pxQueue );

                /* Semaphores are queues with a data size of zero and where the
                 * messages waiting is the semaphore's count.  Reduce the count. */
                pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
 4001dec:	e0bffc17 	ldw	r2,-16(fp)
 4001df0:	10ffffc4 	addi	r3,r2,-1
 4001df4:	e0bffd17 	ldw	r2,-12(fp)
 4001df8:	10c00e15 	stw	r3,56(r2)

                #if ( configUSE_MUTEXES == 1 )
                {
                    if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 4001dfc:	e0bffd17 	ldw	r2,-12(fp)
 4001e00:	10800017 	ldw	r2,0(r2)
 4001e04:	1000041e 	bne	r2,zero,4001e18 <xQueueSemaphoreTake+0x6c>
                    {
                        /* Record the information required to implement
                         * priority inheritance should it become necessary. */
                        pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
 4001e08:	40060780 	call	4006078 <pvTaskIncrementMutexHeldCount>
 4001e0c:	1007883a 	mov	r3,r2
 4001e10:	e0bffd17 	ldw	r2,-12(fp)
 4001e14:	10c00215 	stw	r3,8(r2)
                }
                #endif /* configUSE_MUTEXES */

                /* Check to see if other tasks are blocked waiting to give the
                 * semaphore, and if so, unblock the highest priority such task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 4001e18:	e0bffd17 	ldw	r2,-12(fp)
 4001e1c:	10800417 	ldw	r2,16(r2)
 4001e20:	10000626 	beq	r2,zero,4001e3c <xQueueSemaphoreTake+0x90>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 4001e24:	e0bffd17 	ldw	r2,-12(fp)
 4001e28:	10800404 	addi	r2,r2,16
 4001e2c:	1009883a 	mov	r4,r2
 4001e30:	400502c0 	call	400502c <xTaskRemoveFromEventList>
 4001e34:	10000126 	beq	r2,zero,4001e3c <xQueueSemaphoreTake+0x90>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
 4001e38:	003b683a 	trap	0
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
 4001e3c:	4005fd00 	call	4005fd0 <vTaskExitCritical>
                return pdPASS;
 4001e40:	00800044 	movi	r2,1
 4001e44:	00005806 	br	4001fa8 <xQueueSemaphoreTake+0x1fc>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
 4001e48:	e0bff717 	ldw	r2,-36(fp)
 4001e4c:	1000031e 	bne	r2,zero,4001e5c <xQueueSemaphoreTake+0xb0>
                {
                    /* The semaphore count was 0 and no block time is specified
                     * (or the block time has expired) so exit now. */
                    taskEXIT_CRITICAL();
 4001e50:	4005fd00 	call	4005fd0 <vTaskExitCritical>
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
 4001e54:	0005883a 	mov	r2,zero
 4001e58:	00005306 	br	4001fa8 <xQueueSemaphoreTake+0x1fc>
                }
                else if( xEntryTimeSet == pdFALSE )
 4001e5c:	e0bfff17 	ldw	r2,-4(fp)
 4001e60:	1000051e 	bne	r2,zero,4001e78 <xQueueSemaphoreTake+0xcc>
                {
                    /* The semaphore count was 0 and a block time was specified
                     * so configure the timeout structure ready to block. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
 4001e64:	e0bff904 	addi	r2,fp,-28
 4001e68:	1009883a 	mov	r4,r2
 4001e6c:	40055980 	call	4005598 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
 4001e70:	00800044 	movi	r2,1
 4001e74:	e0bfff15 	stw	r2,-4(fp)
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
 4001e78:	4005fd00 	call	4005fd0 <vTaskExitCritical>

        /* Interrupts and other tasks can give to and take from the semaphore
         * now the critical section has been exited. */

        vTaskSuspendAll();
 4001e7c:	40046f00 	call	40046f0 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
 4001e80:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
 4001e84:	e0bffd17 	ldw	r2,-12(fp)
 4001e88:	10801103 	ldbu	r2,68(r2)
 4001e8c:	10803fcc 	andi	r2,r2,255
 4001e90:	1080201c 	xori	r2,r2,128
 4001e94:	10bfe004 	addi	r2,r2,-128
 4001e98:	10bfffd8 	cmpnei	r2,r2,-1
 4001e9c:	1000021e 	bne	r2,zero,4001ea8 <xQueueSemaphoreTake+0xfc>
 4001ea0:	e0bffd17 	ldw	r2,-12(fp)
 4001ea4:	10001105 	stb	zero,68(r2)
 4001ea8:	e0bffd17 	ldw	r2,-12(fp)
 4001eac:	10801143 	ldbu	r2,69(r2)
 4001eb0:	10803fcc 	andi	r2,r2,255
 4001eb4:	1080201c 	xori	r2,r2,128
 4001eb8:	10bfe004 	addi	r2,r2,-128
 4001ebc:	10bfffd8 	cmpnei	r2,r2,-1
 4001ec0:	1000021e 	bne	r2,zero,4001ecc <xQueueSemaphoreTake+0x120>
 4001ec4:	e0bffd17 	ldw	r2,-12(fp)
 4001ec8:	10001145 	stb	zero,69(r2)
 4001ecc:	4005fd00 	call	4005fd0 <vTaskExitCritical>

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 4001ed0:	e0fff704 	addi	r3,fp,-36
 4001ed4:	e0bff904 	addi	r2,fp,-28
 4001ed8:	180b883a 	mov	r5,r3
 4001edc:	1009883a 	mov	r4,r2
 4001ee0:	40055d40 	call	40055d4 <xTaskCheckForTimeOut>
 4001ee4:	10001d1e 	bne	r2,zero,4001f5c <xQueueSemaphoreTake+0x1b0>
        {
            /* A block time is specified and not expired.  If the semaphore
             * count is 0 then enter the Blocked state to wait for a semaphore to
             * become available.  As semaphores are implemented with queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 4001ee8:	e13ffd17 	ldw	r4,-12(fp)
 4001eec:	40027540 	call	4002754 <prvIsQueueEmpty>
 4001ef0:	10001626 	beq	r2,zero,4001f4c <xQueueSemaphoreTake+0x1a0>
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

                #if ( configUSE_MUTEXES == 1 )
                {
                    if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 4001ef4:	e0bffd17 	ldw	r2,-12(fp)
 4001ef8:	10800017 	ldw	r2,0(r2)
 4001efc:	1000071e 	bne	r2,zero,4001f1c <xQueueSemaphoreTake+0x170>
                    {
                        taskENTER_CRITICAL();
 4001f00:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
                        {
                            xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
 4001f04:	e0bffd17 	ldw	r2,-12(fp)
 4001f08:	10800217 	ldw	r2,8(r2)
 4001f0c:	1009883a 	mov	r4,r2
 4001f10:	40059b80 	call	40059b8 <xTaskPriorityInherit>
 4001f14:	e0bffe15 	stw	r2,-8(fp)
                        }
                        taskEXIT_CRITICAL();
 4001f18:	4005fd00 	call	4005fd0 <vTaskExitCritical>
                        mtCOVERAGE_TEST_MARKER();
                    }
                }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 4001f1c:	e0bffd17 	ldw	r2,-12(fp)
 4001f20:	10800904 	addi	r2,r2,36
 4001f24:	e0fff717 	ldw	r3,-36(fp)
 4001f28:	180b883a 	mov	r5,r3
 4001f2c:	1009883a 	mov	r4,r2
 4001f30:	4004f200 	call	4004f20 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
 4001f34:	e13ffd17 	ldw	r4,-12(fp)
 4001f38:	40026600 	call	4002660 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
 4001f3c:	400471c0 	call	400471c <xTaskResumeAll>
 4001f40:	103fa41e 	bne	r2,zero,4001dd4 <xQueueSemaphoreTake+0x28>
                {
                    portYIELD_WITHIN_API();
 4001f44:	003b683a 	trap	0
 4001f48:	003fa206 	br	4001dd4 <xQueueSemaphoreTake+0x28>
            }
            else
            {
                /* There was no timeout and the semaphore count was not 0, so
                 * attempt to take the semaphore again. */
                prvUnlockQueue( pxQueue );
 4001f4c:	e13ffd17 	ldw	r4,-12(fp)
 4001f50:	40026600 	call	4002660 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
 4001f54:	400471c0 	call	400471c <xTaskResumeAll>
 4001f58:	003f9e06 	br	4001dd4 <xQueueSemaphoreTake+0x28>
            }
        }
        else
        {
            /* Timed out. */
            prvUnlockQueue( pxQueue );
 4001f5c:	e13ffd17 	ldw	r4,-12(fp)
 4001f60:	40026600 	call	4002660 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
 4001f64:	400471c0 	call	400471c <xTaskResumeAll>

            /* If the semaphore count is 0 exit now as the timeout has
             * expired.  Otherwise return to attempt to take the semaphore that is
             * known to be available.  As semaphores are implemented by queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 4001f68:	e13ffd17 	ldw	r4,-12(fp)
 4001f6c:	40027540 	call	4002754 <prvIsQueueEmpty>
 4001f70:	103f9826 	beq	r2,zero,4001dd4 <xQueueSemaphoreTake+0x28>
                #if ( configUSE_MUTEXES == 1 )
                {
                    /* xInheritanceOccurred could only have be set if
                     * pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
                     * test the mutex type again to check it is actually a mutex. */
                    if( xInheritanceOccurred != pdFALSE )
 4001f74:	e0bffe17 	ldw	r2,-8(fp)
 4001f78:	10000a26 	beq	r2,zero,4001fa4 <xQueueSemaphoreTake+0x1f8>
                    {
                        taskENTER_CRITICAL();
 4001f7c:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
                            /* This task blocking on the mutex caused another
                             * task to inherit this task's priority.  Now this task
                             * has timed out the priority should be disinherited
                             * again, but only as low as the next highest priority
                             * task that is waiting for the same mutex. */
                            uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
 4001f80:	e13ffd17 	ldw	r4,-12(fp)
 4001f84:	40023e80 	call	40023e8 <prvGetDisinheritPriorityAfterTimeout>
 4001f88:	e0bffb15 	stw	r2,-20(fp)
                            vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
 4001f8c:	e0bffd17 	ldw	r2,-12(fp)
 4001f90:	10800217 	ldw	r2,8(r2)
 4001f94:	e17ffb17 	ldw	r5,-20(fp)
 4001f98:	1009883a 	mov	r4,r2
 4001f9c:	4005d780 	call	4005d78 <vTaskPriorityDisinheritAfterTimeout>
                        }
                        taskEXIT_CRITICAL();
 4001fa0:	4005fd00 	call	4005fd0 <vTaskExitCritical>
                    }
                }
                #endif /* configUSE_MUTEXES */

                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
 4001fa4:	0005883a 	mov	r2,zero
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
}
 4001fa8:	e037883a 	mov	sp,fp
 4001fac:	dfc00117 	ldw	ra,4(sp)
 4001fb0:	df000017 	ldw	fp,0(sp)
 4001fb4:	dec00204 	addi	sp,sp,8
 4001fb8:	f800283a 	ret

04001fbc <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue,
                       void * const pvBuffer,
                       TickType_t xTicksToWait )
{
 4001fbc:	defff504 	addi	sp,sp,-44
 4001fc0:	dfc00a15 	stw	ra,40(sp)
 4001fc4:	df000915 	stw	fp,36(sp)
 4001fc8:	df000904 	addi	fp,sp,36
 4001fcc:	e13ff915 	stw	r4,-28(fp)
 4001fd0:	e17ff815 	stw	r5,-32(fp)
 4001fd4:	e1bff715 	stw	r6,-36(fp)
    BaseType_t xEntryTimeSet = pdFALSE;
 4001fd8:	e03fff15 	stw	zero,-4(fp)
    TimeOut_t xTimeOut;
    int8_t * pcOriginalReadPosition;
    Queue_t * const pxQueue = xQueue;
 4001fdc:	e0bff917 	ldw	r2,-28(fp)
 4001fe0:	e0bffe15 	stw	r2,-8(fp)
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
 4001fe4:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 4001fe8:	e0bffe17 	ldw	r2,-8(fp)
 4001fec:	10800e17 	ldw	r2,56(r2)
 4001ff0:	e0bffd15 	stw	r2,-12(fp)

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 4001ff4:	e0bffd17 	ldw	r2,-12(fp)
 4001ff8:	10001526 	beq	r2,zero,4002050 <xQueuePeek+0x94>
            {
                /* Remember the read position so it can be reset after the data
                 * is read from the queue as this function is only peeking the
                 * data, not removing it. */
                pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
 4001ffc:	e0bffe17 	ldw	r2,-8(fp)
 4002000:	10800317 	ldw	r2,12(r2)
 4002004:	e0bffc15 	stw	r2,-16(fp)

                prvCopyDataFromQueue( pxQueue, pvBuffer );
 4002008:	e17ff817 	ldw	r5,-32(fp)
 400200c:	e13ffe17 	ldw	r4,-8(fp)
 4002010:	40025c40 	call	40025c4 <prvCopyDataFromQueue>
                traceQUEUE_PEEK( pxQueue );

                /* The data is not being removed, so reset the read pointer. */
                pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
 4002014:	e0bffe17 	ldw	r2,-8(fp)
 4002018:	e0fffc17 	ldw	r3,-16(fp)
 400201c:	10c00315 	stw	r3,12(r2)

                /* The data is being left in the queue, so see if there are
                 * any other tasks waiting for the data. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 4002020:	e0bffe17 	ldw	r2,-8(fp)
 4002024:	10800917 	ldw	r2,36(r2)
 4002028:	10000626 	beq	r2,zero,4002044 <xQueuePeek+0x88>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 400202c:	e0bffe17 	ldw	r2,-8(fp)
 4002030:	10800904 	addi	r2,r2,36
 4002034:	1009883a 	mov	r4,r2
 4002038:	400502c0 	call	400502c <xTaskRemoveFromEventList>
 400203c:	10000126 	beq	r2,zero,4002044 <xQueuePeek+0x88>
                    {
                        /* The task waiting has a higher priority than this task. */
                        queueYIELD_IF_USING_PREEMPTION();
 4002040:	003b683a 	trap	0
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
 4002044:	4005fd00 	call	4005fd0 <vTaskExitCritical>
                return pdPASS;
 4002048:	00800044 	movi	r2,1
 400204c:	00004206 	br	4002158 <xQueuePeek+0x19c>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
 4002050:	e0bff717 	ldw	r2,-36(fp)
 4002054:	1000031e 	bne	r2,zero,4002064 <xQueuePeek+0xa8>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
 4002058:	4005fd00 	call	4005fd0 <vTaskExitCritical>
                    traceQUEUE_PEEK_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
 400205c:	0005883a 	mov	r2,zero
 4002060:	00003d06 	br	4002158 <xQueuePeek+0x19c>
                }
                else if( xEntryTimeSet == pdFALSE )
 4002064:	e0bfff17 	ldw	r2,-4(fp)
 4002068:	1000051e 	bne	r2,zero,4002080 <xQueuePeek+0xc4>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure ready to enter the blocked
                     * state. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
 400206c:	e0bffa04 	addi	r2,fp,-24
 4002070:	1009883a 	mov	r4,r2
 4002074:	40055980 	call	4005598 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
 4002078:	00800044 	movi	r2,1
 400207c:	e0bfff15 	stw	r2,-4(fp)
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
 4002080:	4005fd00 	call	4005fd0 <vTaskExitCritical>

        /* Interrupts and other tasks can send to and receive from the queue
         * now that the critical section has been exited. */

        vTaskSuspendAll();
 4002084:	40046f00 	call	40046f0 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
 4002088:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
 400208c:	e0bffe17 	ldw	r2,-8(fp)
 4002090:	10801103 	ldbu	r2,68(r2)
 4002094:	10803fcc 	andi	r2,r2,255
 4002098:	1080201c 	xori	r2,r2,128
 400209c:	10bfe004 	addi	r2,r2,-128
 40020a0:	10bfffd8 	cmpnei	r2,r2,-1
 40020a4:	1000021e 	bne	r2,zero,40020b0 <xQueuePeek+0xf4>
 40020a8:	e0bffe17 	ldw	r2,-8(fp)
 40020ac:	10001105 	stb	zero,68(r2)
 40020b0:	e0bffe17 	ldw	r2,-8(fp)
 40020b4:	10801143 	ldbu	r2,69(r2)
 40020b8:	10803fcc 	andi	r2,r2,255
 40020bc:	1080201c 	xori	r2,r2,128
 40020c0:	10bfe004 	addi	r2,r2,-128
 40020c4:	10bfffd8 	cmpnei	r2,r2,-1
 40020c8:	1000021e 	bne	r2,zero,40020d4 <xQueuePeek+0x118>
 40020cc:	e0bffe17 	ldw	r2,-8(fp)
 40020d0:	10001145 	stb	zero,69(r2)
 40020d4:	4005fd00 	call	4005fd0 <vTaskExitCritical>

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 40020d8:	e0fff704 	addi	r3,fp,-36
 40020dc:	e0bffa04 	addi	r2,fp,-24
 40020e0:	180b883a 	mov	r5,r3
 40020e4:	1009883a 	mov	r4,r2
 40020e8:	40055d40 	call	40055d4 <xTaskCheckForTimeOut>
 40020ec:	1000131e 	bne	r2,zero,400213c <xQueuePeek+0x180>
        {
            /* Timeout has not expired yet, check to see if there is data in the
            * queue now, and if not enter the Blocked state to wait for data. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 40020f0:	e13ffe17 	ldw	r4,-8(fp)
 40020f4:	40027540 	call	4002754 <prvIsQueueEmpty>
 40020f8:	10000c26 	beq	r2,zero,400212c <xQueuePeek+0x170>
            {
                traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 40020fc:	e0bffe17 	ldw	r2,-8(fp)
 4002100:	10800904 	addi	r2,r2,36
 4002104:	e0fff717 	ldw	r3,-36(fp)
 4002108:	180b883a 	mov	r5,r3
 400210c:	1009883a 	mov	r4,r2
 4002110:	4004f200 	call	4004f20 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
 4002114:	e13ffe17 	ldw	r4,-8(fp)
 4002118:	40026600 	call	4002660 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
 400211c:	400471c0 	call	400471c <xTaskResumeAll>
 4002120:	103fb01e 	bne	r2,zero,4001fe4 <xQueuePeek+0x28>
                {
                    portYIELD_WITHIN_API();
 4002124:	003b683a 	trap	0
 4002128:	003fae06 	br	4001fe4 <xQueuePeek+0x28>
            }
            else
            {
                /* There is data in the queue now, so don't enter the blocked
                 * state, instead return to try and obtain the data. */
                prvUnlockQueue( pxQueue );
 400212c:	e13ffe17 	ldw	r4,-8(fp)
 4002130:	40026600 	call	4002660 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
 4002134:	400471c0 	call	400471c <xTaskResumeAll>
 4002138:	003faa06 	br	4001fe4 <xQueuePeek+0x28>
        }
        else
        {
            /* The timeout has expired.  If there is still no data in the queue
             * exit, otherwise go back and try to read the data again. */
            prvUnlockQueue( pxQueue );
 400213c:	e13ffe17 	ldw	r4,-8(fp)
 4002140:	40026600 	call	4002660 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
 4002144:	400471c0 	call	400471c <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 4002148:	e13ffe17 	ldw	r4,-8(fp)
 400214c:	40027540 	call	4002754 <prvIsQueueEmpty>
 4002150:	103fa426 	beq	r2,zero,4001fe4 <xQueuePeek+0x28>
            {
                traceQUEUE_PEEK_FAILED( pxQueue );
                return errQUEUE_EMPTY;
 4002154:	0005883a 	mov	r2,zero
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
}
 4002158:	e037883a 	mov	sp,fp
 400215c:	dfc00117 	ldw	ra,4(sp)
 4002160:	df000017 	ldw	fp,0(sp)
 4002164:	dec00204 	addi	sp,sp,8
 4002168:	f800283a 	ret

0400216c <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue,
                                 void * const pvBuffer,
                                 BaseType_t * const pxHigherPriorityTaskWoken )
{
 400216c:	defff504 	addi	sp,sp,-44
 4002170:	dfc00a15 	stw	ra,40(sp)
 4002174:	df000915 	stw	fp,36(sp)
 4002178:	df000904 	addi	fp,sp,36
 400217c:	e13ff915 	stw	r4,-28(fp)
 4002180:	e17ff815 	stw	r5,-32(fp)
 4002184:	e1bff715 	stw	r6,-36(fp)
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
 4002188:	e0bff917 	ldw	r2,-28(fp)
 400218c:	e0bffe15 	stw	r2,-8(fp)
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 4002190:	e03ffd15 	stw	zero,-12(fp)
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 4002194:	e0bffe17 	ldw	r2,-8(fp)
 4002198:	10800e17 	ldw	r2,56(r2)
 400219c:	e0bffc15 	stw	r2,-16(fp)

        /* Cannot block in an ISR, so check there is data available. */
        if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 40021a0:	e0bffc17 	ldw	r2,-16(fp)
 40021a4:	10002826 	beq	r2,zero,4002248 <xQueueReceiveFromISR+0xdc>
        {
            const int8_t cRxLock = pxQueue->cRxLock;
 40021a8:	e0bffe17 	ldw	r2,-8(fp)
 40021ac:	10801103 	ldbu	r2,68(r2)
 40021b0:	e0bffbc5 	stb	r2,-17(fp)

            traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

            prvCopyDataFromQueue( pxQueue, pvBuffer );
 40021b4:	e17ff817 	ldw	r5,-32(fp)
 40021b8:	e13ffe17 	ldw	r4,-8(fp)
 40021bc:	40025c40 	call	40025c4 <prvCopyDataFromQueue>
            pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 40021c0:	e0bffc17 	ldw	r2,-16(fp)
 40021c4:	10ffffc4 	addi	r3,r2,-1
 40021c8:	e0bffe17 	ldw	r2,-8(fp)
 40021cc:	10c00e15 	stw	r3,56(r2)

            /* If the queue is locked the event list will not be modified.
             * Instead update the lock count so the task that unlocks the queue
             * will know that an ISR has removed data while the queue was
             * locked. */
            if( cRxLock == queueUNLOCKED )
 40021d0:	e0bffbc7 	ldb	r2,-17(fp)
 40021d4:	10bfffd8 	cmpnei	r2,r2,-1
 40021d8:	10000e1e 	bne	r2,zero,4002214 <xQueueReceiveFromISR+0xa8>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 40021dc:	e0bffe17 	ldw	r2,-8(fp)
 40021e0:	10800417 	ldw	r2,16(r2)
 40021e4:	10001526 	beq	r2,zero,400223c <xQueueReceiveFromISR+0xd0>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 40021e8:	e0bffe17 	ldw	r2,-8(fp)
 40021ec:	10800404 	addi	r2,r2,16
 40021f0:	1009883a 	mov	r4,r2
 40021f4:	400502c0 	call	400502c <xTaskRemoveFromEventList>
 40021f8:	10001026 	beq	r2,zero,400223c <xQueueReceiveFromISR+0xd0>
                    {
                        /* The task waiting has a higher priority than us so
                         * force a context switch. */
                        if( pxHigherPriorityTaskWoken != NULL )
 40021fc:	e0bff717 	ldw	r2,-36(fp)
 4002200:	10000e26 	beq	r2,zero,400223c <xQueueReceiveFromISR+0xd0>
                        {
                            *pxHigherPriorityTaskWoken = pdTRUE;
 4002204:	e0bff717 	ldw	r2,-36(fp)
 4002208:	00c00044 	movi	r3,1
 400220c:	10c00015 	stw	r3,0(r2)
 4002210:	00000a06 	br	400223c <xQueueReceiveFromISR+0xd0>
            }
            else
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was removed while it was locked. */
                prvIncrementQueueRxLock( pxQueue, cRxLock );
 4002214:	4004a440 	call	4004a44 <uxTaskGetNumberOfTasks>
 4002218:	e0bffa15 	stw	r2,-24(fp)
 400221c:	e0fffbc7 	ldb	r3,-17(fp)
 4002220:	e0bffa17 	ldw	r2,-24(fp)
 4002224:	1880052e 	bgeu	r3,r2,400223c <xQueueReceiveFromISR+0xd0>
 4002228:	e0bffbc3 	ldbu	r2,-17(fp)
 400222c:	10800044 	addi	r2,r2,1
 4002230:	1007883a 	mov	r3,r2
 4002234:	e0bffe17 	ldw	r2,-8(fp)
 4002238:	10c01105 	stb	r3,68(r2)
            }

            xReturn = pdPASS;
 400223c:	00800044 	movi	r2,1
 4002240:	e0bfff15 	stw	r2,-4(fp)
 4002244:	00000106 	br	400224c <xQueueReceiveFromISR+0xe0>
        }
        else
        {
            xReturn = pdFAIL;
 4002248:	e03fff15 	stw	zero,-4(fp)
            traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
 400224c:	e0bfff17 	ldw	r2,-4(fp)
}
 4002250:	e037883a 	mov	sp,fp
 4002254:	dfc00117 	ldw	ra,4(sp)
 4002258:	df000017 	ldw	fp,0(sp)
 400225c:	dec00204 	addi	sp,sp,8
 4002260:	f800283a 	ret

04002264 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,
                              void * const pvBuffer )
{
 4002264:	defff804 	addi	sp,sp,-32
 4002268:	dfc00715 	stw	ra,28(sp)
 400226c:	df000615 	stw	fp,24(sp)
 4002270:	df000604 	addi	fp,sp,24
 4002274:	e13ffb15 	stw	r4,-20(fp)
 4002278:	e17ffa15 	stw	r5,-24(fp)
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    int8_t * pcOriginalReadPosition;
    Queue_t * const pxQueue = xQueue;
 400227c:	e0bffb17 	ldw	r2,-20(fp)
 4002280:	e0bffe15 	stw	r2,-8(fp)
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 4002284:	e03ffd15 	stw	zero,-12(fp)
    {
        /* Cannot block in an ISR, so check there is data available. */
        if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 4002288:	e0bffe17 	ldw	r2,-8(fp)
 400228c:	10800e17 	ldw	r2,56(r2)
 4002290:	10000c26 	beq	r2,zero,40022c4 <xQueuePeekFromISR+0x60>
        {
            traceQUEUE_PEEK_FROM_ISR( pxQueue );

            /* Remember the read position so it can be reset as nothing is
             * actually being removed from the queue. */
            pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
 4002294:	e0bffe17 	ldw	r2,-8(fp)
 4002298:	10800317 	ldw	r2,12(r2)
 400229c:	e0bffc15 	stw	r2,-16(fp)
            prvCopyDataFromQueue( pxQueue, pvBuffer );
 40022a0:	e17ffa17 	ldw	r5,-24(fp)
 40022a4:	e13ffe17 	ldw	r4,-8(fp)
 40022a8:	40025c40 	call	40025c4 <prvCopyDataFromQueue>
            pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
 40022ac:	e0bffe17 	ldw	r2,-8(fp)
 40022b0:	e0fffc17 	ldw	r3,-16(fp)
 40022b4:	10c00315 	stw	r3,12(r2)

            xReturn = pdPASS;
 40022b8:	00800044 	movi	r2,1
 40022bc:	e0bfff15 	stw	r2,-4(fp)
 40022c0:	00000106 	br	40022c8 <xQueuePeekFromISR+0x64>
        }
        else
        {
            xReturn = pdFAIL;
 40022c4:	e03fff15 	stw	zero,-4(fp)
            traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
 40022c8:	e0bfff17 	ldw	r2,-4(fp)
}
 40022cc:	e037883a 	mov	sp,fp
 40022d0:	dfc00117 	ldw	ra,4(sp)
 40022d4:	df000017 	ldw	fp,0(sp)
 40022d8:	dec00204 	addi	sp,sp,8
 40022dc:	f800283a 	ret

040022e0 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
 40022e0:	defffc04 	addi	sp,sp,-16
 40022e4:	dfc00315 	stw	ra,12(sp)
 40022e8:	df000215 	stw	fp,8(sp)
 40022ec:	df000204 	addi	fp,sp,8
 40022f0:	e13ffe15 	stw	r4,-8(fp)
    UBaseType_t uxReturn;

    configASSERT( xQueue );

    taskENTER_CRITICAL();
 40022f4:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
    {
        uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
 40022f8:	e0bffe17 	ldw	r2,-8(fp)
 40022fc:	10800e17 	ldw	r2,56(r2)
 4002300:	e0bfff15 	stw	r2,-4(fp)
    }
    taskEXIT_CRITICAL();
 4002304:	4005fd00 	call	4005fd0 <vTaskExitCritical>

    return uxReturn;
 4002308:	e0bfff17 	ldw	r2,-4(fp)
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 400230c:	e037883a 	mov	sp,fp
 4002310:	dfc00117 	ldw	ra,4(sp)
 4002314:	df000017 	ldw	fp,0(sp)
 4002318:	dec00204 	addi	sp,sp,8
 400231c:	f800283a 	ret

04002320 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
 4002320:	defffb04 	addi	sp,sp,-20
 4002324:	dfc00415 	stw	ra,16(sp)
 4002328:	df000315 	stw	fp,12(sp)
 400232c:	df000304 	addi	fp,sp,12
 4002330:	e13ffd15 	stw	r4,-12(fp)
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;
 4002334:	e0bffd17 	ldw	r2,-12(fp)
 4002338:	e0bfff15 	stw	r2,-4(fp)

    configASSERT( pxQueue );

    taskENTER_CRITICAL();
 400233c:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
    {
        uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
 4002340:	e0bfff17 	ldw	r2,-4(fp)
 4002344:	10c00f17 	ldw	r3,60(r2)
 4002348:	e0bfff17 	ldw	r2,-4(fp)
 400234c:	10800e17 	ldw	r2,56(r2)
 4002350:	1885c83a 	sub	r2,r3,r2
 4002354:	e0bffe15 	stw	r2,-8(fp)
    }
    taskEXIT_CRITICAL();
 4002358:	4005fd00 	call	4005fd0 <vTaskExitCritical>

    return uxReturn;
 400235c:	e0bffe17 	ldw	r2,-8(fp)
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 4002360:	e037883a 	mov	sp,fp
 4002364:	dfc00117 	ldw	ra,4(sp)
 4002368:	df000017 	ldw	fp,0(sp)
 400236c:	dec00204 	addi	sp,sp,8
 4002370:	f800283a 	ret

04002374 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
 4002374:	defffc04 	addi	sp,sp,-16
 4002378:	df000315 	stw	fp,12(sp)
 400237c:	df000304 	addi	fp,sp,12
 4002380:	e13ffd15 	stw	r4,-12(fp)
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;
 4002384:	e0bffd17 	ldw	r2,-12(fp)
 4002388:	e0bfff15 	stw	r2,-4(fp)

    configASSERT( pxQueue );
    uxReturn = pxQueue->uxMessagesWaiting;
 400238c:	e0bfff17 	ldw	r2,-4(fp)
 4002390:	10800e17 	ldw	r2,56(r2)
 4002394:	e0bffe15 	stw	r2,-8(fp)

    return uxReturn;
 4002398:	e0bffe17 	ldw	r2,-8(fp)
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 400239c:	e037883a 	mov	sp,fp
 40023a0:	df000017 	ldw	fp,0(sp)
 40023a4:	dec00104 	addi	sp,sp,4
 40023a8:	f800283a 	ret

040023ac <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
 40023ac:	defffc04 	addi	sp,sp,-16
 40023b0:	dfc00315 	stw	ra,12(sp)
 40023b4:	df000215 	stw	fp,8(sp)
 40023b8:	df000204 	addi	fp,sp,8
 40023bc:	e13ffe15 	stw	r4,-8(fp)
    Queue_t * const pxQueue = xQueue;
 40023c0:	e0bffe17 	ldw	r2,-8(fp)
 40023c4:	e0bfff15 	stw	r2,-4(fp)

    #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
    {
        /* The queue can only have been allocated dynamically - free it
         * again. */
        vPortFree( pxQueue );
 40023c8:	e13fff17 	ldw	r4,-4(fp)
 40023cc:	40011240 	call	4001124 <vPortFree>
        /* The queue must have been statically allocated, so is not going to be
         * deleted.  Avoid compiler warnings about the unused parameter. */
        ( void ) pxQueue;
    }
    #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
 40023d0:	0001883a 	nop
 40023d4:	e037883a 	mov	sp,fp
 40023d8:	dfc00117 	ldw	ra,4(sp)
 40023dc:	df000017 	ldw	fp,0(sp)
 40023e0:	dec00204 	addi	sp,sp,8
 40023e4:	f800283a 	ret

040023e8 <prvGetDisinheritPriorityAfterTimeout>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
    {
 40023e8:	defffd04 	addi	sp,sp,-12
 40023ec:	df000215 	stw	fp,8(sp)
 40023f0:	df000204 	addi	fp,sp,8
 40023f4:	e13ffe15 	stw	r4,-8(fp)
         * priority, but the waiting task times out, then the holder should
         * disinherit the priority - but only down to the highest priority of any
         * other tasks that are waiting for the same mutex.  For this purpose,
         * return the priority of the highest priority task that is waiting for the
         * mutex. */
        if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
 40023f8:	e0bffe17 	ldw	r2,-8(fp)
 40023fc:	10800917 	ldw	r2,36(r2)
 4002400:	10000726 	beq	r2,zero,4002420 <prvGetDisinheritPriorityAfterTimeout+0x38>
        {
            uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
 4002404:	e0bffe17 	ldw	r2,-8(fp)
 4002408:	10800c17 	ldw	r2,48(r2)
 400240c:	10800017 	ldw	r2,0(r2)
 4002410:	00c00144 	movi	r3,5
 4002414:	1885c83a 	sub	r2,r3,r2
 4002418:	e0bfff15 	stw	r2,-4(fp)
 400241c:	00000106 	br	4002424 <prvGetDisinheritPriorityAfterTimeout+0x3c>
        }
        else
        {
            uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
 4002420:	e03fff15 	stw	zero,-4(fp)
        }

        return uxHighestPriorityOfWaitingTasks;
 4002424:	e0bfff17 	ldw	r2,-4(fp)
    }
 4002428:	e037883a 	mov	sp,fp
 400242c:	df000017 	ldw	fp,0(sp)
 4002430:	dec00104 	addi	sp,sp,4
 4002434:	f800283a 	ret

04002438 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
                                      const void * pvItemToQueue,
                                      const BaseType_t xPosition )
{
 4002438:	defff904 	addi	sp,sp,-28
 400243c:	dfc00615 	stw	ra,24(sp)
 4002440:	df000515 	stw	fp,20(sp)
 4002444:	df000504 	addi	fp,sp,20
 4002448:	e13ffd15 	stw	r4,-12(fp)
 400244c:	e17ffc15 	stw	r5,-16(fp)
 4002450:	e1bffb15 	stw	r6,-20(fp)
    BaseType_t xReturn = pdFALSE;
 4002454:	e03fff15 	stw	zero,-4(fp)
    UBaseType_t uxMessagesWaiting;

    /* This function is called from a critical section. */

    uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 4002458:	e0bffd17 	ldw	r2,-12(fp)
 400245c:	10800e17 	ldw	r2,56(r2)
 4002460:	e0bffe15 	stw	r2,-8(fp)

    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 4002464:	e0bffd17 	ldw	r2,-12(fp)
 4002468:	10801017 	ldw	r2,64(r2)
 400246c:	10000b1e 	bne	r2,zero,400249c <prvCopyDataToQueue+0x64>
    {
        #if ( configUSE_MUTEXES == 1 )
        {
            if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 4002470:	e0bffd17 	ldw	r2,-12(fp)
 4002474:	10800017 	ldw	r2,0(r2)
 4002478:	1000481e 	bne	r2,zero,400259c <prvCopyDataToQueue+0x164>
            {
                /* The mutex is no longer being held. */
                xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
 400247c:	e0bffd17 	ldw	r2,-12(fp)
 4002480:	10800217 	ldw	r2,8(r2)
 4002484:	1009883a 	mov	r4,r2
 4002488:	4005bc00 	call	4005bc0 <xTaskPriorityDisinherit>
 400248c:	e0bfff15 	stw	r2,-4(fp)
                pxQueue->u.xSemaphore.xMutexHolder = NULL;
 4002490:	e0bffd17 	ldw	r2,-12(fp)
 4002494:	10000215 	stw	zero,8(r2)
 4002498:	00004006 	br	400259c <prvCopyDataToQueue+0x164>
                mtCOVERAGE_TEST_MARKER();
            }
        }
        #endif /* configUSE_MUTEXES */
    }
    else if( xPosition == queueSEND_TO_BACK )
 400249c:	e0bffb17 	ldw	r2,-20(fp)
 40024a0:	1000191e 	bne	r2,zero,4002508 <prvCopyDataToQueue+0xd0>
    {
        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 40024a4:	e0bffd17 	ldw	r2,-12(fp)
 40024a8:	10c00117 	ldw	r3,4(r2)
 40024ac:	e0bffd17 	ldw	r2,-12(fp)
 40024b0:	10801017 	ldw	r2,64(r2)
 40024b4:	100d883a 	mov	r6,r2
 40024b8:	e17ffc17 	ldw	r5,-16(fp)
 40024bc:	1809883a 	mov	r4,r3
 40024c0:	40078800 	call	4007880 <memcpy>
        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 40024c4:	e0bffd17 	ldw	r2,-12(fp)
 40024c8:	10c00117 	ldw	r3,4(r2)
 40024cc:	e0bffd17 	ldw	r2,-12(fp)
 40024d0:	10801017 	ldw	r2,64(r2)
 40024d4:	1887883a 	add	r3,r3,r2
 40024d8:	e0bffd17 	ldw	r2,-12(fp)
 40024dc:	10c00115 	stw	r3,4(r2)

        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 40024e0:	e0bffd17 	ldw	r2,-12(fp)
 40024e4:	10c00117 	ldw	r3,4(r2)
 40024e8:	e0bffd17 	ldw	r2,-12(fp)
 40024ec:	10800217 	ldw	r2,8(r2)
 40024f0:	18802a36 	bltu	r3,r2,400259c <prvCopyDataToQueue+0x164>
        {
            pxQueue->pcWriteTo = pxQueue->pcHead;
 40024f4:	e0bffd17 	ldw	r2,-12(fp)
 40024f8:	10c00017 	ldw	r3,0(r2)
 40024fc:	e0bffd17 	ldw	r2,-12(fp)
 4002500:	10c00115 	stw	r3,4(r2)
 4002504:	00002506 	br	400259c <prvCopyDataToQueue+0x164>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
 4002508:	e0bffd17 	ldw	r2,-12(fp)
 400250c:	10c00317 	ldw	r3,12(r2)
 4002510:	e0bffd17 	ldw	r2,-12(fp)
 4002514:	10801017 	ldw	r2,64(r2)
 4002518:	100d883a 	mov	r6,r2
 400251c:	e17ffc17 	ldw	r5,-16(fp)
 4002520:	1809883a 	mov	r4,r3
 4002524:	40078800 	call	4007880 <memcpy>
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
 4002528:	e0bffd17 	ldw	r2,-12(fp)
 400252c:	10c00317 	ldw	r3,12(r2)
 4002530:	e0bffd17 	ldw	r2,-12(fp)
 4002534:	10801017 	ldw	r2,64(r2)
 4002538:	0085c83a 	sub	r2,zero,r2
 400253c:	1887883a 	add	r3,r3,r2
 4002540:	e0bffd17 	ldw	r2,-12(fp)
 4002544:	10c00315 	stw	r3,12(r2)

        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 4002548:	e0bffd17 	ldw	r2,-12(fp)
 400254c:	10c00317 	ldw	r3,12(r2)
 4002550:	e0bffd17 	ldw	r2,-12(fp)
 4002554:	10800017 	ldw	r2,0(r2)
 4002558:	1880082e 	bgeu	r3,r2,400257c <prvCopyDataToQueue+0x144>
        {
            pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
 400255c:	e0bffd17 	ldw	r2,-12(fp)
 4002560:	10c00217 	ldw	r3,8(r2)
 4002564:	e0bffd17 	ldw	r2,-12(fp)
 4002568:	10801017 	ldw	r2,64(r2)
 400256c:	0085c83a 	sub	r2,zero,r2
 4002570:	1887883a 	add	r3,r3,r2
 4002574:	e0bffd17 	ldw	r2,-12(fp)
 4002578:	10c00315 	stw	r3,12(r2)
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( xPosition == queueOVERWRITE )
 400257c:	e0bffb17 	ldw	r2,-20(fp)
 4002580:	10800098 	cmpnei	r2,r2,2
 4002584:	1000051e 	bne	r2,zero,400259c <prvCopyDataToQueue+0x164>
        {
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 4002588:	e0bffe17 	ldw	r2,-8(fp)
 400258c:	10000326 	beq	r2,zero,400259c <prvCopyDataToQueue+0x164>
            {
                /* An item is not being added but overwritten, so subtract
                 * one from the recorded number of items in the queue so when
                 * one is added again below the number of recorded items remains
                 * correct. */
                --uxMessagesWaiting;
 4002590:	e0bffe17 	ldw	r2,-8(fp)
 4002594:	10bfffc4 	addi	r2,r2,-1
 4002598:	e0bffe15 	stw	r2,-8(fp)
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 400259c:	e0bffe17 	ldw	r2,-8(fp)
 40025a0:	10c00044 	addi	r3,r2,1
 40025a4:	e0bffd17 	ldw	r2,-12(fp)
 40025a8:	10c00e15 	stw	r3,56(r2)

    return xReturn;
 40025ac:	e0bfff17 	ldw	r2,-4(fp)
}
 40025b0:	e037883a 	mov	sp,fp
 40025b4:	dfc00117 	ldw	ra,4(sp)
 40025b8:	df000017 	ldw	fp,0(sp)
 40025bc:	dec00204 	addi	sp,sp,8
 40025c0:	f800283a 	ret

040025c4 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue,
                                  void * const pvBuffer )
{
 40025c4:	defffc04 	addi	sp,sp,-16
 40025c8:	dfc00315 	stw	ra,12(sp)
 40025cc:	df000215 	stw	fp,8(sp)
 40025d0:	df000204 	addi	fp,sp,8
 40025d4:	e13fff15 	stw	r4,-4(fp)
 40025d8:	e17ffe15 	stw	r5,-8(fp)
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 40025dc:	e0bfff17 	ldw	r2,-4(fp)
 40025e0:	10801017 	ldw	r2,64(r2)
 40025e4:	10001826 	beq	r2,zero,4002648 <prvCopyDataFromQueue+0x84>
    {
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 40025e8:	e0bfff17 	ldw	r2,-4(fp)
 40025ec:	10c00317 	ldw	r3,12(r2)
 40025f0:	e0bfff17 	ldw	r2,-4(fp)
 40025f4:	10801017 	ldw	r2,64(r2)
 40025f8:	1887883a 	add	r3,r3,r2
 40025fc:	e0bfff17 	ldw	r2,-4(fp)
 4002600:	10c00315 	stw	r3,12(r2)

        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 4002604:	e0bfff17 	ldw	r2,-4(fp)
 4002608:	10c00317 	ldw	r3,12(r2)
 400260c:	e0bfff17 	ldw	r2,-4(fp)
 4002610:	10800217 	ldw	r2,8(r2)
 4002614:	18800436 	bltu	r3,r2,4002628 <prvCopyDataFromQueue+0x64>
        {
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
 4002618:	e0bfff17 	ldw	r2,-4(fp)
 400261c:	10c00017 	ldw	r3,0(r2)
 4002620:	e0bfff17 	ldw	r2,-4(fp)
 4002624:	10c00315 	stw	r3,12(r2)
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 4002628:	e0bfff17 	ldw	r2,-4(fp)
 400262c:	10c00317 	ldw	r3,12(r2)
 4002630:	e0bfff17 	ldw	r2,-4(fp)
 4002634:	10801017 	ldw	r2,64(r2)
 4002638:	100d883a 	mov	r6,r2
 400263c:	180b883a 	mov	r5,r3
 4002640:	e13ffe17 	ldw	r4,-8(fp)
 4002644:	40078800 	call	4007880 <memcpy>
    }
}
 4002648:	0001883a 	nop
 400264c:	e037883a 	mov	sp,fp
 4002650:	dfc00117 	ldw	ra,4(sp)
 4002654:	df000017 	ldw	fp,0(sp)
 4002658:	dec00204 	addi	sp,sp,8
 400265c:	f800283a 	ret

04002660 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
 4002660:	defffc04 	addi	sp,sp,-16
 4002664:	dfc00315 	stw	ra,12(sp)
 4002668:	df000215 	stw	fp,8(sp)
 400266c:	df000204 	addi	fp,sp,8
 4002670:	e13ffe15 	stw	r4,-8(fp)

    /* The lock counts contains the number of extra data items placed or
     * removed from the queue while the queue was locked.  When a queue is
     * locked items can be added or removed, but the event lists cannot be
     * updated. */
    taskENTER_CRITICAL();
 4002674:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
    {
        int8_t cTxLock = pxQueue->cTxLock;
 4002678:	e0bffe17 	ldw	r2,-8(fp)
 400267c:	10801143 	ldbu	r2,69(r2)
 4002680:	e0bfffc5 	stb	r2,-1(fp)

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
 4002684:	00000c06 	br	40026b8 <prvUnlockQueue+0x58>
            }
            #else /* configUSE_QUEUE_SETS */
            {
                /* Tasks that are removed from the event list will get added to
                 * the pending ready list as the scheduler is still suspended. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 4002688:	e0bffe17 	ldw	r2,-8(fp)
 400268c:	10800917 	ldw	r2,36(r2)
 4002690:	10000c26 	beq	r2,zero,40026c4 <prvUnlockQueue+0x64>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 4002694:	e0bffe17 	ldw	r2,-8(fp)
 4002698:	10800904 	addi	r2,r2,36
 400269c:	1009883a 	mov	r4,r2
 40026a0:	400502c0 	call	400502c <xTaskRemoveFromEventList>
 40026a4:	10000126 	beq	r2,zero,40026ac <prvUnlockQueue+0x4c>
                    {
                        /* The task waiting has a higher priority so record that
                         * a context switch is required. */
                        vTaskMissedYield();
 40026a8:	40056bc0 	call	40056bc <vTaskMissedYield>
                    break;
                }
            }
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
 40026ac:	e0bfffc3 	ldbu	r2,-1(fp)
 40026b0:	10bfffc4 	addi	r2,r2,-1
 40026b4:	e0bfffc5 	stb	r2,-1(fp)
        while( cTxLock > queueLOCKED_UNMODIFIED )
 40026b8:	e0bfffc7 	ldb	r2,-1(fp)
 40026bc:	00bff216 	blt	zero,r2,4002688 <prvUnlockQueue+0x28>
 40026c0:	00000106 	br	40026c8 <prvUnlockQueue+0x68>
                    break;
 40026c4:	0001883a 	nop
        }

        pxQueue->cTxLock = queueUNLOCKED;
 40026c8:	e0bffe17 	ldw	r2,-8(fp)
 40026cc:	00ffffc4 	movi	r3,-1
 40026d0:	10c01145 	stb	r3,69(r2)
    }
    taskEXIT_CRITICAL();
 40026d4:	4005fd00 	call	4005fd0 <vTaskExitCritical>

    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
 40026d8:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
    {
        int8_t cRxLock = pxQueue->cRxLock;
 40026dc:	e0bffe17 	ldw	r2,-8(fp)
 40026e0:	10801103 	ldbu	r2,68(r2)
 40026e4:	e0bfff85 	stb	r2,-2(fp)

        while( cRxLock > queueLOCKED_UNMODIFIED )
 40026e8:	00000c06 	br	400271c <prvUnlockQueue+0xbc>
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 40026ec:	e0bffe17 	ldw	r2,-8(fp)
 40026f0:	10800417 	ldw	r2,16(r2)
 40026f4:	10000c26 	beq	r2,zero,4002728 <prvUnlockQueue+0xc8>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 40026f8:	e0bffe17 	ldw	r2,-8(fp)
 40026fc:	10800404 	addi	r2,r2,16
 4002700:	1009883a 	mov	r4,r2
 4002704:	400502c0 	call	400502c <xTaskRemoveFromEventList>
 4002708:	10000126 	beq	r2,zero,4002710 <prvUnlockQueue+0xb0>
                {
                    vTaskMissedYield();
 400270c:	40056bc0 	call	40056bc <vTaskMissedYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                --cRxLock;
 4002710:	e0bfff83 	ldbu	r2,-2(fp)
 4002714:	10bfffc4 	addi	r2,r2,-1
 4002718:	e0bfff85 	stb	r2,-2(fp)
        while( cRxLock > queueLOCKED_UNMODIFIED )
 400271c:	e0bfff87 	ldb	r2,-2(fp)
 4002720:	00bff216 	blt	zero,r2,40026ec <prvUnlockQueue+0x8c>
 4002724:	00000106 	br	400272c <prvUnlockQueue+0xcc>
            }
            else
            {
                break;
 4002728:	0001883a 	nop
            }
        }

        pxQueue->cRxLock = queueUNLOCKED;
 400272c:	e0bffe17 	ldw	r2,-8(fp)
 4002730:	00ffffc4 	movi	r3,-1
 4002734:	10c01105 	stb	r3,68(r2)
    }
    taskEXIT_CRITICAL();
 4002738:	4005fd00 	call	4005fd0 <vTaskExitCritical>
}
 400273c:	0001883a 	nop
 4002740:	e037883a 	mov	sp,fp
 4002744:	dfc00117 	ldw	ra,4(sp)
 4002748:	df000017 	ldw	fp,0(sp)
 400274c:	dec00204 	addi	sp,sp,8
 4002750:	f800283a 	ret

04002754 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
 4002754:	defffc04 	addi	sp,sp,-16
 4002758:	dfc00315 	stw	ra,12(sp)
 400275c:	df000215 	stw	fp,8(sp)
 4002760:	df000204 	addi	fp,sp,8
 4002764:	e13ffe15 	stw	r4,-8(fp)
    BaseType_t xReturn;

    taskENTER_CRITICAL();
 4002768:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
 400276c:	e0bffe17 	ldw	r2,-8(fp)
 4002770:	10800e17 	ldw	r2,56(r2)
 4002774:	1000031e 	bne	r2,zero,4002784 <prvIsQueueEmpty+0x30>
        {
            xReturn = pdTRUE;
 4002778:	00800044 	movi	r2,1
 400277c:	e0bfff15 	stw	r2,-4(fp)
 4002780:	00000106 	br	4002788 <prvIsQueueEmpty+0x34>
        }
        else
        {
            xReturn = pdFALSE;
 4002784:	e03fff15 	stw	zero,-4(fp)
        }
    }
    taskEXIT_CRITICAL();
 4002788:	4005fd00 	call	4005fd0 <vTaskExitCritical>

    return xReturn;
 400278c:	e0bfff17 	ldw	r2,-4(fp)
}
 4002790:	e037883a 	mov	sp,fp
 4002794:	dfc00117 	ldw	ra,4(sp)
 4002798:	df000017 	ldw	fp,0(sp)
 400279c:	dec00204 	addi	sp,sp,8
 40027a0:	f800283a 	ret

040027a4 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
 40027a4:	defffc04 	addi	sp,sp,-16
 40027a8:	df000315 	stw	fp,12(sp)
 40027ac:	df000304 	addi	fp,sp,12
 40027b0:	e13ffd15 	stw	r4,-12(fp)
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;
 40027b4:	e0bffd17 	ldw	r2,-12(fp)
 40027b8:	e0bffe15 	stw	r2,-8(fp)

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
 40027bc:	e0bffe17 	ldw	r2,-8(fp)
 40027c0:	10800e17 	ldw	r2,56(r2)
 40027c4:	1000031e 	bne	r2,zero,40027d4 <xQueueIsQueueEmptyFromISR+0x30>
    {
        xReturn = pdTRUE;
 40027c8:	00800044 	movi	r2,1
 40027cc:	e0bfff15 	stw	r2,-4(fp)
 40027d0:	00000106 	br	40027d8 <xQueueIsQueueEmptyFromISR+0x34>
    }
    else
    {
        xReturn = pdFALSE;
 40027d4:	e03fff15 	stw	zero,-4(fp)
    }

    return xReturn;
 40027d8:	e0bfff17 	ldw	r2,-4(fp)
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 40027dc:	e037883a 	mov	sp,fp
 40027e0:	df000017 	ldw	fp,0(sp)
 40027e4:	dec00104 	addi	sp,sp,4
 40027e8:	f800283a 	ret

040027ec <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )
{
 40027ec:	defffc04 	addi	sp,sp,-16
 40027f0:	dfc00315 	stw	ra,12(sp)
 40027f4:	df000215 	stw	fp,8(sp)
 40027f8:	df000204 	addi	fp,sp,8
 40027fc:	e13ffe15 	stw	r4,-8(fp)
    BaseType_t xReturn;

    taskENTER_CRITICAL();
 4002800:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
    {
        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 4002804:	e0bffe17 	ldw	r2,-8(fp)
 4002808:	10c00e17 	ldw	r3,56(r2)
 400280c:	e0bffe17 	ldw	r2,-8(fp)
 4002810:	10800f17 	ldw	r2,60(r2)
 4002814:	1880031e 	bne	r3,r2,4002824 <prvIsQueueFull+0x38>
        {
            xReturn = pdTRUE;
 4002818:	00800044 	movi	r2,1
 400281c:	e0bfff15 	stw	r2,-4(fp)
 4002820:	00000106 	br	4002828 <prvIsQueueFull+0x3c>
        }
        else
        {
            xReturn = pdFALSE;
 4002824:	e03fff15 	stw	zero,-4(fp)
        }
    }
    taskEXIT_CRITICAL();
 4002828:	4005fd00 	call	4005fd0 <vTaskExitCritical>

    return xReturn;
 400282c:	e0bfff17 	ldw	r2,-4(fp)
}
 4002830:	e037883a 	mov	sp,fp
 4002834:	dfc00117 	ldw	ra,4(sp)
 4002838:	df000017 	ldw	fp,0(sp)
 400283c:	dec00204 	addi	sp,sp,8
 4002840:	f800283a 	ret

04002844 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
 4002844:	defffc04 	addi	sp,sp,-16
 4002848:	df000315 	stw	fp,12(sp)
 400284c:	df000304 	addi	fp,sp,12
 4002850:	e13ffd15 	stw	r4,-12(fp)
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;
 4002854:	e0bffd17 	ldw	r2,-12(fp)
 4002858:	e0bffe15 	stw	r2,-8(fp)

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 400285c:	e0bffe17 	ldw	r2,-8(fp)
 4002860:	10c00e17 	ldw	r3,56(r2)
 4002864:	e0bffe17 	ldw	r2,-8(fp)
 4002868:	10800f17 	ldw	r2,60(r2)
 400286c:	1880031e 	bne	r3,r2,400287c <xQueueIsQueueFullFromISR+0x38>
    {
        xReturn = pdTRUE;
 4002870:	00800044 	movi	r2,1
 4002874:	e0bfff15 	stw	r2,-4(fp)
 4002878:	00000106 	br	4002880 <xQueueIsQueueFullFromISR+0x3c>
    }
    else
    {
        xReturn = pdFALSE;
 400287c:	e03fff15 	stw	zero,-4(fp)
    }

    return xReturn;
 4002880:	e0bfff17 	ldw	r2,-4(fp)
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 4002884:	e037883a 	mov	sp,fp
 4002888:	df000017 	ldw	fp,0(sp)
 400288c:	dec00104 	addi	sp,sp,4
 4002890:	f800283a 	ret

04002894 <xStreamBufferGenericCreate>:
    StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes,
                                                     size_t xTriggerLevelBytes,
                                                     BaseType_t xIsMessageBuffer,
                                                     StreamBufferCallbackFunction_t pxSendCompletedCallback,
                                                     StreamBufferCallbackFunction_t pxReceiveCompletedCallback )
    {
 4002894:	defff504 	addi	sp,sp,-44
 4002898:	dfc00a15 	stw	ra,40(sp)
 400289c:	df000915 	stw	fp,36(sp)
 40028a0:	df000904 	addi	fp,sp,36
 40028a4:	e13ffd15 	stw	r4,-12(fp)
 40028a8:	e17ffc15 	stw	r5,-16(fp)
 40028ac:	e1bffb15 	stw	r6,-20(fp)
 40028b0:	e1fffa15 	stw	r7,-24(fp)

        /* In case the stream buffer is going to be used as a message buffer
         * (that is, it will hold discrete messages with a little meta data that
         * says how big the next message is) check the buffer will be large enough
         * to hold at least one message. */
        if( xIsMessageBuffer == pdTRUE )
 40028b4:	e0bffb17 	ldw	r2,-20(fp)
 40028b8:	10800058 	cmpnei	r2,r2,1
 40028bc:	1000031e 	bne	r2,zero,40028cc <xStreamBufferGenericCreate+0x38>
        {
            /* Is a message buffer but not statically allocated. */
            ucFlags = sbFLAGS_IS_MESSAGE_BUFFER;
 40028c0:	00800044 	movi	r2,1
 40028c4:	e0bffec5 	stb	r2,-5(fp)
 40028c8:	00000106 	br	40028d0 <xStreamBufferGenericCreate+0x3c>
            configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );
        }
        else
        {
            /* Not a message buffer and not statically allocated. */
            ucFlags = 0;
 40028cc:	e03ffec5 	stb	zero,-5(fp)

        configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );

        /* A trigger level of 0 would cause a waiting task to unblock even when
         * the buffer was empty. */
        if( xTriggerLevelBytes == ( size_t ) 0 )
 40028d0:	e0bffc17 	ldw	r2,-16(fp)
 40028d4:	1000021e 	bne	r2,zero,40028e0 <xStreamBufferGenericCreate+0x4c>
        {
            xTriggerLevelBytes = ( size_t ) 1;
 40028d8:	00800044 	movi	r2,1
 40028dc:	e0bffc15 	stw	r2,-16(fp)
         * and the buffer follows immediately after.  The requested size is
         * incremented so the free space is returned as the user would expect -
         * this is a quirk of the implementation that means otherwise the free
         * space would be reported as one byte smaller than would be logically
         * expected. */
        if( xBufferSizeBytes < ( xBufferSizeBytes + 1 + sizeof( StreamBuffer_t ) ) )
 40028e0:	e0bffd17 	ldw	r2,-12(fp)
 40028e4:	00fff784 	movi	r3,-34
 40028e8:	18800936 	bltu	r3,r2,4002910 <xStreamBufferGenericCreate+0x7c>
        {
            xBufferSizeBytes++;
 40028ec:	e0bffd17 	ldw	r2,-12(fp)
 40028f0:	10800044 	addi	r2,r2,1
 40028f4:	e0bffd15 	stw	r2,-12(fp)
            pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */
 40028f8:	e0bffd17 	ldw	r2,-12(fp)
 40028fc:	10800804 	addi	r2,r2,32
 4002900:	1009883a 	mov	r4,r2
 4002904:	400103c0 	call	400103c <pvPortMalloc>
 4002908:	e0bfff15 	stw	r2,-4(fp)
 400290c:	00000106 	br	4002914 <xStreamBufferGenericCreate+0x80>
        }
        else
        {
            pucAllocatedMemory = NULL;
 4002910:	e03fff15 	stw	zero,-4(fp)
        }

        if( pucAllocatedMemory != NULL )
 4002914:	e0bfff17 	ldw	r2,-4(fp)
 4002918:	10000d26 	beq	r2,zero,4002950 <xStreamBufferGenericCreate+0xbc>
        {
            prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory,       /* Structure at the start of the allocated memory. */ /*lint !e9087 Safe cast as allocated memory is aligned. */ /*lint !e826 Area is not too small and alignment is guaranteed provided malloc() behaves as expected and returns aligned buffer. */
 400291c:	e0bfff17 	ldw	r2,-4(fp)
 4002920:	11000804 	addi	r4,r2,32
 4002924:	e0bffec3 	ldbu	r2,-5(fp)
 4002928:	e0c00217 	ldw	r3,8(fp)
 400292c:	d8c00215 	stw	r3,8(sp)
 4002930:	e0fffa17 	ldw	r3,-24(fp)
 4002934:	d8c00115 	stw	r3,4(sp)
 4002938:	d8800015 	stw	r2,0(sp)
 400293c:	e1fffc17 	ldw	r7,-16(fp)
 4002940:	e1bffd17 	ldw	r6,-12(fp)
 4002944:	200b883a 	mov	r5,r4
 4002948:	e13fff17 	ldw	r4,-4(fp)
 400294c:	40037340 	call	4003734 <prvInitialiseNewStreamBuffer>
        else
        {
            traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );
        }

        return ( StreamBufferHandle_t ) pucAllocatedMemory; /*lint !e9087 !e826 Safe cast as allocated memory is aligned. */
 4002950:	e0bfff17 	ldw	r2,-4(fp)
    }
 4002954:	e037883a 	mov	sp,fp
 4002958:	dfc00117 	ldw	ra,4(sp)
 400295c:	df000017 	ldw	fp,0(sp)
 4002960:	dec00204 	addi	sp,sp,8
 4002964:	f800283a 	ret

04002968 <vStreamBufferDelete>:
    }
#endif /* ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
/*-----------------------------------------------------------*/

void vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer )
{
 4002968:	defffc04 	addi	sp,sp,-16
 400296c:	dfc00315 	stw	ra,12(sp)
 4002970:	df000215 	stw	fp,8(sp)
 4002974:	df000204 	addi	fp,sp,8
 4002978:	e13ffe15 	stw	r4,-8(fp)
    StreamBuffer_t * pxStreamBuffer = xStreamBuffer;
 400297c:	e0bffe17 	ldw	r2,-8(fp)
 4002980:	e0bfff15 	stw	r2,-4(fp)

    configASSERT( pxStreamBuffer );

    traceSTREAM_BUFFER_DELETE( xStreamBuffer );

    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) pdFALSE )
 4002984:	e0bfff17 	ldw	r2,-4(fp)
 4002988:	10800703 	ldbu	r2,28(r2)
 400298c:	10803fcc 	andi	r2,r2,255
 4002990:	1080008c 	andi	r2,r2,2
 4002994:	1000031e 	bne	r2,zero,40029a4 <vStreamBufferDelete+0x3c>
    {
        #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
        {
            /* Both the structure and the buffer were allocated using a single call
            * to pvPortMalloc(), hence only one call to vPortFree() is required. */
            vPortFree( ( void * ) pxStreamBuffer ); /*lint !e9087 Standard free() semantics require void *, plus pxStreamBuffer was allocated by pvPortMalloc(). */
 4002998:	e13fff17 	ldw	r4,-4(fp)
 400299c:	40011240 	call	4001124 <vPortFree>
    {
        /* The structure and buffer were not allocated dynamically and cannot be
         * freed - just scrub the structure so future use will assert. */
        ( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
    }
}
 40029a0:	00000406 	br	40029b4 <vStreamBufferDelete+0x4c>
        ( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
 40029a4:	01800804 	movi	r6,32
 40029a8:	000b883a 	mov	r5,zero
 40029ac:	e13fff17 	ldw	r4,-4(fp)
 40029b0:	40079800 	call	4007980 <memset>
}
 40029b4:	0001883a 	nop
 40029b8:	e037883a 	mov	sp,fp
 40029bc:	dfc00117 	ldw	ra,4(sp)
 40029c0:	df000017 	ldw	fp,0(sp)
 40029c4:	dec00204 	addi	sp,sp,8
 40029c8:	f800283a 	ret

040029cc <xStreamBufferReset>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer )
{
 40029cc:	defff604 	addi	sp,sp,-40
 40029d0:	dfc00915 	stw	ra,36(sp)
 40029d4:	df000815 	stw	fp,32(sp)
 40029d8:	df000804 	addi	fp,sp,32
 40029dc:	e13ffb15 	stw	r4,-20(fp)
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 40029e0:	e0bffb17 	ldw	r2,-20(fp)
 40029e4:	e0bffe15 	stw	r2,-8(fp)
    BaseType_t xReturn = pdFAIL;
 40029e8:	e03fff15 	stw	zero,-4(fp)
    StreamBufferCallbackFunction_t pxSendCallback = NULL, pxReceiveCallback = NULL;
 40029ec:	e03ffd15 	stw	zero,-12(fp)
 40029f0:	e03ffc15 	stw	zero,-16(fp)
        uxStreamBufferNumber = pxStreamBuffer->uxStreamBufferNumber;
    }
    #endif

    /* Can only reset a message buffer if there are no tasks blocked on it. */
    taskENTER_CRITICAL();
 40029f4:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
    {
        if( ( pxStreamBuffer->xTaskWaitingToReceive == NULL ) && ( pxStreamBuffer->xTaskWaitingToSend == NULL ) )
 40029f8:	e0bffe17 	ldw	r2,-8(fp)
 40029fc:	10800417 	ldw	r2,16(r2)
 4002a00:	1000181e 	bne	r2,zero,4002a64 <xStreamBufferReset+0x98>
 4002a04:	e0bffe17 	ldw	r2,-8(fp)
 4002a08:	10800517 	ldw	r2,20(r2)
 4002a0c:	1000151e 	bne	r2,zero,4002a64 <xStreamBufferReset+0x98>
                pxSendCallback = pxStreamBuffer->pxSendCompletedCallback;
                pxReceiveCallback = pxStreamBuffer->pxReceiveCompletedCallback;
            }
            #endif

            prvInitialiseNewStreamBuffer( pxStreamBuffer,
 4002a10:	e0bffe17 	ldw	r2,-8(fp)
 4002a14:	11000617 	ldw	r4,24(r2)
 4002a18:	e0bffe17 	ldw	r2,-8(fp)
 4002a1c:	11400217 	ldw	r5,8(r2)
 4002a20:	e0bffe17 	ldw	r2,-8(fp)
 4002a24:	11800317 	ldw	r6,12(r2)
                                          pxStreamBuffer->pucBuffer,
                                          pxStreamBuffer->xLength,
                                          pxStreamBuffer->xTriggerLevelBytes,
                                          pxStreamBuffer->ucFlags,
 4002a28:	e0bffe17 	ldw	r2,-8(fp)
 4002a2c:	10800703 	ldbu	r2,28(r2)
            prvInitialiseNewStreamBuffer( pxStreamBuffer,
 4002a30:	10803fcc 	andi	r2,r2,255
 4002a34:	e0fffc17 	ldw	r3,-16(fp)
 4002a38:	d8c00215 	stw	r3,8(sp)
 4002a3c:	e0fffd17 	ldw	r3,-12(fp)
 4002a40:	d8c00115 	stw	r3,4(sp)
 4002a44:	d8800015 	stw	r2,0(sp)
 4002a48:	300f883a 	mov	r7,r6
 4002a4c:	280d883a 	mov	r6,r5
 4002a50:	200b883a 	mov	r5,r4
 4002a54:	e13ffe17 	ldw	r4,-8(fp)
 4002a58:	40037340 	call	4003734 <prvInitialiseNewStreamBuffer>
            }
            #endif

            traceSTREAM_BUFFER_RESET( xStreamBuffer );

            xReturn = pdPASS;
 4002a5c:	00800044 	movi	r2,1
 4002a60:	e0bfff15 	stw	r2,-4(fp)
        }
    }
    taskEXIT_CRITICAL();
 4002a64:	4005fd00 	call	4005fd0 <vTaskExitCritical>

    return xReturn;
 4002a68:	e0bfff17 	ldw	r2,-4(fp)
}
 4002a6c:	e037883a 	mov	sp,fp
 4002a70:	dfc00117 	ldw	ra,4(sp)
 4002a74:	df000017 	ldw	fp,0(sp)
 4002a78:	dec00204 	addi	sp,sp,8
 4002a7c:	f800283a 	ret

04002a80 <xStreamBufferSetTriggerLevel>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer,
                                         size_t xTriggerLevel )
{
 4002a80:	defffb04 	addi	sp,sp,-20
 4002a84:	df000415 	stw	fp,16(sp)
 4002a88:	df000404 	addi	fp,sp,16
 4002a8c:	e13ffd15 	stw	r4,-12(fp)
 4002a90:	e17ffc15 	stw	r5,-16(fp)
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 4002a94:	e0bffd17 	ldw	r2,-12(fp)
 4002a98:	e0bffe15 	stw	r2,-8(fp)
    BaseType_t xReturn;

    configASSERT( pxStreamBuffer );

    /* It is not valid for the trigger level to be 0. */
    if( xTriggerLevel == ( size_t ) 0 )
 4002a9c:	e0bffc17 	ldw	r2,-16(fp)
 4002aa0:	1000021e 	bne	r2,zero,4002aac <xStreamBufferSetTriggerLevel+0x2c>
    {
        xTriggerLevel = ( size_t ) 1;
 4002aa4:	00800044 	movi	r2,1
 4002aa8:	e0bffc15 	stw	r2,-16(fp)
    }

    /* The trigger level is the number of bytes that must be in the stream
     * buffer before a task that is waiting for data is unblocked. */
    if( xTriggerLevel < pxStreamBuffer->xLength )
 4002aac:	e0bffe17 	ldw	r2,-8(fp)
 4002ab0:	10800217 	ldw	r2,8(r2)
 4002ab4:	e0fffc17 	ldw	r3,-16(fp)
 4002ab8:	1880062e 	bgeu	r3,r2,4002ad4 <xStreamBufferSetTriggerLevel+0x54>
    {
        pxStreamBuffer->xTriggerLevelBytes = xTriggerLevel;
 4002abc:	e0bffe17 	ldw	r2,-8(fp)
 4002ac0:	e0fffc17 	ldw	r3,-16(fp)
 4002ac4:	10c00315 	stw	r3,12(r2)
        xReturn = pdPASS;
 4002ac8:	00800044 	movi	r2,1
 4002acc:	e0bfff15 	stw	r2,-4(fp)
 4002ad0:	00000106 	br	4002ad8 <xStreamBufferSetTriggerLevel+0x58>
    }
    else
    {
        xReturn = pdFALSE;
 4002ad4:	e03fff15 	stw	zero,-4(fp)
    }

    return xReturn;
 4002ad8:	e0bfff17 	ldw	r2,-4(fp)
}
 4002adc:	e037883a 	mov	sp,fp
 4002ae0:	df000017 	ldw	fp,0(sp)
 4002ae4:	dec00104 	addi	sp,sp,4
 4002ae8:	f800283a 	ret

04002aec <xStreamBufferSpacesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer )
{
 4002aec:	defffb04 	addi	sp,sp,-20
 4002af0:	df000415 	stw	fp,16(sp)
 4002af4:	df000404 	addi	fp,sp,16
 4002af8:	e13ffc15 	stw	r4,-16(fp)
    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 4002afc:	e0bffc17 	ldw	r2,-16(fp)
 4002b00:	e0bffe15 	stw	r2,-8(fp)
    /* The code below reads xTail and then xHead.  This is safe if the stream
     * buffer is updated once between the two reads - but not if the stream buffer
     * is updated more than once between the two reads - hence the loop. */
    do
    {
        xOriginalTail = pxStreamBuffer->xTail;
 4002b04:	e0bffe17 	ldw	r2,-8(fp)
 4002b08:	10800017 	ldw	r2,0(r2)
 4002b0c:	e0bffd15 	stw	r2,-12(fp)
        xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
 4002b10:	e0bffe17 	ldw	r2,-8(fp)
 4002b14:	10c00217 	ldw	r3,8(r2)
 4002b18:	e0bffe17 	ldw	r2,-8(fp)
 4002b1c:	10800017 	ldw	r2,0(r2)
 4002b20:	1885883a 	add	r2,r3,r2
 4002b24:	e0bfff15 	stw	r2,-4(fp)
        xSpace -= pxStreamBuffer->xHead;
 4002b28:	e0bffe17 	ldw	r2,-8(fp)
 4002b2c:	10800117 	ldw	r2,4(r2)
 4002b30:	e0ffff17 	ldw	r3,-4(fp)
 4002b34:	1885c83a 	sub	r2,r3,r2
 4002b38:	e0bfff15 	stw	r2,-4(fp)
    } while( xOriginalTail != pxStreamBuffer->xTail );
 4002b3c:	e0bffe17 	ldw	r2,-8(fp)
 4002b40:	10800017 	ldw	r2,0(r2)
 4002b44:	e0fffd17 	ldw	r3,-12(fp)
 4002b48:	18bfee1e 	bne	r3,r2,4002b04 <xStreamBufferSpacesAvailable+0x18>

    xSpace -= ( size_t ) 1;
 4002b4c:	e0bfff17 	ldw	r2,-4(fp)
 4002b50:	10bfffc4 	addi	r2,r2,-1
 4002b54:	e0bfff15 	stw	r2,-4(fp)

    if( xSpace >= pxStreamBuffer->xLength )
 4002b58:	e0bffe17 	ldw	r2,-8(fp)
 4002b5c:	10800217 	ldw	r2,8(r2)
 4002b60:	e0ffff17 	ldw	r3,-4(fp)
 4002b64:	18800536 	bltu	r3,r2,4002b7c <xStreamBufferSpacesAvailable+0x90>
    {
        xSpace -= pxStreamBuffer->xLength;
 4002b68:	e0bffe17 	ldw	r2,-8(fp)
 4002b6c:	10800217 	ldw	r2,8(r2)
 4002b70:	e0ffff17 	ldw	r3,-4(fp)
 4002b74:	1885c83a 	sub	r2,r3,r2
 4002b78:	e0bfff15 	stw	r2,-4(fp)
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xSpace;
 4002b7c:	e0bfff17 	ldw	r2,-4(fp)
}
 4002b80:	e037883a 	mov	sp,fp
 4002b84:	df000017 	ldw	fp,0(sp)
 4002b88:	dec00104 	addi	sp,sp,4
 4002b8c:	f800283a 	ret

04002b90 <xStreamBufferBytesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer )
{
 4002b90:	defffb04 	addi	sp,sp,-20
 4002b94:	dfc00415 	stw	ra,16(sp)
 4002b98:	df000315 	stw	fp,12(sp)
 4002b9c:	df000304 	addi	fp,sp,12
 4002ba0:	e13ffd15 	stw	r4,-12(fp)
    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 4002ba4:	e0bffd17 	ldw	r2,-12(fp)
 4002ba8:	e0bfff15 	stw	r2,-4(fp)
    size_t xReturn;

    configASSERT( pxStreamBuffer );

    xReturn = prvBytesInBuffer( pxStreamBuffer );
 4002bac:	e13fff17 	ldw	r4,-4(fp)
 4002bb0:	40036c00 	call	40036c0 <prvBytesInBuffer>
 4002bb4:	e0bffe15 	stw	r2,-8(fp)
    return xReturn;
 4002bb8:	e0bffe17 	ldw	r2,-8(fp)
}
 4002bbc:	e037883a 	mov	sp,fp
 4002bc0:	dfc00117 	ldw	ra,4(sp)
 4002bc4:	df000017 	ldw	fp,0(sp)
 4002bc8:	dec00204 	addi	sp,sp,8
 4002bcc:	f800283a 	ret

04002bd0 <xStreamBufferSend>:

size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,
                          const void * pvTxData,
                          size_t xDataLengthBytes,
                          TickType_t xTicksToWait )
{
 4002bd0:	defff204 	addi	sp,sp,-56
 4002bd4:	dfc00d15 	stw	ra,52(sp)
 4002bd8:	df000c15 	stw	fp,48(sp)
 4002bdc:	df000c04 	addi	fp,sp,48
 4002be0:	e13ff815 	stw	r4,-32(fp)
 4002be4:	e17ff715 	stw	r5,-36(fp)
 4002be8:	e1bff615 	stw	r6,-40(fp)
 4002bec:	e1fff515 	stw	r7,-44(fp)
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 4002bf0:	e0bff817 	ldw	r2,-32(fp)
 4002bf4:	e0bffd15 	stw	r2,-12(fp)
    size_t xReturn, xSpace = 0;
 4002bf8:	e03fff15 	stw	zero,-4(fp)
    size_t xRequiredSpace = xDataLengthBytes;
 4002bfc:	e0bff617 	ldw	r2,-40(fp)
 4002c00:	e0bffe15 	stw	r2,-8(fp)
    TimeOut_t xTimeOut;
    size_t xMaxReportedSpace = 0;
 4002c04:	e03ffc15 	stw	zero,-16(fp)
    configASSERT( pvTxData );
    configASSERT( pxStreamBuffer );

    /* The maximum amount of space a stream buffer will ever report is its length
     * minus 1. */
    xMaxReportedSpace = pxStreamBuffer->xLength - ( size_t ) 1;
 4002c08:	e0bffd17 	ldw	r2,-12(fp)
 4002c0c:	10800217 	ldw	r2,8(r2)
 4002c10:	10bfffc4 	addi	r2,r2,-1
 4002c14:	e0bffc15 	stw	r2,-16(fp)

    /* This send function is used to write to both message buffers and stream
     * buffers.  If this is a message buffer then the space needed must be
     * increased by the amount of bytes needed to store the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 4002c18:	e0bffd17 	ldw	r2,-12(fp)
 4002c1c:	10800703 	ldbu	r2,28(r2)
 4002c20:	10803fcc 	andi	r2,r2,255
 4002c24:	1080004c 	andi	r2,r2,1
 4002c28:	10000826 	beq	r2,zero,4002c4c <xStreamBufferSend+0x7c>
    {
        xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
 4002c2c:	e0bffe17 	ldw	r2,-8(fp)
 4002c30:	10800104 	addi	r2,r2,4
 4002c34:	e0bffe15 	stw	r2,-8(fp)
        /* Overflow? */
        configASSERT( xRequiredSpace > xDataLengthBytes );

        /* If this is a message buffer then it must be possible to write the
         * whole message. */
        if( xRequiredSpace > xMaxReportedSpace )
 4002c38:	e0bffe17 	ldw	r2,-8(fp)
 4002c3c:	e0fffc17 	ldw	r3,-16(fp)
 4002c40:	1880072e 	bgeu	r3,r2,4002c60 <xStreamBufferSend+0x90>
        {
            /* The message would not fit even if the entire buffer was empty,
             * so don't wait for space. */
            xTicksToWait = ( TickType_t ) 0;
 4002c44:	e03ff515 	stw	zero,-44(fp)
 4002c48:	00000506 	br	4002c60 <xStreamBufferSend+0x90>
    else
    {
        /* If this is a stream buffer then it is acceptable to write only part
         * of the message to the buffer.  Cap the length to the total length of
         * the buffer. */
        if( xRequiredSpace > xMaxReportedSpace )
 4002c4c:	e0bffe17 	ldw	r2,-8(fp)
 4002c50:	e0fffc17 	ldw	r3,-16(fp)
 4002c54:	1880022e 	bgeu	r3,r2,4002c60 <xStreamBufferSend+0x90>
        {
            xRequiredSpace = xMaxReportedSpace;
 4002c58:	e0bffc17 	ldw	r2,-16(fp)
 4002c5c:	e0bffe15 	stw	r2,-8(fp)
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    if( xTicksToWait != ( TickType_t ) 0 )
 4002c60:	e0bff517 	ldw	r2,-44(fp)
 4002c64:	10002426 	beq	r2,zero,4002cf8 <xStreamBufferSend+0x128>
    {
        vTaskSetTimeOutState( &xTimeOut );
 4002c68:	e0bff904 	addi	r2,fp,-28
 4002c6c:	1009883a 	mov	r4,r2
 4002c70:	400554c0 	call	400554c <vTaskSetTimeOutState>

        do
        {
            /* Wait until the required number of bytes are free in the message
             * buffer. */
            taskENTER_CRITICAL();
 4002c74:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
            {
                xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
 4002c78:	e13ffd17 	ldw	r4,-12(fp)
 4002c7c:	4002aec0 	call	4002aec <xStreamBufferSpacesAvailable>
 4002c80:	e0bfff15 	stw	r2,-4(fp)

                if( xSpace < xRequiredSpace )
 4002c84:	e0ffff17 	ldw	r3,-4(fp)
 4002c88:	e0bffe17 	ldw	r2,-8(fp)
 4002c8c:	1880082e 	bgeu	r3,r2,4002cb0 <xStreamBufferSend+0xe0>
                {
                    /* Clear notification state as going to wait for space. */
                    ( void ) xTaskNotifyStateClear( NULL );
 4002c90:	000b883a 	mov	r5,zero
 4002c94:	0009883a 	mov	r4,zero
 4002c98:	4006d040 	call	4006d04 <xTaskGenericNotifyStateClear>

                    /* Should only be one writer. */
                    configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
                    pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
 4002c9c:	40059900 	call	4005990 <xTaskGetCurrentTaskHandle>
 4002ca0:	1007883a 	mov	r3,r2
 4002ca4:	e0bffd17 	ldw	r2,-12(fp)
 4002ca8:	10c00515 	stw	r3,20(r2)
 4002cac:	00000206 	br	4002cb8 <xStreamBufferSend+0xe8>
                }
                else
                {
                    taskEXIT_CRITICAL();
 4002cb0:	4005fd00 	call	4005fd0 <vTaskExitCritical>
                    break;
 4002cb4:	00001006 	br	4002cf8 <xStreamBufferSend+0x128>
                }
            }
            taskEXIT_CRITICAL();
 4002cb8:	4005fd00 	call	4005fd0 <vTaskExitCritical>

            traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer );
            ( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
 4002cbc:	e0bff517 	ldw	r2,-44(fp)
 4002cc0:	d8800015 	stw	r2,0(sp)
 4002cc4:	000f883a 	mov	r7,zero
 4002cc8:	000d883a 	mov	r6,zero
 4002ccc:	000b883a 	mov	r5,zero
 4002cd0:	0009883a 	mov	r4,zero
 4002cd4:	40061b40 	call	40061b4 <xTaskGenericNotifyWait>
            pxStreamBuffer->xTaskWaitingToSend = NULL;
 4002cd8:	e0bffd17 	ldw	r2,-12(fp)
 4002cdc:	10000515 	stw	zero,20(r2)
        } while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );
 4002ce0:	e0fff504 	addi	r3,fp,-44
 4002ce4:	e0bff904 	addi	r2,fp,-28
 4002ce8:	180b883a 	mov	r5,r3
 4002cec:	1009883a 	mov	r4,r2
 4002cf0:	40055d40 	call	40055d4 <xTaskCheckForTimeOut>
 4002cf4:	103fdf26 	beq	r2,zero,4002c74 <xStreamBufferSend+0xa4>
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    if( xSpace == ( size_t ) 0 )
 4002cf8:	e0bfff17 	ldw	r2,-4(fp)
 4002cfc:	1000031e 	bne	r2,zero,4002d0c <xStreamBufferSend+0x13c>
    {
        xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
 4002d00:	e13ffd17 	ldw	r4,-12(fp)
 4002d04:	4002aec0 	call	4002aec <xStreamBufferSpacesAvailable>
 4002d08:	e0bfff15 	stw	r2,-4(fp)
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
 4002d0c:	e0bffe17 	ldw	r2,-8(fp)
 4002d10:	d8800015 	stw	r2,0(sp)
 4002d14:	e1ffff17 	ldw	r7,-4(fp)
 4002d18:	e1bff617 	ldw	r6,-40(fp)
 4002d1c:	e17ff717 	ldw	r5,-36(fp)
 4002d20:	e13ffd17 	ldw	r4,-12(fp)
 4002d24:	4002e940 	call	4002e94 <prvWriteMessageToBuffer>
 4002d28:	e0bffb15 	stw	r2,-20(fp)

    if( xReturn > ( size_t ) 0 )
 4002d2c:	e0bffb17 	ldw	r2,-20(fp)
 4002d30:	10001526 	beq	r2,zero,4002d88 <xStreamBufferSend+0x1b8>
    {
        traceSTREAM_BUFFER_SEND( xStreamBuffer, xReturn );

        /* Was a task waiting for the data? */
        if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
 4002d34:	e13ffd17 	ldw	r4,-12(fp)
 4002d38:	40036c00 	call	40036c0 <prvBytesInBuffer>
 4002d3c:	1007883a 	mov	r3,r2
 4002d40:	e0bffd17 	ldw	r2,-12(fp)
 4002d44:	10800317 	ldw	r2,12(r2)
 4002d48:	18800f36 	bltu	r3,r2,4002d88 <xStreamBufferSend+0x1b8>
        {
            prvSEND_COMPLETED( pxStreamBuffer );
 4002d4c:	40046f00 	call	40046f0 <vTaskSuspendAll>
 4002d50:	e0bffd17 	ldw	r2,-12(fp)
 4002d54:	10800417 	ldw	r2,16(r2)
 4002d58:	10000a26 	beq	r2,zero,4002d84 <xStreamBufferSend+0x1b4>
 4002d5c:	e0bffd17 	ldw	r2,-12(fp)
 4002d60:	10800417 	ldw	r2,16(r2)
 4002d64:	d8000015 	stw	zero,0(sp)
 4002d68:	000f883a 	mov	r7,zero
 4002d6c:	000d883a 	mov	r6,zero
 4002d70:	000b883a 	mov	r5,zero
 4002d74:	1009883a 	mov	r4,r2
 4002d78:	40063180 	call	4006318 <xTaskGenericNotify>
 4002d7c:	e0bffd17 	ldw	r2,-12(fp)
 4002d80:	10000415 	stw	zero,16(r2)
 4002d84:	400471c0 	call	400471c <xTaskResumeAll>
    {
        mtCOVERAGE_TEST_MARKER();
        traceSTREAM_BUFFER_SEND_FAILED( xStreamBuffer );
    }

    return xReturn;
 4002d88:	e0bffb17 	ldw	r2,-20(fp)
}
 4002d8c:	e037883a 	mov	sp,fp
 4002d90:	dfc00117 	ldw	ra,4(sp)
 4002d94:	df000017 	ldw	fp,0(sp)
 4002d98:	dec00204 	addi	sp,sp,8
 4002d9c:	f800283a 	ret

04002da0 <xStreamBufferSendFromISR>:

size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,
                                 const void * pvTxData,
                                 size_t xDataLengthBytes,
                                 BaseType_t * const pxHigherPriorityTaskWoken )
{
 4002da0:	defff304 	addi	sp,sp,-52
 4002da4:	dfc00c15 	stw	ra,48(sp)
 4002da8:	df000b15 	stw	fp,44(sp)
 4002dac:	df000b04 	addi	fp,sp,44
 4002db0:	e13ffa15 	stw	r4,-24(fp)
 4002db4:	e17ff915 	stw	r5,-28(fp)
 4002db8:	e1bff815 	stw	r6,-32(fp)
 4002dbc:	e1fff715 	stw	r7,-36(fp)
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 4002dc0:	e0bffa17 	ldw	r2,-24(fp)
 4002dc4:	e0bffe15 	stw	r2,-8(fp)
    size_t xReturn, xSpace;
    size_t xRequiredSpace = xDataLengthBytes;
 4002dc8:	e0bff817 	ldw	r2,-32(fp)
 4002dcc:	e0bfff15 	stw	r2,-4(fp)

    /* This send function is used to write to both message buffers and stream
     * buffers.  If this is a message buffer then the space needed must be
     * increased by the amount of bytes needed to store the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 4002dd0:	e0bffe17 	ldw	r2,-8(fp)
 4002dd4:	10800703 	ldbu	r2,28(r2)
 4002dd8:	10803fcc 	andi	r2,r2,255
 4002ddc:	1080004c 	andi	r2,r2,1
 4002de0:	10000326 	beq	r2,zero,4002df0 <xStreamBufferSendFromISR+0x50>
    {
        xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
 4002de4:	e0bfff17 	ldw	r2,-4(fp)
 4002de8:	10800104 	addi	r2,r2,4
 4002dec:	e0bfff15 	stw	r2,-4(fp)
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
 4002df0:	e13ffe17 	ldw	r4,-8(fp)
 4002df4:	4002aec0 	call	4002aec <xStreamBufferSpacesAvailable>
 4002df8:	e0bffd15 	stw	r2,-12(fp)
    xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
 4002dfc:	e0bfff17 	ldw	r2,-4(fp)
 4002e00:	d8800015 	stw	r2,0(sp)
 4002e04:	e1fffd17 	ldw	r7,-12(fp)
 4002e08:	e1bff817 	ldw	r6,-32(fp)
 4002e0c:	e17ff917 	ldw	r5,-28(fp)
 4002e10:	e13ffe17 	ldw	r4,-8(fp)
 4002e14:	4002e940 	call	4002e94 <prvWriteMessageToBuffer>
 4002e18:	e0bffc15 	stw	r2,-16(fp)

    if( xReturn > ( size_t ) 0 )
 4002e1c:	e0bffc17 	ldw	r2,-16(fp)
 4002e20:	10001626 	beq	r2,zero,4002e7c <xStreamBufferSendFromISR+0xdc>
    {
        /* Was a task waiting for the data? */
        if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
 4002e24:	e13ffe17 	ldw	r4,-8(fp)
 4002e28:	40036c00 	call	40036c0 <prvBytesInBuffer>
 4002e2c:	1007883a 	mov	r3,r2
 4002e30:	e0bffe17 	ldw	r2,-8(fp)
 4002e34:	10800317 	ldw	r2,12(r2)
 4002e38:	18801036 	bltu	r3,r2,4002e7c <xStreamBufferSendFromISR+0xdc>
        {
            prvSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
 4002e3c:	e03ffb15 	stw	zero,-20(fp)
 4002e40:	e0bffe17 	ldw	r2,-8(fp)
 4002e44:	10800417 	ldw	r2,16(r2)
 4002e48:	10000c26 	beq	r2,zero,4002e7c <xStreamBufferSendFromISR+0xdc>
 4002e4c:	e0bffe17 	ldw	r2,-8(fp)
 4002e50:	10c00417 	ldw	r3,16(r2)
 4002e54:	e0bff717 	ldw	r2,-36(fp)
 4002e58:	d8800115 	stw	r2,4(sp)
 4002e5c:	d8000015 	stw	zero,0(sp)
 4002e60:	000f883a 	mov	r7,zero
 4002e64:	000d883a 	mov	r6,zero
 4002e68:	000b883a 	mov	r5,zero
 4002e6c:	1809883a 	mov	r4,r3
 4002e70:	40066600 	call	4006660 <xTaskGenericNotifyFromISR>
 4002e74:	e0bffe17 	ldw	r2,-8(fp)
 4002e78:	10000415 	stw	zero,16(r2)
        mtCOVERAGE_TEST_MARKER();
    }

    traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xReturn );

    return xReturn;
 4002e7c:	e0bffc17 	ldw	r2,-16(fp)
}
 4002e80:	e037883a 	mov	sp,fp
 4002e84:	dfc00117 	ldw	ra,4(sp)
 4002e88:	df000017 	ldw	fp,0(sp)
 4002e8c:	dec00204 	addi	sp,sp,8
 4002e90:	f800283a 	ret

04002e94 <prvWriteMessageToBuffer>:
static size_t prvWriteMessageToBuffer( StreamBuffer_t * const pxStreamBuffer,
                                       const void * pvTxData,
                                       size_t xDataLengthBytes,
                                       size_t xSpace,
                                       size_t xRequiredSpace )
{
 4002e94:	defff804 	addi	sp,sp,-32
 4002e98:	dfc00715 	stw	ra,28(sp)
 4002e9c:	df000615 	stw	fp,24(sp)
 4002ea0:	df000604 	addi	fp,sp,24
 4002ea4:	e13ffd15 	stw	r4,-12(fp)
 4002ea8:	e17ffc15 	stw	r5,-16(fp)
 4002eac:	e1bffb15 	stw	r6,-20(fp)
 4002eb0:	e1fffa15 	stw	r7,-24(fp)
    size_t xNextHead = pxStreamBuffer->xHead;
 4002eb4:	e0bffd17 	ldw	r2,-12(fp)
 4002eb8:	10800117 	ldw	r2,4(r2)
 4002ebc:	e0bfff15 	stw	r2,-4(fp)
    configMESSAGE_BUFFER_LENGTH_TYPE xMessageLength;

    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 4002ec0:	e0bffd17 	ldw	r2,-12(fp)
 4002ec4:	10800703 	ldbu	r2,28(r2)
 4002ec8:	10803fcc 	andi	r2,r2,255
 4002ecc:	1080004c 	andi	r2,r2,1
 4002ed0:	10000f26 	beq	r2,zero,4002f10 <prvWriteMessageToBuffer+0x7c>
    {
        /* This is a message buffer, as opposed to a stream buffer. */

        /* Convert xDataLengthBytes to the message length type. */
        xMessageLength = ( configMESSAGE_BUFFER_LENGTH_TYPE ) xDataLengthBytes;
 4002ed4:	e0bffb17 	ldw	r2,-20(fp)
 4002ed8:	e0bffe15 	stw	r2,-8(fp)

        /* Ensure the data length given fits within configMESSAGE_BUFFER_LENGTH_TYPE. */
        configASSERT( ( size_t ) xMessageLength == xDataLengthBytes );

        if( xSpace >= xRequiredSpace )
 4002edc:	e0fffa17 	ldw	r3,-24(fp)
 4002ee0:	e0800217 	ldw	r2,8(fp)
 4002ee4:	18800836 	bltu	r3,r2,4002f08 <prvWriteMessageToBuffer+0x74>
        {
            /* There is enough space to write both the message length and the message
             * itself into the buffer.  Start by writing the length of the data, the data
             * itself will be written later in this function. */
            xNextHead = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) &( xMessageLength ), sbBYTES_TO_STORE_MESSAGE_LENGTH, xNextHead );
 4002ee8:	e0bffe04 	addi	r2,fp,-8
 4002eec:	e1ffff17 	ldw	r7,-4(fp)
 4002ef0:	01800104 	movi	r6,4
 4002ef4:	100b883a 	mov	r5,r2
 4002ef8:	e13ffd17 	ldw	r4,-12(fp)
 4002efc:	40035000 	call	4003500 <prvWriteBytesToBuffer>
 4002f00:	e0bfff15 	stw	r2,-4(fp)
 4002f04:	00000706 	br	4002f24 <prvWriteMessageToBuffer+0x90>
        }
        else
        {
            /* Not enough space, so do not write data to the buffer. */
            xDataLengthBytes = 0;
 4002f08:	e03ffb15 	stw	zero,-20(fp)
 4002f0c:	00000506 	br	4002f24 <prvWriteMessageToBuffer+0x90>
    else
    {
        /* This is a stream buffer, as opposed to a message buffer, so writing a
         * stream of bytes rather than discrete messages.  Plan to write as many
         * bytes as possible. */
        xDataLengthBytes = configMIN( xDataLengthBytes, xSpace );
 4002f10:	e0fffb17 	ldw	r3,-20(fp)
 4002f14:	e0bffa17 	ldw	r2,-24(fp)
 4002f18:	1880012e 	bgeu	r3,r2,4002f20 <prvWriteMessageToBuffer+0x8c>
 4002f1c:	1805883a 	mov	r2,r3
 4002f20:	e0bffb15 	stw	r2,-20(fp)
    }

    if( xDataLengthBytes != ( size_t ) 0 )
 4002f24:	e0bffb17 	ldw	r2,-20(fp)
 4002f28:	10000826 	beq	r2,zero,4002f4c <prvWriteMessageToBuffer+0xb8>
    {
        /* Write the data to the buffer. */
        pxStreamBuffer->xHead = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes, xNextHead ); /*lint !e9079 Storage buffer is implemented as uint8_t for ease of sizing, alignment and access. */
 4002f2c:	e1ffff17 	ldw	r7,-4(fp)
 4002f30:	e1bffb17 	ldw	r6,-20(fp)
 4002f34:	e17ffc17 	ldw	r5,-16(fp)
 4002f38:	e13ffd17 	ldw	r4,-12(fp)
 4002f3c:	40035000 	call	4003500 <prvWriteBytesToBuffer>
 4002f40:	1007883a 	mov	r3,r2
 4002f44:	e0bffd17 	ldw	r2,-12(fp)
 4002f48:	10c00115 	stw	r3,4(r2)
    }

    return xDataLengthBytes;
 4002f4c:	e0bffb17 	ldw	r2,-20(fp)
}
 4002f50:	e037883a 	mov	sp,fp
 4002f54:	dfc00117 	ldw	ra,4(sp)
 4002f58:	df000017 	ldw	fp,0(sp)
 4002f5c:	dec00204 	addi	sp,sp,8
 4002f60:	f800283a 	ret

04002f64 <xStreamBufferReceive>:

size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,
                             void * pvRxData,
                             size_t xBufferLengthBytes,
                             TickType_t xTicksToWait )
{
 4002f64:	defff504 	addi	sp,sp,-44
 4002f68:	dfc00a15 	stw	ra,40(sp)
 4002f6c:	df000915 	stw	fp,36(sp)
 4002f70:	df000904 	addi	fp,sp,36
 4002f74:	e13ffb15 	stw	r4,-20(fp)
 4002f78:	e17ffa15 	stw	r5,-24(fp)
 4002f7c:	e1bff915 	stw	r6,-28(fp)
 4002f80:	e1fff815 	stw	r7,-32(fp)
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 4002f84:	e0bffb17 	ldw	r2,-20(fp)
 4002f88:	e0bffc15 	stw	r2,-16(fp)
    size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
 4002f8c:	e03fff15 	stw	zero,-4(fp)
    /* This receive function is used by both message buffers, which store
     * discrete messages, and stream buffers, which store a continuous stream of
     * bytes.  Discrete messages include an additional
     * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 4002f90:	e0bffc17 	ldw	r2,-16(fp)
 4002f94:	10800703 	ldbu	r2,28(r2)
 4002f98:	10803fcc 	andi	r2,r2,255
 4002f9c:	1080004c 	andi	r2,r2,1
 4002fa0:	10000326 	beq	r2,zero,4002fb0 <xStreamBufferReceive+0x4c>
    {
        xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
 4002fa4:	00800104 	movi	r2,4
 4002fa8:	e0bffd15 	stw	r2,-12(fp)
 4002fac:	00000106 	br	4002fb4 <xStreamBufferReceive+0x50>
    }
    else
    {
        xBytesToStoreMessageLength = 0;
 4002fb0:	e03ffd15 	stw	zero,-12(fp)
    }

    if( xTicksToWait != ( TickType_t ) 0 )
 4002fb4:	e0bff817 	ldw	r2,-32(fp)
 4002fb8:	10001f26 	beq	r2,zero,4003038 <xStreamBufferReceive+0xd4>
    {
        /* Checking if there is data and clearing the notification state must be
         * performed atomically. */
        taskENTER_CRITICAL();
 4002fbc:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
        {
            xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
 4002fc0:	e13ffc17 	ldw	r4,-16(fp)
 4002fc4:	40036c00 	call	40036c0 <prvBytesInBuffer>
 4002fc8:	e0bffe15 	stw	r2,-8(fp)
            /* If this function was invoked by a message buffer read then
             * xBytesToStoreMessageLength holds the number of bytes used to hold
             * the length of the next discrete message.  If this function was
             * invoked by a stream buffer read then xBytesToStoreMessageLength will
             * be 0. */
            if( xBytesAvailable <= xBytesToStoreMessageLength )
 4002fcc:	e0bffe17 	ldw	r2,-8(fp)
 4002fd0:	e0fffd17 	ldw	r3,-12(fp)
 4002fd4:	18800736 	bltu	r3,r2,4002ff4 <xStreamBufferReceive+0x90>
            {
                /* Clear notification state as going to wait for data. */
                ( void ) xTaskNotifyStateClear( NULL );
 4002fd8:	000b883a 	mov	r5,zero
 4002fdc:	0009883a 	mov	r4,zero
 4002fe0:	4006d040 	call	4006d04 <xTaskGenericNotifyStateClear>

                /* Should only be one reader. */
                configASSERT( pxStreamBuffer->xTaskWaitingToReceive == NULL );
                pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();
 4002fe4:	40059900 	call	4005990 <xTaskGetCurrentTaskHandle>
 4002fe8:	1007883a 	mov	r3,r2
 4002fec:	e0bffc17 	ldw	r2,-16(fp)
 4002ff0:	10c00415 	stw	r3,16(r2)
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
 4002ff4:	4005fd00 	call	4005fd0 <vTaskExitCritical>

        if( xBytesAvailable <= xBytesToStoreMessageLength )
 4002ff8:	e0bffe17 	ldw	r2,-8(fp)
 4002ffc:	e0fffd17 	ldw	r3,-12(fp)
 4003000:	18801036 	bltu	r3,r2,4003044 <xStreamBufferReceive+0xe0>
        {
            /* Wait for data to be available. */
            traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer );
            ( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
 4003004:	e0bff817 	ldw	r2,-32(fp)
 4003008:	d8800015 	stw	r2,0(sp)
 400300c:	000f883a 	mov	r7,zero
 4003010:	000d883a 	mov	r6,zero
 4003014:	000b883a 	mov	r5,zero
 4003018:	0009883a 	mov	r4,zero
 400301c:	40061b40 	call	40061b4 <xTaskGenericNotifyWait>
            pxStreamBuffer->xTaskWaitingToReceive = NULL;
 4003020:	e0bffc17 	ldw	r2,-16(fp)
 4003024:	10000415 	stw	zero,16(r2)

            /* Recheck the data available after blocking. */
            xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
 4003028:	e13ffc17 	ldw	r4,-16(fp)
 400302c:	40036c00 	call	40036c0 <prvBytesInBuffer>
 4003030:	e0bffe15 	stw	r2,-8(fp)
 4003034:	00000306 	br	4003044 <xStreamBufferReceive+0xe0>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
 4003038:	e13ffc17 	ldw	r4,-16(fp)
 400303c:	40036c00 	call	40036c0 <prvBytesInBuffer>
 4003040:	e0bffe15 	stw	r2,-8(fp)
    /* Whether receiving a discrete message (where xBytesToStoreMessageLength
     * holds the number of bytes used to store the message length) or a stream of
     * bytes (where xBytesToStoreMessageLength is zero), the number of bytes
     * available must be greater than xBytesToStoreMessageLength to be able to
     * read bytes from the buffer. */
    if( xBytesAvailable > xBytesToStoreMessageLength )
 4003044:	e0bffe17 	ldw	r2,-8(fp)
 4003048:	e0fffd17 	ldw	r3,-12(fp)
 400304c:	1880172e 	bgeu	r3,r2,40030ac <xStreamBufferReceive+0x148>
    {
        xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable );
 4003050:	e1fffe17 	ldw	r7,-8(fp)
 4003054:	e1bff917 	ldw	r6,-28(fp)
 4003058:	e17ffa17 	ldw	r5,-24(fp)
 400305c:	e13ffc17 	ldw	r4,-16(fp)
 4003060:	400323c0 	call	400323c <prvReadMessageFromBuffer>
 4003064:	e0bfff15 	stw	r2,-4(fp)

        /* Was a task waiting for space in the buffer? */
        if( xReceivedLength != ( size_t ) 0 )
 4003068:	e0bfff17 	ldw	r2,-4(fp)
 400306c:	10000f26 	beq	r2,zero,40030ac <xStreamBufferReceive+0x148>
        {
            traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength );
            prvRECEIVE_COMPLETED( xStreamBuffer );
 4003070:	40046f00 	call	40046f0 <vTaskSuspendAll>
 4003074:	e0bffb17 	ldw	r2,-20(fp)
 4003078:	10800517 	ldw	r2,20(r2)
 400307c:	10000a26 	beq	r2,zero,40030a8 <xStreamBufferReceive+0x144>
 4003080:	e0bffb17 	ldw	r2,-20(fp)
 4003084:	10800517 	ldw	r2,20(r2)
 4003088:	d8000015 	stw	zero,0(sp)
 400308c:	000f883a 	mov	r7,zero
 4003090:	000d883a 	mov	r6,zero
 4003094:	000b883a 	mov	r5,zero
 4003098:	1009883a 	mov	r4,r2
 400309c:	40063180 	call	4006318 <xTaskGenericNotify>
 40030a0:	e0bffb17 	ldw	r2,-20(fp)
 40030a4:	10000515 	stw	zero,20(r2)
 40030a8:	400471c0 	call	400471c <xTaskResumeAll>
    {
        traceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer );
        mtCOVERAGE_TEST_MARKER();
    }

    return xReceivedLength;
 40030ac:	e0bfff17 	ldw	r2,-4(fp)
}
 40030b0:	e037883a 	mov	sp,fp
 40030b4:	dfc00117 	ldw	ra,4(sp)
 40030b8:	df000017 	ldw	fp,0(sp)
 40030bc:	dec00204 	addi	sp,sp,8
 40030c0:	f800283a 	ret

040030c4 <xStreamBufferNextMessageLengthBytes>:
/*-----------------------------------------------------------*/

size_t xStreamBufferNextMessageLengthBytes( StreamBufferHandle_t xStreamBuffer )
{
 40030c4:	defff904 	addi	sp,sp,-28
 40030c8:	dfc00615 	stw	ra,24(sp)
 40030cc:	df000515 	stw	fp,20(sp)
 40030d0:	df000504 	addi	fp,sp,20
 40030d4:	e13ffb15 	stw	r4,-20(fp)
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 40030d8:	e0bffb17 	ldw	r2,-20(fp)
 40030dc:	e0bffe15 	stw	r2,-8(fp)
    configMESSAGE_BUFFER_LENGTH_TYPE xTempReturn;

    configASSERT( pxStreamBuffer );

    /* Ensure the stream buffer is being used as a message buffer. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 40030e0:	e0bffe17 	ldw	r2,-8(fp)
 40030e4:	10800703 	ldbu	r2,28(r2)
 40030e8:	10803fcc 	andi	r2,r2,255
 40030ec:	1080004c 	andi	r2,r2,1
 40030f0:	10001326 	beq	r2,zero,4003140 <xStreamBufferNextMessageLengthBytes+0x7c>
    {
        xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
 40030f4:	e13ffe17 	ldw	r4,-8(fp)
 40030f8:	40036c00 	call	40036c0 <prvBytesInBuffer>
 40030fc:	e0bffd15 	stw	r2,-12(fp)

        if( xBytesAvailable > sbBYTES_TO_STORE_MESSAGE_LENGTH )
 4003100:	e0bffd17 	ldw	r2,-12(fp)
 4003104:	10800170 	cmpltui	r2,r2,5
 4003108:	10000b1e 	bne	r2,zero,4003138 <xStreamBufferNextMessageLengthBytes+0x74>
        {
            /* The number of bytes available is greater than the number of bytes
             * required to hold the length of the next message, so another message
             * is available. */
            ( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempReturn, sbBYTES_TO_STORE_MESSAGE_LENGTH, pxStreamBuffer->xTail );
 400310c:	e0bffe17 	ldw	r2,-8(fp)
 4003110:	10c00017 	ldw	r3,0(r2)
 4003114:	e0bffc04 	addi	r2,fp,-16
 4003118:	180f883a 	mov	r7,r3
 400311c:	01800104 	movi	r6,4
 4003120:	100b883a 	mov	r5,r2
 4003124:	e13ffe17 	ldw	r4,-8(fp)
 4003128:	40035e00 	call	40035e0 <prvReadBytesFromBuffer>
            xReturn = ( size_t ) xTempReturn;
 400312c:	e0bffc17 	ldw	r2,-16(fp)
 4003130:	e0bfff15 	stw	r2,-4(fp)
 4003134:	00000306 	br	4003144 <xStreamBufferNextMessageLengthBytes+0x80>
            /* The minimum amount of bytes in a message buffer is
             * ( sbBYTES_TO_STORE_MESSAGE_LENGTH + 1 ), so if xBytesAvailable is
             * less than sbBYTES_TO_STORE_MESSAGE_LENGTH the only other valid
             * value is 0. */
            configASSERT( xBytesAvailable == 0 );
            xReturn = 0;
 4003138:	e03fff15 	stw	zero,-4(fp)
 400313c:	00000106 	br	4003144 <xStreamBufferNextMessageLengthBytes+0x80>
        }
    }
    else
    {
        xReturn = 0;
 4003140:	e03fff15 	stw	zero,-4(fp)
    }

    return xReturn;
 4003144:	e0bfff17 	ldw	r2,-4(fp)
}
 4003148:	e037883a 	mov	sp,fp
 400314c:	dfc00117 	ldw	ra,4(sp)
 4003150:	df000017 	ldw	fp,0(sp)
 4003154:	dec00204 	addi	sp,sp,8
 4003158:	f800283a 	ret

0400315c <xStreamBufferReceiveFromISR>:

size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,
                                    void * pvRxData,
                                    size_t xBufferLengthBytes,
                                    BaseType_t * const pxHigherPriorityTaskWoken )
{
 400315c:	defff304 	addi	sp,sp,-52
 4003160:	dfc00c15 	stw	ra,48(sp)
 4003164:	df000b15 	stw	fp,44(sp)
 4003168:	df000b04 	addi	fp,sp,44
 400316c:	e13ffa15 	stw	r4,-24(fp)
 4003170:	e17ff915 	stw	r5,-28(fp)
 4003174:	e1bff815 	stw	r6,-32(fp)
 4003178:	e1fff715 	stw	r7,-36(fp)
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 400317c:	e0bffa17 	ldw	r2,-24(fp)
 4003180:	e0bffd15 	stw	r2,-12(fp)
    size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
 4003184:	e03fff15 	stw	zero,-4(fp)
    /* This receive function is used by both message buffers, which store
     * discrete messages, and stream buffers, which store a continuous stream of
     * bytes.  Discrete messages include an additional
     * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 4003188:	e0bffd17 	ldw	r2,-12(fp)
 400318c:	10800703 	ldbu	r2,28(r2)
 4003190:	10803fcc 	andi	r2,r2,255
 4003194:	1080004c 	andi	r2,r2,1
 4003198:	10000326 	beq	r2,zero,40031a8 <xStreamBufferReceiveFromISR+0x4c>
    {
        xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
 400319c:	00800104 	movi	r2,4
 40031a0:	e0bffe15 	stw	r2,-8(fp)
 40031a4:	00000106 	br	40031ac <xStreamBufferReceiveFromISR+0x50>
    }
    else
    {
        xBytesToStoreMessageLength = 0;
 40031a8:	e03ffe15 	stw	zero,-8(fp)
    }

    xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
 40031ac:	e13ffd17 	ldw	r4,-12(fp)
 40031b0:	40036c00 	call	40036c0 <prvBytesInBuffer>
 40031b4:	e0bffc15 	stw	r2,-16(fp)
    /* Whether receiving a discrete message (where xBytesToStoreMessageLength
     * holds the number of bytes used to store the message length) or a stream of
     * bytes (where xBytesToStoreMessageLength is zero), the number of bytes
     * available must be greater than xBytesToStoreMessageLength to be able to
     * read bytes from the buffer. */
    if( xBytesAvailable > xBytesToStoreMessageLength )
 40031b8:	e0bffc17 	ldw	r2,-16(fp)
 40031bc:	e0fffe17 	ldw	r3,-8(fp)
 40031c0:	1880182e 	bgeu	r3,r2,4003224 <xStreamBufferReceiveFromISR+0xc8>
    {
        xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable );
 40031c4:	e1fffc17 	ldw	r7,-16(fp)
 40031c8:	e1bff817 	ldw	r6,-32(fp)
 40031cc:	e17ff917 	ldw	r5,-28(fp)
 40031d0:	e13ffd17 	ldw	r4,-12(fp)
 40031d4:	400323c0 	call	400323c <prvReadMessageFromBuffer>
 40031d8:	e0bfff15 	stw	r2,-4(fp)

        /* Was a task waiting for space in the buffer? */
        if( xReceivedLength != ( size_t ) 0 )
 40031dc:	e0bfff17 	ldw	r2,-4(fp)
 40031e0:	10001026 	beq	r2,zero,4003224 <xStreamBufferReceiveFromISR+0xc8>
        {
            prvRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
 40031e4:	e03ffb15 	stw	zero,-20(fp)
 40031e8:	e0bffd17 	ldw	r2,-12(fp)
 40031ec:	10800517 	ldw	r2,20(r2)
 40031f0:	10000c26 	beq	r2,zero,4003224 <xStreamBufferReceiveFromISR+0xc8>
 40031f4:	e0bffd17 	ldw	r2,-12(fp)
 40031f8:	10c00517 	ldw	r3,20(r2)
 40031fc:	e0bff717 	ldw	r2,-36(fp)
 4003200:	d8800115 	stw	r2,4(sp)
 4003204:	d8000015 	stw	zero,0(sp)
 4003208:	000f883a 	mov	r7,zero
 400320c:	000d883a 	mov	r6,zero
 4003210:	000b883a 	mov	r5,zero
 4003214:	1809883a 	mov	r4,r3
 4003218:	40066600 	call	4006660 <xTaskGenericNotifyFromISR>
 400321c:	e0bffd17 	ldw	r2,-12(fp)
 4003220:	10000515 	stw	zero,20(r2)
        mtCOVERAGE_TEST_MARKER();
    }

    traceSTREAM_BUFFER_RECEIVE_FROM_ISR( xStreamBuffer, xReceivedLength );

    return xReceivedLength;
 4003224:	e0bfff17 	ldw	r2,-4(fp)
}
 4003228:	e037883a 	mov	sp,fp
 400322c:	dfc00117 	ldw	ra,4(sp)
 4003230:	df000017 	ldw	fp,0(sp)
 4003234:	dec00204 	addi	sp,sp,8
 4003238:	f800283a 	ret

0400323c <prvReadMessageFromBuffer>:

static size_t prvReadMessageFromBuffer( StreamBuffer_t * pxStreamBuffer,
                                        void * pvRxData,
                                        size_t xBufferLengthBytes,
                                        size_t xBytesAvailable )
{
 400323c:	defff604 	addi	sp,sp,-40
 4003240:	dfc00915 	stw	ra,36(sp)
 4003244:	df000815 	stw	fp,32(sp)
 4003248:	df000804 	addi	fp,sp,32
 400324c:	e13ffb15 	stw	r4,-20(fp)
 4003250:	e17ffa15 	stw	r5,-24(fp)
 4003254:	e1bff915 	stw	r6,-28(fp)
 4003258:	e1fff815 	stw	r7,-32(fp)
    size_t xCount, xNextMessageLength;
    configMESSAGE_BUFFER_LENGTH_TYPE xTempNextMessageLength;
    size_t xNextTail = pxStreamBuffer->xTail;
 400325c:	e0bffb17 	ldw	r2,-20(fp)
 4003260:	10800017 	ldw	r2,0(r2)
 4003264:	e0bffe15 	stw	r2,-8(fp)

    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 4003268:	e0bffb17 	ldw	r2,-20(fp)
 400326c:	10800703 	ldbu	r2,28(r2)
 4003270:	10803fcc 	andi	r2,r2,255
 4003274:	1080004c 	andi	r2,r2,1
 4003278:	10001126 	beq	r2,zero,40032c0 <prvReadMessageFromBuffer+0x84>
    {
        /* A discrete message is being received.  First receive the length
         * of the message. */
        xNextTail = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, sbBYTES_TO_STORE_MESSAGE_LENGTH, xNextTail );
 400327c:	e0bffc04 	addi	r2,fp,-16
 4003280:	e1fffe17 	ldw	r7,-8(fp)
 4003284:	01800104 	movi	r6,4
 4003288:	100b883a 	mov	r5,r2
 400328c:	e13ffb17 	ldw	r4,-20(fp)
 4003290:	40035e00 	call	40035e0 <prvReadBytesFromBuffer>
 4003294:	e0bffe15 	stw	r2,-8(fp)
        xNextMessageLength = ( size_t ) xTempNextMessageLength;
 4003298:	e0bffc17 	ldw	r2,-16(fp)
 400329c:	e0bfff15 	stw	r2,-4(fp)

        /* Reduce the number of bytes available by the number of bytes just
         * read out. */
        xBytesAvailable -= sbBYTES_TO_STORE_MESSAGE_LENGTH;
 40032a0:	e0bff817 	ldw	r2,-32(fp)
 40032a4:	10bfff04 	addi	r2,r2,-4
 40032a8:	e0bff815 	stw	r2,-32(fp)

        /* Check there is enough space in the buffer provided by the
         * user. */
        if( xNextMessageLength > xBufferLengthBytes )
 40032ac:	e0bfff17 	ldw	r2,-4(fp)
 40032b0:	e0fff917 	ldw	r3,-28(fp)
 40032b4:	1880042e 	bgeu	r3,r2,40032c8 <prvReadMessageFromBuffer+0x8c>
        {
            /* The user has provided insufficient space to read the message. */
            xNextMessageLength = 0;
 40032b8:	e03fff15 	stw	zero,-4(fp)
 40032bc:	00000206 	br	40032c8 <prvReadMessageFromBuffer+0x8c>
    }
    else
    {
        /* A stream of bytes is being received (as opposed to a discrete
         * message), so read as many bytes as possible. */
        xNextMessageLength = xBufferLengthBytes;
 40032c0:	e0bff917 	ldw	r2,-28(fp)
 40032c4:	e0bfff15 	stw	r2,-4(fp)
    }

    /* Use the minimum of the wanted bytes and the available bytes. */
    xCount = configMIN( xNextMessageLength, xBytesAvailable );
 40032c8:	e0ffff17 	ldw	r3,-4(fp)
 40032cc:	e0bff817 	ldw	r2,-32(fp)
 40032d0:	1880012e 	bgeu	r3,r2,40032d8 <prvReadMessageFromBuffer+0x9c>
 40032d4:	1805883a 	mov	r2,r3
 40032d8:	e0bffd15 	stw	r2,-12(fp)

    if( xCount != ( size_t ) 0 )
 40032dc:	e0bffd17 	ldw	r2,-12(fp)
 40032e0:	10000826 	beq	r2,zero,4003304 <prvReadMessageFromBuffer+0xc8>
    {
        /* Read the actual data and update the tail to mark the data as officially consumed. */
        pxStreamBuffer->xTail = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) pvRxData, xCount, xNextTail ); /*lint !e9079 Data storage area is implemented as uint8_t array for ease of sizing, indexing and alignment. */
 40032e4:	e1fffe17 	ldw	r7,-8(fp)
 40032e8:	e1bffd17 	ldw	r6,-12(fp)
 40032ec:	e17ffa17 	ldw	r5,-24(fp)
 40032f0:	e13ffb17 	ldw	r4,-20(fp)
 40032f4:	40035e00 	call	40035e0 <prvReadBytesFromBuffer>
 40032f8:	1007883a 	mov	r3,r2
 40032fc:	e0bffb17 	ldw	r2,-20(fp)
 4003300:	10c00015 	stw	r3,0(r2)
    }

    return xCount;
 4003304:	e0bffd17 	ldw	r2,-12(fp)
}
 4003308:	e037883a 	mov	sp,fp
 400330c:	dfc00117 	ldw	ra,4(sp)
 4003310:	df000017 	ldw	fp,0(sp)
 4003314:	dec00204 	addi	sp,sp,8
 4003318:	f800283a 	ret

0400331c <xStreamBufferIsEmpty>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer )
{
 400331c:	defffb04 	addi	sp,sp,-20
 4003320:	df000415 	stw	fp,16(sp)
 4003324:	df000404 	addi	fp,sp,16
 4003328:	e13ffc15 	stw	r4,-16(fp)
    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 400332c:	e0bffc17 	ldw	r2,-16(fp)
 4003330:	e0bffe15 	stw	r2,-8(fp)
    size_t xTail;

    configASSERT( pxStreamBuffer );

    /* True if no bytes are available. */
    xTail = pxStreamBuffer->xTail;
 4003334:	e0bffe17 	ldw	r2,-8(fp)
 4003338:	10800017 	ldw	r2,0(r2)
 400333c:	e0bffd15 	stw	r2,-12(fp)

    if( pxStreamBuffer->xHead == xTail )
 4003340:	e0bffe17 	ldw	r2,-8(fp)
 4003344:	10800117 	ldw	r2,4(r2)
 4003348:	e0fffd17 	ldw	r3,-12(fp)
 400334c:	1880031e 	bne	r3,r2,400335c <xStreamBufferIsEmpty+0x40>
    {
        xReturn = pdTRUE;
 4003350:	00800044 	movi	r2,1
 4003354:	e0bfff15 	stw	r2,-4(fp)
 4003358:	00000106 	br	4003360 <xStreamBufferIsEmpty+0x44>
    }
    else
    {
        xReturn = pdFALSE;
 400335c:	e03fff15 	stw	zero,-4(fp)
    }

    return xReturn;
 4003360:	e0bfff17 	ldw	r2,-4(fp)
}
 4003364:	e037883a 	mov	sp,fp
 4003368:	df000017 	ldw	fp,0(sp)
 400336c:	dec00104 	addi	sp,sp,4
 4003370:	f800283a 	ret

04003374 <xStreamBufferIsFull>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer )
{
 4003374:	defffa04 	addi	sp,sp,-24
 4003378:	dfc00515 	stw	ra,20(sp)
 400337c:	df000415 	stw	fp,16(sp)
 4003380:	df000404 	addi	fp,sp,16
 4003384:	e13ffc15 	stw	r4,-16(fp)
    BaseType_t xReturn;
    size_t xBytesToStoreMessageLength;
    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 4003388:	e0bffc17 	ldw	r2,-16(fp)
 400338c:	e0bffd15 	stw	r2,-12(fp)

    /* This generic version of the receive function is used by both message
     * buffers, which store discrete messages, and stream buffers, which store a
     * continuous stream of bytes.  Discrete messages include an additional
     * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 4003390:	e0bffd17 	ldw	r2,-12(fp)
 4003394:	10800703 	ldbu	r2,28(r2)
 4003398:	10803fcc 	andi	r2,r2,255
 400339c:	1080004c 	andi	r2,r2,1
 40033a0:	10000326 	beq	r2,zero,40033b0 <xStreamBufferIsFull+0x3c>
    {
        xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
 40033a4:	00800104 	movi	r2,4
 40033a8:	e0bffe15 	stw	r2,-8(fp)
 40033ac:	00000106 	br	40033b4 <xStreamBufferIsFull+0x40>
    }
    else
    {
        xBytesToStoreMessageLength = 0;
 40033b0:	e03ffe15 	stw	zero,-8(fp)
    }

    /* True if the available space equals zero. */
    if( xStreamBufferSpacesAvailable( xStreamBuffer ) <= xBytesToStoreMessageLength )
 40033b4:	e13ffc17 	ldw	r4,-16(fp)
 40033b8:	4002aec0 	call	4002aec <xStreamBufferSpacesAvailable>
 40033bc:	1007883a 	mov	r3,r2
 40033c0:	e0bffe17 	ldw	r2,-8(fp)
 40033c4:	10c00336 	bltu	r2,r3,40033d4 <xStreamBufferIsFull+0x60>
    {
        xReturn = pdTRUE;
 40033c8:	00800044 	movi	r2,1
 40033cc:	e0bfff15 	stw	r2,-4(fp)
 40033d0:	00000106 	br	40033d8 <xStreamBufferIsFull+0x64>
    }
    else
    {
        xReturn = pdFALSE;
 40033d4:	e03fff15 	stw	zero,-4(fp)
    }

    return xReturn;
 40033d8:	e0bfff17 	ldw	r2,-4(fp)
}
 40033dc:	e037883a 	mov	sp,fp
 40033e0:	dfc00117 	ldw	ra,4(sp)
 40033e4:	df000017 	ldw	fp,0(sp)
 40033e8:	dec00204 	addi	sp,sp,8
 40033ec:	f800283a 	ret

040033f0 <xStreamBufferSendCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer,
                                              BaseType_t * pxHigherPriorityTaskWoken )
{
 40033f0:	defff704 	addi	sp,sp,-36
 40033f4:	dfc00815 	stw	ra,32(sp)
 40033f8:	df000715 	stw	fp,28(sp)
 40033fc:	df000704 	addi	fp,sp,28
 4003400:	e13ffc15 	stw	r4,-16(fp)
 4003404:	e17ffb15 	stw	r5,-20(fp)
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 4003408:	e0bffc17 	ldw	r2,-16(fp)
 400340c:	e0bffe15 	stw	r2,-8(fp)
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;

    configASSERT( pxStreamBuffer );

    uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
 4003410:	e03ffd15 	stw	zero,-12(fp)
    {
        if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )
 4003414:	e0bffe17 	ldw	r2,-8(fp)
 4003418:	10800417 	ldw	r2,16(r2)
 400341c:	10000f26 	beq	r2,zero,400345c <xStreamBufferSendCompletedFromISR+0x6c>
        {
            ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,
 4003420:	e0bffe17 	ldw	r2,-8(fp)
 4003424:	10c00417 	ldw	r3,16(r2)
 4003428:	e0bffb17 	ldw	r2,-20(fp)
 400342c:	d8800115 	stw	r2,4(sp)
 4003430:	d8000015 	stw	zero,0(sp)
 4003434:	000f883a 	mov	r7,zero
 4003438:	000d883a 	mov	r6,zero
 400343c:	000b883a 	mov	r5,zero
 4003440:	1809883a 	mov	r4,r3
 4003444:	40066600 	call	4006660 <xTaskGenericNotifyFromISR>
                                         ( uint32_t ) 0,
                                         eNoAction,
                                         pxHigherPriorityTaskWoken );
            ( pxStreamBuffer )->xTaskWaitingToReceive = NULL;
 4003448:	e0bffe17 	ldw	r2,-8(fp)
 400344c:	10000415 	stw	zero,16(r2)
            xReturn = pdTRUE;
 4003450:	00800044 	movi	r2,1
 4003454:	e0bfff15 	stw	r2,-4(fp)
 4003458:	00000106 	br	4003460 <xStreamBufferSendCompletedFromISR+0x70>
        }
        else
        {
            xReturn = pdFALSE;
 400345c:	e03fff15 	stw	zero,-4(fp)
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
 4003460:	e0bfff17 	ldw	r2,-4(fp)
}
 4003464:	e037883a 	mov	sp,fp
 4003468:	dfc00117 	ldw	ra,4(sp)
 400346c:	df000017 	ldw	fp,0(sp)
 4003470:	dec00204 	addi	sp,sp,8
 4003474:	f800283a 	ret

04003478 <xStreamBufferReceiveCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer,
                                                 BaseType_t * pxHigherPriorityTaskWoken )
{
 4003478:	defff704 	addi	sp,sp,-36
 400347c:	dfc00815 	stw	ra,32(sp)
 4003480:	df000715 	stw	fp,28(sp)
 4003484:	df000704 	addi	fp,sp,28
 4003488:	e13ffc15 	stw	r4,-16(fp)
 400348c:	e17ffb15 	stw	r5,-20(fp)
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 4003490:	e0bffc17 	ldw	r2,-16(fp)
 4003494:	e0bffe15 	stw	r2,-8(fp)
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;

    configASSERT( pxStreamBuffer );

    uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
 4003498:	e03ffd15 	stw	zero,-12(fp)
    {
        if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )
 400349c:	e0bffe17 	ldw	r2,-8(fp)
 40034a0:	10800517 	ldw	r2,20(r2)
 40034a4:	10000f26 	beq	r2,zero,40034e4 <xStreamBufferReceiveCompletedFromISR+0x6c>
        {
            ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,
 40034a8:	e0bffe17 	ldw	r2,-8(fp)
 40034ac:	10c00517 	ldw	r3,20(r2)
 40034b0:	e0bffb17 	ldw	r2,-20(fp)
 40034b4:	d8800115 	stw	r2,4(sp)
 40034b8:	d8000015 	stw	zero,0(sp)
 40034bc:	000f883a 	mov	r7,zero
 40034c0:	000d883a 	mov	r6,zero
 40034c4:	000b883a 	mov	r5,zero
 40034c8:	1809883a 	mov	r4,r3
 40034cc:	40066600 	call	4006660 <xTaskGenericNotifyFromISR>
                                         ( uint32_t ) 0,
                                         eNoAction,
                                         pxHigherPriorityTaskWoken );
            ( pxStreamBuffer )->xTaskWaitingToSend = NULL;
 40034d0:	e0bffe17 	ldw	r2,-8(fp)
 40034d4:	10000515 	stw	zero,20(r2)
            xReturn = pdTRUE;
 40034d8:	00800044 	movi	r2,1
 40034dc:	e0bfff15 	stw	r2,-4(fp)
 40034e0:	00000106 	br	40034e8 <xStreamBufferReceiveCompletedFromISR+0x70>
        }
        else
        {
            xReturn = pdFALSE;
 40034e4:	e03fff15 	stw	zero,-4(fp)
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
 40034e8:	e0bfff17 	ldw	r2,-4(fp)
}
 40034ec:	e037883a 	mov	sp,fp
 40034f0:	dfc00117 	ldw	ra,4(sp)
 40034f4:	df000017 	ldw	fp,0(sp)
 40034f8:	dec00204 	addi	sp,sp,8
 40034fc:	f800283a 	ret

04003500 <prvWriteBytesToBuffer>:

static size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer,
                                     const uint8_t * pucData,
                                     size_t xCount,
                                     size_t xHead )
{
 4003500:	defff904 	addi	sp,sp,-28
 4003504:	dfc00615 	stw	ra,24(sp)
 4003508:	df000515 	stw	fp,20(sp)
 400350c:	df000504 	addi	fp,sp,20
 4003510:	e13ffe15 	stw	r4,-8(fp)
 4003514:	e17ffd15 	stw	r5,-12(fp)
 4003518:	e1bffc15 	stw	r6,-16(fp)
 400351c:	e1fffb15 	stw	r7,-20(fp)
    configASSERT( xCount > ( size_t ) 0 );

    /* Calculate the number of bytes that can be added in the first write -
     * which may be less than the total number of bytes that need to be added if
     * the buffer will wrap back to the beginning. */
    xFirstLength = configMIN( pxStreamBuffer->xLength - xHead, xCount );
 4003520:	e0bffe17 	ldw	r2,-8(fp)
 4003524:	10c00217 	ldw	r3,8(r2)
 4003528:	e0bffb17 	ldw	r2,-20(fp)
 400352c:	1887c83a 	sub	r3,r3,r2
 4003530:	e0bffc17 	ldw	r2,-16(fp)
 4003534:	1880012e 	bgeu	r3,r2,400353c <prvWriteBytesToBuffer+0x3c>
 4003538:	1805883a 	mov	r2,r3
 400353c:	e0bfff15 	stw	r2,-4(fp)

    /* Write as many bytes as can be written in the first write. */
    configASSERT( ( xHead + xFirstLength ) <= pxStreamBuffer->xLength );
    ( void ) memcpy( ( void * ) ( &( pxStreamBuffer->pucBuffer[ xHead ] ) ), ( const void * ) pucData, xFirstLength ); /*lint !e9087 memcpy() requires void *. */
 4003540:	e0bffe17 	ldw	r2,-8(fp)
 4003544:	10c00617 	ldw	r3,24(r2)
 4003548:	e0bffb17 	ldw	r2,-20(fp)
 400354c:	1885883a 	add	r2,r3,r2
 4003550:	e1bfff17 	ldw	r6,-4(fp)
 4003554:	e17ffd17 	ldw	r5,-12(fp)
 4003558:	1009883a 	mov	r4,r2
 400355c:	40078800 	call	4007880 <memcpy>

    /* If the number of bytes written was less than the number that could be
     * written in the first write... */
    if( xCount > xFirstLength )
 4003560:	e0bffc17 	ldw	r2,-16(fp)
 4003564:	e0ffff17 	ldw	r3,-4(fp)
 4003568:	18800a2e 	bgeu	r3,r2,4003594 <prvWriteBytesToBuffer+0x94>
    {
        /* ...then write the remaining bytes to the start of the buffer. */
        configASSERT( ( xCount - xFirstLength ) <= pxStreamBuffer->xLength );
        ( void ) memcpy( ( void * ) pxStreamBuffer->pucBuffer, ( const void * ) &( pucData[ xFirstLength ] ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
 400356c:	e0bffe17 	ldw	r2,-8(fp)
 4003570:	11000617 	ldw	r4,24(r2)
 4003574:	e0fffd17 	ldw	r3,-12(fp)
 4003578:	e0bfff17 	ldw	r2,-4(fp)
 400357c:	188b883a 	add	r5,r3,r2
 4003580:	e0fffc17 	ldw	r3,-16(fp)
 4003584:	e0bfff17 	ldw	r2,-4(fp)
 4003588:	1885c83a 	sub	r2,r3,r2
 400358c:	100d883a 	mov	r6,r2
 4003590:	40078800 	call	4007880 <memcpy>
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    xHead += xCount;
 4003594:	e0fffb17 	ldw	r3,-20(fp)
 4003598:	e0bffc17 	ldw	r2,-16(fp)
 400359c:	1885883a 	add	r2,r3,r2
 40035a0:	e0bffb15 	stw	r2,-20(fp)

    if( xHead >= pxStreamBuffer->xLength )
 40035a4:	e0bffe17 	ldw	r2,-8(fp)
 40035a8:	10800217 	ldw	r2,8(r2)
 40035ac:	e0fffb17 	ldw	r3,-20(fp)
 40035b0:	18800536 	bltu	r3,r2,40035c8 <prvWriteBytesToBuffer+0xc8>
    {
        xHead -= pxStreamBuffer->xLength;
 40035b4:	e0bffe17 	ldw	r2,-8(fp)
 40035b8:	10800217 	ldw	r2,8(r2)
 40035bc:	e0fffb17 	ldw	r3,-20(fp)
 40035c0:	1885c83a 	sub	r2,r3,r2
 40035c4:	e0bffb15 	stw	r2,-20(fp)
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xHead;
 40035c8:	e0bffb17 	ldw	r2,-20(fp)
}
 40035cc:	e037883a 	mov	sp,fp
 40035d0:	dfc00117 	ldw	ra,4(sp)
 40035d4:	df000017 	ldw	fp,0(sp)
 40035d8:	dec00204 	addi	sp,sp,8
 40035dc:	f800283a 	ret

040035e0 <prvReadBytesFromBuffer>:

static size_t prvReadBytesFromBuffer( StreamBuffer_t * pxStreamBuffer,
                                      uint8_t * pucData,
                                      size_t xCount,
                                      size_t xTail )
{
 40035e0:	defff904 	addi	sp,sp,-28
 40035e4:	dfc00615 	stw	ra,24(sp)
 40035e8:	df000515 	stw	fp,20(sp)
 40035ec:	df000504 	addi	fp,sp,20
 40035f0:	e13ffe15 	stw	r4,-8(fp)
 40035f4:	e17ffd15 	stw	r5,-12(fp)
 40035f8:	e1bffc15 	stw	r6,-16(fp)
 40035fc:	e1fffb15 	stw	r7,-20(fp)
    configASSERT( xCount != ( size_t ) 0 );

    /* Calculate the number of bytes that can be read - which may be
     * less than the number wanted if the data wraps around to the start of
     * the buffer. */
    xFirstLength = configMIN( pxStreamBuffer->xLength - xTail, xCount );
 4003600:	e0bffe17 	ldw	r2,-8(fp)
 4003604:	10c00217 	ldw	r3,8(r2)
 4003608:	e0bffb17 	ldw	r2,-20(fp)
 400360c:	1887c83a 	sub	r3,r3,r2
 4003610:	e0bffc17 	ldw	r2,-16(fp)
 4003614:	1880012e 	bgeu	r3,r2,400361c <prvReadBytesFromBuffer+0x3c>
 4003618:	1805883a 	mov	r2,r3
 400361c:	e0bfff15 	stw	r2,-4(fp)

    /* Obtain the number of bytes it is possible to obtain in the first
     * read.  Asserts check bounds of read and write. */
    configASSERT( xFirstLength <= xCount );
    configASSERT( ( xTail + xFirstLength ) <= pxStreamBuffer->xLength );
    ( void ) memcpy( ( void * ) pucData, ( const void * ) &( pxStreamBuffer->pucBuffer[ xTail ] ), xFirstLength ); /*lint !e9087 memcpy() requires void *. */
 4003620:	e0bffe17 	ldw	r2,-8(fp)
 4003624:	10c00617 	ldw	r3,24(r2)
 4003628:	e0bffb17 	ldw	r2,-20(fp)
 400362c:	1885883a 	add	r2,r3,r2
 4003630:	e1bfff17 	ldw	r6,-4(fp)
 4003634:	100b883a 	mov	r5,r2
 4003638:	e13ffd17 	ldw	r4,-12(fp)
 400363c:	40078800 	call	4007880 <memcpy>

    /* If the total number of wanted bytes is greater than the number
     * that could be read in the first read... */
    if( xCount > xFirstLength )
 4003640:	e0bffc17 	ldw	r2,-16(fp)
 4003644:	e0ffff17 	ldw	r3,-4(fp)
 4003648:	18800a2e 	bgeu	r3,r2,4003674 <prvReadBytesFromBuffer+0x94>
    {
        /* ...then read the remaining bytes from the start of the buffer. */
        ( void ) memcpy( ( void * ) &( pucData[ xFirstLength ] ), ( void * ) ( pxStreamBuffer->pucBuffer ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
 400364c:	e0fffd17 	ldw	r3,-12(fp)
 4003650:	e0bfff17 	ldw	r2,-4(fp)
 4003654:	1889883a 	add	r4,r3,r2
 4003658:	e0bffe17 	ldw	r2,-8(fp)
 400365c:	11400617 	ldw	r5,24(r2)
 4003660:	e0fffc17 	ldw	r3,-16(fp)
 4003664:	e0bfff17 	ldw	r2,-4(fp)
 4003668:	1885c83a 	sub	r2,r3,r2
 400366c:	100d883a 	mov	r6,r2
 4003670:	40078800 	call	4007880 <memcpy>
    {
        mtCOVERAGE_TEST_MARKER();
    }

    /* Move the tail pointer to effectively remove the data read from the buffer. */
    xTail += xCount;
 4003674:	e0fffb17 	ldw	r3,-20(fp)
 4003678:	e0bffc17 	ldw	r2,-16(fp)
 400367c:	1885883a 	add	r2,r3,r2
 4003680:	e0bffb15 	stw	r2,-20(fp)

    if( xTail >= pxStreamBuffer->xLength )
 4003684:	e0bffe17 	ldw	r2,-8(fp)
 4003688:	10800217 	ldw	r2,8(r2)
 400368c:	e0fffb17 	ldw	r3,-20(fp)
 4003690:	18800536 	bltu	r3,r2,40036a8 <prvReadBytesFromBuffer+0xc8>
    {
        xTail -= pxStreamBuffer->xLength;
 4003694:	e0bffe17 	ldw	r2,-8(fp)
 4003698:	10800217 	ldw	r2,8(r2)
 400369c:	e0fffb17 	ldw	r3,-20(fp)
 40036a0:	1885c83a 	sub	r2,r3,r2
 40036a4:	e0bffb15 	stw	r2,-20(fp)
    }

    return xTail;
 40036a8:	e0bffb17 	ldw	r2,-20(fp)
}
 40036ac:	e037883a 	mov	sp,fp
 40036b0:	dfc00117 	ldw	ra,4(sp)
 40036b4:	df000017 	ldw	fp,0(sp)
 40036b8:	dec00204 	addi	sp,sp,8
 40036bc:	f800283a 	ret

040036c0 <prvBytesInBuffer>:
/*-----------------------------------------------------------*/

static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
 40036c0:	defffd04 	addi	sp,sp,-12
 40036c4:	df000215 	stw	fp,8(sp)
 40036c8:	df000204 	addi	fp,sp,8
 40036cc:	e13ffe15 	stw	r4,-8(fp)
/* Returns the distance between xTail and xHead. */
    size_t xCount;

    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
 40036d0:	e0bffe17 	ldw	r2,-8(fp)
 40036d4:	10c00217 	ldw	r3,8(r2)
 40036d8:	e0bffe17 	ldw	r2,-8(fp)
 40036dc:	10800117 	ldw	r2,4(r2)
 40036e0:	1885883a 	add	r2,r3,r2
 40036e4:	e0bfff15 	stw	r2,-4(fp)
    xCount -= pxStreamBuffer->xTail;
 40036e8:	e0bffe17 	ldw	r2,-8(fp)
 40036ec:	10800017 	ldw	r2,0(r2)
 40036f0:	e0ffff17 	ldw	r3,-4(fp)
 40036f4:	1885c83a 	sub	r2,r3,r2
 40036f8:	e0bfff15 	stw	r2,-4(fp)

    if( xCount >= pxStreamBuffer->xLength )
 40036fc:	e0bffe17 	ldw	r2,-8(fp)
 4003700:	10800217 	ldw	r2,8(r2)
 4003704:	e0ffff17 	ldw	r3,-4(fp)
 4003708:	18800536 	bltu	r3,r2,4003720 <prvBytesInBuffer+0x60>
    {
        xCount -= pxStreamBuffer->xLength;
 400370c:	e0bffe17 	ldw	r2,-8(fp)
 4003710:	10800217 	ldw	r2,8(r2)
 4003714:	e0ffff17 	ldw	r3,-4(fp)
 4003718:	1885c83a 	sub	r2,r3,r2
 400371c:	e0bfff15 	stw	r2,-4(fp)
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xCount;
 4003720:	e0bfff17 	ldw	r2,-4(fp)
}
 4003724:	e037883a 	mov	sp,fp
 4003728:	df000017 	ldw	fp,0(sp)
 400372c:	dec00104 	addi	sp,sp,4
 4003730:	f800283a 	ret

04003734 <prvInitialiseNewStreamBuffer>:
                                          size_t xBufferSizeBytes,
                                          size_t xTriggerLevelBytes,
                                          uint8_t ucFlags,
                                          StreamBufferCallbackFunction_t pxSendCompletedCallback,
                                          StreamBufferCallbackFunction_t pxReceiveCompletedCallback )
{
 4003734:	defff904 	addi	sp,sp,-28
 4003738:	dfc00615 	stw	ra,24(sp)
 400373c:	df000515 	stw	fp,20(sp)
 4003740:	df000504 	addi	fp,sp,20
 4003744:	e13fff15 	stw	r4,-4(fp)
 4003748:	e17ffe15 	stw	r5,-8(fp)
 400374c:	e1bffd15 	stw	r6,-12(fp)
 4003750:	e1fffc15 	stw	r7,-16(fp)
 4003754:	e0800217 	ldw	r2,8(fp)
 4003758:	e0bffb05 	stb	r2,-20(fp)
        const BaseType_t xWriteValue = 0x55;
        configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );
    } /*lint !e529 !e438 xWriteValue is only used if configASSERT() is defined. */
    #endif

    ( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); /*lint !e9087 memset() requires void *. */
 400375c:	01800804 	movi	r6,32
 4003760:	000b883a 	mov	r5,zero
 4003764:	e13fff17 	ldw	r4,-4(fp)
 4003768:	40079800 	call	4007980 <memset>
    pxStreamBuffer->pucBuffer = pucBuffer;
 400376c:	e0bfff17 	ldw	r2,-4(fp)
 4003770:	e0fffe17 	ldw	r3,-8(fp)
 4003774:	10c00615 	stw	r3,24(r2)
    pxStreamBuffer->xLength = xBufferSizeBytes;
 4003778:	e0bfff17 	ldw	r2,-4(fp)
 400377c:	e0fffd17 	ldw	r3,-12(fp)
 4003780:	10c00215 	stw	r3,8(r2)
    pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
 4003784:	e0bfff17 	ldw	r2,-4(fp)
 4003788:	e0fffc17 	ldw	r3,-16(fp)
 400378c:	10c00315 	stw	r3,12(r2)
    pxStreamBuffer->ucFlags = ucFlags;
 4003790:	e0bfff17 	ldw	r2,-4(fp)
 4003794:	e0fffb03 	ldbu	r3,-20(fp)
 4003798:	10c00705 	stb	r3,28(r2)
    {
        ( void ) pxSendCompletedCallback;
        ( void ) pxReceiveCompletedCallback;
    }
    #endif
}
 400379c:	0001883a 	nop
 40037a0:	e037883a 	mov	sp,fp
 40037a4:	dfc00117 	ldw	ra,4(sp)
 40037a8:	df000017 	ldw	fp,0(sp)
 40037ac:	dec00204 	addi	sp,sp,8
 40037b0:	f800283a 	ret

040037b4 <xTaskCreate>:
                            const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                            const configSTACK_DEPTH_TYPE usStackDepth,
                            void * const pvParameters,
                            UBaseType_t uxPriority,
                            TaskHandle_t * const pxCreatedTask )
    {
 40037b4:	defff304 	addi	sp,sp,-52
 40037b8:	dfc00c15 	stw	ra,48(sp)
 40037bc:	df000b15 	stw	fp,44(sp)
 40037c0:	df000b04 	addi	fp,sp,44
 40037c4:	e13ffc15 	stw	r4,-16(fp)
 40037c8:	e17ffb15 	stw	r5,-20(fp)
 40037cc:	3005883a 	mov	r2,r6
 40037d0:	e1fff915 	stw	r7,-28(fp)
 40037d4:	e0bffa0d 	sth	r2,-24(fp)
        #else /* portSTACK_GROWTH */
        {
            StackType_t * pxStack;

            /* Allocate space for the stack used by the task being created. */
            pxStack = pvPortMallocStack( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
 40037d8:	e0bffa0b 	ldhu	r2,-24(fp)
 40037dc:	100490ba 	slli	r2,r2,2
 40037e0:	1009883a 	mov	r4,r2
 40037e4:	400103c0 	call	400103c <pvPortMalloc>
 40037e8:	e0bffd15 	stw	r2,-12(fp)

            if( pxStack != NULL )
 40037ec:	e0bffd17 	ldw	r2,-12(fp)
 40037f0:	10001026 	beq	r2,zero,4003834 <xTaskCreate+0x80>
            {
                /* Allocate space for the TCB. */
                pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
 40037f4:	01001404 	movi	r4,80
 40037f8:	400103c0 	call	400103c <pvPortMalloc>
 40037fc:	e0bfff15 	stw	r2,-4(fp)

                if( pxNewTCB != NULL )
 4003800:	e0bfff17 	ldw	r2,-4(fp)
 4003804:	10000826 	beq	r2,zero,4003828 <xTaskCreate+0x74>
                {
                    memset( ( void * ) pxNewTCB, 0x00, sizeof( TCB_t ) );
 4003808:	01801404 	movi	r6,80
 400380c:	000b883a 	mov	r5,zero
 4003810:	e13fff17 	ldw	r4,-4(fp)
 4003814:	40079800 	call	4007980 <memset>

                    /* Store the stack location in the TCB. */
                    pxNewTCB->pxStack = pxStack;
 4003818:	e0bfff17 	ldw	r2,-4(fp)
 400381c:	e0fffd17 	ldw	r3,-12(fp)
 4003820:	10c00c15 	stw	r3,48(r2)
 4003824:	00000406 	br	4003838 <xTaskCreate+0x84>
                }
                else
                {
                    /* The stack cannot be used as the TCB was not created.  Free
                     * it again. */
                    vPortFreeStack( pxStack );
 4003828:	e13ffd17 	ldw	r4,-12(fp)
 400382c:	40011240 	call	4001124 <vPortFree>
 4003830:	00000106 	br	4003838 <xTaskCreate+0x84>
                }
            }
            else
            {
                pxNewTCB = NULL;
 4003834:	e03fff15 	stw	zero,-4(fp)
            }
        }
        #endif /* portSTACK_GROWTH */

        if( pxNewTCB != NULL )
 4003838:	e0bfff17 	ldw	r2,-4(fp)
 400383c:	10001226 	beq	r2,zero,4003888 <xTaskCreate+0xd4>
                 * task was created dynamically in case it is later deleted. */
                pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
            }
            #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

            prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
 4003840:	e0fffa0b 	ldhu	r3,-24(fp)
 4003844:	d8000315 	stw	zero,12(sp)
 4003848:	e0bfff17 	ldw	r2,-4(fp)
 400384c:	d8800215 	stw	r2,8(sp)
 4003850:	e0800317 	ldw	r2,12(fp)
 4003854:	d8800115 	stw	r2,4(sp)
 4003858:	e0800217 	ldw	r2,8(fp)
 400385c:	d8800015 	stw	r2,0(sp)
 4003860:	e1fff917 	ldw	r7,-28(fp)
 4003864:	180d883a 	mov	r6,r3
 4003868:	e17ffb17 	ldw	r5,-20(fp)
 400386c:	e13ffc17 	ldw	r4,-16(fp)
 4003870:	40038a80 	call	40038a8 <prvInitialiseNewTask>
            prvAddNewTaskToReadyList( pxNewTCB );
 4003874:	e13fff17 	ldw	r4,-4(fp)
 4003878:	4003a540 	call	4003a54 <prvAddNewTaskToReadyList>
            xReturn = pdPASS;
 400387c:	00800044 	movi	r2,1
 4003880:	e0bffe15 	stw	r2,-8(fp)
 4003884:	00000206 	br	4003890 <xTaskCreate+0xdc>
        }
        else
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 4003888:	00bfffc4 	movi	r2,-1
 400388c:	e0bffe15 	stw	r2,-8(fp)
        }

        return xReturn;
 4003890:	e0bffe17 	ldw	r2,-8(fp)
    }
 4003894:	e037883a 	mov	sp,fp
 4003898:	dfc00117 	ldw	ra,4(sp)
 400389c:	df000017 	ldw	fp,0(sp)
 40038a0:	dec00204 	addi	sp,sp,8
 40038a4:	f800283a 	ret

040038a8 <prvInitialiseNewTask>:
                                  void * const pvParameters,
                                  UBaseType_t uxPriority,
                                  TaskHandle_t * const pxCreatedTask,
                                  TCB_t * pxNewTCB,
                                  const MemoryRegion_t * const xRegions )
{
 40038a8:	defff804 	addi	sp,sp,-32
 40038ac:	dfc00715 	stw	ra,28(sp)
 40038b0:	df000615 	stw	fp,24(sp)
 40038b4:	df000604 	addi	fp,sp,24
 40038b8:	e13ffd15 	stw	r4,-12(fp)
 40038bc:	e17ffc15 	stw	r5,-16(fp)
 40038c0:	e1bffb15 	stw	r6,-20(fp)
 40038c4:	e1fffa15 	stw	r7,-24(fp)

    /* Avoid dependency on memset() if it is not required. */
    #if ( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
    {
        /* Fill the stack with a known value to assist debugging. */
        ( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 40038c8:	e0800417 	ldw	r2,16(fp)
 40038cc:	10c00c17 	ldw	r3,48(r2)
 40038d0:	e0bffb17 	ldw	r2,-20(fp)
 40038d4:	100490ba 	slli	r2,r2,2
 40038d8:	100d883a 	mov	r6,r2
 40038dc:	01402944 	movi	r5,165
 40038e0:	1809883a 	mov	r4,r3
 40038e4:	40079800 	call	4007980 <memset>
     * grows from high memory to low (as per the 80x86) or vice versa.
     * portSTACK_GROWTH is used to make the result positive or negative as required
     * by the port. */
    #if ( portSTACK_GROWTH < 0 )
    {
        pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
 40038e8:	e0800417 	ldw	r2,16(fp)
 40038ec:	10c00c17 	ldw	r3,48(r2)
 40038f0:	e13ffb17 	ldw	r4,-20(fp)
 40038f4:	00900034 	movhi	r2,16384
 40038f8:	10bfffc4 	addi	r2,r2,-1
 40038fc:	2085883a 	add	r2,r4,r2
 4003900:	100490ba 	slli	r2,r2,2
 4003904:	1885883a 	add	r2,r3,r2
 4003908:	e0bffe15 	stw	r2,-8(fp)
        pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
 400390c:	e0fffe17 	ldw	r3,-8(fp)
 4003910:	00bfff04 	movi	r2,-4
 4003914:	1884703a 	and	r2,r3,r2
 4003918:	e0bffe15 	stw	r2,-8(fp)
        pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
    }
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
 400391c:	e0bffc17 	ldw	r2,-16(fp)
 4003920:	10001c26 	beq	r2,zero,4003994 <prvInitialiseNewTask+0xec>
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 4003924:	e03fff15 	stw	zero,-4(fp)
 4003928:	00001306 	br	4003978 <prvInitialiseNewTask+0xd0>
        {
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 400392c:	e0fffc17 	ldw	r3,-16(fp)
 4003930:	e0bfff17 	ldw	r2,-4(fp)
 4003934:	1885883a 	add	r2,r3,r2
 4003938:	10c00003 	ldbu	r3,0(r2)
 400393c:	e1000417 	ldw	r4,16(fp)
 4003940:	e0bfff17 	ldw	r2,-4(fp)
 4003944:	2085883a 	add	r2,r4,r2
 4003948:	10c00d05 	stb	r3,52(r2)

            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
             * configMAX_TASK_NAME_LEN characters just in case the memory after the
             * string is not accessible (extremely unlikely). */
            if( pcName[ x ] == ( char ) 0x00 )
 400394c:	e0fffc17 	ldw	r3,-16(fp)
 4003950:	e0bfff17 	ldw	r2,-4(fp)
 4003954:	1885883a 	add	r2,r3,r2
 4003958:	10800003 	ldbu	r2,0(r2)
 400395c:	10803fcc 	andi	r2,r2,255
 4003960:	1080201c 	xori	r2,r2,128
 4003964:	10bfe004 	addi	r2,r2,-128
 4003968:	10000726 	beq	r2,zero,4003988 <prvInitialiseNewTask+0xe0>
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 400396c:	e0bfff17 	ldw	r2,-4(fp)
 4003970:	10800044 	addi	r2,r2,1
 4003974:	e0bfff15 	stw	r2,-4(fp)
 4003978:	e0bfff17 	ldw	r2,-4(fp)
 400397c:	10800230 	cmpltui	r2,r2,8
 4003980:	103fea1e 	bne	r2,zero,400392c <prvInitialiseNewTask+0x84>
 4003984:	00000106 	br	400398c <prvInitialiseNewTask+0xe4>
            {
                break;
 4003988:	0001883a 	nop
            }
        }

        /* Ensure the name string is terminated in the case that the string length
         * was greater or equal to configMAX_TASK_NAME_LEN. */
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 400398c:	e0800417 	ldw	r2,16(fp)
 4003990:	10000ec5 	stb	zero,59(r2)
    }

    /* This is used as an array index so must ensure it's not too large. */
    configASSERT( uxPriority < configMAX_PRIORITIES );

    if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 4003994:	e0800217 	ldw	r2,8(fp)
 4003998:	10800170 	cmpltui	r2,r2,5
 400399c:	1000021e 	bne	r2,zero,40039a8 <prvInitialiseNewTask+0x100>
    {
        uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 40039a0:	00800104 	movi	r2,4
 40039a4:	e0800215 	stw	r2,8(fp)
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxNewTCB->uxPriority = uxPriority;
 40039a8:	e0800417 	ldw	r2,16(fp)
 40039ac:	e0c00217 	ldw	r3,8(fp)
 40039b0:	10c00b15 	stw	r3,44(r2)
    #if ( configUSE_MUTEXES == 1 )
    {
        pxNewTCB->uxBasePriority = uxPriority;
 40039b4:	e0800417 	ldw	r2,16(fp)
 40039b8:	e0c00217 	ldw	r3,8(fp)
 40039bc:	10c01015 	stw	r3,64(r2)
    }
    #endif /* configUSE_MUTEXES */

    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 40039c0:	e0800417 	ldw	r2,16(fp)
 40039c4:	10800104 	addi	r2,r2,4
 40039c8:	1009883a 	mov	r4,r2
 40039cc:	4000b080 	call	4000b08 <vListInitialiseItem>
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 40039d0:	e0800417 	ldw	r2,16(fp)
 40039d4:	10800604 	addi	r2,r2,24
 40039d8:	1009883a 	mov	r4,r2
 40039dc:	4000b080 	call	4000b08 <vListInitialiseItem>

    /* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
     * back to  the containing TCB from a generic item in a list. */
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 40039e0:	e0800417 	ldw	r2,16(fp)
 40039e4:	e0c00417 	ldw	r3,16(fp)
 40039e8:	10c00415 	stw	r3,16(r2)

    /* Event lists are always in priority order. */
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 40039ec:	00c00144 	movi	r3,5
 40039f0:	e0800217 	ldw	r2,8(fp)
 40039f4:	1887c83a 	sub	r3,r3,r2
 40039f8:	e0800417 	ldw	r2,16(fp)
 40039fc:	10c00615 	stw	r3,24(r2)
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 4003a00:	e0800417 	ldw	r2,16(fp)
 4003a04:	e0c00417 	ldw	r3,16(fp)
 4003a08:	10c00915 	stw	r3,36(r2)
            }
            #endif /* portSTACK_GROWTH */
        }
        #else /* portHAS_STACK_OVERFLOW_CHECKING */
        {
            pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 4003a0c:	e1bffa17 	ldw	r6,-24(fp)
 4003a10:	e17ffd17 	ldw	r5,-12(fp)
 4003a14:	e13ffe17 	ldw	r4,-8(fp)
 4003a18:	4000d5c0 	call	4000d5c <pxPortInitialiseStack>
 4003a1c:	1007883a 	mov	r3,r2
 4003a20:	e0800417 	ldw	r2,16(fp)
 4003a24:	10c00015 	stw	r3,0(r2)
        }
        #endif /* portHAS_STACK_OVERFLOW_CHECKING */
    }
    #endif /* portUSING_MPU_WRAPPERS */

    if( pxCreatedTask != NULL )
 4003a28:	e0800317 	ldw	r2,12(fp)
 4003a2c:	10000326 	beq	r2,zero,4003a3c <prvInitialiseNewTask+0x194>
    {
        /* Pass the handle out in an anonymous way.  The handle can be used to
         * change the created task's priority, delete the created task, etc.*/
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 4003a30:	e0800317 	ldw	r2,12(fp)
 4003a34:	e0c00417 	ldw	r3,16(fp)
 4003a38:	10c00015 	stw	r3,0(r2)
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
 4003a3c:	0001883a 	nop
 4003a40:	e037883a 	mov	sp,fp
 4003a44:	dfc00117 	ldw	ra,4(sp)
 4003a48:	df000017 	ldw	fp,0(sp)
 4003a4c:	dec00204 	addi	sp,sp,8
 4003a50:	f800283a 	ret

04003a54 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB )
{
 4003a54:	defffa04 	addi	sp,sp,-24
 4003a58:	dfc00515 	stw	ra,20(sp)
 4003a5c:	df000415 	stw	fp,16(sp)
 4003a60:	dc400315 	stw	r17,12(sp)
 4003a64:	dc000215 	stw	r16,8(sp)
 4003a68:	df000404 	addi	fp,sp,16
 4003a6c:	e13ffc15 	stw	r4,-16(fp)
    /* Ensure interrupts don't access the task lists while the lists are being
     * updated. */
    taskENTER_CRITICAL();
 4003a70:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
    {
        uxCurrentNumberOfTasks++;
 4003a74:	d0a6b117 	ldw	r2,-25916(gp)
 4003a78:	10800044 	addi	r2,r2,1
 4003a7c:	d0a6b115 	stw	r2,-25916(gp)

        if( pxCurrentTCB == NULL )
 4003a80:	d0a6ad17 	ldw	r2,-25932(gp)
 4003a84:	1000071e 	bne	r2,zero,4003aa4 <prvAddNewTaskToReadyList+0x50>
        {
            /* There are no other tasks, or all the other tasks are in
             * the suspended state - make this the current task. */
            pxCurrentTCB = pxNewTCB;
 4003a88:	e0bffc17 	ldw	r2,-16(fp)
 4003a8c:	d0a6ad15 	stw	r2,-25932(gp)

            if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 4003a90:	d0a6b117 	ldw	r2,-25916(gp)
 4003a94:	10800058 	cmpnei	r2,r2,1
 4003a98:	10000b1e 	bne	r2,zero,4003ac8 <prvAddNewTaskToReadyList+0x74>
            {
                /* This is the first task to be created so do the preliminary
                 * initialisation required.  We will not recover if this call
                 * fails, but we will report the failure. */
                prvInitialiseTaskLists();
 4003a9c:	40057000 	call	4005700 <prvInitialiseTaskLists>
 4003aa0:	00000906 	br	4003ac8 <prvAddNewTaskToReadyList+0x74>
        else
        {
            /* If the scheduler is not already running, make this task the
             * current task if it is the highest priority task to be created
             * so far. */
            if( xSchedulerRunning == pdFALSE )
 4003aa4:	d0a6b417 	ldw	r2,-25904(gp)
 4003aa8:	1000071e 	bne	r2,zero,4003ac8 <prvAddNewTaskToReadyList+0x74>
            {
                if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 4003aac:	d0a6ad17 	ldw	r2,-25932(gp)
 4003ab0:	10800b17 	ldw	r2,44(r2)
 4003ab4:	e0fffc17 	ldw	r3,-16(fp)
 4003ab8:	18c00b17 	ldw	r3,44(r3)
 4003abc:	18800236 	bltu	r3,r2,4003ac8 <prvAddNewTaskToReadyList+0x74>
                {
                    pxCurrentTCB = pxNewTCB;
 4003ac0:	e0bffc17 	ldw	r2,-16(fp)
 4003ac4:	d0a6ad15 	stw	r2,-25932(gp)
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }

        uxTaskNumber++;
 4003ac8:	d0a6b817 	ldw	r2,-25888(gp)
 4003acc:	10800044 	addi	r2,r2,1
 4003ad0:	d0a6b815 	stw	r2,-25888(gp)
            pxNewTCB->uxTCBNumber = uxTaskNumber;
        }
        #endif /* configUSE_TRACE_FACILITY */
        traceTASK_CREATE( pxNewTCB );

        prvAddTaskToReadyList( pxNewTCB );
 4003ad4:	e0bffc17 	ldw	r2,-16(fp)
 4003ad8:	10800b17 	ldw	r2,44(r2)
 4003adc:	d0e6b317 	ldw	r3,-25908(gp)
 4003ae0:	1880032e 	bgeu	r3,r2,4003af0 <prvAddNewTaskToReadyList+0x9c>
 4003ae4:	e0bffc17 	ldw	r2,-16(fp)
 4003ae8:	10800b17 	ldw	r2,44(r2)
 4003aec:	d0a6b315 	stw	r2,-25908(gp)
 4003af0:	e0bffc17 	ldw	r2,-16(fp)
 4003af4:	10800b17 	ldw	r2,44(r2)
 4003af8:	01400504 	movi	r5,20
 4003afc:	1009883a 	mov	r4,r2
 4003b00:	40078580 	call	4007858 <__mulsi3>
 4003b04:	1007883a 	mov	r3,r2
 4003b08:	00812074 	movhi	r2,1153
 4003b0c:	1885883a 	add	r2,r3,r2
 4003b10:	10807717 	ldw	r2,476(r2)
 4003b14:	e0bffd15 	stw	r2,-12(fp)
 4003b18:	e0bffc17 	ldw	r2,-16(fp)
 4003b1c:	e0fffd17 	ldw	r3,-12(fp)
 4003b20:	10c00215 	stw	r3,8(r2)
 4003b24:	e0bffd17 	ldw	r2,-12(fp)
 4003b28:	10c00217 	ldw	r3,8(r2)
 4003b2c:	e0bffc17 	ldw	r2,-16(fp)
 4003b30:	10c00315 	stw	r3,12(r2)
 4003b34:	e0bffd17 	ldw	r2,-12(fp)
 4003b38:	10800217 	ldw	r2,8(r2)
 4003b3c:	e0fffc17 	ldw	r3,-16(fp)
 4003b40:	18c00104 	addi	r3,r3,4
 4003b44:	10c00115 	stw	r3,4(r2)
 4003b48:	e0bffc17 	ldw	r2,-16(fp)
 4003b4c:	10c00104 	addi	r3,r2,4
 4003b50:	e0bffd17 	ldw	r2,-12(fp)
 4003b54:	10c00215 	stw	r3,8(r2)
 4003b58:	e0bffc17 	ldw	r2,-16(fp)
 4003b5c:	10800b17 	ldw	r2,44(r2)
 4003b60:	01400504 	movi	r5,20
 4003b64:	1009883a 	mov	r4,r2
 4003b68:	40078580 	call	4007858 <__mulsi3>
 4003b6c:	1007883a 	mov	r3,r2
 4003b70:	00812074 	movhi	r2,1153
 4003b74:	10807604 	addi	r2,r2,472
 4003b78:	1887883a 	add	r3,r3,r2
 4003b7c:	e0bffc17 	ldw	r2,-16(fp)
 4003b80:	10c00515 	stw	r3,20(r2)
 4003b84:	e0bffc17 	ldw	r2,-16(fp)
 4003b88:	14400b17 	ldw	r17,44(r2)
 4003b8c:	01400504 	movi	r5,20
 4003b90:	8809883a 	mov	r4,r17
 4003b94:	40078580 	call	4007858 <__mulsi3>
 4003b98:	1007883a 	mov	r3,r2
 4003b9c:	00812074 	movhi	r2,1153
 4003ba0:	1885883a 	add	r2,r3,r2
 4003ba4:	10807617 	ldw	r2,472(r2)
 4003ba8:	14000044 	addi	r16,r2,1
 4003bac:	01400504 	movi	r5,20
 4003bb0:	8809883a 	mov	r4,r17
 4003bb4:	40078580 	call	4007858 <__mulsi3>
 4003bb8:	1007883a 	mov	r3,r2
 4003bbc:	00812074 	movhi	r2,1153
 4003bc0:	1885883a 	add	r2,r3,r2
 4003bc4:	14007615 	stw	r16,472(r2)

        portSETUP_TCB( pxNewTCB );
    }
    taskEXIT_CRITICAL();
 4003bc8:	4005fd00 	call	4005fd0 <vTaskExitCritical>

    if( xSchedulerRunning != pdFALSE )
 4003bcc:	d0a6b417 	ldw	r2,-25904(gp)
 4003bd0:	10000626 	beq	r2,zero,4003bec <prvAddNewTaskToReadyList+0x198>
    {
        /* If the created task is of a higher priority than the current task
         * then it should run now. */
        if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 4003bd4:	d0a6ad17 	ldw	r2,-25932(gp)
 4003bd8:	10c00b17 	ldw	r3,44(r2)
 4003bdc:	e0bffc17 	ldw	r2,-16(fp)
 4003be0:	10800b17 	ldw	r2,44(r2)
 4003be4:	1880012e 	bgeu	r3,r2,4003bec <prvAddNewTaskToReadyList+0x198>
        {
            taskYIELD_IF_USING_PREEMPTION();
 4003be8:	003b683a 	trap	0
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
 4003bec:	0001883a 	nop
 4003bf0:	e6fffe04 	addi	sp,fp,-8
 4003bf4:	dfc00317 	ldw	ra,12(sp)
 4003bf8:	df000217 	ldw	fp,8(sp)
 4003bfc:	dc400117 	ldw	r17,4(sp)
 4003c00:	dc000017 	ldw	r16,0(sp)
 4003c04:	dec00404 	addi	sp,sp,16
 4003c08:	f800283a 	ret

04003c0c <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    void vTaskDelete( TaskHandle_t xTaskToDelete )
    {
 4003c0c:	defffc04 	addi	sp,sp,-16
 4003c10:	dfc00315 	stw	ra,12(sp)
 4003c14:	df000215 	stw	fp,8(sp)
 4003c18:	df000204 	addi	fp,sp,8
 4003c1c:	e13ffe15 	stw	r4,-8(fp)
        TCB_t * pxTCB;

        taskENTER_CRITICAL();
 4003c20:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
        {
            /* If null is passed in here then it is the calling task that is
             * being deleted. */
            pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 4003c24:	e0bffe17 	ldw	r2,-8(fp)
 4003c28:	1000021e 	bne	r2,zero,4003c34 <vTaskDelete+0x28>
 4003c2c:	d0a6ad17 	ldw	r2,-25932(gp)
 4003c30:	00000106 	br	4003c38 <vTaskDelete+0x2c>
 4003c34:	e0bffe17 	ldw	r2,-8(fp)
 4003c38:	e0bfff15 	stw	r2,-4(fp)

            /* Remove task from the ready/delayed list. */
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 4003c3c:	e0bfff17 	ldw	r2,-4(fp)
 4003c40:	10800104 	addi	r2,r2,4
 4003c44:	1009883a 	mov	r4,r2
 4003c48:	4000c980 	call	4000c98 <uxListRemove>
            {
                mtCOVERAGE_TEST_MARKER();
            }

            /* Is the task waiting on an event also? */
            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 4003c4c:	e0bfff17 	ldw	r2,-4(fp)
 4003c50:	10800a17 	ldw	r2,40(r2)
 4003c54:	10000426 	beq	r2,zero,4003c68 <vTaskDelete+0x5c>
            {
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 4003c58:	e0bfff17 	ldw	r2,-4(fp)
 4003c5c:	10800604 	addi	r2,r2,24
 4003c60:	1009883a 	mov	r4,r2
 4003c64:	4000c980 	call	4000c98 <uxListRemove>

            /* Increment the uxTaskNumber also so kernel aware debuggers can
             * detect that the task lists need re-generating.  This is done before
             * portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
             * not return. */
            uxTaskNumber++;
 4003c68:	d0a6b817 	ldw	r2,-25888(gp)
 4003c6c:	10800044 	addi	r2,r2,1
 4003c70:	d0a6b815 	stw	r2,-25888(gp)

            if( pxTCB == pxCurrentTCB )
 4003c74:	d0a6ad17 	ldw	r2,-25932(gp)
 4003c78:	e0ffff17 	ldw	r3,-4(fp)
 4003c7c:	18800a1e 	bne	r3,r2,4003ca8 <vTaskDelete+0x9c>
                /* A task is deleting itself.  This cannot complete within the
                 * task itself, as a context switch to another task is required.
                 * Place the task in the termination list.  The idle task will
                 * check the termination list and free up any memory allocated by
                 * the scheduler for the TCB and stack of the deleted task. */
                vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
 4003c80:	e0bfff17 	ldw	r2,-4(fp)
 4003c84:	10800104 	addi	r2,r2,4
 4003c88:	100b883a 	mov	r5,r2
 4003c8c:	01012074 	movhi	r4,1153
 4003c90:	21009e04 	addi	r4,r4,632
 4003c94:	4000b340 	call	4000b34 <vListInsertEnd>

                /* Increment the ucTasksDeleted variable so the idle task knows
                 * there is a task that has been deleted and that it should therefore
                 * check the xTasksWaitingTermination list. */
                ++uxDeletedTasksWaitingCleanUp;
 4003c98:	d0a6b017 	ldw	r2,-25920(gp)
 4003c9c:	10800044 	addi	r2,r2,1
 4003ca0:	d0a6b015 	stw	r2,-25920(gp)
 4003ca4:	00000406 	br	4003cb8 <vTaskDelete+0xac>
                 * required. */
                portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
            }
            else
            {
                --uxCurrentNumberOfTasks;
 4003ca8:	d0a6b117 	ldw	r2,-25916(gp)
 4003cac:	10bfffc4 	addi	r2,r2,-1
 4003cb0:	d0a6b115 	stw	r2,-25916(gp)
                traceTASK_DELETE( pxTCB );

                /* Reset the next expected unblock time in case it referred to
                 * the task that has just been deleted. */
                prvResetNextTaskUnblockTime();
 4003cb4:	40059480 	call	4005948 <prvResetNextTaskUnblockTime>
            }
        }
        taskEXIT_CRITICAL();
 4003cb8:	4005fd00 	call	4005fd0 <vTaskExitCritical>

        /* If the task is not deleting itself, call prvDeleteTCB from outside of
         * critical section. If a task deletes itself, prvDeleteTCB is called
         * from prvCheckTasksWaitingTermination which is called from Idle task. */
        if( pxTCB != pxCurrentTCB )
 4003cbc:	d0a6ad17 	ldw	r2,-25932(gp)
 4003cc0:	e0ffff17 	ldw	r3,-4(fp)
 4003cc4:	18800226 	beq	r3,r2,4003cd0 <vTaskDelete+0xc4>
        {
            prvDeleteTCB( pxTCB );
 4003cc8:	e13fff17 	ldw	r4,-4(fp)
 4003ccc:	40059040 	call	4005904 <prvDeleteTCB>
        }

        /* Force a reschedule if it is the currently running task that has just
         * been deleted. */
        if( xSchedulerRunning != pdFALSE )
 4003cd0:	d0a6b417 	ldw	r2,-25904(gp)
 4003cd4:	10000426 	beq	r2,zero,4003ce8 <vTaskDelete+0xdc>
        {
            if( pxTCB == pxCurrentTCB )
 4003cd8:	d0a6ad17 	ldw	r2,-25932(gp)
 4003cdc:	e0ffff17 	ldw	r3,-4(fp)
 4003ce0:	1880011e 	bne	r3,r2,4003ce8 <vTaskDelete+0xdc>
            {
                configASSERT( uxSchedulerSuspended == 0 );
                portYIELD_WITHIN_API();
 4003ce4:	003b683a 	trap	0
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    }
 4003ce8:	0001883a 	nop
 4003cec:	e037883a 	mov	sp,fp
 4003cf0:	dfc00117 	ldw	ra,4(sp)
 4003cf4:	df000017 	ldw	fp,0(sp)
 4003cf8:	dec00204 	addi	sp,sp,8
 4003cfc:	f800283a 	ret

04003d00 <xTaskDelayUntil>:

#if ( INCLUDE_xTaskDelayUntil == 1 )

    BaseType_t xTaskDelayUntil( TickType_t * const pxPreviousWakeTime,
                                const TickType_t xTimeIncrement )
    {
 4003d00:	defff804 	addi	sp,sp,-32
 4003d04:	dfc00715 	stw	ra,28(sp)
 4003d08:	df000615 	stw	fp,24(sp)
 4003d0c:	df000604 	addi	fp,sp,24
 4003d10:	e13ffb15 	stw	r4,-20(fp)
 4003d14:	e17ffa15 	stw	r5,-24(fp)
        TickType_t xTimeToWake;
        BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
 4003d18:	e03fff15 	stw	zero,-4(fp)

        configASSERT( pxPreviousWakeTime );
        configASSERT( ( xTimeIncrement > 0U ) );
        configASSERT( uxSchedulerSuspended == 0 );

        vTaskSuspendAll();
 4003d1c:	40046f00 	call	40046f0 <vTaskSuspendAll>
        {
            /* Minor optimisation.  The tick count cannot change in this
             * block. */
            const TickType_t xConstTickCount = xTickCount;
 4003d20:	d0a6b217 	ldw	r2,-25912(gp)
 4003d24:	e0bffe15 	stw	r2,-8(fp)

            /* Generate the tick time at which the task wants to wake. */
            xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 4003d28:	e0bffb17 	ldw	r2,-20(fp)
 4003d2c:	10800017 	ldw	r2,0(r2)
 4003d30:	e0fffa17 	ldw	r3,-24(fp)
 4003d34:	1885883a 	add	r2,r3,r2
 4003d38:	e0bffd15 	stw	r2,-12(fp)

            if( xConstTickCount < *pxPreviousWakeTime )
 4003d3c:	e0bffb17 	ldw	r2,-20(fp)
 4003d40:	10800017 	ldw	r2,0(r2)
 4003d44:	e0fffe17 	ldw	r3,-8(fp)
 4003d48:	18800a2e 	bgeu	r3,r2,4003d74 <xTaskDelayUntil+0x74>
                /* The tick count has overflowed since this function was
                 * lasted called.  In this case the only time we should ever
                 * actually delay is if the wake time has also  overflowed,
                 * and the wake time is greater than the tick time.  When this
                 * is the case it is as if neither time had overflowed. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
 4003d4c:	e0bffb17 	ldw	r2,-20(fp)
 4003d50:	10800017 	ldw	r2,0(r2)
 4003d54:	e0fffd17 	ldw	r3,-12(fp)
 4003d58:	18800f2e 	bgeu	r3,r2,4003d98 <xTaskDelayUntil+0x98>
 4003d5c:	e0bffd17 	ldw	r2,-12(fp)
 4003d60:	e0fffe17 	ldw	r3,-8(fp)
 4003d64:	18800c2e 	bgeu	r3,r2,4003d98 <xTaskDelayUntil+0x98>
                {
                    xShouldDelay = pdTRUE;
 4003d68:	00800044 	movi	r2,1
 4003d6c:	e0bfff15 	stw	r2,-4(fp)
 4003d70:	00000906 	br	4003d98 <xTaskDelayUntil+0x98>
            else
            {
                /* The tick time has not overflowed.  In this case we will
                 * delay if either the wake time has overflowed, and/or the
                 * tick time is less than the wake time. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
 4003d74:	e0bffb17 	ldw	r2,-20(fp)
 4003d78:	10800017 	ldw	r2,0(r2)
 4003d7c:	e0fffd17 	ldw	r3,-12(fp)
 4003d80:	18800336 	bltu	r3,r2,4003d90 <xTaskDelayUntil+0x90>
 4003d84:	e0bffd17 	ldw	r2,-12(fp)
 4003d88:	e0fffe17 	ldw	r3,-8(fp)
 4003d8c:	1880022e 	bgeu	r3,r2,4003d98 <xTaskDelayUntil+0x98>
                {
                    xShouldDelay = pdTRUE;
 4003d90:	00800044 	movi	r2,1
 4003d94:	e0bfff15 	stw	r2,-4(fp)
                    mtCOVERAGE_TEST_MARKER();
                }
            }

            /* Update the wake time ready for the next call. */
            *pxPreviousWakeTime = xTimeToWake;
 4003d98:	e0bffb17 	ldw	r2,-20(fp)
 4003d9c:	e0fffd17 	ldw	r3,-12(fp)
 4003da0:	10c00015 	stw	r3,0(r2)

            if( xShouldDelay != pdFALSE )
 4003da4:	e0bfff17 	ldw	r2,-4(fp)
 4003da8:	10000626 	beq	r2,zero,4003dc4 <xTaskDelayUntil+0xc4>
            {
                traceTASK_DELAY_UNTIL( xTimeToWake );

                /* prvAddCurrentTaskToDelayedList() needs the block time, not
                 * the time to wake, so subtract the current tick count. */
                prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
 4003dac:	e0fffd17 	ldw	r3,-12(fp)
 4003db0:	e0bffe17 	ldw	r2,-8(fp)
 4003db4:	1885c83a 	sub	r2,r3,r2
 4003db8:	000b883a 	mov	r5,zero
 4003dbc:	1009883a 	mov	r4,r2
 4003dc0:	4006e3c0 	call	4006e3c <prvAddCurrentTaskToDelayedList>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        xAlreadyYielded = xTaskResumeAll();
 4003dc4:	400471c0 	call	400471c <xTaskResumeAll>
 4003dc8:	e0bffc15 	stw	r2,-16(fp)

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
 4003dcc:	e0bffc17 	ldw	r2,-16(fp)
 4003dd0:	1000011e 	bne	r2,zero,4003dd8 <xTaskDelayUntil+0xd8>
        {
            portYIELD_WITHIN_API();
 4003dd4:	003b683a 	trap	0
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xShouldDelay;
 4003dd8:	e0bfff17 	ldw	r2,-4(fp)
    }
 4003ddc:	e037883a 	mov	sp,fp
 4003de0:	dfc00117 	ldw	ra,4(sp)
 4003de4:	df000017 	ldw	fp,0(sp)
 4003de8:	dec00204 	addi	sp,sp,8
 4003dec:	f800283a 	ret

04003df0 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

    void vTaskDelay( const TickType_t xTicksToDelay )
    {
 4003df0:	defffc04 	addi	sp,sp,-16
 4003df4:	dfc00315 	stw	ra,12(sp)
 4003df8:	df000215 	stw	fp,8(sp)
 4003dfc:	df000204 	addi	fp,sp,8
 4003e00:	e13ffe15 	stw	r4,-8(fp)
        BaseType_t xAlreadyYielded = pdFALSE;
 4003e04:	e03fff15 	stw	zero,-4(fp)

        /* A delay time of zero just forces a reschedule. */
        if( xTicksToDelay > ( TickType_t ) 0U )
 4003e08:	e0bffe17 	ldw	r2,-8(fp)
 4003e0c:	10000626 	beq	r2,zero,4003e28 <vTaskDelay+0x38>
        {
            configASSERT( uxSchedulerSuspended == 0 );
            vTaskSuspendAll();
 4003e10:	40046f00 	call	40046f0 <vTaskSuspendAll>
                 * list or removed from the blocked list until the scheduler
                 * is resumed.
                 *
                 * This task cannot be in an event list as it is the currently
                 * executing task. */
                prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 4003e14:	000b883a 	mov	r5,zero
 4003e18:	e13ffe17 	ldw	r4,-8(fp)
 4003e1c:	4006e3c0 	call	4006e3c <prvAddCurrentTaskToDelayedList>
            }
            xAlreadyYielded = xTaskResumeAll();
 4003e20:	400471c0 	call	400471c <xTaskResumeAll>
 4003e24:	e0bfff15 	stw	r2,-4(fp)
            mtCOVERAGE_TEST_MARKER();
        }

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
 4003e28:	e0bfff17 	ldw	r2,-4(fp)
 4003e2c:	1000011e 	bne	r2,zero,4003e34 <vTaskDelay+0x44>
        {
            portYIELD_WITHIN_API();
 4003e30:	003b683a 	trap	0
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
 4003e34:	0001883a 	nop
 4003e38:	e037883a 	mov	sp,fp
 4003e3c:	dfc00117 	ldw	ra,4(sp)
 4003e40:	df000017 	ldw	fp,0(sp)
 4003e44:	dec00204 	addi	sp,sp,8
 4003e48:	f800283a 	ret

04003e4c <uxTaskPriorityGet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

    UBaseType_t uxTaskPriorityGet( const TaskHandle_t xTask )
    {
 4003e4c:	defffb04 	addi	sp,sp,-20
 4003e50:	dfc00415 	stw	ra,16(sp)
 4003e54:	df000315 	stw	fp,12(sp)
 4003e58:	df000304 	addi	fp,sp,12
 4003e5c:	e13ffd15 	stw	r4,-12(fp)
        TCB_t const * pxTCB;
        UBaseType_t uxReturn;

        taskENTER_CRITICAL();
 4003e60:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
        {
            /* If null is passed in here then it is the priority of the task
             * that called uxTaskPriorityGet() that is being queried. */
            pxTCB = prvGetTCBFromHandle( xTask );
 4003e64:	e0bffd17 	ldw	r2,-12(fp)
 4003e68:	1000021e 	bne	r2,zero,4003e74 <uxTaskPriorityGet+0x28>
 4003e6c:	d0a6ad17 	ldw	r2,-25932(gp)
 4003e70:	00000106 	br	4003e78 <uxTaskPriorityGet+0x2c>
 4003e74:	e0bffd17 	ldw	r2,-12(fp)
 4003e78:	e0bfff15 	stw	r2,-4(fp)
            uxReturn = pxTCB->uxPriority;
 4003e7c:	e0bfff17 	ldw	r2,-4(fp)
 4003e80:	10800b17 	ldw	r2,44(r2)
 4003e84:	e0bffe15 	stw	r2,-8(fp)
        }
        taskEXIT_CRITICAL();
 4003e88:	4005fd00 	call	4005fd0 <vTaskExitCritical>

        return uxReturn;
 4003e8c:	e0bffe17 	ldw	r2,-8(fp)
    }
 4003e90:	e037883a 	mov	sp,fp
 4003e94:	dfc00117 	ldw	ra,4(sp)
 4003e98:	df000017 	ldw	fp,0(sp)
 4003e9c:	dec00204 	addi	sp,sp,8
 4003ea0:	f800283a 	ret

04003ea4 <uxTaskPriorityGetFromISR>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

    UBaseType_t uxTaskPriorityGetFromISR( const TaskHandle_t xTask )
    {
 4003ea4:	defffb04 	addi	sp,sp,-20
 4003ea8:	df000415 	stw	fp,16(sp)
 4003eac:	df000404 	addi	fp,sp,16
 4003eb0:	e13ffc15 	stw	r4,-16(fp)
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
 4003eb4:	e03fff15 	stw	zero,-4(fp)
        {
            /* If null is passed in here then it is the priority of the calling
             * task that is being queried. */
            pxTCB = prvGetTCBFromHandle( xTask );
 4003eb8:	e0bffc17 	ldw	r2,-16(fp)
 4003ebc:	1000021e 	bne	r2,zero,4003ec8 <uxTaskPriorityGetFromISR+0x24>
 4003ec0:	d0a6ad17 	ldw	r2,-25932(gp)
 4003ec4:	00000106 	br	4003ecc <uxTaskPriorityGetFromISR+0x28>
 4003ec8:	e0bffc17 	ldw	r2,-16(fp)
 4003ecc:	e0bffe15 	stw	r2,-8(fp)
            uxReturn = pxTCB->uxPriority;
 4003ed0:	e0bffe17 	ldw	r2,-8(fp)
 4003ed4:	10800b17 	ldw	r2,44(r2)
 4003ed8:	e0bffd15 	stw	r2,-12(fp)
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );

        return uxReturn;
 4003edc:	e0bffd17 	ldw	r2,-12(fp)
    }
 4003ee0:	e037883a 	mov	sp,fp
 4003ee4:	df000017 	ldw	fp,0(sp)
 4003ee8:	dec00104 	addi	sp,sp,4
 4003eec:	f800283a 	ret

04003ef0 <vTaskPrioritySet>:

#if ( INCLUDE_vTaskPrioritySet == 1 )

    void vTaskPrioritySet( TaskHandle_t xTask,
                           UBaseType_t uxNewPriority )
    {
 4003ef0:	defff504 	addi	sp,sp,-44
 4003ef4:	dfc00a15 	stw	ra,40(sp)
 4003ef8:	df000915 	stw	fp,36(sp)
 4003efc:	dc400815 	stw	r17,32(sp)
 4003f00:	dc000715 	stw	r16,28(sp)
 4003f04:	df000904 	addi	fp,sp,36
 4003f08:	e13ff815 	stw	r4,-32(fp)
 4003f0c:	e17ff715 	stw	r5,-36(fp)
        TCB_t * pxTCB;
        UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
        BaseType_t xYieldRequired = pdFALSE;
 4003f10:	e03ffd15 	stw	zero,-12(fp)

        configASSERT( uxNewPriority < configMAX_PRIORITIES );

        /* Ensure the new priority is valid. */
        if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 4003f14:	e0bff717 	ldw	r2,-36(fp)
 4003f18:	10800170 	cmpltui	r2,r2,5
 4003f1c:	1000021e 	bne	r2,zero,4003f28 <vTaskPrioritySet+0x38>
        {
            uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 4003f20:	00800104 	movi	r2,4
 4003f24:	e0bff715 	stw	r2,-36(fp)
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        taskENTER_CRITICAL();
 4003f28:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
        {
            /* If null is passed in here then it is the priority of the calling
             * task that is being changed. */
            pxTCB = prvGetTCBFromHandle( xTask );
 4003f2c:	e0bff817 	ldw	r2,-32(fp)
 4003f30:	1000021e 	bne	r2,zero,4003f3c <vTaskPrioritySet+0x4c>
 4003f34:	d0a6ad17 	ldw	r2,-25932(gp)
 4003f38:	00000106 	br	4003f40 <vTaskPrioritySet+0x50>
 4003f3c:	e0bff817 	ldw	r2,-32(fp)
 4003f40:	e0bffc15 	stw	r2,-16(fp)

            traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );

            #if ( configUSE_MUTEXES == 1 )
            {
                uxCurrentBasePriority = pxTCB->uxBasePriority;
 4003f44:	e0bffc17 	ldw	r2,-16(fp)
 4003f48:	10801017 	ldw	r2,64(r2)
 4003f4c:	e0bffb15 	stw	r2,-20(fp)
            {
                uxCurrentBasePriority = pxTCB->uxPriority;
            }
            #endif

            if( uxCurrentBasePriority != uxNewPriority )
 4003f50:	e0fffb17 	ldw	r3,-20(fp)
 4003f54:	e0bff717 	ldw	r2,-36(fp)
 4003f58:	18807626 	beq	r3,r2,4004134 <vTaskPrioritySet+0x244>
            {
                /* The priority change may have readied a task of higher
                 * priority than the calling task. */
                if( uxNewPriority > uxCurrentBasePriority )
 4003f5c:	e0bff717 	ldw	r2,-36(fp)
 4003f60:	e0fffb17 	ldw	r3,-20(fp)
 4003f64:	18800a2e 	bgeu	r3,r2,4003f90 <vTaskPrioritySet+0xa0>
                {
                    if( pxTCB != pxCurrentTCB )
 4003f68:	d0a6ad17 	ldw	r2,-25932(gp)
 4003f6c:	e0fffc17 	ldw	r3,-16(fp)
 4003f70:	18800c26 	beq	r3,r2,4003fa4 <vTaskPrioritySet+0xb4>
                    {
                        /* The priority of a task other than the currently
                         * running task is being raised.  Is the priority being
                         * raised above that of the running task? */
                        if( uxNewPriority >= pxCurrentTCB->uxPriority )
 4003f74:	d0a6ad17 	ldw	r2,-25932(gp)
 4003f78:	10800b17 	ldw	r2,44(r2)
 4003f7c:	e0fff717 	ldw	r3,-36(fp)
 4003f80:	18800836 	bltu	r3,r2,4003fa4 <vTaskPrioritySet+0xb4>
                        {
                            xYieldRequired = pdTRUE;
 4003f84:	00800044 	movi	r2,1
 4003f88:	e0bffd15 	stw	r2,-12(fp)
 4003f8c:	00000506 	br	4003fa4 <vTaskPrioritySet+0xb4>
                        /* The priority of the running task is being raised,
                         * but the running task must already be the highest
                         * priority task able to run so no yield is required. */
                    }
                }
                else if( pxTCB == pxCurrentTCB )
 4003f90:	d0a6ad17 	ldw	r2,-25932(gp)
 4003f94:	e0fffc17 	ldw	r3,-16(fp)
 4003f98:	1880021e 	bne	r3,r2,4003fa4 <vTaskPrioritySet+0xb4>
                {
                    /* Setting the priority of the running task down means
                     * there may now be another task of higher priority that
                     * is ready to execute. */
                    xYieldRequired = pdTRUE;
 4003f9c:	00800044 	movi	r2,1
 4003fa0:	e0bffd15 	stw	r2,-12(fp)
                }

                /* Remember the ready list the task might be referenced from
                 * before its uxPriority member is changed so the
                 * taskRESET_READY_PRIORITY() macro can function correctly. */
                uxPriorityUsedOnEntry = pxTCB->uxPriority;
 4003fa4:	e0bffc17 	ldw	r2,-16(fp)
 4003fa8:	10800b17 	ldw	r2,44(r2)
 4003fac:	e0bffa15 	stw	r2,-24(fp)

                #if ( configUSE_MUTEXES == 1 )
                {
                    /* Only change the priority being used if the task is not
                     * currently using an inherited priority. */
                    if( pxTCB->uxBasePriority == pxTCB->uxPriority )
 4003fb0:	e0bffc17 	ldw	r2,-16(fp)
 4003fb4:	10c01017 	ldw	r3,64(r2)
 4003fb8:	e0bffc17 	ldw	r2,-16(fp)
 4003fbc:	10800b17 	ldw	r2,44(r2)
 4003fc0:	1880031e 	bne	r3,r2,4003fd0 <vTaskPrioritySet+0xe0>
                    {
                        pxTCB->uxPriority = uxNewPriority;
 4003fc4:	e0bffc17 	ldw	r2,-16(fp)
 4003fc8:	e0fff717 	ldw	r3,-36(fp)
 4003fcc:	10c00b15 	stw	r3,44(r2)
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* The base priority gets set whatever. */
                    pxTCB->uxBasePriority = uxNewPriority;
 4003fd0:	e0bffc17 	ldw	r2,-16(fp)
 4003fd4:	e0fff717 	ldw	r3,-36(fp)
 4003fd8:	10c01015 	stw	r3,64(r2)
                }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                /* Only reset the event list item value if the value is not
                 * being used for anything else. */
                if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 4003fdc:	e0bffc17 	ldw	r2,-16(fp)
 4003fe0:	10800617 	ldw	r2,24(r2)
 4003fe4:	10000516 	blt	r2,zero,4003ffc <vTaskPrioritySet+0x10c>
                {
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 4003fe8:	00c00144 	movi	r3,5
 4003fec:	e0bff717 	ldw	r2,-36(fp)
 4003ff0:	1887c83a 	sub	r3,r3,r2
 4003ff4:	e0bffc17 	ldw	r2,-16(fp)
 4003ff8:	10c00615 	stw	r3,24(r2)

                /* If the task is in the blocked or suspended list we need do
                 * nothing more than change its priority variable. However, if
                 * the task is in a ready list it needs to be removed and placed
                 * in the list appropriate to its new priority. */
                if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 4003ffc:	e0bffc17 	ldw	r2,-16(fp)
 4004000:	14000517 	ldw	r16,20(r2)
 4004004:	01400504 	movi	r5,20
 4004008:	e13ffa17 	ldw	r4,-24(fp)
 400400c:	40078580 	call	4007858 <__mulsi3>
 4004010:	1007883a 	mov	r3,r2
 4004014:	00812074 	movhi	r2,1153
 4004018:	10807604 	addi	r2,r2,472
 400401c:	1885883a 	add	r2,r3,r2
 4004020:	8080411e 	bne	r16,r2,4004128 <vTaskPrioritySet+0x238>
                {
                    /* The task is currently in its ready list - remove before
                     * adding it to its new ready list.  As we are in a critical
                     * section we can do this even if the scheduler is suspended. */
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 4004024:	e0bffc17 	ldw	r2,-16(fp)
 4004028:	10800104 	addi	r2,r2,4
 400402c:	1009883a 	mov	r4,r2
 4004030:	4000c980 	call	4000c98 <uxListRemove>
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    prvAddTaskToReadyList( pxTCB );
 4004034:	e0bffc17 	ldw	r2,-16(fp)
 4004038:	10800b17 	ldw	r2,44(r2)
 400403c:	d0e6b317 	ldw	r3,-25908(gp)
 4004040:	1880032e 	bgeu	r3,r2,4004050 <vTaskPrioritySet+0x160>
 4004044:	e0bffc17 	ldw	r2,-16(fp)
 4004048:	10800b17 	ldw	r2,44(r2)
 400404c:	d0a6b315 	stw	r2,-25908(gp)
 4004050:	e0bffc17 	ldw	r2,-16(fp)
 4004054:	10800b17 	ldw	r2,44(r2)
 4004058:	01400504 	movi	r5,20
 400405c:	1009883a 	mov	r4,r2
 4004060:	40078580 	call	4007858 <__mulsi3>
 4004064:	1007883a 	mov	r3,r2
 4004068:	00812074 	movhi	r2,1153
 400406c:	1885883a 	add	r2,r3,r2
 4004070:	10807717 	ldw	r2,476(r2)
 4004074:	e0bff915 	stw	r2,-28(fp)
 4004078:	e0bffc17 	ldw	r2,-16(fp)
 400407c:	e0fff917 	ldw	r3,-28(fp)
 4004080:	10c00215 	stw	r3,8(r2)
 4004084:	e0bff917 	ldw	r2,-28(fp)
 4004088:	10c00217 	ldw	r3,8(r2)
 400408c:	e0bffc17 	ldw	r2,-16(fp)
 4004090:	10c00315 	stw	r3,12(r2)
 4004094:	e0bff917 	ldw	r2,-28(fp)
 4004098:	10800217 	ldw	r2,8(r2)
 400409c:	e0fffc17 	ldw	r3,-16(fp)
 40040a0:	18c00104 	addi	r3,r3,4
 40040a4:	10c00115 	stw	r3,4(r2)
 40040a8:	e0bffc17 	ldw	r2,-16(fp)
 40040ac:	10c00104 	addi	r3,r2,4
 40040b0:	e0bff917 	ldw	r2,-28(fp)
 40040b4:	10c00215 	stw	r3,8(r2)
 40040b8:	e0bffc17 	ldw	r2,-16(fp)
 40040bc:	10800b17 	ldw	r2,44(r2)
 40040c0:	01400504 	movi	r5,20
 40040c4:	1009883a 	mov	r4,r2
 40040c8:	40078580 	call	4007858 <__mulsi3>
 40040cc:	1007883a 	mov	r3,r2
 40040d0:	00812074 	movhi	r2,1153
 40040d4:	10807604 	addi	r2,r2,472
 40040d8:	1887883a 	add	r3,r3,r2
 40040dc:	e0bffc17 	ldw	r2,-16(fp)
 40040e0:	10c00515 	stw	r3,20(r2)
 40040e4:	e0bffc17 	ldw	r2,-16(fp)
 40040e8:	14400b17 	ldw	r17,44(r2)
 40040ec:	01400504 	movi	r5,20
 40040f0:	8809883a 	mov	r4,r17
 40040f4:	40078580 	call	4007858 <__mulsi3>
 40040f8:	1007883a 	mov	r3,r2
 40040fc:	00812074 	movhi	r2,1153
 4004100:	1885883a 	add	r2,r3,r2
 4004104:	10807617 	ldw	r2,472(r2)
 4004108:	14000044 	addi	r16,r2,1
 400410c:	01400504 	movi	r5,20
 4004110:	8809883a 	mov	r4,r17
 4004114:	40078580 	call	4007858 <__mulsi3>
 4004118:	1007883a 	mov	r3,r2
 400411c:	00812074 	movhi	r2,1153
 4004120:	1885883a 	add	r2,r3,r2
 4004124:	14007615 	stw	r16,472(r2)
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                if( xYieldRequired != pdFALSE )
 4004128:	e0bffd17 	ldw	r2,-12(fp)
 400412c:	10000126 	beq	r2,zero,4004134 <vTaskPrioritySet+0x244>
                {
                    taskYIELD_IF_USING_PREEMPTION();
 4004130:	003b683a 	trap	0
                /* Remove compiler warning about unused variables when the port
                 * optimised task selection is not being used. */
                ( void ) uxPriorityUsedOnEntry;
            }
        }
        taskEXIT_CRITICAL();
 4004134:	4005fd00 	call	4005fd0 <vTaskExitCritical>
    }
 4004138:	0001883a 	nop
 400413c:	e6fffe04 	addi	sp,fp,-8
 4004140:	dfc00317 	ldw	ra,12(sp)
 4004144:	df000217 	ldw	fp,8(sp)
 4004148:	dc400117 	ldw	r17,4(sp)
 400414c:	dc000017 	ldw	r16,0(sp)
 4004150:	dec00404 	addi	sp,sp,16
 4004154:	f800283a 	ret

04004158 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

    void vTaskSuspend( TaskHandle_t xTaskToSuspend )
    {
 4004158:	defffb04 	addi	sp,sp,-20
 400415c:	dfc00415 	stw	ra,16(sp)
 4004160:	df000315 	stw	fp,12(sp)
 4004164:	df000304 	addi	fp,sp,12
 4004168:	e13ffd15 	stw	r4,-12(fp)
        TCB_t * pxTCB;

        taskENTER_CRITICAL();
 400416c:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
        {
            /* If null is passed in here then it is the running task that is
             * being suspended. */
            pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
 4004170:	e0bffd17 	ldw	r2,-12(fp)
 4004174:	1000021e 	bne	r2,zero,4004180 <vTaskSuspend+0x28>
 4004178:	d0a6ad17 	ldw	r2,-25932(gp)
 400417c:	00000106 	br	4004184 <vTaskSuspend+0x2c>
 4004180:	e0bffd17 	ldw	r2,-12(fp)
 4004184:	e0bffe15 	stw	r2,-8(fp)

            traceTASK_SUSPEND( pxTCB );

            /* Remove task from the ready/delayed list and place in the
             * suspended list. */
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 4004188:	e0bffe17 	ldw	r2,-8(fp)
 400418c:	10800104 	addi	r2,r2,4
 4004190:	1009883a 	mov	r4,r2
 4004194:	4000c980 	call	4000c98 <uxListRemove>
            {
                mtCOVERAGE_TEST_MARKER();
            }

            /* Is the task waiting on an event also? */
            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 4004198:	e0bffe17 	ldw	r2,-8(fp)
 400419c:	10800a17 	ldw	r2,40(r2)
 40041a0:	10000426 	beq	r2,zero,40041b4 <vTaskSuspend+0x5c>
            {
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 40041a4:	e0bffe17 	ldw	r2,-8(fp)
 40041a8:	10800604 	addi	r2,r2,24
 40041ac:	1009883a 	mov	r4,r2
 40041b0:	4000c980 	call	4000c98 <uxListRemove>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
 40041b4:	e0bffe17 	ldw	r2,-8(fp)
 40041b8:	10800104 	addi	r2,r2,4
 40041bc:	100b883a 	mov	r5,r2
 40041c0:	01012074 	movhi	r4,1153
 40041c4:	2100a304 	addi	r4,r4,652
 40041c8:	4000b340 	call	4000b34 <vListInsertEnd>

            #if ( configUSE_TASK_NOTIFICATIONS == 1 )
            {
                BaseType_t x;

                for( x = 0; x < configTASK_NOTIFICATION_ARRAY_ENTRIES; x++ )
 40041cc:	e03fff15 	stw	zero,-4(fp)
 40041d0:	00000e06 	br	400420c <vTaskSuspend+0xb4>
                {
                    if( pxTCB->ucNotifyState[ x ] == taskWAITING_NOTIFICATION )
 40041d4:	e0fffe17 	ldw	r3,-8(fp)
 40041d8:	e0bfff17 	ldw	r2,-4(fp)
 40041dc:	1885883a 	add	r2,r3,r2
 40041e0:	10801303 	ldbu	r2,76(r2)
 40041e4:	10803fcc 	andi	r2,r2,255
 40041e8:	10800058 	cmpnei	r2,r2,1
 40041ec:	1000041e 	bne	r2,zero,4004200 <vTaskSuspend+0xa8>
                    {
                        /* The task was blocked to wait for a notification, but is
                         * now suspended, so no notification was received. */
                        pxTCB->ucNotifyState[ x ] = taskNOT_WAITING_NOTIFICATION;
 40041f0:	e0fffe17 	ldw	r3,-8(fp)
 40041f4:	e0bfff17 	ldw	r2,-4(fp)
 40041f8:	1885883a 	add	r2,r3,r2
 40041fc:	10001305 	stb	zero,76(r2)
                for( x = 0; x < configTASK_NOTIFICATION_ARRAY_ENTRIES; x++ )
 4004200:	e0bfff17 	ldw	r2,-4(fp)
 4004204:	10800044 	addi	r2,r2,1
 4004208:	e0bfff15 	stw	r2,-4(fp)
 400420c:	e0bfff17 	ldw	r2,-4(fp)
 4004210:	00bff00e 	bge	zero,r2,40041d4 <vTaskSuspend+0x7c>
                    }
                }
            }
            #endif /* if ( configUSE_TASK_NOTIFICATIONS == 1 ) */
        }
        taskEXIT_CRITICAL();
 4004214:	4005fd00 	call	4005fd0 <vTaskExitCritical>

        if( xSchedulerRunning != pdFALSE )
 4004218:	d0a6b417 	ldw	r2,-25904(gp)
 400421c:	10000326 	beq	r2,zero,400422c <vTaskSuspend+0xd4>
        {
            /* Reset the next expected unblock time in case it referred to the
             * task that is now in the Suspended state. */
            taskENTER_CRITICAL();
 4004220:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
            {
                prvResetNextTaskUnblockTime();
 4004224:	40059480 	call	4005948 <prvResetNextTaskUnblockTime>
            }
            taskEXIT_CRITICAL();
 4004228:	4005fd00 	call	4005fd0 <vTaskExitCritical>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( pxTCB == pxCurrentTCB )
 400422c:	d0a6ad17 	ldw	r2,-25932(gp)
 4004230:	e0fffe17 	ldw	r3,-8(fp)
 4004234:	18800b1e 	bne	r3,r2,4004264 <vTaskSuspend+0x10c>
        {
            if( xSchedulerRunning != pdFALSE )
 4004238:	d0a6b417 	ldw	r2,-25904(gp)
 400423c:	10000226 	beq	r2,zero,4004248 <vTaskSuspend+0xf0>
            {
                /* The current task has just been suspended. */
                configASSERT( uxSchedulerSuspended == 0 );
                portYIELD_WITHIN_API();
 4004240:	003b683a 	trap	0
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
 4004244:	00000706 	br	4004264 <vTaskSuspend+0x10c>
                if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
 4004248:	00812074 	movhi	r2,1153
 400424c:	10c0a317 	ldw	r3,652(r2)
 4004250:	d0a6b117 	ldw	r2,-25916(gp)
 4004254:	1880021e 	bne	r3,r2,4004260 <vTaskSuspend+0x108>
                    pxCurrentTCB = NULL;
 4004258:	d026ad15 	stw	zero,-25932(gp)
    }
 400425c:	00000106 	br	4004264 <vTaskSuspend+0x10c>
                    vTaskSwitchContext();
 4004260:	4004e300 	call	4004e30 <vTaskSwitchContext>
    }
 4004264:	0001883a 	nop
 4004268:	e037883a 	mov	sp,fp
 400426c:	dfc00117 	ldw	ra,4(sp)
 4004270:	df000017 	ldw	fp,0(sp)
 4004274:	dec00204 	addi	sp,sp,8
 4004278:	f800283a 	ret

0400427c <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

    static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
    {
 400427c:	defffc04 	addi	sp,sp,-16
 4004280:	df000315 	stw	fp,12(sp)
 4004284:	df000304 	addi	fp,sp,12
 4004288:	e13ffd15 	stw	r4,-12(fp)
        BaseType_t xReturn = pdFALSE;
 400428c:	e03fff15 	stw	zero,-4(fp)
        const TCB_t * const pxTCB = xTask;
 4004290:	e0bffd17 	ldw	r2,-12(fp)
 4004294:	e0bffe15 	stw	r2,-8(fp)

        /* It does not make sense to check if the calling task is suspended. */
        configASSERT( xTask );

        /* Is the task being resumed actually in the suspended list? */
        if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
 4004298:	e0bffe17 	ldw	r2,-8(fp)
 400429c:	10c00517 	ldw	r3,20(r2)
 40042a0:	00812074 	movhi	r2,1153
 40042a4:	1080a304 	addi	r2,r2,652
 40042a8:	18800a1e 	bne	r3,r2,40042d4 <prvTaskIsTaskSuspended+0x58>
        {
            /* Has the task already been resumed from within an ISR? */
            if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
 40042ac:	e0bffe17 	ldw	r2,-8(fp)
 40042b0:	10c00a17 	ldw	r3,40(r2)
 40042b4:	00812074 	movhi	r2,1153
 40042b8:	10809904 	addi	r2,r2,612
 40042bc:	18800526 	beq	r3,r2,40042d4 <prvTaskIsTaskSuspended+0x58>
            {
                /* Is it in the suspended list because it is in the Suspended
                 * state, or because is is blocked with no timeout? */
                if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
 40042c0:	e0bffe17 	ldw	r2,-8(fp)
 40042c4:	10800a17 	ldw	r2,40(r2)
 40042c8:	1000021e 	bne	r2,zero,40042d4 <prvTaskIsTaskSuspended+0x58>
                {
                    xReturn = pdTRUE;
 40042cc:	00800044 	movi	r2,1
 40042d0:	e0bfff15 	stw	r2,-4(fp)
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
 40042d4:	e0bfff17 	ldw	r2,-4(fp)
    } /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
 40042d8:	e037883a 	mov	sp,fp
 40042dc:	df000017 	ldw	fp,0(sp)
 40042e0:	dec00104 	addi	sp,sp,4
 40042e4:	f800283a 	ret

040042e8 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

    void vTaskResume( TaskHandle_t xTaskToResume )
    {
 40042e8:	defff904 	addi	sp,sp,-28
 40042ec:	dfc00615 	stw	ra,24(sp)
 40042f0:	df000515 	stw	fp,20(sp)
 40042f4:	dc400415 	stw	r17,16(sp)
 40042f8:	dc000315 	stw	r16,12(sp)
 40042fc:	df000504 	addi	fp,sp,20
 4004300:	e13ffb15 	stw	r4,-20(fp)
        TCB_t * const pxTCB = xTaskToResume;
 4004304:	e0bffb17 	ldw	r2,-20(fp)
 4004308:	e0bffd15 	stw	r2,-12(fp)
        /* It does not make sense to resume the calling task. */
        configASSERT( xTaskToResume );

        /* The parameter cannot be NULL as it is impossible to resume the
         * currently executing task. */
        if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
 400430c:	d0a6ad17 	ldw	r2,-25932(gp)
 4004310:	e0fffd17 	ldw	r3,-12(fp)
 4004314:	18804e26 	beq	r3,r2,4004450 <vTaskResume+0x168>
 4004318:	e0bffd17 	ldw	r2,-12(fp)
 400431c:	10004c26 	beq	r2,zero,4004450 <vTaskResume+0x168>
        {
            taskENTER_CRITICAL();
 4004320:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
            {
                if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
 4004324:	e13ffd17 	ldw	r4,-12(fp)
 4004328:	400427c0 	call	400427c <prvTaskIsTaskSuspended>
 400432c:	10004726 	beq	r2,zero,400444c <vTaskResume+0x164>
                {
                    traceTASK_RESUME( pxTCB );

                    /* The ready list can be accessed even if the scheduler is
                     * suspended because this is inside a critical section. */
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 4004330:	e0bffd17 	ldw	r2,-12(fp)
 4004334:	10800104 	addi	r2,r2,4
 4004338:	1009883a 	mov	r4,r2
 400433c:	4000c980 	call	4000c98 <uxListRemove>
                    prvAddTaskToReadyList( pxTCB );
 4004340:	e0bffd17 	ldw	r2,-12(fp)
 4004344:	10800b17 	ldw	r2,44(r2)
 4004348:	d0e6b317 	ldw	r3,-25908(gp)
 400434c:	1880032e 	bgeu	r3,r2,400435c <vTaskResume+0x74>
 4004350:	e0bffd17 	ldw	r2,-12(fp)
 4004354:	10800b17 	ldw	r2,44(r2)
 4004358:	d0a6b315 	stw	r2,-25908(gp)
 400435c:	e0bffd17 	ldw	r2,-12(fp)
 4004360:	10800b17 	ldw	r2,44(r2)
 4004364:	01400504 	movi	r5,20
 4004368:	1009883a 	mov	r4,r2
 400436c:	40078580 	call	4007858 <__mulsi3>
 4004370:	1007883a 	mov	r3,r2
 4004374:	00812074 	movhi	r2,1153
 4004378:	1885883a 	add	r2,r3,r2
 400437c:	10807717 	ldw	r2,476(r2)
 4004380:	e0bffc15 	stw	r2,-16(fp)
 4004384:	e0bffd17 	ldw	r2,-12(fp)
 4004388:	e0fffc17 	ldw	r3,-16(fp)
 400438c:	10c00215 	stw	r3,8(r2)
 4004390:	e0bffc17 	ldw	r2,-16(fp)
 4004394:	10c00217 	ldw	r3,8(r2)
 4004398:	e0bffd17 	ldw	r2,-12(fp)
 400439c:	10c00315 	stw	r3,12(r2)
 40043a0:	e0bffc17 	ldw	r2,-16(fp)
 40043a4:	10800217 	ldw	r2,8(r2)
 40043a8:	e0fffd17 	ldw	r3,-12(fp)
 40043ac:	18c00104 	addi	r3,r3,4
 40043b0:	10c00115 	stw	r3,4(r2)
 40043b4:	e0bffd17 	ldw	r2,-12(fp)
 40043b8:	10c00104 	addi	r3,r2,4
 40043bc:	e0bffc17 	ldw	r2,-16(fp)
 40043c0:	10c00215 	stw	r3,8(r2)
 40043c4:	e0bffd17 	ldw	r2,-12(fp)
 40043c8:	10800b17 	ldw	r2,44(r2)
 40043cc:	01400504 	movi	r5,20
 40043d0:	1009883a 	mov	r4,r2
 40043d4:	40078580 	call	4007858 <__mulsi3>
 40043d8:	1007883a 	mov	r3,r2
 40043dc:	00812074 	movhi	r2,1153
 40043e0:	10807604 	addi	r2,r2,472
 40043e4:	1887883a 	add	r3,r3,r2
 40043e8:	e0bffd17 	ldw	r2,-12(fp)
 40043ec:	10c00515 	stw	r3,20(r2)
 40043f0:	e0bffd17 	ldw	r2,-12(fp)
 40043f4:	14400b17 	ldw	r17,44(r2)
 40043f8:	01400504 	movi	r5,20
 40043fc:	8809883a 	mov	r4,r17
 4004400:	40078580 	call	4007858 <__mulsi3>
 4004404:	1007883a 	mov	r3,r2
 4004408:	00812074 	movhi	r2,1153
 400440c:	1885883a 	add	r2,r3,r2
 4004410:	10807617 	ldw	r2,472(r2)
 4004414:	14000044 	addi	r16,r2,1
 4004418:	01400504 	movi	r5,20
 400441c:	8809883a 	mov	r4,r17
 4004420:	40078580 	call	4007858 <__mulsi3>
 4004424:	1007883a 	mov	r3,r2
 4004428:	00812074 	movhi	r2,1153
 400442c:	1885883a 	add	r2,r3,r2
 4004430:	14007615 	stw	r16,472(r2)

                    /* A higher priority task may have just been resumed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 4004434:	e0bffd17 	ldw	r2,-12(fp)
 4004438:	10c00b17 	ldw	r3,44(r2)
 400443c:	d0a6ad17 	ldw	r2,-25932(gp)
 4004440:	10800b17 	ldw	r2,44(r2)
 4004444:	18800136 	bltu	r3,r2,400444c <vTaskResume+0x164>
                    {
                        /* This yield may not cause the task just resumed to run,
                         * but will leave the lists in the correct state for the
                         * next yield. */
                        taskYIELD_IF_USING_PREEMPTION();
 4004448:	003b683a 	trap	0
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            taskEXIT_CRITICAL();
 400444c:	4005fd00 	call	4005fd0 <vTaskExitCritical>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
 4004450:	0001883a 	nop
 4004454:	e6fffe04 	addi	sp,fp,-8
 4004458:	dfc00317 	ldw	ra,12(sp)
 400445c:	df000217 	ldw	fp,8(sp)
 4004460:	dc400117 	ldw	r17,4(sp)
 4004464:	dc000017 	ldw	r16,0(sp)
 4004468:	dec00404 	addi	sp,sp,16
 400446c:	f800283a 	ret

04004470 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

    BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
    {
 4004470:	defff704 	addi	sp,sp,-36
 4004474:	dfc00815 	stw	ra,32(sp)
 4004478:	df000715 	stw	fp,28(sp)
 400447c:	dc400615 	stw	r17,24(sp)
 4004480:	dc000515 	stw	r16,20(sp)
 4004484:	df000704 	addi	fp,sp,28
 4004488:	e13ff915 	stw	r4,-28(fp)
        BaseType_t xYieldRequired = pdFALSE;
 400448c:	e03ffd15 	stw	zero,-12(fp)
        TCB_t * const pxTCB = xTaskToResume;
 4004490:	e0bff917 	ldw	r2,-28(fp)
 4004494:	e0bffc15 	stw	r2,-16(fp)
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 4004498:	e03ffb15 	stw	zero,-20(fp)
        {
            if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
 400449c:	e13ffc17 	ldw	r4,-16(fp)
 40044a0:	400427c0 	call	400427c <prvTaskIsTaskSuspended>
 40044a4:	10005326 	beq	r2,zero,40045f4 <xTaskResumeFromISR+0x184>
            {
                traceTASK_RESUME_FROM_ISR( pxTCB );

                /* Check the ready lists can be accessed. */
                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 40044a8:	d0a6bb17 	ldw	r2,-25876(gp)
 40044ac:	10004b1e 	bne	r2,zero,40045dc <xTaskResumeFromISR+0x16c>
                {
                    /* Ready lists can be accessed so move the task from the
                     * suspended list to the ready list directly. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 40044b0:	e0bffc17 	ldw	r2,-16(fp)
 40044b4:	10c00b17 	ldw	r3,44(r2)
 40044b8:	d0a6ad17 	ldw	r2,-25932(gp)
 40044bc:	10800b17 	ldw	r2,44(r2)
 40044c0:	18800436 	bltu	r3,r2,40044d4 <xTaskResumeFromISR+0x64>
                    {
                        xYieldRequired = pdTRUE;
 40044c4:	00800044 	movi	r2,1
 40044c8:	e0bffd15 	stw	r2,-12(fp)

                        /* Mark that a yield is pending in case the user is not
                         * using the return value to initiate a context switch
                         * from the ISR using portYIELD_FROM_ISR. */
                        xYieldPending = pdTRUE;
 40044cc:	00800044 	movi	r2,1
 40044d0:	d0a6b615 	stw	r2,-25896(gp)
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 40044d4:	e0bffc17 	ldw	r2,-16(fp)
 40044d8:	10800104 	addi	r2,r2,4
 40044dc:	1009883a 	mov	r4,r2
 40044e0:	4000c980 	call	4000c98 <uxListRemove>
                    prvAddTaskToReadyList( pxTCB );
 40044e4:	e0bffc17 	ldw	r2,-16(fp)
 40044e8:	10800b17 	ldw	r2,44(r2)
 40044ec:	d0e6b317 	ldw	r3,-25908(gp)
 40044f0:	1880032e 	bgeu	r3,r2,4004500 <xTaskResumeFromISR+0x90>
 40044f4:	e0bffc17 	ldw	r2,-16(fp)
 40044f8:	10800b17 	ldw	r2,44(r2)
 40044fc:	d0a6b315 	stw	r2,-25908(gp)
 4004500:	e0bffc17 	ldw	r2,-16(fp)
 4004504:	10800b17 	ldw	r2,44(r2)
 4004508:	01400504 	movi	r5,20
 400450c:	1009883a 	mov	r4,r2
 4004510:	40078580 	call	4007858 <__mulsi3>
 4004514:	1007883a 	mov	r3,r2
 4004518:	00812074 	movhi	r2,1153
 400451c:	1885883a 	add	r2,r3,r2
 4004520:	10807717 	ldw	r2,476(r2)
 4004524:	e0bffa15 	stw	r2,-24(fp)
 4004528:	e0bffc17 	ldw	r2,-16(fp)
 400452c:	e0fffa17 	ldw	r3,-24(fp)
 4004530:	10c00215 	stw	r3,8(r2)
 4004534:	e0bffa17 	ldw	r2,-24(fp)
 4004538:	10c00217 	ldw	r3,8(r2)
 400453c:	e0bffc17 	ldw	r2,-16(fp)
 4004540:	10c00315 	stw	r3,12(r2)
 4004544:	e0bffa17 	ldw	r2,-24(fp)
 4004548:	10800217 	ldw	r2,8(r2)
 400454c:	e0fffc17 	ldw	r3,-16(fp)
 4004550:	18c00104 	addi	r3,r3,4
 4004554:	10c00115 	stw	r3,4(r2)
 4004558:	e0bffc17 	ldw	r2,-16(fp)
 400455c:	10c00104 	addi	r3,r2,4
 4004560:	e0bffa17 	ldw	r2,-24(fp)
 4004564:	10c00215 	stw	r3,8(r2)
 4004568:	e0bffc17 	ldw	r2,-16(fp)
 400456c:	10800b17 	ldw	r2,44(r2)
 4004570:	01400504 	movi	r5,20
 4004574:	1009883a 	mov	r4,r2
 4004578:	40078580 	call	4007858 <__mulsi3>
 400457c:	1007883a 	mov	r3,r2
 4004580:	00812074 	movhi	r2,1153
 4004584:	10807604 	addi	r2,r2,472
 4004588:	1887883a 	add	r3,r3,r2
 400458c:	e0bffc17 	ldw	r2,-16(fp)
 4004590:	10c00515 	stw	r3,20(r2)
 4004594:	e0bffc17 	ldw	r2,-16(fp)
 4004598:	14400b17 	ldw	r17,44(r2)
 400459c:	01400504 	movi	r5,20
 40045a0:	8809883a 	mov	r4,r17
 40045a4:	40078580 	call	4007858 <__mulsi3>
 40045a8:	1007883a 	mov	r3,r2
 40045ac:	00812074 	movhi	r2,1153
 40045b0:	1885883a 	add	r2,r3,r2
 40045b4:	10807617 	ldw	r2,472(r2)
 40045b8:	14000044 	addi	r16,r2,1
 40045bc:	01400504 	movi	r5,20
 40045c0:	8809883a 	mov	r4,r17
 40045c4:	40078580 	call	4007858 <__mulsi3>
 40045c8:	1007883a 	mov	r3,r2
 40045cc:	00812074 	movhi	r2,1153
 40045d0:	1885883a 	add	r2,r3,r2
 40045d4:	14007615 	stw	r16,472(r2)
 40045d8:	00000606 	br	40045f4 <xTaskResumeFromISR+0x184>
                else
                {
                    /* The delayed or ready lists cannot be accessed so the task
                     * is held in the pending ready list until the scheduler is
                     * unsuspended. */
                    vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 40045dc:	e0bffc17 	ldw	r2,-16(fp)
 40045e0:	10800604 	addi	r2,r2,24
 40045e4:	100b883a 	mov	r5,r2
 40045e8:	01012074 	movhi	r4,1153
 40045ec:	21009904 	addi	r4,r4,612
 40045f0:	4000b340 	call	4000b34 <vListInsertEnd>
                mtCOVERAGE_TEST_MARKER();
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

        return xYieldRequired;
 40045f4:	e0bffd17 	ldw	r2,-12(fp)
    }
 40045f8:	e6fffe04 	addi	sp,fp,-8
 40045fc:	dfc00317 	ldw	ra,12(sp)
 4004600:	df000217 	ldw	fp,8(sp)
 4004604:	dc400117 	ldw	r17,4(sp)
 4004608:	dc000017 	ldw	r16,0(sp)
 400460c:	dec00404 	addi	sp,sp,16
 4004610:	f800283a 	ret

04004614 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
 4004614:	defffa04 	addi	sp,sp,-24
 4004618:	dfc00515 	stw	ra,20(sp)
 400461c:	df000415 	stw	fp,16(sp)
 4004620:	df000404 	addi	fp,sp,16
        }
    }
    #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
    {
        /* The Idle task is being created using dynamically allocated RAM. */
        xReturn = xTaskCreate( prvIdleTask,
 4004624:	d0a6ba04 	addi	r2,gp,-25880
 4004628:	d8800115 	stw	r2,4(sp)
 400462c:	d8000015 	stw	zero,0(sp)
 4004630:	000f883a 	mov	r7,zero
 4004634:	01810004 	movi	r6,1024
 4004638:	01410074 	movhi	r5,1025
 400463c:	2972fa04 	addi	r5,r5,-13336
 4004640:	01010034 	movhi	r4,1024
 4004644:	2115b904 	addi	r4,r4,22244
 4004648:	40037b40 	call	40037b4 <xTaskCreate>
 400464c:	e0bfff15 	stw	r2,-4(fp)
            mtCOVERAGE_TEST_MARKER();
        }
    }
    #endif /* configUSE_TIMERS */

    if( xReturn == pdPASS )
 4004650:	e0bfff17 	ldw	r2,-4(fp)
 4004654:	10800058 	cmpnei	r2,r2,1
 4004658:	10000c1e 	bne	r2,zero,400468c <vTaskStartScheduler+0x78>
  NIOS2_READ_STATUS (context);
 400465c:	0005303a 	rdctl	r2,status
 4004660:	e0bffe15 	stw	r2,-8(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 4004664:	e0fffe17 	ldw	r3,-8(fp)
 4004668:	00bfff84 	movi	r2,-2
 400466c:	1884703a 	and	r2,r3,r2
 4004670:	1001703a 	wrctl	status,r2
             * block specific to the task that will run first. */
            configSET_TLS_BLOCK( pxCurrentTCB->xTLSBlock );
        }
        #endif

        xNextTaskUnblockTime = portMAX_DELAY;
 4004674:	00bfffc4 	movi	r2,-1
 4004678:	d0a6b915 	stw	r2,-25884(gp)
        xSchedulerRunning = pdTRUE;
 400467c:	00800044 	movi	r2,1
 4004680:	d0a6b415 	stw	r2,-25904(gp)
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
 4004684:	d026b215 	stw	zero,-25912(gp)

        traceTASK_SWITCHED_IN();

        /* Setting up the timer tick is hardware specific and thus in the
         * portable interface. */
        xPortStartScheduler();
 4004688:	4000e3c0 	call	4000e3c <xPortStartScheduler>
     * meaning xIdleTaskHandle is not used anywhere else. */
    ( void ) xIdleTaskHandle;

    /* OpenOCD makes use of uxTopUsedPriority for thread debugging. Prevent uxTopUsedPriority
     * from getting optimized out as it is no longer used by the kernel. */
    ( void ) uxTopUsedPriority;
 400468c:	d0a00017 	ldw	r2,-32768(gp)
}
 4004690:	0001883a 	nop
 4004694:	e037883a 	mov	sp,fp
 4004698:	dfc00117 	ldw	ra,4(sp)
 400469c:	df000017 	ldw	fp,0(sp)
 40046a0:	dec00204 	addi	sp,sp,8
 40046a4:	f800283a 	ret

040046a8 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
 40046a8:	defffd04 	addi	sp,sp,-12
 40046ac:	dfc00215 	stw	ra,8(sp)
 40046b0:	df000115 	stw	fp,4(sp)
 40046b4:	df000104 	addi	fp,sp,4
  NIOS2_READ_STATUS (context);
 40046b8:	0005303a 	rdctl	r2,status
 40046bc:	e0bfff15 	stw	r2,-4(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 40046c0:	e0ffff17 	ldw	r3,-4(fp)
 40046c4:	00bfff84 	movi	r2,-2
 40046c8:	1884703a 	and	r2,r3,r2
 40046cc:	1001703a 	wrctl	status,r2
    /* Stop the scheduler interrupts and call the portable scheduler end
     * routine so the original ISRs can be restored if necessary.  The port
     * layer must ensure interrupts enable  bit is left in the correct state. */
    portDISABLE_INTERRUPTS();
    xSchedulerRunning = pdFALSE;
 40046d0:	d026b415 	stw	zero,-25904(gp)
    vPortEndScheduler();
 40046d4:	4000e740 	call	4000e74 <vPortEndScheduler>
}
 40046d8:	0001883a 	nop
 40046dc:	e037883a 	mov	sp,fp
 40046e0:	dfc00117 	ldw	ra,4(sp)
 40046e4:	df000017 	ldw	fp,0(sp)
 40046e8:	dec00204 	addi	sp,sp,8
 40046ec:	f800283a 	ret

040046f0 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
 40046f0:	deffff04 	addi	sp,sp,-4
 40046f4:	df000015 	stw	fp,0(sp)
 40046f8:	d839883a 	mov	fp,sp
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
 40046fc:	d0a6bb17 	ldw	r2,-25876(gp)
 4004700:	10800044 	addi	r2,r2,1
 4004704:	d0a6bb15 	stw	r2,-25876(gp)

    /* Enforces ordering for ports and optimised compilers that may otherwise place
     * the above increment elsewhere. */
    portMEMORY_BARRIER();
}
 4004708:	0001883a 	nop
 400470c:	e037883a 	mov	sp,fp
 4004710:	df000017 	ldw	fp,0(sp)
 4004714:	dec00104 	addi	sp,sp,4
 4004718:	f800283a 	ret

0400471c <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
 400471c:	defff604 	addi	sp,sp,-40
 4004720:	dfc00915 	stw	ra,36(sp)
 4004724:	df000815 	stw	fp,32(sp)
 4004728:	dc400715 	stw	r17,28(sp)
 400472c:	dc000615 	stw	r16,24(sp)
 4004730:	df000804 	addi	fp,sp,32
    TCB_t * pxTCB = NULL;
 4004734:	e03ffd15 	stw	zero,-12(fp)
    BaseType_t xAlreadyYielded = pdFALSE;
 4004738:	e03ffc15 	stw	zero,-16(fp)
    /* It is possible that an ISR caused a task to be removed from an event
     * list while the scheduler was suspended.  If this was the case then the
     * removed task will have been added to the xPendingReadyList.  Once the
     * scheduler has been resumed it is safe to move all the pending ready
     * tasks from this list into their appropriate ready list. */
    taskENTER_CRITICAL();
 400473c:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
    {
        --uxSchedulerSuspended;
 4004740:	d0a6bb17 	ldw	r2,-25876(gp)
 4004744:	10bfffc4 	addi	r2,r2,-1
 4004748:	d0a6bb15 	stw	r2,-25876(gp)

        if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 400474c:	d0a6bb17 	ldw	r2,-25876(gp)
 4004750:	10009e1e 	bne	r2,zero,40049cc <xTaskResumeAll+0x2b0>
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 4004754:	d0a6b117 	ldw	r2,-25916(gp)
 4004758:	10009c26 	beq	r2,zero,40049cc <xTaskResumeAll+0x2b0>
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 400475c:	00008206 	br	4004968 <xTaskResumeAll+0x24c>
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 4004760:	00812074 	movhi	r2,1153
 4004764:	10809c17 	ldw	r2,624(r2)
 4004768:	10800317 	ldw	r2,12(r2)
 400476c:	e0bffd15 	stw	r2,-12(fp)
                    listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
 4004770:	e0bffd17 	ldw	r2,-12(fp)
 4004774:	10800a17 	ldw	r2,40(r2)
 4004778:	e0bffa15 	stw	r2,-24(fp)
 400477c:	e0bffd17 	ldw	r2,-12(fp)
 4004780:	10800717 	ldw	r2,28(r2)
 4004784:	e0fffd17 	ldw	r3,-12(fp)
 4004788:	18c00817 	ldw	r3,32(r3)
 400478c:	10c00215 	stw	r3,8(r2)
 4004790:	e0bffd17 	ldw	r2,-12(fp)
 4004794:	10800817 	ldw	r2,32(r2)
 4004798:	e0fffd17 	ldw	r3,-12(fp)
 400479c:	18c00717 	ldw	r3,28(r3)
 40047a0:	10c00115 	stw	r3,4(r2)
 40047a4:	e0bffa17 	ldw	r2,-24(fp)
 40047a8:	10c00117 	ldw	r3,4(r2)
 40047ac:	e0bffd17 	ldw	r2,-12(fp)
 40047b0:	10800604 	addi	r2,r2,24
 40047b4:	1880041e 	bne	r3,r2,40047c8 <xTaskResumeAll+0xac>
 40047b8:	e0bffd17 	ldw	r2,-12(fp)
 40047bc:	10c00817 	ldw	r3,32(r2)
 40047c0:	e0bffa17 	ldw	r2,-24(fp)
 40047c4:	10c00115 	stw	r3,4(r2)
 40047c8:	e0bffd17 	ldw	r2,-12(fp)
 40047cc:	10000a15 	stw	zero,40(r2)
 40047d0:	e0bffa17 	ldw	r2,-24(fp)
 40047d4:	10800017 	ldw	r2,0(r2)
 40047d8:	10ffffc4 	addi	r3,r2,-1
 40047dc:	e0bffa17 	ldw	r2,-24(fp)
 40047e0:	10c00015 	stw	r3,0(r2)
                    portMEMORY_BARRIER();
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 40047e4:	e0bffd17 	ldw	r2,-12(fp)
 40047e8:	10800517 	ldw	r2,20(r2)
 40047ec:	e0bff915 	stw	r2,-28(fp)
 40047f0:	e0bffd17 	ldw	r2,-12(fp)
 40047f4:	10800217 	ldw	r2,8(r2)
 40047f8:	e0fffd17 	ldw	r3,-12(fp)
 40047fc:	18c00317 	ldw	r3,12(r3)
 4004800:	10c00215 	stw	r3,8(r2)
 4004804:	e0bffd17 	ldw	r2,-12(fp)
 4004808:	10800317 	ldw	r2,12(r2)
 400480c:	e0fffd17 	ldw	r3,-12(fp)
 4004810:	18c00217 	ldw	r3,8(r3)
 4004814:	10c00115 	stw	r3,4(r2)
 4004818:	e0bff917 	ldw	r2,-28(fp)
 400481c:	10c00117 	ldw	r3,4(r2)
 4004820:	e0bffd17 	ldw	r2,-12(fp)
 4004824:	10800104 	addi	r2,r2,4
 4004828:	1880041e 	bne	r3,r2,400483c <xTaskResumeAll+0x120>
 400482c:	e0bffd17 	ldw	r2,-12(fp)
 4004830:	10c00317 	ldw	r3,12(r2)
 4004834:	e0bff917 	ldw	r2,-28(fp)
 4004838:	10c00115 	stw	r3,4(r2)
 400483c:	e0bffd17 	ldw	r2,-12(fp)
 4004840:	10000515 	stw	zero,20(r2)
 4004844:	e0bff917 	ldw	r2,-28(fp)
 4004848:	10800017 	ldw	r2,0(r2)
 400484c:	10ffffc4 	addi	r3,r2,-1
 4004850:	e0bff917 	ldw	r2,-28(fp)
 4004854:	10c00015 	stw	r3,0(r2)
                    prvAddTaskToReadyList( pxTCB );
 4004858:	e0bffd17 	ldw	r2,-12(fp)
 400485c:	10800b17 	ldw	r2,44(r2)
 4004860:	d0e6b317 	ldw	r3,-25908(gp)
 4004864:	1880032e 	bgeu	r3,r2,4004874 <xTaskResumeAll+0x158>
 4004868:	e0bffd17 	ldw	r2,-12(fp)
 400486c:	10800b17 	ldw	r2,44(r2)
 4004870:	d0a6b315 	stw	r2,-25908(gp)
 4004874:	e0bffd17 	ldw	r2,-12(fp)
 4004878:	10800b17 	ldw	r2,44(r2)
 400487c:	01400504 	movi	r5,20
 4004880:	1009883a 	mov	r4,r2
 4004884:	40078580 	call	4007858 <__mulsi3>
 4004888:	1007883a 	mov	r3,r2
 400488c:	00812074 	movhi	r2,1153
 4004890:	1885883a 	add	r2,r3,r2
 4004894:	10807717 	ldw	r2,476(r2)
 4004898:	e0bff815 	stw	r2,-32(fp)
 400489c:	e0bffd17 	ldw	r2,-12(fp)
 40048a0:	e0fff817 	ldw	r3,-32(fp)
 40048a4:	10c00215 	stw	r3,8(r2)
 40048a8:	e0bff817 	ldw	r2,-32(fp)
 40048ac:	10c00217 	ldw	r3,8(r2)
 40048b0:	e0bffd17 	ldw	r2,-12(fp)
 40048b4:	10c00315 	stw	r3,12(r2)
 40048b8:	e0bff817 	ldw	r2,-32(fp)
 40048bc:	10800217 	ldw	r2,8(r2)
 40048c0:	e0fffd17 	ldw	r3,-12(fp)
 40048c4:	18c00104 	addi	r3,r3,4
 40048c8:	10c00115 	stw	r3,4(r2)
 40048cc:	e0bffd17 	ldw	r2,-12(fp)
 40048d0:	10c00104 	addi	r3,r2,4
 40048d4:	e0bff817 	ldw	r2,-32(fp)
 40048d8:	10c00215 	stw	r3,8(r2)
 40048dc:	e0bffd17 	ldw	r2,-12(fp)
 40048e0:	10800b17 	ldw	r2,44(r2)
 40048e4:	01400504 	movi	r5,20
 40048e8:	1009883a 	mov	r4,r2
 40048ec:	40078580 	call	4007858 <__mulsi3>
 40048f0:	1007883a 	mov	r3,r2
 40048f4:	00812074 	movhi	r2,1153
 40048f8:	10807604 	addi	r2,r2,472
 40048fc:	1887883a 	add	r3,r3,r2
 4004900:	e0bffd17 	ldw	r2,-12(fp)
 4004904:	10c00515 	stw	r3,20(r2)
 4004908:	e0bffd17 	ldw	r2,-12(fp)
 400490c:	14400b17 	ldw	r17,44(r2)
 4004910:	01400504 	movi	r5,20
 4004914:	8809883a 	mov	r4,r17
 4004918:	40078580 	call	4007858 <__mulsi3>
 400491c:	1007883a 	mov	r3,r2
 4004920:	00812074 	movhi	r2,1153
 4004924:	1885883a 	add	r2,r3,r2
 4004928:	10807617 	ldw	r2,472(r2)
 400492c:	14000044 	addi	r16,r2,1
 4004930:	01400504 	movi	r5,20
 4004934:	8809883a 	mov	r4,r17
 4004938:	40078580 	call	4007858 <__mulsi3>
 400493c:	1007883a 	mov	r3,r2
 4004940:	00812074 	movhi	r2,1153
 4004944:	1885883a 	add	r2,r3,r2
 4004948:	14007615 	stw	r16,472(r2)

                    /* If the moved task has a priority higher than or equal to
                     * the current task then a yield must be performed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 400494c:	e0bffd17 	ldw	r2,-12(fp)
 4004950:	10c00b17 	ldw	r3,44(r2)
 4004954:	d0a6ad17 	ldw	r2,-25932(gp)
 4004958:	10800b17 	ldw	r2,44(r2)
 400495c:	18800236 	bltu	r3,r2,4004968 <xTaskResumeAll+0x24c>
                    {
                        xYieldPending = pdTRUE;
 4004960:	00800044 	movi	r2,1
 4004964:	d0a6b615 	stw	r2,-25896(gp)
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 4004968:	00812074 	movhi	r2,1153
 400496c:	10809917 	ldw	r2,612(r2)
 4004970:	103f7b1e 	bne	r2,zero,4004760 <xTaskResumeAll+0x44>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( pxTCB != NULL )
 4004974:	e0bffd17 	ldw	r2,-12(fp)
 4004978:	10000126 	beq	r2,zero,4004980 <xTaskResumeAll+0x264>
                     * which may have prevented the next unblock time from being
                     * re-calculated, in which case re-calculate it now.  Mainly
                     * important for low power tickless implementations, where
                     * this can prevent an unnecessary exit from low power
                     * state. */
                    prvResetNextTaskUnblockTime();
 400497c:	40059480 	call	4005948 <prvResetNextTaskUnblockTime>
                /* If any ticks occurred while the scheduler was suspended then
                 * they should be processed now.  This ensures the tick count does
                 * not  slip, and that any delayed tasks are resumed at the correct
                 * time. */
                {
                    TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
 4004980:	d0a6b517 	ldw	r2,-25900(gp)
 4004984:	e0bffb15 	stw	r2,-20(fp)

                    if( xPendedCounts > ( TickType_t ) 0U )
 4004988:	e0bffb17 	ldw	r2,-20(fp)
 400498c:	10000a26 	beq	r2,zero,40049b8 <xTaskResumeAll+0x29c>
                    {
                        do
                        {
                            if( xTaskIncrementTick() != pdFALSE )
 4004990:	4004af40 	call	4004af4 <xTaskIncrementTick>
 4004994:	10000226 	beq	r2,zero,40049a0 <xTaskResumeAll+0x284>
                            {
                                xYieldPending = pdTRUE;
 4004998:	00800044 	movi	r2,1
 400499c:	d0a6b615 	stw	r2,-25896(gp)
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }

                            --xPendedCounts;
 40049a0:	e0bffb17 	ldw	r2,-20(fp)
 40049a4:	10bfffc4 	addi	r2,r2,-1
 40049a8:	e0bffb15 	stw	r2,-20(fp)
                        } while( xPendedCounts > ( TickType_t ) 0U );
 40049ac:	e0bffb17 	ldw	r2,-20(fp)
 40049b0:	103ff71e 	bne	r2,zero,4004990 <xTaskResumeAll+0x274>

                        xPendedTicks = 0;
 40049b4:	d026b515 	stw	zero,-25900(gp)
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( xYieldPending != pdFALSE )
 40049b8:	d0a6b617 	ldw	r2,-25896(gp)
 40049bc:	10000326 	beq	r2,zero,40049cc <xTaskResumeAll+0x2b0>
                {
                    #if ( configUSE_PREEMPTION != 0 )
                    {
                        xAlreadyYielded = pdTRUE;
 40049c0:	00800044 	movi	r2,1
 40049c4:	e0bffc15 	stw	r2,-16(fp)
                    }
                    #endif
                    taskYIELD_IF_USING_PREEMPTION();
 40049c8:	003b683a 	trap	0
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    taskEXIT_CRITICAL();
 40049cc:	4005fd00 	call	4005fd0 <vTaskExitCritical>

    return xAlreadyYielded;
 40049d0:	e0bffc17 	ldw	r2,-16(fp)
}
 40049d4:	e6fffe04 	addi	sp,fp,-8
 40049d8:	dfc00317 	ldw	ra,12(sp)
 40049dc:	df000217 	ldw	fp,8(sp)
 40049e0:	dc400117 	ldw	r17,4(sp)
 40049e4:	dc000017 	ldw	r16,0(sp)
 40049e8:	dec00404 	addi	sp,sp,16
 40049ec:	f800283a 	ret

040049f0 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
 40049f0:	defffe04 	addi	sp,sp,-8
 40049f4:	df000115 	stw	fp,4(sp)
 40049f8:	df000104 	addi	fp,sp,4
    TickType_t xTicks;

    /* Critical section required if running on a 16 bit processor. */
    portTICK_TYPE_ENTER_CRITICAL();
    {
        xTicks = xTickCount;
 40049fc:	d0a6b217 	ldw	r2,-25912(gp)
 4004a00:	e0bfff15 	stw	r2,-4(fp)
    }
    portTICK_TYPE_EXIT_CRITICAL();

    return xTicks;
 4004a04:	e0bfff17 	ldw	r2,-4(fp)
}
 4004a08:	e037883a 	mov	sp,fp
 4004a0c:	df000017 	ldw	fp,0(sp)
 4004a10:	dec00104 	addi	sp,sp,4
 4004a14:	f800283a 	ret

04004a18 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
 4004a18:	defffd04 	addi	sp,sp,-12
 4004a1c:	df000215 	stw	fp,8(sp)
 4004a20:	df000204 	addi	fp,sp,8
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
 4004a24:	e03fff15 	stw	zero,-4(fp)
    {
        xReturn = xTickCount;
 4004a28:	d0a6b217 	ldw	r2,-25912(gp)
 4004a2c:	e0bffe15 	stw	r2,-8(fp)
    }
    portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
 4004a30:	e0bffe17 	ldw	r2,-8(fp)
}
 4004a34:	e037883a 	mov	sp,fp
 4004a38:	df000017 	ldw	fp,0(sp)
 4004a3c:	dec00104 	addi	sp,sp,4
 4004a40:	f800283a 	ret

04004a44 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
 4004a44:	deffff04 	addi	sp,sp,-4
 4004a48:	df000015 	stw	fp,0(sp)
 4004a4c:	d839883a 	mov	fp,sp
    /* A critical section is not required because the variables are of type
     * BaseType_t. */
    return uxCurrentNumberOfTasks;
 4004a50:	d0a6b117 	ldw	r2,-25916(gp)
}
 4004a54:	e037883a 	mov	sp,fp
 4004a58:	df000017 	ldw	fp,0(sp)
 4004a5c:	dec00104 	addi	sp,sp,4
 4004a60:	f800283a 	ret

04004a64 <pcTaskGetName>:
/*-----------------------------------------------------------*/

char * pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
 4004a64:	defffd04 	addi	sp,sp,-12
 4004a68:	df000215 	stw	fp,8(sp)
 4004a6c:	df000204 	addi	fp,sp,8
 4004a70:	e13ffe15 	stw	r4,-8(fp)
    TCB_t * pxTCB;

    /* If null is passed in here then the name of the calling task is being
     * queried. */
    pxTCB = prvGetTCBFromHandle( xTaskToQuery );
 4004a74:	e0bffe17 	ldw	r2,-8(fp)
 4004a78:	1000021e 	bne	r2,zero,4004a84 <pcTaskGetName+0x20>
 4004a7c:	d0a6ad17 	ldw	r2,-25932(gp)
 4004a80:	00000106 	br	4004a88 <pcTaskGetName+0x24>
 4004a84:	e0bffe17 	ldw	r2,-8(fp)
 4004a88:	e0bfff15 	stw	r2,-4(fp)
    configASSERT( pxTCB );
    return &( pxTCB->pcTaskName[ 0 ] );
 4004a8c:	e0bfff17 	ldw	r2,-4(fp)
 4004a90:	10800d04 	addi	r2,r2,52
}
 4004a94:	e037883a 	mov	sp,fp
 4004a98:	df000017 	ldw	fp,0(sp)
 4004a9c:	dec00104 	addi	sp,sp,4
 4004aa0:	f800283a 	ret

04004aa4 <xTaskCatchUpTicks>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp )
{
 4004aa4:	defffc04 	addi	sp,sp,-16
 4004aa8:	dfc00315 	stw	ra,12(sp)
 4004aac:	df000215 	stw	fp,8(sp)
 4004ab0:	df000204 	addi	fp,sp,8
 4004ab4:	e13ffe15 	stw	r4,-8(fp)
     * relies on xPendedTicks being wound down to 0 in xTaskResumeAll(). */
    configASSERT( uxSchedulerSuspended == 0 );

    /* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
     * the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
    vTaskSuspendAll();
 4004ab8:	40046f00 	call	40046f0 <vTaskSuspendAll>

    /* Prevent the tick interrupt modifying xPendedTicks simultaneously. */
    taskENTER_CRITICAL();
 4004abc:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
    {
        xPendedTicks += xTicksToCatchUp;
 4004ac0:	d0e6b517 	ldw	r3,-25900(gp)
 4004ac4:	e0bffe17 	ldw	r2,-8(fp)
 4004ac8:	1885883a 	add	r2,r3,r2
 4004acc:	d0a6b515 	stw	r2,-25900(gp)
    }
    taskEXIT_CRITICAL();
 4004ad0:	4005fd00 	call	4005fd0 <vTaskExitCritical>
    xYieldOccurred = xTaskResumeAll();
 4004ad4:	400471c0 	call	400471c <xTaskResumeAll>
 4004ad8:	e0bfff15 	stw	r2,-4(fp)

    return xYieldOccurred;
 4004adc:	e0bfff17 	ldw	r2,-4(fp)
}
 4004ae0:	e037883a 	mov	sp,fp
 4004ae4:	dfc00117 	ldw	ra,4(sp)
 4004ae8:	df000017 	ldw	fp,0(sp)
 4004aec:	dec00204 	addi	sp,sp,8
 4004af0:	f800283a 	ret

04004af4 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
 4004af4:	defff404 	addi	sp,sp,-48
 4004af8:	dfc00b15 	stw	ra,44(sp)
 4004afc:	df000a15 	stw	fp,40(sp)
 4004b00:	dc400915 	stw	r17,36(sp)
 4004b04:	dc000815 	stw	r16,32(sp)
 4004b08:	df000a04 	addi	fp,sp,40
    TCB_t * pxTCB;
    TickType_t xItemValue;
    BaseType_t xSwitchRequired = pdFALSE;
 4004b0c:	e03ffd15 	stw	zero,-12(fp)
    /* Called by the portable layer each time a tick interrupt occurs.
     * Increments the tick then checks to see if the new tick value will cause any
     * tasks to be unblocked. */
    traceTASK_INCREMENT_TICK( xTickCount );

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 4004b10:	d0a6bb17 	ldw	r2,-25876(gp)
 4004b14:	1000bb1e 	bne	r2,zero,4004e04 <xTaskIncrementTick+0x310>
    {
        /* Minor optimisation.  The tick count cannot change in this
         * block. */
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
 4004b18:	d0a6b217 	ldw	r2,-25912(gp)
 4004b1c:	10800044 	addi	r2,r2,1
 4004b20:	e0bffc15 	stw	r2,-16(fp)

        /* Increment the RTOS tick, switching the delayed and overflowed
         * delayed lists if it wraps to 0. */
        xTickCount = xConstTickCount;
 4004b24:	e0bffc17 	ldw	r2,-16(fp)
 4004b28:	d0a6b215 	stw	r2,-25912(gp)

        if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
 4004b2c:	e0bffc17 	ldw	r2,-16(fp)
 4004b30:	10000a1e 	bne	r2,zero,4004b5c <xTaskIncrementTick+0x68>
        {
            taskSWITCH_DELAYED_LISTS();
 4004b34:	d0a6ae17 	ldw	r2,-25928(gp)
 4004b38:	e0bffb15 	stw	r2,-20(fp)
 4004b3c:	d0a6af17 	ldw	r2,-25924(gp)
 4004b40:	d0a6ae15 	stw	r2,-25928(gp)
 4004b44:	e0bffb17 	ldw	r2,-20(fp)
 4004b48:	d0a6af15 	stw	r2,-25924(gp)
 4004b4c:	d0a6b717 	ldw	r2,-25892(gp)
 4004b50:	10800044 	addi	r2,r2,1
 4004b54:	d0a6b715 	stw	r2,-25892(gp)
 4004b58:	40059480 	call	4005948 <prvResetNextTaskUnblockTime>

        /* See if this tick has made a timeout expire.  Tasks are stored in
         * the  queue in the order of their wake time - meaning once one task
         * has been found whose block time has not expired there is no need to
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
 4004b5c:	d0a6b917 	ldw	r2,-25884(gp)
 4004b60:	e0fffc17 	ldw	r3,-16(fp)
 4004b64:	18809536 	bltu	r3,r2,4004dbc <xTaskIncrementTick+0x2c8>
        {
            for( ; ; )
            {
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 4004b68:	d0a6ae17 	ldw	r2,-25928(gp)
 4004b6c:	10800017 	ldw	r2,0(r2)
 4004b70:	1000031e 	bne	r2,zero,4004b80 <xTaskIncrementTick+0x8c>
                    /* The delayed list is empty.  Set xNextTaskUnblockTime
                     * to the maximum possible value so it is extremely
                     * unlikely that the
                     * if( xTickCount >= xNextTaskUnblockTime ) test will pass
                     * next time through. */
                    xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 4004b74:	00bfffc4 	movi	r2,-1
 4004b78:	d0a6b915 	stw	r2,-25884(gp)
                    break;
 4004b7c:	00008f06 	br	4004dbc <xTaskIncrementTick+0x2c8>
                {
                    /* The delayed list is not empty, get the value of the
                     * item at the head of the delayed list.  This is the time
                     * at which the task at the head of the delayed list must
                     * be removed from the Blocked state. */
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 4004b80:	d0a6ae17 	ldw	r2,-25928(gp)
 4004b84:	10800317 	ldw	r2,12(r2)
 4004b88:	10800317 	ldw	r2,12(r2)
 4004b8c:	e0bffa15 	stw	r2,-24(fp)
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 4004b90:	e0bffa17 	ldw	r2,-24(fp)
 4004b94:	10800117 	ldw	r2,4(r2)
 4004b98:	e0bff915 	stw	r2,-28(fp)

                    if( xConstTickCount < xItemValue )
 4004b9c:	e0fffc17 	ldw	r3,-16(fp)
 4004ba0:	e0bff917 	ldw	r2,-28(fp)
 4004ba4:	1880032e 	bgeu	r3,r2,4004bb4 <xTaskIncrementTick+0xc0>
                        /* It is not time to unblock this item yet, but the
                         * item value is the time at which the task at the head
                         * of the blocked list must be removed from the Blocked
                         * state -  so record the item value in
                         * xNextTaskUnblockTime. */
                        xNextTaskUnblockTime = xItemValue;
 4004ba8:	e0bff917 	ldw	r2,-28(fp)
 4004bac:	d0a6b915 	stw	r2,-25884(gp)
                        break; /*lint !e9011 Code structure here is deemed easier to understand with multiple breaks. */
 4004bb0:	00008206 	br	4004dbc <xTaskIncrementTick+0x2c8>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* It is time to remove the item from the Blocked state. */
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 4004bb4:	e0bffa17 	ldw	r2,-24(fp)
 4004bb8:	10800517 	ldw	r2,20(r2)
 4004bbc:	e0bff815 	stw	r2,-32(fp)
 4004bc0:	e0bffa17 	ldw	r2,-24(fp)
 4004bc4:	10800217 	ldw	r2,8(r2)
 4004bc8:	e0fffa17 	ldw	r3,-24(fp)
 4004bcc:	18c00317 	ldw	r3,12(r3)
 4004bd0:	10c00215 	stw	r3,8(r2)
 4004bd4:	e0bffa17 	ldw	r2,-24(fp)
 4004bd8:	10800317 	ldw	r2,12(r2)
 4004bdc:	e0fffa17 	ldw	r3,-24(fp)
 4004be0:	18c00217 	ldw	r3,8(r3)
 4004be4:	10c00115 	stw	r3,4(r2)
 4004be8:	e0bff817 	ldw	r2,-32(fp)
 4004bec:	10c00117 	ldw	r3,4(r2)
 4004bf0:	e0bffa17 	ldw	r2,-24(fp)
 4004bf4:	10800104 	addi	r2,r2,4
 4004bf8:	1880041e 	bne	r3,r2,4004c0c <xTaskIncrementTick+0x118>
 4004bfc:	e0bffa17 	ldw	r2,-24(fp)
 4004c00:	10c00317 	ldw	r3,12(r2)
 4004c04:	e0bff817 	ldw	r2,-32(fp)
 4004c08:	10c00115 	stw	r3,4(r2)
 4004c0c:	e0bffa17 	ldw	r2,-24(fp)
 4004c10:	10000515 	stw	zero,20(r2)
 4004c14:	e0bff817 	ldw	r2,-32(fp)
 4004c18:	10800017 	ldw	r2,0(r2)
 4004c1c:	10ffffc4 	addi	r3,r2,-1
 4004c20:	e0bff817 	ldw	r2,-32(fp)
 4004c24:	10c00015 	stw	r3,0(r2)

                    /* Is the task waiting on an event also?  If so remove
                     * it from the event list. */
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 4004c28:	e0bffa17 	ldw	r2,-24(fp)
 4004c2c:	10800a17 	ldw	r2,40(r2)
 4004c30:	10001d26 	beq	r2,zero,4004ca8 <xTaskIncrementTick+0x1b4>
                    {
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
 4004c34:	e0bffa17 	ldw	r2,-24(fp)
 4004c38:	10800a17 	ldw	r2,40(r2)
 4004c3c:	e0bff715 	stw	r2,-36(fp)
 4004c40:	e0bffa17 	ldw	r2,-24(fp)
 4004c44:	10800717 	ldw	r2,28(r2)
 4004c48:	e0fffa17 	ldw	r3,-24(fp)
 4004c4c:	18c00817 	ldw	r3,32(r3)
 4004c50:	10c00215 	stw	r3,8(r2)
 4004c54:	e0bffa17 	ldw	r2,-24(fp)
 4004c58:	10800817 	ldw	r2,32(r2)
 4004c5c:	e0fffa17 	ldw	r3,-24(fp)
 4004c60:	18c00717 	ldw	r3,28(r3)
 4004c64:	10c00115 	stw	r3,4(r2)
 4004c68:	e0bff717 	ldw	r2,-36(fp)
 4004c6c:	10c00117 	ldw	r3,4(r2)
 4004c70:	e0bffa17 	ldw	r2,-24(fp)
 4004c74:	10800604 	addi	r2,r2,24
 4004c78:	1880041e 	bne	r3,r2,4004c8c <xTaskIncrementTick+0x198>
 4004c7c:	e0bffa17 	ldw	r2,-24(fp)
 4004c80:	10c00817 	ldw	r3,32(r2)
 4004c84:	e0bff717 	ldw	r2,-36(fp)
 4004c88:	10c00115 	stw	r3,4(r2)
 4004c8c:	e0bffa17 	ldw	r2,-24(fp)
 4004c90:	10000a15 	stw	zero,40(r2)
 4004c94:	e0bff717 	ldw	r2,-36(fp)
 4004c98:	10800017 	ldw	r2,0(r2)
 4004c9c:	10ffffc4 	addi	r3,r2,-1
 4004ca0:	e0bff717 	ldw	r2,-36(fp)
 4004ca4:	10c00015 	stw	r3,0(r2)
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
 4004ca8:	e0bffa17 	ldw	r2,-24(fp)
 4004cac:	10800b17 	ldw	r2,44(r2)
 4004cb0:	d0e6b317 	ldw	r3,-25908(gp)
 4004cb4:	1880032e 	bgeu	r3,r2,4004cc4 <xTaskIncrementTick+0x1d0>
 4004cb8:	e0bffa17 	ldw	r2,-24(fp)
 4004cbc:	10800b17 	ldw	r2,44(r2)
 4004cc0:	d0a6b315 	stw	r2,-25908(gp)
 4004cc4:	e0bffa17 	ldw	r2,-24(fp)
 4004cc8:	10800b17 	ldw	r2,44(r2)
 4004ccc:	01400504 	movi	r5,20
 4004cd0:	1009883a 	mov	r4,r2
 4004cd4:	40078580 	call	4007858 <__mulsi3>
 4004cd8:	1007883a 	mov	r3,r2
 4004cdc:	00812074 	movhi	r2,1153
 4004ce0:	1885883a 	add	r2,r3,r2
 4004ce4:	10807717 	ldw	r2,476(r2)
 4004ce8:	e0bff615 	stw	r2,-40(fp)
 4004cec:	e0bffa17 	ldw	r2,-24(fp)
 4004cf0:	e0fff617 	ldw	r3,-40(fp)
 4004cf4:	10c00215 	stw	r3,8(r2)
 4004cf8:	e0bff617 	ldw	r2,-40(fp)
 4004cfc:	10c00217 	ldw	r3,8(r2)
 4004d00:	e0bffa17 	ldw	r2,-24(fp)
 4004d04:	10c00315 	stw	r3,12(r2)
 4004d08:	e0bff617 	ldw	r2,-40(fp)
 4004d0c:	10800217 	ldw	r2,8(r2)
 4004d10:	e0fffa17 	ldw	r3,-24(fp)
 4004d14:	18c00104 	addi	r3,r3,4
 4004d18:	10c00115 	stw	r3,4(r2)
 4004d1c:	e0bffa17 	ldw	r2,-24(fp)
 4004d20:	10c00104 	addi	r3,r2,4
 4004d24:	e0bff617 	ldw	r2,-40(fp)
 4004d28:	10c00215 	stw	r3,8(r2)
 4004d2c:	e0bffa17 	ldw	r2,-24(fp)
 4004d30:	10800b17 	ldw	r2,44(r2)
 4004d34:	01400504 	movi	r5,20
 4004d38:	1009883a 	mov	r4,r2
 4004d3c:	40078580 	call	4007858 <__mulsi3>
 4004d40:	1007883a 	mov	r3,r2
 4004d44:	00812074 	movhi	r2,1153
 4004d48:	10807604 	addi	r2,r2,472
 4004d4c:	1887883a 	add	r3,r3,r2
 4004d50:	e0bffa17 	ldw	r2,-24(fp)
 4004d54:	10c00515 	stw	r3,20(r2)
 4004d58:	e0bffa17 	ldw	r2,-24(fp)
 4004d5c:	14400b17 	ldw	r17,44(r2)
 4004d60:	01400504 	movi	r5,20
 4004d64:	8809883a 	mov	r4,r17
 4004d68:	40078580 	call	4007858 <__mulsi3>
 4004d6c:	1007883a 	mov	r3,r2
 4004d70:	00812074 	movhi	r2,1153
 4004d74:	1885883a 	add	r2,r3,r2
 4004d78:	10807617 	ldw	r2,472(r2)
 4004d7c:	14000044 	addi	r16,r2,1
 4004d80:	01400504 	movi	r5,20
 4004d84:	8809883a 	mov	r4,r17
 4004d88:	40078580 	call	4007858 <__mulsi3>
 4004d8c:	1007883a 	mov	r3,r2
 4004d90:	00812074 	movhi	r2,1153
 4004d94:	1885883a 	add	r2,r3,r2
 4004d98:	14007615 	stw	r16,472(r2)
                         * task.
                         * The case of equal priority tasks sharing
                         * processing time (which happens when both
                         * preemption and time slicing are on) is
                         * handled below.*/
                        if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 4004d9c:	e0bffa17 	ldw	r2,-24(fp)
 4004da0:	10800b17 	ldw	r2,44(r2)
 4004da4:	d0e6ad17 	ldw	r3,-25932(gp)
 4004da8:	18c00b17 	ldw	r3,44(r3)
 4004dac:	18bf6e2e 	bgeu	r3,r2,4004b68 <xTaskIncrementTick+0x74>
                        {
                            xSwitchRequired = pdTRUE;
 4004db0:	00800044 	movi	r2,1
 4004db4:	e0bffd15 	stw	r2,-12(fp)
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 4004db8:	003f6b06 	br	4004b68 <xTaskIncrementTick+0x74>
        /* Tasks of equal priority to the currently running task will share
         * processing time (time slice) if preemption is on, and the application
         * writer has not explicitly turned time slicing off. */
        #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
        {
            if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 4004dbc:	d0a6ad17 	ldw	r2,-25932(gp)
 4004dc0:	10800b17 	ldw	r2,44(r2)
 4004dc4:	01400504 	movi	r5,20
 4004dc8:	1009883a 	mov	r4,r2
 4004dcc:	40078580 	call	4007858 <__mulsi3>
 4004dd0:	1007883a 	mov	r3,r2
 4004dd4:	00812074 	movhi	r2,1153
 4004dd8:	1885883a 	add	r2,r3,r2
 4004ddc:	10807617 	ldw	r2,472(r2)
 4004de0:	108000b0 	cmpltui	r2,r2,2
 4004de4:	1000021e 	bne	r2,zero,4004df0 <xTaskIncrementTick+0x2fc>
            {
                xSwitchRequired = pdTRUE;
 4004de8:	00800044 	movi	r2,1
 4004dec:	e0bffd15 	stw	r2,-12(fp)
        }
        #endif /* configUSE_TICK_HOOK */

        #if ( configUSE_PREEMPTION == 1 )
        {
            if( xYieldPending != pdFALSE )
 4004df0:	d0a6b617 	ldw	r2,-25896(gp)
 4004df4:	10000626 	beq	r2,zero,4004e10 <xTaskIncrementTick+0x31c>
            {
                xSwitchRequired = pdTRUE;
 4004df8:	00800044 	movi	r2,1
 4004dfc:	e0bffd15 	stw	r2,-12(fp)
 4004e00:	00000306 	br	4004e10 <xTaskIncrementTick+0x31c>
        }
        #endif /* configUSE_PREEMPTION */
    }
    else
    {
        ++xPendedTicks;
 4004e04:	d0a6b517 	ldw	r2,-25900(gp)
 4004e08:	10800044 	addi	r2,r2,1
 4004e0c:	d0a6b515 	stw	r2,-25900(gp)
            vApplicationTickHook();
        }
        #endif
    }

    return xSwitchRequired;
 4004e10:	e0bffd17 	ldw	r2,-12(fp)
}
 4004e14:	e6fffe04 	addi	sp,fp,-8
 4004e18:	dfc00317 	ldw	ra,12(sp)
 4004e1c:	df000217 	ldw	fp,8(sp)
 4004e20:	dc400117 	ldw	r17,4(sp)
 4004e24:	dc000017 	ldw	r16,0(sp)
 4004e28:	dec00404 	addi	sp,sp,16
 4004e2c:	f800283a 	ret

04004e30 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
 4004e30:	defffc04 	addi	sp,sp,-16
 4004e34:	dfc00315 	stw	ra,12(sp)
 4004e38:	df000215 	stw	fp,8(sp)
 4004e3c:	df000204 	addi	fp,sp,8
    if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 4004e40:	d0a6bb17 	ldw	r2,-25876(gp)
 4004e44:	10000326 	beq	r2,zero,4004e54 <vTaskSwitchContext+0x24>
    {
        /* The scheduler is currently suspended - do not allow a context
         * switch. */
        xYieldPending = pdTRUE;
 4004e48:	00800044 	movi	r2,1
 4004e4c:	d0a6b615 	stw	r2,-25896(gp)
             * Block specific to this task. */
            configSET_TLS_BLOCK( pxCurrentTCB->xTLSBlock );
        }
        #endif
    }
}
 4004e50:	00002d06 	br	4004f08 <vTaskSwitchContext+0xd8>
        xYieldPending = pdFALSE;
 4004e54:	d026b615 	stw	zero,-25896(gp)
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 4004e58:	d0a6b317 	ldw	r2,-25908(gp)
 4004e5c:	e0bfff15 	stw	r2,-4(fp)
 4004e60:	00000306 	br	4004e70 <vTaskSwitchContext+0x40>
 4004e64:	e0bfff17 	ldw	r2,-4(fp)
 4004e68:	10bfffc4 	addi	r2,r2,-1
 4004e6c:	e0bfff15 	stw	r2,-4(fp)
 4004e70:	e0bfff17 	ldw	r2,-4(fp)
 4004e74:	01400504 	movi	r5,20
 4004e78:	1009883a 	mov	r4,r2
 4004e7c:	40078580 	call	4007858 <__mulsi3>
 4004e80:	1007883a 	mov	r3,r2
 4004e84:	00812074 	movhi	r2,1153
 4004e88:	1885883a 	add	r2,r3,r2
 4004e8c:	10807617 	ldw	r2,472(r2)
 4004e90:	103ff426 	beq	r2,zero,4004e64 <vTaskSwitchContext+0x34>
 4004e94:	01400504 	movi	r5,20
 4004e98:	e13fff17 	ldw	r4,-4(fp)
 4004e9c:	40078580 	call	4007858 <__mulsi3>
 4004ea0:	1007883a 	mov	r3,r2
 4004ea4:	00812074 	movhi	r2,1153
 4004ea8:	10807604 	addi	r2,r2,472
 4004eac:	1885883a 	add	r2,r3,r2
 4004eb0:	e0bffe15 	stw	r2,-8(fp)
 4004eb4:	e0bffe17 	ldw	r2,-8(fp)
 4004eb8:	10800117 	ldw	r2,4(r2)
 4004ebc:	10c00117 	ldw	r3,4(r2)
 4004ec0:	e0bffe17 	ldw	r2,-8(fp)
 4004ec4:	10c00115 	stw	r3,4(r2)
 4004ec8:	e0bffe17 	ldw	r2,-8(fp)
 4004ecc:	10c00117 	ldw	r3,4(r2)
 4004ed0:	e0bffe17 	ldw	r2,-8(fp)
 4004ed4:	10800204 	addi	r2,r2,8
 4004ed8:	1880051e 	bne	r3,r2,4004ef0 <vTaskSwitchContext+0xc0>
 4004edc:	e0bffe17 	ldw	r2,-8(fp)
 4004ee0:	10800117 	ldw	r2,4(r2)
 4004ee4:	10c00117 	ldw	r3,4(r2)
 4004ee8:	e0bffe17 	ldw	r2,-8(fp)
 4004eec:	10c00115 	stw	r3,4(r2)
 4004ef0:	e0bffe17 	ldw	r2,-8(fp)
 4004ef4:	10800117 	ldw	r2,4(r2)
 4004ef8:	10800317 	ldw	r2,12(r2)
 4004efc:	d0a6ad15 	stw	r2,-25932(gp)
 4004f00:	e0bfff17 	ldw	r2,-4(fp)
 4004f04:	d0a6b315 	stw	r2,-25908(gp)
}
 4004f08:	0001883a 	nop
 4004f0c:	e037883a 	mov	sp,fp
 4004f10:	dfc00117 	ldw	ra,4(sp)
 4004f14:	df000017 	ldw	fp,0(sp)
 4004f18:	dec00204 	addi	sp,sp,8
 4004f1c:	f800283a 	ret

04004f20 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList,
                            const TickType_t xTicksToWait )
{
 4004f20:	defffc04 	addi	sp,sp,-16
 4004f24:	dfc00315 	stw	ra,12(sp)
 4004f28:	df000215 	stw	fp,8(sp)
 4004f2c:	df000204 	addi	fp,sp,8
 4004f30:	e13fff15 	stw	r4,-4(fp)
 4004f34:	e17ffe15 	stw	r5,-8(fp)
     *      xItemValue = ( configMAX_PRIORITIES - uxPriority )
     * Therefore, the event list is sorted in descending priority order.
     *
     * The queue that contains the event list is locked, preventing
     * simultaneous access from interrupts. */
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 4004f38:	d0a6ad17 	ldw	r2,-25932(gp)
 4004f3c:	10800604 	addi	r2,r2,24
 4004f40:	100b883a 	mov	r5,r2
 4004f44:	e13fff17 	ldw	r4,-4(fp)
 4004f48:	4000bc00 	call	4000bc0 <vListInsert>

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 4004f4c:	01400044 	movi	r5,1
 4004f50:	e13ffe17 	ldw	r4,-8(fp)
 4004f54:	4006e3c0 	call	4006e3c <prvAddCurrentTaskToDelayedList>
}
 4004f58:	0001883a 	nop
 4004f5c:	e037883a 	mov	sp,fp
 4004f60:	dfc00117 	ldw	ra,4(sp)
 4004f64:	df000017 	ldw	fp,0(sp)
 4004f68:	dec00204 	addi	sp,sp,8
 4004f6c:	f800283a 	ret

04004f70 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList,
                                     const TickType_t xItemValue,
                                     const TickType_t xTicksToWait )
{
 4004f70:	defffa04 	addi	sp,sp,-24
 4004f74:	dfc00515 	stw	ra,20(sp)
 4004f78:	df000415 	stw	fp,16(sp)
 4004f7c:	df000404 	addi	fp,sp,16
 4004f80:	e13ffe15 	stw	r4,-8(fp)
 4004f84:	e17ffd15 	stw	r5,-12(fp)
 4004f88:	e1bffc15 	stw	r6,-16(fp)
    configASSERT( uxSchedulerSuspended != 0 );

    /* Store the item value in the event list item.  It is safe to access the
     * event list item here as interrupts won't access the event list item of a
     * task that is not in the Blocked state. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
 4004f8c:	d0a6ad17 	ldw	r2,-25932(gp)
 4004f90:	e0fffd17 	ldw	r3,-12(fp)
 4004f94:	18e00034 	orhi	r3,r3,32768
 4004f98:	10c00615 	stw	r3,24(r2)
    /* Place the event list item of the TCB at the end of the appropriate event
     * list.  It is safe to access the event list here because it is part of an
     * event group implementation - and interrupts don't access event groups
     * directly (instead they access them indirectly by pending function calls to
     * the task level). */
    listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 4004f9c:	e0bffe17 	ldw	r2,-8(fp)
 4004fa0:	10800117 	ldw	r2,4(r2)
 4004fa4:	e0bfff15 	stw	r2,-4(fp)
 4004fa8:	d0a6ad17 	ldw	r2,-25932(gp)
 4004fac:	e0ffff17 	ldw	r3,-4(fp)
 4004fb0:	10c00715 	stw	r3,28(r2)
 4004fb4:	d0a6ad17 	ldw	r2,-25932(gp)
 4004fb8:	e0ffff17 	ldw	r3,-4(fp)
 4004fbc:	18c00217 	ldw	r3,8(r3)
 4004fc0:	10c00815 	stw	r3,32(r2)
 4004fc4:	d0e6ad17 	ldw	r3,-25932(gp)
 4004fc8:	e0bfff17 	ldw	r2,-4(fp)
 4004fcc:	10800217 	ldw	r2,8(r2)
 4004fd0:	18c00604 	addi	r3,r3,24
 4004fd4:	10c00115 	stw	r3,4(r2)
 4004fd8:	d0a6ad17 	ldw	r2,-25932(gp)
 4004fdc:	10c00604 	addi	r3,r2,24
 4004fe0:	e0bfff17 	ldw	r2,-4(fp)
 4004fe4:	10c00215 	stw	r3,8(r2)
 4004fe8:	d0a6ad17 	ldw	r2,-25932(gp)
 4004fec:	e0fffe17 	ldw	r3,-8(fp)
 4004ff0:	10c00a15 	stw	r3,40(r2)
 4004ff4:	e0bffe17 	ldw	r2,-8(fp)
 4004ff8:	10800017 	ldw	r2,0(r2)
 4004ffc:	10c00044 	addi	r3,r2,1
 4005000:	e0bffe17 	ldw	r2,-8(fp)
 4005004:	10c00015 	stw	r3,0(r2)

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 4005008:	01400044 	movi	r5,1
 400500c:	e13ffc17 	ldw	r4,-16(fp)
 4005010:	4006e3c0 	call	4006e3c <prvAddCurrentTaskToDelayedList>
}
 4005014:	0001883a 	nop
 4005018:	e037883a 	mov	sp,fp
 400501c:	dfc00117 	ldw	ra,4(sp)
 4005020:	df000017 	ldw	fp,0(sp)
 4005024:	dec00204 	addi	sp,sp,8
 4005028:	f800283a 	ret

0400502c <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
 400502c:	defff504 	addi	sp,sp,-44
 4005030:	dfc00a15 	stw	ra,40(sp)
 4005034:	df000915 	stw	fp,36(sp)
 4005038:	dc400815 	stw	r17,32(sp)
 400503c:	dc000715 	stw	r16,28(sp)
 4005040:	df000904 	addi	fp,sp,36
 4005044:	e13ff715 	stw	r4,-36(fp)
     * get called - the lock count on the queue will get modified instead.  This
     * means exclusive access to the event list is guaranteed here.
     *
     * This function assumes that a check has already been made to ensure that
     * pxEventList is not empty. */
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 4005048:	e0bff717 	ldw	r2,-36(fp)
 400504c:	10800317 	ldw	r2,12(r2)
 4005050:	10800317 	ldw	r2,12(r2)
 4005054:	e0bffc15 	stw	r2,-16(fp)
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( &( pxUnblockedTCB->xEventListItem ) );
 4005058:	e0bffc17 	ldw	r2,-16(fp)
 400505c:	10800a17 	ldw	r2,40(r2)
 4005060:	e0bffb15 	stw	r2,-20(fp)
 4005064:	e0bffc17 	ldw	r2,-16(fp)
 4005068:	10800717 	ldw	r2,28(r2)
 400506c:	e0fffc17 	ldw	r3,-16(fp)
 4005070:	18c00817 	ldw	r3,32(r3)
 4005074:	10c00215 	stw	r3,8(r2)
 4005078:	e0bffc17 	ldw	r2,-16(fp)
 400507c:	10800817 	ldw	r2,32(r2)
 4005080:	e0fffc17 	ldw	r3,-16(fp)
 4005084:	18c00717 	ldw	r3,28(r3)
 4005088:	10c00115 	stw	r3,4(r2)
 400508c:	e0bffb17 	ldw	r2,-20(fp)
 4005090:	10c00117 	ldw	r3,4(r2)
 4005094:	e0bffc17 	ldw	r2,-16(fp)
 4005098:	10800604 	addi	r2,r2,24
 400509c:	1880041e 	bne	r3,r2,40050b0 <xTaskRemoveFromEventList+0x84>
 40050a0:	e0bffc17 	ldw	r2,-16(fp)
 40050a4:	10c00817 	ldw	r3,32(r2)
 40050a8:	e0bffb17 	ldw	r2,-20(fp)
 40050ac:	10c00115 	stw	r3,4(r2)
 40050b0:	e0bffc17 	ldw	r2,-16(fp)
 40050b4:	10000a15 	stw	zero,40(r2)
 40050b8:	e0bffb17 	ldw	r2,-20(fp)
 40050bc:	10800017 	ldw	r2,0(r2)
 40050c0:	10ffffc4 	addi	r3,r2,-1
 40050c4:	e0bffb17 	ldw	r2,-20(fp)
 40050c8:	10c00015 	stw	r3,0(r2)

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 40050cc:	d0a6bb17 	ldw	r2,-25876(gp)
 40050d0:	10005b1e 	bne	r2,zero,4005240 <xTaskRemoveFromEventList+0x214>
    {
        listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
 40050d4:	e0bffc17 	ldw	r2,-16(fp)
 40050d8:	10800517 	ldw	r2,20(r2)
 40050dc:	e0bff915 	stw	r2,-28(fp)
 40050e0:	e0bffc17 	ldw	r2,-16(fp)
 40050e4:	10800217 	ldw	r2,8(r2)
 40050e8:	e0fffc17 	ldw	r3,-16(fp)
 40050ec:	18c00317 	ldw	r3,12(r3)
 40050f0:	10c00215 	stw	r3,8(r2)
 40050f4:	e0bffc17 	ldw	r2,-16(fp)
 40050f8:	10800317 	ldw	r2,12(r2)
 40050fc:	e0fffc17 	ldw	r3,-16(fp)
 4005100:	18c00217 	ldw	r3,8(r3)
 4005104:	10c00115 	stw	r3,4(r2)
 4005108:	e0bff917 	ldw	r2,-28(fp)
 400510c:	10c00117 	ldw	r3,4(r2)
 4005110:	e0bffc17 	ldw	r2,-16(fp)
 4005114:	10800104 	addi	r2,r2,4
 4005118:	1880041e 	bne	r3,r2,400512c <xTaskRemoveFromEventList+0x100>
 400511c:	e0bffc17 	ldw	r2,-16(fp)
 4005120:	10c00317 	ldw	r3,12(r2)
 4005124:	e0bff917 	ldw	r2,-28(fp)
 4005128:	10c00115 	stw	r3,4(r2)
 400512c:	e0bffc17 	ldw	r2,-16(fp)
 4005130:	10000515 	stw	zero,20(r2)
 4005134:	e0bff917 	ldw	r2,-28(fp)
 4005138:	10800017 	ldw	r2,0(r2)
 400513c:	10ffffc4 	addi	r3,r2,-1
 4005140:	e0bff917 	ldw	r2,-28(fp)
 4005144:	10c00015 	stw	r3,0(r2)
        prvAddTaskToReadyList( pxUnblockedTCB );
 4005148:	e0bffc17 	ldw	r2,-16(fp)
 400514c:	10800b17 	ldw	r2,44(r2)
 4005150:	d0e6b317 	ldw	r3,-25908(gp)
 4005154:	1880032e 	bgeu	r3,r2,4005164 <xTaskRemoveFromEventList+0x138>
 4005158:	e0bffc17 	ldw	r2,-16(fp)
 400515c:	10800b17 	ldw	r2,44(r2)
 4005160:	d0a6b315 	stw	r2,-25908(gp)
 4005164:	e0bffc17 	ldw	r2,-16(fp)
 4005168:	10800b17 	ldw	r2,44(r2)
 400516c:	01400504 	movi	r5,20
 4005170:	1009883a 	mov	r4,r2
 4005174:	40078580 	call	4007858 <__mulsi3>
 4005178:	1007883a 	mov	r3,r2
 400517c:	00812074 	movhi	r2,1153
 4005180:	1885883a 	add	r2,r3,r2
 4005184:	10807717 	ldw	r2,476(r2)
 4005188:	e0bff815 	stw	r2,-32(fp)
 400518c:	e0bffc17 	ldw	r2,-16(fp)
 4005190:	e0fff817 	ldw	r3,-32(fp)
 4005194:	10c00215 	stw	r3,8(r2)
 4005198:	e0bff817 	ldw	r2,-32(fp)
 400519c:	10c00217 	ldw	r3,8(r2)
 40051a0:	e0bffc17 	ldw	r2,-16(fp)
 40051a4:	10c00315 	stw	r3,12(r2)
 40051a8:	e0bff817 	ldw	r2,-32(fp)
 40051ac:	10800217 	ldw	r2,8(r2)
 40051b0:	e0fffc17 	ldw	r3,-16(fp)
 40051b4:	18c00104 	addi	r3,r3,4
 40051b8:	10c00115 	stw	r3,4(r2)
 40051bc:	e0bffc17 	ldw	r2,-16(fp)
 40051c0:	10c00104 	addi	r3,r2,4
 40051c4:	e0bff817 	ldw	r2,-32(fp)
 40051c8:	10c00215 	stw	r3,8(r2)
 40051cc:	e0bffc17 	ldw	r2,-16(fp)
 40051d0:	10800b17 	ldw	r2,44(r2)
 40051d4:	01400504 	movi	r5,20
 40051d8:	1009883a 	mov	r4,r2
 40051dc:	40078580 	call	4007858 <__mulsi3>
 40051e0:	1007883a 	mov	r3,r2
 40051e4:	00812074 	movhi	r2,1153
 40051e8:	10807604 	addi	r2,r2,472
 40051ec:	1887883a 	add	r3,r3,r2
 40051f0:	e0bffc17 	ldw	r2,-16(fp)
 40051f4:	10c00515 	stw	r3,20(r2)
 40051f8:	e0bffc17 	ldw	r2,-16(fp)
 40051fc:	14400b17 	ldw	r17,44(r2)
 4005200:	01400504 	movi	r5,20
 4005204:	8809883a 	mov	r4,r17
 4005208:	40078580 	call	4007858 <__mulsi3>
 400520c:	1007883a 	mov	r3,r2
 4005210:	00812074 	movhi	r2,1153
 4005214:	1885883a 	add	r2,r3,r2
 4005218:	10807617 	ldw	r2,472(r2)
 400521c:	14000044 	addi	r16,r2,1
 4005220:	01400504 	movi	r5,20
 4005224:	8809883a 	mov	r4,r17
 4005228:	40078580 	call	4007858 <__mulsi3>
 400522c:	1007883a 	mov	r3,r2
 4005230:	00812074 	movhi	r2,1153
 4005234:	1885883a 	add	r2,r3,r2
 4005238:	14007615 	stw	r16,472(r2)
 400523c:	00001c06 	br	40052b0 <xTaskRemoveFromEventList+0x284>
    }
    else
    {
        /* The delayed and ready lists cannot be accessed, so hold this task
         * pending until the scheduler is resumed. */
        listINSERT_END( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 4005240:	00812074 	movhi	r2,1153
 4005244:	10809a17 	ldw	r2,616(r2)
 4005248:	e0bffa15 	stw	r2,-24(fp)
 400524c:	e0bffc17 	ldw	r2,-16(fp)
 4005250:	e0fffa17 	ldw	r3,-24(fp)
 4005254:	10c00715 	stw	r3,28(r2)
 4005258:	e0bffa17 	ldw	r2,-24(fp)
 400525c:	10c00217 	ldw	r3,8(r2)
 4005260:	e0bffc17 	ldw	r2,-16(fp)
 4005264:	10c00815 	stw	r3,32(r2)
 4005268:	e0bffa17 	ldw	r2,-24(fp)
 400526c:	10800217 	ldw	r2,8(r2)
 4005270:	e0fffc17 	ldw	r3,-16(fp)
 4005274:	18c00604 	addi	r3,r3,24
 4005278:	10c00115 	stw	r3,4(r2)
 400527c:	e0bffc17 	ldw	r2,-16(fp)
 4005280:	10c00604 	addi	r3,r2,24
 4005284:	e0bffa17 	ldw	r2,-24(fp)
 4005288:	10c00215 	stw	r3,8(r2)
 400528c:	e0fffc17 	ldw	r3,-16(fp)
 4005290:	00812074 	movhi	r2,1153
 4005294:	10809904 	addi	r2,r2,612
 4005298:	18800a15 	stw	r2,40(r3)
 400529c:	00812074 	movhi	r2,1153
 40052a0:	10809917 	ldw	r2,612(r2)
 40052a4:	10c00044 	addi	r3,r2,1
 40052a8:	00812074 	movhi	r2,1153
 40052ac:	10c09915 	stw	r3,612(r2)
    }

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 40052b0:	e0bffc17 	ldw	r2,-16(fp)
 40052b4:	10800b17 	ldw	r2,44(r2)
 40052b8:	d0e6ad17 	ldw	r3,-25932(gp)
 40052bc:	18c00b17 	ldw	r3,44(r3)
 40052c0:	1880052e 	bgeu	r3,r2,40052d8 <xTaskRemoveFromEventList+0x2ac>
    {
        /* Return true if the task removed from the event list has a higher
         * priority than the calling task.  This allows the calling task to know if
         * it should force a context switch now. */
        xReturn = pdTRUE;
 40052c4:	00800044 	movi	r2,1
 40052c8:	e0bffd15 	stw	r2,-12(fp)

        /* Mark that a yield is pending in case the user is not using the
         * "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
        xYieldPending = pdTRUE;
 40052cc:	00800044 	movi	r2,1
 40052d0:	d0a6b615 	stw	r2,-25896(gp)
 40052d4:	00000106 	br	40052dc <xTaskRemoveFromEventList+0x2b0>
    }
    else
    {
        xReturn = pdFALSE;
 40052d8:	e03ffd15 	stw	zero,-12(fp)
    }

    return xReturn;
 40052dc:	e0bffd17 	ldw	r2,-12(fp)
}
 40052e0:	e6fffe04 	addi	sp,fp,-8
 40052e4:	dfc00317 	ldw	ra,12(sp)
 40052e8:	df000217 	ldw	fp,8(sp)
 40052ec:	dc400117 	ldw	r17,4(sp)
 40052f0:	dc000017 	ldw	r16,0(sp)
 40052f4:	dec00404 	addi	sp,sp,16
 40052f8:	f800283a 	ret

040052fc <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem,
                                        const TickType_t xItemValue )
{
 40052fc:	defff604 	addi	sp,sp,-40
 4005300:	dfc00915 	stw	ra,36(sp)
 4005304:	df000815 	stw	fp,32(sp)
 4005308:	dc400715 	stw	r17,28(sp)
 400530c:	dc000615 	stw	r16,24(sp)
 4005310:	df000804 	addi	fp,sp,32
 4005314:	e13ff915 	stw	r4,-28(fp)
 4005318:	e17ff815 	stw	r5,-32(fp)
    /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
     * the event flags implementation. */
    configASSERT( uxSchedulerSuspended != pdFALSE );

    /* Store the new item value in the event list. */
    listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
 400531c:	e0bff817 	ldw	r2,-32(fp)
 4005320:	10e00034 	orhi	r3,r2,32768
 4005324:	e0bff917 	ldw	r2,-28(fp)
 4005328:	10c00015 	stw	r3,0(r2)

    /* Remove the event list form the event flag.  Interrupts do not access
     * event flags. */
    pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 400532c:	e0bff917 	ldw	r2,-28(fp)
 4005330:	10800317 	ldw	r2,12(r2)
 4005334:	e0bffd15 	stw	r2,-12(fp)
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( pxEventListItem );
 4005338:	e0bff917 	ldw	r2,-28(fp)
 400533c:	10800417 	ldw	r2,16(r2)
 4005340:	e0bffc15 	stw	r2,-16(fp)
 4005344:	e0bff917 	ldw	r2,-28(fp)
 4005348:	10800117 	ldw	r2,4(r2)
 400534c:	e0fff917 	ldw	r3,-28(fp)
 4005350:	18c00217 	ldw	r3,8(r3)
 4005354:	10c00215 	stw	r3,8(r2)
 4005358:	e0bff917 	ldw	r2,-28(fp)
 400535c:	10800217 	ldw	r2,8(r2)
 4005360:	e0fff917 	ldw	r3,-28(fp)
 4005364:	18c00117 	ldw	r3,4(r3)
 4005368:	10c00115 	stw	r3,4(r2)
 400536c:	e0bffc17 	ldw	r2,-16(fp)
 4005370:	10800117 	ldw	r2,4(r2)
 4005374:	e0fff917 	ldw	r3,-28(fp)
 4005378:	1880041e 	bne	r3,r2,400538c <vTaskRemoveFromUnorderedEventList+0x90>
 400537c:	e0bff917 	ldw	r2,-28(fp)
 4005380:	10c00217 	ldw	r3,8(r2)
 4005384:	e0bffc17 	ldw	r2,-16(fp)
 4005388:	10c00115 	stw	r3,4(r2)
 400538c:	e0bff917 	ldw	r2,-28(fp)
 4005390:	10000415 	stw	zero,16(r2)
 4005394:	e0bffc17 	ldw	r2,-16(fp)
 4005398:	10800017 	ldw	r2,0(r2)
 400539c:	10ffffc4 	addi	r3,r2,-1
 40053a0:	e0bffc17 	ldw	r2,-16(fp)
 40053a4:	10c00015 	stw	r3,0(r2)
    #endif

    /* Remove the task from the delayed list and add it to the ready list.  The
     * scheduler is suspended so interrupts will not be accessing the ready
     * lists. */
    listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
 40053a8:	e0bffd17 	ldw	r2,-12(fp)
 40053ac:	10800517 	ldw	r2,20(r2)
 40053b0:	e0bffb15 	stw	r2,-20(fp)
 40053b4:	e0bffd17 	ldw	r2,-12(fp)
 40053b8:	10800217 	ldw	r2,8(r2)
 40053bc:	e0fffd17 	ldw	r3,-12(fp)
 40053c0:	18c00317 	ldw	r3,12(r3)
 40053c4:	10c00215 	stw	r3,8(r2)
 40053c8:	e0bffd17 	ldw	r2,-12(fp)
 40053cc:	10800317 	ldw	r2,12(r2)
 40053d0:	e0fffd17 	ldw	r3,-12(fp)
 40053d4:	18c00217 	ldw	r3,8(r3)
 40053d8:	10c00115 	stw	r3,4(r2)
 40053dc:	e0bffb17 	ldw	r2,-20(fp)
 40053e0:	10c00117 	ldw	r3,4(r2)
 40053e4:	e0bffd17 	ldw	r2,-12(fp)
 40053e8:	10800104 	addi	r2,r2,4
 40053ec:	1880041e 	bne	r3,r2,4005400 <vTaskRemoveFromUnorderedEventList+0x104>
 40053f0:	e0bffd17 	ldw	r2,-12(fp)
 40053f4:	10c00317 	ldw	r3,12(r2)
 40053f8:	e0bffb17 	ldw	r2,-20(fp)
 40053fc:	10c00115 	stw	r3,4(r2)
 4005400:	e0bffd17 	ldw	r2,-12(fp)
 4005404:	10000515 	stw	zero,20(r2)
 4005408:	e0bffb17 	ldw	r2,-20(fp)
 400540c:	10800017 	ldw	r2,0(r2)
 4005410:	10ffffc4 	addi	r3,r2,-1
 4005414:	e0bffb17 	ldw	r2,-20(fp)
 4005418:	10c00015 	stw	r3,0(r2)
    prvAddTaskToReadyList( pxUnblockedTCB );
 400541c:	e0bffd17 	ldw	r2,-12(fp)
 4005420:	10800b17 	ldw	r2,44(r2)
 4005424:	d0e6b317 	ldw	r3,-25908(gp)
 4005428:	1880032e 	bgeu	r3,r2,4005438 <vTaskRemoveFromUnorderedEventList+0x13c>
 400542c:	e0bffd17 	ldw	r2,-12(fp)
 4005430:	10800b17 	ldw	r2,44(r2)
 4005434:	d0a6b315 	stw	r2,-25908(gp)
 4005438:	e0bffd17 	ldw	r2,-12(fp)
 400543c:	10800b17 	ldw	r2,44(r2)
 4005440:	01400504 	movi	r5,20
 4005444:	1009883a 	mov	r4,r2
 4005448:	40078580 	call	4007858 <__mulsi3>
 400544c:	1007883a 	mov	r3,r2
 4005450:	00812074 	movhi	r2,1153
 4005454:	1885883a 	add	r2,r3,r2
 4005458:	10807717 	ldw	r2,476(r2)
 400545c:	e0bffa15 	stw	r2,-24(fp)
 4005460:	e0bffd17 	ldw	r2,-12(fp)
 4005464:	e0fffa17 	ldw	r3,-24(fp)
 4005468:	10c00215 	stw	r3,8(r2)
 400546c:	e0bffa17 	ldw	r2,-24(fp)
 4005470:	10c00217 	ldw	r3,8(r2)
 4005474:	e0bffd17 	ldw	r2,-12(fp)
 4005478:	10c00315 	stw	r3,12(r2)
 400547c:	e0bffa17 	ldw	r2,-24(fp)
 4005480:	10800217 	ldw	r2,8(r2)
 4005484:	e0fffd17 	ldw	r3,-12(fp)
 4005488:	18c00104 	addi	r3,r3,4
 400548c:	10c00115 	stw	r3,4(r2)
 4005490:	e0bffd17 	ldw	r2,-12(fp)
 4005494:	10c00104 	addi	r3,r2,4
 4005498:	e0bffa17 	ldw	r2,-24(fp)
 400549c:	10c00215 	stw	r3,8(r2)
 40054a0:	e0bffd17 	ldw	r2,-12(fp)
 40054a4:	10800b17 	ldw	r2,44(r2)
 40054a8:	01400504 	movi	r5,20
 40054ac:	1009883a 	mov	r4,r2
 40054b0:	40078580 	call	4007858 <__mulsi3>
 40054b4:	1007883a 	mov	r3,r2
 40054b8:	00812074 	movhi	r2,1153
 40054bc:	10807604 	addi	r2,r2,472
 40054c0:	1887883a 	add	r3,r3,r2
 40054c4:	e0bffd17 	ldw	r2,-12(fp)
 40054c8:	10c00515 	stw	r3,20(r2)
 40054cc:	e0bffd17 	ldw	r2,-12(fp)
 40054d0:	14400b17 	ldw	r17,44(r2)
 40054d4:	01400504 	movi	r5,20
 40054d8:	8809883a 	mov	r4,r17
 40054dc:	40078580 	call	4007858 <__mulsi3>
 40054e0:	1007883a 	mov	r3,r2
 40054e4:	00812074 	movhi	r2,1153
 40054e8:	1885883a 	add	r2,r3,r2
 40054ec:	10807617 	ldw	r2,472(r2)
 40054f0:	14000044 	addi	r16,r2,1
 40054f4:	01400504 	movi	r5,20
 40054f8:	8809883a 	mov	r4,r17
 40054fc:	40078580 	call	4007858 <__mulsi3>
 4005500:	1007883a 	mov	r3,r2
 4005504:	00812074 	movhi	r2,1153
 4005508:	1885883a 	add	r2,r3,r2
 400550c:	14007615 	stw	r16,472(r2)

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 4005510:	e0bffd17 	ldw	r2,-12(fp)
 4005514:	10800b17 	ldw	r2,44(r2)
 4005518:	d0e6ad17 	ldw	r3,-25932(gp)
 400551c:	18c00b17 	ldw	r3,44(r3)
 4005520:	1880022e 	bgeu	r3,r2,400552c <vTaskRemoveFromUnorderedEventList+0x230>
    {
        /* The unblocked task has a priority above that of the calling task, so
         * a context switch is required.  This function is called with the
         * scheduler suspended so xYieldPending is set so the context switch
         * occurs immediately that the scheduler is resumed (unsuspended). */
        xYieldPending = pdTRUE;
 4005524:	00800044 	movi	r2,1
 4005528:	d0a6b615 	stw	r2,-25896(gp)
    }
}
 400552c:	0001883a 	nop
 4005530:	e6fffe04 	addi	sp,fp,-8
 4005534:	dfc00317 	ldw	ra,12(sp)
 4005538:	df000217 	ldw	fp,8(sp)
 400553c:	dc400117 	ldw	r17,4(sp)
 4005540:	dc000017 	ldw	r16,0(sp)
 4005544:	dec00404 	addi	sp,sp,16
 4005548:	f800283a 	ret

0400554c <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
 400554c:	defffd04 	addi	sp,sp,-12
 4005550:	dfc00215 	stw	ra,8(sp)
 4005554:	df000115 	stw	fp,4(sp)
 4005558:	df000104 	addi	fp,sp,4
 400555c:	e13fff15 	stw	r4,-4(fp)
    configASSERT( pxTimeOut );
    taskENTER_CRITICAL();
 4005560:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
    {
        pxTimeOut->xOverflowCount = xNumOfOverflows;
 4005564:	d0e6b717 	ldw	r3,-25892(gp)
 4005568:	e0bfff17 	ldw	r2,-4(fp)
 400556c:	10c00015 	stw	r3,0(r2)
        pxTimeOut->xTimeOnEntering = xTickCount;
 4005570:	d0e6b217 	ldw	r3,-25912(gp)
 4005574:	e0bfff17 	ldw	r2,-4(fp)
 4005578:	10c00115 	stw	r3,4(r2)
    }
    taskEXIT_CRITICAL();
 400557c:	4005fd00 	call	4005fd0 <vTaskExitCritical>
}
 4005580:	0001883a 	nop
 4005584:	e037883a 	mov	sp,fp
 4005588:	dfc00117 	ldw	ra,4(sp)
 400558c:	df000017 	ldw	fp,0(sp)
 4005590:	dec00204 	addi	sp,sp,8
 4005594:	f800283a 	ret

04005598 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
 4005598:	defffe04 	addi	sp,sp,-8
 400559c:	df000115 	stw	fp,4(sp)
 40055a0:	df000104 	addi	fp,sp,4
 40055a4:	e13fff15 	stw	r4,-4(fp)
    /* For internal use only as it does not use a critical section. */
    pxTimeOut->xOverflowCount = xNumOfOverflows;
 40055a8:	d0e6b717 	ldw	r3,-25892(gp)
 40055ac:	e0bfff17 	ldw	r2,-4(fp)
 40055b0:	10c00015 	stw	r3,0(r2)
    pxTimeOut->xTimeOnEntering = xTickCount;
 40055b4:	d0e6b217 	ldw	r3,-25912(gp)
 40055b8:	e0bfff17 	ldw	r2,-4(fp)
 40055bc:	10c00115 	stw	r3,4(r2)
}
 40055c0:	0001883a 	nop
 40055c4:	e037883a 	mov	sp,fp
 40055c8:	df000017 	ldw	fp,0(sp)
 40055cc:	dec00104 	addi	sp,sp,4
 40055d0:	f800283a 	ret

040055d4 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,
                                 TickType_t * const pxTicksToWait )
{
 40055d4:	defff904 	addi	sp,sp,-28
 40055d8:	dfc00615 	stw	ra,24(sp)
 40055dc:	df000515 	stw	fp,20(sp)
 40055e0:	df000504 	addi	fp,sp,20
 40055e4:	e13ffc15 	stw	r4,-16(fp)
 40055e8:	e17ffb15 	stw	r5,-20(fp)
    BaseType_t xReturn;

    configASSERT( pxTimeOut );
    configASSERT( pxTicksToWait );

    taskENTER_CRITICAL();
 40055ec:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
 40055f0:	d0a6b217 	ldw	r2,-25912(gp)
 40055f4:	e0bffe15 	stw	r2,-8(fp)
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 40055f8:	e0bffc17 	ldw	r2,-16(fp)
 40055fc:	10800117 	ldw	r2,4(r2)
 4005600:	e0fffe17 	ldw	r3,-8(fp)
 4005604:	1885c83a 	sub	r2,r3,r2
 4005608:	e0bffd15 	stw	r2,-12(fp)
            }
            else
        #endif

        #if ( INCLUDE_vTaskSuspend == 1 )
            if( *pxTicksToWait == portMAX_DELAY )
 400560c:	e0bffb17 	ldw	r2,-20(fp)
 4005610:	10800017 	ldw	r2,0(r2)
 4005614:	10bfffd8 	cmpnei	r2,r2,-1
 4005618:	1000021e 	bne	r2,zero,4005624 <xTaskCheckForTimeOut+0x50>
            {
                /* If INCLUDE_vTaskSuspend is set to 1 and the block time
                 * specified is the maximum block time then the task should block
                 * indefinitely, and therefore never time out. */
                xReturn = pdFALSE;
 400561c:	e03fff15 	stw	zero,-4(fp)
 4005620:	00001f06 	br	40056a0 <xTaskCheckForTimeOut+0xcc>
            }
            else
        #endif

        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 4005624:	e0bffc17 	ldw	r2,-16(fp)
 4005628:	10c00017 	ldw	r3,0(r2)
 400562c:	d0a6b717 	ldw	r2,-25892(gp)
 4005630:	18800926 	beq	r3,r2,4005658 <xTaskCheckForTimeOut+0x84>
 4005634:	e0bffc17 	ldw	r2,-16(fp)
 4005638:	10800117 	ldw	r2,4(r2)
 400563c:	e0fffe17 	ldw	r3,-8(fp)
 4005640:	18800536 	bltu	r3,r2,4005658 <xTaskCheckForTimeOut+0x84>
            /* The tick count is greater than the time at which
             * vTaskSetTimeout() was called, but has also overflowed since
             * vTaskSetTimeOut() was called.  It must have wrapped all the way
             * around and gone past again. This passed since vTaskSetTimeout()
             * was called. */
            xReturn = pdTRUE;
 4005644:	00800044 	movi	r2,1
 4005648:	e0bfff15 	stw	r2,-4(fp)
            *pxTicksToWait = ( TickType_t ) 0;
 400564c:	e0bffb17 	ldw	r2,-20(fp)
 4005650:	10000015 	stw	zero,0(r2)
 4005654:	00001206 	br	40056a0 <xTaskCheckForTimeOut+0xcc>
        }
        else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
 4005658:	e0bffb17 	ldw	r2,-20(fp)
 400565c:	10800017 	ldw	r2,0(r2)
 4005660:	e0fffd17 	ldw	r3,-12(fp)
 4005664:	18800a2e 	bgeu	r3,r2,4005690 <xTaskCheckForTimeOut+0xbc>
        {
            /* Not a genuine timeout. Adjust parameters for time remaining. */
            *pxTicksToWait -= xElapsedTime;
 4005668:	e0bffb17 	ldw	r2,-20(fp)
 400566c:	10c00017 	ldw	r3,0(r2)
 4005670:	e0bffd17 	ldw	r2,-12(fp)
 4005674:	1887c83a 	sub	r3,r3,r2
 4005678:	e0bffb17 	ldw	r2,-20(fp)
 400567c:	10c00015 	stw	r3,0(r2)
            vTaskInternalSetTimeOutState( pxTimeOut );
 4005680:	e13ffc17 	ldw	r4,-16(fp)
 4005684:	40055980 	call	4005598 <vTaskInternalSetTimeOutState>
            xReturn = pdFALSE;
 4005688:	e03fff15 	stw	zero,-4(fp)
 400568c:	00000406 	br	40056a0 <xTaskCheckForTimeOut+0xcc>
        }
        else
        {
            *pxTicksToWait = ( TickType_t ) 0;
 4005690:	e0bffb17 	ldw	r2,-20(fp)
 4005694:	10000015 	stw	zero,0(r2)
            xReturn = pdTRUE;
 4005698:	00800044 	movi	r2,1
 400569c:	e0bfff15 	stw	r2,-4(fp)
        }
    }
    taskEXIT_CRITICAL();
 40056a0:	4005fd00 	call	4005fd0 <vTaskExitCritical>

    return xReturn;
 40056a4:	e0bfff17 	ldw	r2,-4(fp)
}
 40056a8:	e037883a 	mov	sp,fp
 40056ac:	dfc00117 	ldw	ra,4(sp)
 40056b0:	df000017 	ldw	fp,0(sp)
 40056b4:	dec00204 	addi	sp,sp,8
 40056b8:	f800283a 	ret

040056bc <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
 40056bc:	deffff04 	addi	sp,sp,-4
 40056c0:	df000015 	stw	fp,0(sp)
 40056c4:	d839883a 	mov	fp,sp
    xYieldPending = pdTRUE;
 40056c8:	00800044 	movi	r2,1
 40056cc:	d0a6b615 	stw	r2,-25896(gp)
}
 40056d0:	0001883a 	nop
 40056d4:	e037883a 	mov	sp,fp
 40056d8:	df000017 	ldw	fp,0(sp)
 40056dc:	dec00104 	addi	sp,sp,4
 40056e0:	f800283a 	ret

040056e4 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
 40056e4:	defffd04 	addi	sp,sp,-12
 40056e8:	dfc00215 	stw	ra,8(sp)
 40056ec:	df000115 	stw	fp,4(sp)
 40056f0:	df000104 	addi	fp,sp,4
 40056f4:	e13fff15 	stw	r4,-4(fp)

    for( ; ; )
    {
        /* See if any tasks have deleted themselves - if so then the idle task
         * is responsible for freeing the deleted task's TCB and stack. */
        prvCheckTasksWaitingTermination();
 40056f8:	40057c00 	call	40057c0 <prvCheckTasksWaitingTermination>
 40056fc:	003ffe06 	br	40056f8 <prvIdleTask+0x14>

04005700 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
 4005700:	defffd04 	addi	sp,sp,-12
 4005704:	dfc00215 	stw	ra,8(sp)
 4005708:	df000115 	stw	fp,4(sp)
 400570c:	df000104 	addi	fp,sp,4
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 4005710:	e03fff15 	stw	zero,-4(fp)
 4005714:	00000c06 	br	4005748 <prvInitialiseTaskLists+0x48>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 4005718:	01400504 	movi	r5,20
 400571c:	e13fff17 	ldw	r4,-4(fp)
 4005720:	40078580 	call	4007858 <__mulsi3>
 4005724:	1007883a 	mov	r3,r2
 4005728:	00812074 	movhi	r2,1153
 400572c:	10807604 	addi	r2,r2,472
 4005730:	1885883a 	add	r2,r3,r2
 4005734:	1009883a 	mov	r4,r2
 4005738:	4000aa00 	call	4000aa0 <vListInitialise>
    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 400573c:	e0bfff17 	ldw	r2,-4(fp)
 4005740:	10800044 	addi	r2,r2,1
 4005744:	e0bfff15 	stw	r2,-4(fp)
 4005748:	e0bfff17 	ldw	r2,-4(fp)
 400574c:	10800170 	cmpltui	r2,r2,5
 4005750:	103ff11e 	bne	r2,zero,4005718 <prvInitialiseTaskLists+0x18>
    }

    vListInitialise( &xDelayedTaskList1 );
 4005754:	01012074 	movhi	r4,1153
 4005758:	21008f04 	addi	r4,r4,572
 400575c:	4000aa00 	call	4000aa0 <vListInitialise>
    vListInitialise( &xDelayedTaskList2 );
 4005760:	01012074 	movhi	r4,1153
 4005764:	21009404 	addi	r4,r4,592
 4005768:	4000aa00 	call	4000aa0 <vListInitialise>
    vListInitialise( &xPendingReadyList );
 400576c:	01012074 	movhi	r4,1153
 4005770:	21009904 	addi	r4,r4,612
 4005774:	4000aa00 	call	4000aa0 <vListInitialise>

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        vListInitialise( &xTasksWaitingTermination );
 4005778:	01012074 	movhi	r4,1153
 400577c:	21009e04 	addi	r4,r4,632
 4005780:	4000aa00 	call	4000aa0 <vListInitialise>
    }
    #endif /* INCLUDE_vTaskDelete */

    #if ( INCLUDE_vTaskSuspend == 1 )
    {
        vListInitialise( &xSuspendedTaskList );
 4005784:	01012074 	movhi	r4,1153
 4005788:	2100a304 	addi	r4,r4,652
 400578c:	4000aa00 	call	4000aa0 <vListInitialise>
    }
    #endif /* INCLUDE_vTaskSuspend */

    /* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
     * using list2. */
    pxDelayedTaskList = &xDelayedTaskList1;
 4005790:	00812074 	movhi	r2,1153
 4005794:	10808f04 	addi	r2,r2,572
 4005798:	d0a6ae15 	stw	r2,-25928(gp)
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
 400579c:	00812074 	movhi	r2,1153
 40057a0:	10809404 	addi	r2,r2,592
 40057a4:	d0a6af15 	stw	r2,-25924(gp)
}
 40057a8:	0001883a 	nop
 40057ac:	e037883a 	mov	sp,fp
 40057b0:	dfc00117 	ldw	ra,4(sp)
 40057b4:	df000017 	ldw	fp,0(sp)
 40057b8:	dec00204 	addi	sp,sp,8
 40057bc:	f800283a 	ret

040057c0 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
 40057c0:	defffd04 	addi	sp,sp,-12
 40057c4:	dfc00215 	stw	ra,8(sp)
 40057c8:	df000115 	stw	fp,4(sp)
 40057cc:	df000104 	addi	fp,sp,4
    {
        TCB_t * pxTCB;

        /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
         * being called too often in the idle task. */
        while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 40057d0:	00001206 	br	400581c <prvCheckTasksWaitingTermination+0x5c>
        {
            taskENTER_CRITICAL();
 40057d4:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
            {
                pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 40057d8:	00812074 	movhi	r2,1153
 40057dc:	1080a117 	ldw	r2,644(r2)
 40057e0:	10800317 	ldw	r2,12(r2)
 40057e4:	e0bfff15 	stw	r2,-4(fp)
                ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 40057e8:	e0bfff17 	ldw	r2,-4(fp)
 40057ec:	10800104 	addi	r2,r2,4
 40057f0:	1009883a 	mov	r4,r2
 40057f4:	4000c980 	call	4000c98 <uxListRemove>
                --uxCurrentNumberOfTasks;
 40057f8:	d0a6b117 	ldw	r2,-25916(gp)
 40057fc:	10bfffc4 	addi	r2,r2,-1
 4005800:	d0a6b115 	stw	r2,-25916(gp)
                --uxDeletedTasksWaitingCleanUp;
 4005804:	d0a6b017 	ldw	r2,-25920(gp)
 4005808:	10bfffc4 	addi	r2,r2,-1
 400580c:	d0a6b015 	stw	r2,-25920(gp)
            }
            taskEXIT_CRITICAL();
 4005810:	4005fd00 	call	4005fd0 <vTaskExitCritical>

            prvDeleteTCB( pxTCB );
 4005814:	e13fff17 	ldw	r4,-4(fp)
 4005818:	40059040 	call	4005904 <prvDeleteTCB>
        while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 400581c:	d0a6b017 	ldw	r2,-25920(gp)
 4005820:	103fec1e 	bne	r2,zero,40057d4 <prvCheckTasksWaitingTermination+0x14>
        }
    }
    #endif /* INCLUDE_vTaskDelete */
}
 4005824:	0001883a 	nop
 4005828:	0001883a 	nop
 400582c:	e037883a 	mov	sp,fp
 4005830:	dfc00117 	ldw	ra,4(sp)
 4005834:	df000017 	ldw	fp,0(sp)
 4005838:	dec00204 	addi	sp,sp,8
 400583c:	f800283a 	ret

04005840 <prvTaskCheckFreeStackSpace>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark2 == 1 ) )

    static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
    {
 4005840:	defffd04 	addi	sp,sp,-12
 4005844:	df000215 	stw	fp,8(sp)
 4005848:	df000204 	addi	fp,sp,8
 400584c:	e13ffe15 	stw	r4,-8(fp)
        uint32_t ulCount = 0U;
 4005850:	e03fff15 	stw	zero,-4(fp)

        while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
 4005854:	00000606 	br	4005870 <prvTaskCheckFreeStackSpace+0x30>
        {
            pucStackByte -= portSTACK_GROWTH;
 4005858:	e0bffe17 	ldw	r2,-8(fp)
 400585c:	10800044 	addi	r2,r2,1
 4005860:	e0bffe15 	stw	r2,-8(fp)
            ulCount++;
 4005864:	e0bfff17 	ldw	r2,-4(fp)
 4005868:	10800044 	addi	r2,r2,1
 400586c:	e0bfff15 	stw	r2,-4(fp)
        while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
 4005870:	e0bffe17 	ldw	r2,-8(fp)
 4005874:	10800003 	ldbu	r2,0(r2)
 4005878:	10803fcc 	andi	r2,r2,255
 400587c:	10802960 	cmpeqi	r2,r2,165
 4005880:	103ff51e 	bne	r2,zero,4005858 <prvTaskCheckFreeStackSpace+0x18>
        }

        ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller architectures. */
 4005884:	e0bfff17 	ldw	r2,-4(fp)
 4005888:	1004d0ba 	srli	r2,r2,2
 400588c:	e0bfff15 	stw	r2,-4(fp)

        return ( configSTACK_DEPTH_TYPE ) ulCount;
 4005890:	e0bfff17 	ldw	r2,-4(fp)
    }
 4005894:	e037883a 	mov	sp,fp
 4005898:	df000017 	ldw	fp,0(sp)
 400589c:	dec00104 	addi	sp,sp,4
 40058a0:	f800283a 	ret

040058a4 <uxTaskGetStackHighWaterMark>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )

    UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
    {
 40058a4:	defffa04 	addi	sp,sp,-24
 40058a8:	dfc00515 	stw	ra,20(sp)
 40058ac:	df000415 	stw	fp,16(sp)
 40058b0:	df000404 	addi	fp,sp,16
 40058b4:	e13ffc15 	stw	r4,-16(fp)
        TCB_t * pxTCB;
        uint8_t * pucEndOfStack;
        UBaseType_t uxReturn;

        pxTCB = prvGetTCBFromHandle( xTask );
 40058b8:	e0bffc17 	ldw	r2,-16(fp)
 40058bc:	1000021e 	bne	r2,zero,40058c8 <uxTaskGetStackHighWaterMark+0x24>
 40058c0:	d0a6ad17 	ldw	r2,-25932(gp)
 40058c4:	00000106 	br	40058cc <uxTaskGetStackHighWaterMark+0x28>
 40058c8:	e0bffc17 	ldw	r2,-16(fp)
 40058cc:	e0bfff15 	stw	r2,-4(fp)

        #if portSTACK_GROWTH < 0
        {
            pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
 40058d0:	e0bfff17 	ldw	r2,-4(fp)
 40058d4:	10800c17 	ldw	r2,48(r2)
 40058d8:	e0bffe15 	stw	r2,-8(fp)
        {
            pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
        }
        #endif

        uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
 40058dc:	e13ffe17 	ldw	r4,-8(fp)
 40058e0:	40058400 	call	4005840 <prvTaskCheckFreeStackSpace>
 40058e4:	10bfffcc 	andi	r2,r2,65535
 40058e8:	e0bffd15 	stw	r2,-12(fp)

        return uxReturn;
 40058ec:	e0bffd17 	ldw	r2,-12(fp)
    }
 40058f0:	e037883a 	mov	sp,fp
 40058f4:	dfc00117 	ldw	ra,4(sp)
 40058f8:	df000017 	ldw	fp,0(sp)
 40058fc:	dec00204 	addi	sp,sp,8
 4005900:	f800283a 	ret

04005904 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    static void prvDeleteTCB( TCB_t * pxTCB )
    {
 4005904:	defffd04 	addi	sp,sp,-12
 4005908:	dfc00215 	stw	ra,8(sp)
 400590c:	df000115 	stw	fp,4(sp)
 4005910:	df000104 	addi	fp,sp,4
 4005914:	e13fff15 	stw	r4,-4(fp)

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
        {
            /* The task can only have been allocated dynamically - free both
             * the stack and TCB. */
            vPortFreeStack( pxTCB->pxStack );
 4005918:	e0bfff17 	ldw	r2,-4(fp)
 400591c:	10800c17 	ldw	r2,48(r2)
 4005920:	1009883a 	mov	r4,r2
 4005924:	40011240 	call	4001124 <vPortFree>
            vPortFree( pxTCB );
 4005928:	e13fff17 	ldw	r4,-4(fp)
 400592c:	40011240 	call	4001124 <vPortFree>
                configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB );
                mtCOVERAGE_TEST_MARKER();
            }
        }
        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    }
 4005930:	0001883a 	nop
 4005934:	e037883a 	mov	sp,fp
 4005938:	dfc00117 	ldw	ra,4(sp)
 400593c:	df000017 	ldw	fp,0(sp)
 4005940:	dec00204 	addi	sp,sp,8
 4005944:	f800283a 	ret

04005948 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
 4005948:	deffff04 	addi	sp,sp,-4
 400594c:	df000015 	stw	fp,0(sp)
 4005950:	d839883a 	mov	fp,sp
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 4005954:	d0a6ae17 	ldw	r2,-25928(gp)
 4005958:	10800017 	ldw	r2,0(r2)
 400595c:	1000031e 	bne	r2,zero,400596c <prvResetNextTaskUnblockTime+0x24>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
 4005960:	00bfffc4 	movi	r2,-1
 4005964:	d0a6b915 	stw	r2,-25884(gp)
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    }
}
 4005968:	00000406 	br	400597c <prvResetNextTaskUnblockTime+0x34>
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
 400596c:	d0a6ae17 	ldw	r2,-25928(gp)
 4005970:	10800317 	ldw	r2,12(r2)
 4005974:	10800017 	ldw	r2,0(r2)
 4005978:	d0a6b915 	stw	r2,-25884(gp)
}
 400597c:	0001883a 	nop
 4005980:	e037883a 	mov	sp,fp
 4005984:	df000017 	ldw	fp,0(sp)
 4005988:	dec00104 	addi	sp,sp,4
 400598c:	f800283a 	ret

04005990 <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

    TaskHandle_t xTaskGetCurrentTaskHandle( void )
    {
 4005990:	defffe04 	addi	sp,sp,-8
 4005994:	df000115 	stw	fp,4(sp)
 4005998:	df000104 	addi	fp,sp,4
        TaskHandle_t xReturn;

        /* A critical section is not required as this is not called from
         * an interrupt and the current TCB will always be the same for any
         * individual execution thread. */
        xReturn = pxCurrentTCB;
 400599c:	d0a6ad17 	ldw	r2,-25932(gp)
 40059a0:	e0bfff15 	stw	r2,-4(fp)

        return xReturn;
 40059a4:	e0bfff17 	ldw	r2,-4(fp)
    }
 40059a8:	e037883a 	mov	sp,fp
 40059ac:	df000017 	ldw	fp,0(sp)
 40059b0:	dec00104 	addi	sp,sp,4
 40059b4:	f800283a 	ret

040059b8 <xTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
    {
 40059b8:	defff804 	addi	sp,sp,-32
 40059bc:	dfc00715 	stw	ra,28(sp)
 40059c0:	df000615 	stw	fp,24(sp)
 40059c4:	dc400515 	stw	r17,20(sp)
 40059c8:	dc000415 	stw	r16,16(sp)
 40059cc:	df000604 	addi	fp,sp,24
 40059d0:	e13ffa15 	stw	r4,-24(fp)
        TCB_t * const pxMutexHolderTCB = pxMutexHolder;
 40059d4:	e0bffa17 	ldw	r2,-24(fp)
 40059d8:	e0bffc15 	stw	r2,-16(fp)
        BaseType_t xReturn = pdFALSE;
 40059dc:	e03ffd15 	stw	zero,-12(fp)

        /* If the mutex was given back by an interrupt while the queue was
         * locked then the mutex holder might now be NULL.  _RB_ Is this still
         * needed as interrupts can no longer use mutexes? */
        if( pxMutexHolder != NULL )
 40059e0:	e0bffa17 	ldw	r2,-24(fp)
 40059e4:	10006e26 	beq	r2,zero,4005ba0 <xTaskPriorityInherit+0x1e8>
        {
            /* If the holder of the mutex has a priority below the priority of
             * the task attempting to obtain the mutex then it will temporarily
             * inherit the priority of the task attempting to obtain the mutex. */
            if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
 40059e8:	e0bffc17 	ldw	r2,-16(fp)
 40059ec:	10c00b17 	ldw	r3,44(r2)
 40059f0:	d0a6ad17 	ldw	r2,-25932(gp)
 40059f4:	10800b17 	ldw	r2,44(r2)
 40059f8:	1880622e 	bgeu	r3,r2,4005b84 <xTaskPriorityInherit+0x1cc>
            {
                /* Adjust the mutex holder state to account for its new
                 * priority.  Only reset the event list item value if the value is
                 * not being used for anything else. */
                if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 40059fc:	e0bffc17 	ldw	r2,-16(fp)
 4005a00:	10800617 	ldw	r2,24(r2)
 4005a04:	10000616 	blt	r2,zero,4005a20 <xTaskPriorityInherit+0x68>
                {
                    listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 4005a08:	d0a6ad17 	ldw	r2,-25932(gp)
 4005a0c:	10800b17 	ldw	r2,44(r2)
 4005a10:	00c00144 	movi	r3,5
 4005a14:	1887c83a 	sub	r3,r3,r2
 4005a18:	e0bffc17 	ldw	r2,-16(fp)
 4005a1c:	10c00615 	stw	r3,24(r2)
                    mtCOVERAGE_TEST_MARKER();
                }

                /* If the task being modified is in the ready state it will need
                 * to be moved into a new list. */
                if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
 4005a20:	e0bffc17 	ldw	r2,-16(fp)
 4005a24:	14000517 	ldw	r16,20(r2)
 4005a28:	e0bffc17 	ldw	r2,-16(fp)
 4005a2c:	10800b17 	ldw	r2,44(r2)
 4005a30:	01400504 	movi	r5,20
 4005a34:	1009883a 	mov	r4,r2
 4005a38:	40078580 	call	4007858 <__mulsi3>
 4005a3c:	1007883a 	mov	r3,r2
 4005a40:	00812074 	movhi	r2,1153
 4005a44:	10807604 	addi	r2,r2,472
 4005a48:	1885883a 	add	r2,r3,r2
 4005a4c:	8080461e 	bne	r16,r2,4005b68 <xTaskPriorityInherit+0x1b0>
                {
                    if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 4005a50:	e0bffc17 	ldw	r2,-16(fp)
 4005a54:	10800104 	addi	r2,r2,4
 4005a58:	1009883a 	mov	r4,r2
 4005a5c:	4000c980 	call	4000c98 <uxListRemove>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Inherit the priority before being moved into the new list. */
                    pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 4005a60:	d0a6ad17 	ldw	r2,-25932(gp)
 4005a64:	10c00b17 	ldw	r3,44(r2)
 4005a68:	e0bffc17 	ldw	r2,-16(fp)
 4005a6c:	10c00b15 	stw	r3,44(r2)
                    prvAddTaskToReadyList( pxMutexHolderTCB );
 4005a70:	e0bffc17 	ldw	r2,-16(fp)
 4005a74:	10800b17 	ldw	r2,44(r2)
 4005a78:	d0e6b317 	ldw	r3,-25908(gp)
 4005a7c:	1880032e 	bgeu	r3,r2,4005a8c <xTaskPriorityInherit+0xd4>
 4005a80:	e0bffc17 	ldw	r2,-16(fp)
 4005a84:	10800b17 	ldw	r2,44(r2)
 4005a88:	d0a6b315 	stw	r2,-25908(gp)
 4005a8c:	e0bffc17 	ldw	r2,-16(fp)
 4005a90:	10800b17 	ldw	r2,44(r2)
 4005a94:	01400504 	movi	r5,20
 4005a98:	1009883a 	mov	r4,r2
 4005a9c:	40078580 	call	4007858 <__mulsi3>
 4005aa0:	1007883a 	mov	r3,r2
 4005aa4:	00812074 	movhi	r2,1153
 4005aa8:	1885883a 	add	r2,r3,r2
 4005aac:	10807717 	ldw	r2,476(r2)
 4005ab0:	e0bffb15 	stw	r2,-20(fp)
 4005ab4:	e0bffc17 	ldw	r2,-16(fp)
 4005ab8:	e0fffb17 	ldw	r3,-20(fp)
 4005abc:	10c00215 	stw	r3,8(r2)
 4005ac0:	e0bffb17 	ldw	r2,-20(fp)
 4005ac4:	10c00217 	ldw	r3,8(r2)
 4005ac8:	e0bffc17 	ldw	r2,-16(fp)
 4005acc:	10c00315 	stw	r3,12(r2)
 4005ad0:	e0bffb17 	ldw	r2,-20(fp)
 4005ad4:	10800217 	ldw	r2,8(r2)
 4005ad8:	e0fffc17 	ldw	r3,-16(fp)
 4005adc:	18c00104 	addi	r3,r3,4
 4005ae0:	10c00115 	stw	r3,4(r2)
 4005ae4:	e0bffc17 	ldw	r2,-16(fp)
 4005ae8:	10c00104 	addi	r3,r2,4
 4005aec:	e0bffb17 	ldw	r2,-20(fp)
 4005af0:	10c00215 	stw	r3,8(r2)
 4005af4:	e0bffc17 	ldw	r2,-16(fp)
 4005af8:	10800b17 	ldw	r2,44(r2)
 4005afc:	01400504 	movi	r5,20
 4005b00:	1009883a 	mov	r4,r2
 4005b04:	40078580 	call	4007858 <__mulsi3>
 4005b08:	1007883a 	mov	r3,r2
 4005b0c:	00812074 	movhi	r2,1153
 4005b10:	10807604 	addi	r2,r2,472
 4005b14:	1887883a 	add	r3,r3,r2
 4005b18:	e0bffc17 	ldw	r2,-16(fp)
 4005b1c:	10c00515 	stw	r3,20(r2)
 4005b20:	e0bffc17 	ldw	r2,-16(fp)
 4005b24:	14400b17 	ldw	r17,44(r2)
 4005b28:	01400504 	movi	r5,20
 4005b2c:	8809883a 	mov	r4,r17
 4005b30:	40078580 	call	4007858 <__mulsi3>
 4005b34:	1007883a 	mov	r3,r2
 4005b38:	00812074 	movhi	r2,1153
 4005b3c:	1885883a 	add	r2,r3,r2
 4005b40:	10807617 	ldw	r2,472(r2)
 4005b44:	14000044 	addi	r16,r2,1
 4005b48:	01400504 	movi	r5,20
 4005b4c:	8809883a 	mov	r4,r17
 4005b50:	40078580 	call	4007858 <__mulsi3>
 4005b54:	1007883a 	mov	r3,r2
 4005b58:	00812074 	movhi	r2,1153
 4005b5c:	1885883a 	add	r2,r3,r2
 4005b60:	14007615 	stw	r16,472(r2)
 4005b64:	00000406 	br	4005b78 <xTaskPriorityInherit+0x1c0>
                }
                else
                {
                    /* Just inherit the priority. */
                    pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 4005b68:	d0a6ad17 	ldw	r2,-25932(gp)
 4005b6c:	10c00b17 	ldw	r3,44(r2)
 4005b70:	e0bffc17 	ldw	r2,-16(fp)
 4005b74:	10c00b15 	stw	r3,44(r2)
                }

                traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );

                /* Inheritance occurred. */
                xReturn = pdTRUE;
 4005b78:	00800044 	movi	r2,1
 4005b7c:	e0bffd15 	stw	r2,-12(fp)
 4005b80:	00000706 	br	4005ba0 <xTaskPriorityInherit+0x1e8>
            }
            else
            {
                if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
 4005b84:	e0bffc17 	ldw	r2,-16(fp)
 4005b88:	10c01017 	ldw	r3,64(r2)
 4005b8c:	d0a6ad17 	ldw	r2,-25932(gp)
 4005b90:	10800b17 	ldw	r2,44(r2)
 4005b94:	1880022e 	bgeu	r3,r2,4005ba0 <xTaskPriorityInherit+0x1e8>
                     * current priority of the mutex holder is not lower than the
                     * priority of the task attempting to take the mutex.
                     * Therefore the mutex holder must have already inherited a
                     * priority, but inheritance would have occurred if that had
                     * not been the case. */
                    xReturn = pdTRUE;
 4005b98:	00800044 	movi	r2,1
 4005b9c:	e0bffd15 	stw	r2,-12(fp)
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
 4005ba0:	e0bffd17 	ldw	r2,-12(fp)
    }
 4005ba4:	e6fffe04 	addi	sp,fp,-8
 4005ba8:	dfc00317 	ldw	ra,12(sp)
 4005bac:	df000217 	ldw	fp,8(sp)
 4005bb0:	dc400117 	ldw	r17,4(sp)
 4005bb4:	dc000017 	ldw	r16,0(sp)
 4005bb8:	dec00404 	addi	sp,sp,16
 4005bbc:	f800283a 	ret

04005bc0 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
 4005bc0:	defff804 	addi	sp,sp,-32
 4005bc4:	dfc00715 	stw	ra,28(sp)
 4005bc8:	df000615 	stw	fp,24(sp)
 4005bcc:	dc400515 	stw	r17,20(sp)
 4005bd0:	dc000415 	stw	r16,16(sp)
 4005bd4:	df000604 	addi	fp,sp,24
 4005bd8:	e13ffa15 	stw	r4,-24(fp)
        TCB_t * const pxTCB = pxMutexHolder;
 4005bdc:	e0bffa17 	ldw	r2,-24(fp)
 4005be0:	e0bffc15 	stw	r2,-16(fp)
        BaseType_t xReturn = pdFALSE;
 4005be4:	e03ffd15 	stw	zero,-12(fp)

        if( pxMutexHolder != NULL )
 4005be8:	e0bffa17 	ldw	r2,-24(fp)
 4005bec:	10005a26 	beq	r2,zero,4005d58 <xTaskPriorityDisinherit+0x198>
             * If the mutex is held by a task then it cannot be given from an
             * interrupt, and if a mutex is given by the holding task then it must
             * be the running state task. */
            configASSERT( pxTCB == pxCurrentTCB );
            configASSERT( pxTCB->uxMutexesHeld );
            ( pxTCB->uxMutexesHeld )--;
 4005bf0:	e0bffc17 	ldw	r2,-16(fp)
 4005bf4:	10801117 	ldw	r2,68(r2)
 4005bf8:	10ffffc4 	addi	r3,r2,-1
 4005bfc:	e0bffc17 	ldw	r2,-16(fp)
 4005c00:	10c01115 	stw	r3,68(r2)

            /* Has the holder of the mutex inherited the priority of another
             * task? */
            if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 4005c04:	e0bffc17 	ldw	r2,-16(fp)
 4005c08:	10c00b17 	ldw	r3,44(r2)
 4005c0c:	e0bffc17 	ldw	r2,-16(fp)
 4005c10:	10801017 	ldw	r2,64(r2)
 4005c14:	18805026 	beq	r3,r2,4005d58 <xTaskPriorityDisinherit+0x198>
            {
                /* Only disinherit if no other mutexes are held. */
                if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
 4005c18:	e0bffc17 	ldw	r2,-16(fp)
 4005c1c:	10801117 	ldw	r2,68(r2)
 4005c20:	10004d1e 	bne	r2,zero,4005d58 <xTaskPriorityDisinherit+0x198>
                    /* A task can only have an inherited priority if it holds
                     * the mutex.  If the mutex is held by a task then it cannot be
                     * given from an interrupt, and if a mutex is given by the
                     * holding task then it must be the running state task.  Remove
                     * the holding task from the ready list. */
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 4005c24:	e0bffc17 	ldw	r2,-16(fp)
 4005c28:	10800104 	addi	r2,r2,4
 4005c2c:	1009883a 	mov	r4,r2
 4005c30:	4000c980 	call	4000c98 <uxListRemove>
                    }

                    /* Disinherit the priority before adding the task into the
                     * new  ready list. */
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
                    pxTCB->uxPriority = pxTCB->uxBasePriority;
 4005c34:	e0bffc17 	ldw	r2,-16(fp)
 4005c38:	10c01017 	ldw	r3,64(r2)
 4005c3c:	e0bffc17 	ldw	r2,-16(fp)
 4005c40:	10c00b15 	stw	r3,44(r2)

                    /* Reset the event list item value.  It cannot be in use for
                     * any other purpose if this task is running, and it must be
                     * running to give back the mutex. */
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 4005c44:	e0bffc17 	ldw	r2,-16(fp)
 4005c48:	10800b17 	ldw	r2,44(r2)
 4005c4c:	00c00144 	movi	r3,5
 4005c50:	1887c83a 	sub	r3,r3,r2
 4005c54:	e0bffc17 	ldw	r2,-16(fp)
 4005c58:	10c00615 	stw	r3,24(r2)
                    prvAddTaskToReadyList( pxTCB );
 4005c5c:	e0bffc17 	ldw	r2,-16(fp)
 4005c60:	10800b17 	ldw	r2,44(r2)
 4005c64:	d0e6b317 	ldw	r3,-25908(gp)
 4005c68:	1880032e 	bgeu	r3,r2,4005c78 <xTaskPriorityDisinherit+0xb8>
 4005c6c:	e0bffc17 	ldw	r2,-16(fp)
 4005c70:	10800b17 	ldw	r2,44(r2)
 4005c74:	d0a6b315 	stw	r2,-25908(gp)
 4005c78:	e0bffc17 	ldw	r2,-16(fp)
 4005c7c:	10800b17 	ldw	r2,44(r2)
 4005c80:	01400504 	movi	r5,20
 4005c84:	1009883a 	mov	r4,r2
 4005c88:	40078580 	call	4007858 <__mulsi3>
 4005c8c:	1007883a 	mov	r3,r2
 4005c90:	00812074 	movhi	r2,1153
 4005c94:	1885883a 	add	r2,r3,r2
 4005c98:	10807717 	ldw	r2,476(r2)
 4005c9c:	e0bffb15 	stw	r2,-20(fp)
 4005ca0:	e0bffc17 	ldw	r2,-16(fp)
 4005ca4:	e0fffb17 	ldw	r3,-20(fp)
 4005ca8:	10c00215 	stw	r3,8(r2)
 4005cac:	e0bffb17 	ldw	r2,-20(fp)
 4005cb0:	10c00217 	ldw	r3,8(r2)
 4005cb4:	e0bffc17 	ldw	r2,-16(fp)
 4005cb8:	10c00315 	stw	r3,12(r2)
 4005cbc:	e0bffb17 	ldw	r2,-20(fp)
 4005cc0:	10800217 	ldw	r2,8(r2)
 4005cc4:	e0fffc17 	ldw	r3,-16(fp)
 4005cc8:	18c00104 	addi	r3,r3,4
 4005ccc:	10c00115 	stw	r3,4(r2)
 4005cd0:	e0bffc17 	ldw	r2,-16(fp)
 4005cd4:	10c00104 	addi	r3,r2,4
 4005cd8:	e0bffb17 	ldw	r2,-20(fp)
 4005cdc:	10c00215 	stw	r3,8(r2)
 4005ce0:	e0bffc17 	ldw	r2,-16(fp)
 4005ce4:	10800b17 	ldw	r2,44(r2)
 4005ce8:	01400504 	movi	r5,20
 4005cec:	1009883a 	mov	r4,r2
 4005cf0:	40078580 	call	4007858 <__mulsi3>
 4005cf4:	1007883a 	mov	r3,r2
 4005cf8:	00812074 	movhi	r2,1153
 4005cfc:	10807604 	addi	r2,r2,472
 4005d00:	1887883a 	add	r3,r3,r2
 4005d04:	e0bffc17 	ldw	r2,-16(fp)
 4005d08:	10c00515 	stw	r3,20(r2)
 4005d0c:	e0bffc17 	ldw	r2,-16(fp)
 4005d10:	14400b17 	ldw	r17,44(r2)
 4005d14:	01400504 	movi	r5,20
 4005d18:	8809883a 	mov	r4,r17
 4005d1c:	40078580 	call	4007858 <__mulsi3>
 4005d20:	1007883a 	mov	r3,r2
 4005d24:	00812074 	movhi	r2,1153
 4005d28:	1885883a 	add	r2,r3,r2
 4005d2c:	10807617 	ldw	r2,472(r2)
 4005d30:	14000044 	addi	r16,r2,1
 4005d34:	01400504 	movi	r5,20
 4005d38:	8809883a 	mov	r4,r17
 4005d3c:	40078580 	call	4007858 <__mulsi3>
 4005d40:	1007883a 	mov	r3,r2
 4005d44:	00812074 	movhi	r2,1153
 4005d48:	1885883a 	add	r2,r3,r2
 4005d4c:	14007615 	stw	r16,472(r2)
                     * in an order different to that in which they were taken.
                     * If a context switch did not occur when the first mutex was
                     * returned, even if a task was waiting on it, then a context
                     * switch should occur when the last mutex is returned whether
                     * a task is waiting on it or not. */
                    xReturn = pdTRUE;
 4005d50:	00800044 	movi	r2,1
 4005d54:	e0bffd15 	stw	r2,-12(fp)
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
 4005d58:	e0bffd17 	ldw	r2,-12(fp)
    }
 4005d5c:	e6fffe04 	addi	sp,fp,-8
 4005d60:	dfc00317 	ldw	ra,12(sp)
 4005d64:	df000217 	ldw	fp,8(sp)
 4005d68:	dc400117 	ldw	r17,4(sp)
 4005d6c:	dc000017 	ldw	r16,0(sp)
 4005d70:	dec00404 	addi	sp,sp,16
 4005d74:	f800283a 	ret

04005d78 <vTaskPriorityDisinheritAfterTimeout>:

#if ( configUSE_MUTEXES == 1 )

    void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder,
                                              UBaseType_t uxHighestPriorityWaitingTask )
    {
 4005d78:	defff504 	addi	sp,sp,-44
 4005d7c:	dfc00a15 	stw	ra,40(sp)
 4005d80:	df000915 	stw	fp,36(sp)
 4005d84:	dc400815 	stw	r17,32(sp)
 4005d88:	dc000715 	stw	r16,28(sp)
 4005d8c:	df000904 	addi	fp,sp,36
 4005d90:	e13ff815 	stw	r4,-32(fp)
 4005d94:	e17ff715 	stw	r5,-36(fp)
        TCB_t * const pxTCB = pxMutexHolder;
 4005d98:	e0bff817 	ldw	r2,-32(fp)
 4005d9c:	e0bffc15 	stw	r2,-16(fp)
        UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
        const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
 4005da0:	00800044 	movi	r2,1
 4005da4:	e0bffb15 	stw	r2,-20(fp)

        if( pxMutexHolder != NULL )
 4005da8:	e0bff817 	ldw	r2,-32(fp)
 4005dac:	10006b26 	beq	r2,zero,4005f5c <vTaskPriorityDisinheritAfterTimeout+0x1e4>

            /* Determine the priority to which the priority of the task that
             * holds the mutex should be set.  This will be the greater of the
             * holding task's base priority and the priority of the highest
             * priority task that is waiting to obtain the mutex. */
            if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
 4005db0:	e0bffc17 	ldw	r2,-16(fp)
 4005db4:	10c01017 	ldw	r3,64(r2)
 4005db8:	e0bff717 	ldw	r2,-36(fp)
 4005dbc:	1880032e 	bgeu	r3,r2,4005dcc <vTaskPriorityDisinheritAfterTimeout+0x54>
            {
                uxPriorityToUse = uxHighestPriorityWaitingTask;
 4005dc0:	e0bff717 	ldw	r2,-36(fp)
 4005dc4:	e0bffd15 	stw	r2,-12(fp)
 4005dc8:	00000306 	br	4005dd8 <vTaskPriorityDisinheritAfterTimeout+0x60>
            }
            else
            {
                uxPriorityToUse = pxTCB->uxBasePriority;
 4005dcc:	e0bffc17 	ldw	r2,-16(fp)
 4005dd0:	10801017 	ldw	r2,64(r2)
 4005dd4:	e0bffd15 	stw	r2,-12(fp)
            }

            /* Does the priority need to change? */
            if( pxTCB->uxPriority != uxPriorityToUse )
 4005dd8:	e0bffc17 	ldw	r2,-16(fp)
 4005ddc:	10800b17 	ldw	r2,44(r2)
 4005de0:	e0fffd17 	ldw	r3,-12(fp)
 4005de4:	18805d26 	beq	r3,r2,4005f5c <vTaskPriorityDisinheritAfterTimeout+0x1e4>
            {
                /* Only disinherit if no other mutexes are held.  This is a
                 * simplification in the priority inheritance implementation.  If
                 * the task that holds the mutex is also holding other mutexes then
                 * the other mutexes may have caused the priority inheritance. */
                if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
 4005de8:	e0bffc17 	ldw	r2,-16(fp)
 4005dec:	10801117 	ldw	r2,68(r2)
 4005df0:	e0fffb17 	ldw	r3,-20(fp)
 4005df4:	1880591e 	bne	r3,r2,4005f5c <vTaskPriorityDisinheritAfterTimeout+0x1e4>

                    /* Disinherit the priority, remembering the previous
                     * priority to facilitate determining the subject task's
                     * state. */
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, uxPriorityToUse );
                    uxPriorityUsedOnEntry = pxTCB->uxPriority;
 4005df8:	e0bffc17 	ldw	r2,-16(fp)
 4005dfc:	10800b17 	ldw	r2,44(r2)
 4005e00:	e0bffa15 	stw	r2,-24(fp)
                    pxTCB->uxPriority = uxPriorityToUse;
 4005e04:	e0bffc17 	ldw	r2,-16(fp)
 4005e08:	e0fffd17 	ldw	r3,-12(fp)
 4005e0c:	10c00b15 	stw	r3,44(r2)

                    /* Only reset the event list item value if the value is not
                     * being used for anything else. */
                    if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 4005e10:	e0bffc17 	ldw	r2,-16(fp)
 4005e14:	10800617 	ldw	r2,24(r2)
 4005e18:	10000516 	blt	r2,zero,4005e30 <vTaskPriorityDisinheritAfterTimeout+0xb8>
                    {
                        listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 4005e1c:	00c00144 	movi	r3,5
 4005e20:	e0bffd17 	ldw	r2,-12(fp)
 4005e24:	1887c83a 	sub	r3,r3,r2
 4005e28:	e0bffc17 	ldw	r2,-16(fp)
 4005e2c:	10c00615 	stw	r3,24(r2)
                     * then the task that holds the mutex could be in either the
                     * Ready, Blocked or Suspended states.  Only remove the task
                     * from its current state list if it is in the Ready state as
                     * the task's priority is going to change and there is one
                     * Ready list per priority. */
                    if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 4005e30:	e0bffc17 	ldw	r2,-16(fp)
 4005e34:	14000517 	ldw	r16,20(r2)
 4005e38:	01400504 	movi	r5,20
 4005e3c:	e13ffa17 	ldw	r4,-24(fp)
 4005e40:	40078580 	call	4007858 <__mulsi3>
 4005e44:	1007883a 	mov	r3,r2
 4005e48:	00812074 	movhi	r2,1153
 4005e4c:	10807604 	addi	r2,r2,472
 4005e50:	1885883a 	add	r2,r3,r2
 4005e54:	8080411e 	bne	r16,r2,4005f5c <vTaskPriorityDisinheritAfterTimeout+0x1e4>
                    {
                        if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 4005e58:	e0bffc17 	ldw	r2,-16(fp)
 4005e5c:	10800104 	addi	r2,r2,4
 4005e60:	1009883a 	mov	r4,r2
 4005e64:	4000c980 	call	4000c98 <uxListRemove>
                        else
                        {
                            mtCOVERAGE_TEST_MARKER();
                        }

                        prvAddTaskToReadyList( pxTCB );
 4005e68:	e0bffc17 	ldw	r2,-16(fp)
 4005e6c:	10800b17 	ldw	r2,44(r2)
 4005e70:	d0e6b317 	ldw	r3,-25908(gp)
 4005e74:	1880032e 	bgeu	r3,r2,4005e84 <vTaskPriorityDisinheritAfterTimeout+0x10c>
 4005e78:	e0bffc17 	ldw	r2,-16(fp)
 4005e7c:	10800b17 	ldw	r2,44(r2)
 4005e80:	d0a6b315 	stw	r2,-25908(gp)
 4005e84:	e0bffc17 	ldw	r2,-16(fp)
 4005e88:	10800b17 	ldw	r2,44(r2)
 4005e8c:	01400504 	movi	r5,20
 4005e90:	1009883a 	mov	r4,r2
 4005e94:	40078580 	call	4007858 <__mulsi3>
 4005e98:	1007883a 	mov	r3,r2
 4005e9c:	00812074 	movhi	r2,1153
 4005ea0:	1885883a 	add	r2,r3,r2
 4005ea4:	10807717 	ldw	r2,476(r2)
 4005ea8:	e0bff915 	stw	r2,-28(fp)
 4005eac:	e0bffc17 	ldw	r2,-16(fp)
 4005eb0:	e0fff917 	ldw	r3,-28(fp)
 4005eb4:	10c00215 	stw	r3,8(r2)
 4005eb8:	e0bff917 	ldw	r2,-28(fp)
 4005ebc:	10c00217 	ldw	r3,8(r2)
 4005ec0:	e0bffc17 	ldw	r2,-16(fp)
 4005ec4:	10c00315 	stw	r3,12(r2)
 4005ec8:	e0bff917 	ldw	r2,-28(fp)
 4005ecc:	10800217 	ldw	r2,8(r2)
 4005ed0:	e0fffc17 	ldw	r3,-16(fp)
 4005ed4:	18c00104 	addi	r3,r3,4
 4005ed8:	10c00115 	stw	r3,4(r2)
 4005edc:	e0bffc17 	ldw	r2,-16(fp)
 4005ee0:	10c00104 	addi	r3,r2,4
 4005ee4:	e0bff917 	ldw	r2,-28(fp)
 4005ee8:	10c00215 	stw	r3,8(r2)
 4005eec:	e0bffc17 	ldw	r2,-16(fp)
 4005ef0:	10800b17 	ldw	r2,44(r2)
 4005ef4:	01400504 	movi	r5,20
 4005ef8:	1009883a 	mov	r4,r2
 4005efc:	40078580 	call	4007858 <__mulsi3>
 4005f00:	1007883a 	mov	r3,r2
 4005f04:	00812074 	movhi	r2,1153
 4005f08:	10807604 	addi	r2,r2,472
 4005f0c:	1887883a 	add	r3,r3,r2
 4005f10:	e0bffc17 	ldw	r2,-16(fp)
 4005f14:	10c00515 	stw	r3,20(r2)
 4005f18:	e0bffc17 	ldw	r2,-16(fp)
 4005f1c:	14400b17 	ldw	r17,44(r2)
 4005f20:	01400504 	movi	r5,20
 4005f24:	8809883a 	mov	r4,r17
 4005f28:	40078580 	call	4007858 <__mulsi3>
 4005f2c:	1007883a 	mov	r3,r2
 4005f30:	00812074 	movhi	r2,1153
 4005f34:	1885883a 	add	r2,r3,r2
 4005f38:	10807617 	ldw	r2,472(r2)
 4005f3c:	14000044 	addi	r16,r2,1
 4005f40:	01400504 	movi	r5,20
 4005f44:	8809883a 	mov	r4,r17
 4005f48:	40078580 	call	4007858 <__mulsi3>
 4005f4c:	1007883a 	mov	r3,r2
 4005f50:	00812074 	movhi	r2,1153
 4005f54:	1885883a 	add	r2,r3,r2
 4005f58:	14007615 	stw	r16,472(r2)
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
 4005f5c:	0001883a 	nop
 4005f60:	e6fffe04 	addi	sp,fp,-8
 4005f64:	dfc00317 	ldw	ra,12(sp)
 4005f68:	df000217 	ldw	fp,8(sp)
 4005f6c:	dc400117 	ldw	r17,4(sp)
 4005f70:	dc000017 	ldw	r16,0(sp)
 4005f74:	dec00404 	addi	sp,sp,16
 4005f78:	f800283a 	ret

04005f7c <vTaskEnterCritical>:
/*-----------------------------------------------------------*/

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

    void vTaskEnterCritical( void )
    {
 4005f7c:	defffe04 	addi	sp,sp,-8
 4005f80:	df000115 	stw	fp,4(sp)
 4005f84:	df000104 	addi	fp,sp,4
  NIOS2_READ_STATUS (context);
 4005f88:	0005303a 	rdctl	r2,status
 4005f8c:	e0bfff15 	stw	r2,-4(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 4005f90:	e0ffff17 	ldw	r3,-4(fp)
 4005f94:	00bfff84 	movi	r2,-2
 4005f98:	1884703a 	and	r2,r3,r2
 4005f9c:	1001703a 	wrctl	status,r2
        portDISABLE_INTERRUPTS();

        if( xSchedulerRunning != pdFALSE )
 4005fa0:	d0a6b417 	ldw	r2,-25904(gp)
 4005fa4:	10000526 	beq	r2,zero,4005fbc <vTaskEnterCritical+0x40>
        {
            ( pxCurrentTCB->uxCriticalNesting )++;
 4005fa8:	d0a6ad17 	ldw	r2,-25932(gp)
 4005fac:	10c00f17 	ldw	r3,60(r2)
 4005fb0:	18c00044 	addi	r3,r3,1
 4005fb4:	10c00f15 	stw	r3,60(r2)
             * function so  assert() if it is being called from an interrupt
             * context.  Only API functions that end in "FromISR" can be used in an
             * interrupt.  Only assert if the critical nesting count is 1 to
             * protect against recursive calls if the assert function also uses a
             * critical section. */
            if( pxCurrentTCB->uxCriticalNesting == 1 )
 4005fb8:	d0a6ad17 	ldw	r2,-25932(gp)
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
 4005fbc:	0001883a 	nop
 4005fc0:	e037883a 	mov	sp,fp
 4005fc4:	df000017 	ldw	fp,0(sp)
 4005fc8:	dec00104 	addi	sp,sp,4
 4005fcc:	f800283a 	ret

04005fd0 <vTaskExitCritical>:
/*-----------------------------------------------------------*/

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

    void vTaskExitCritical( void )
    {
 4005fd0:	defffe04 	addi	sp,sp,-8
 4005fd4:	df000115 	stw	fp,4(sp)
 4005fd8:	df000104 	addi	fp,sp,4
        if( xSchedulerRunning != pdFALSE )
 4005fdc:	d0a6b417 	ldw	r2,-25904(gp)
 4005fe0:	10000f26 	beq	r2,zero,4006020 <vTaskExitCritical+0x50>
        {
            if( pxCurrentTCB->uxCriticalNesting > 0U )
 4005fe4:	d0a6ad17 	ldw	r2,-25932(gp)
 4005fe8:	10800f17 	ldw	r2,60(r2)
 4005fec:	10000c26 	beq	r2,zero,4006020 <vTaskExitCritical+0x50>
            {
                ( pxCurrentTCB->uxCriticalNesting )--;
 4005ff0:	d0a6ad17 	ldw	r2,-25932(gp)
 4005ff4:	10c00f17 	ldw	r3,60(r2)
 4005ff8:	18ffffc4 	addi	r3,r3,-1
 4005ffc:	10c00f15 	stw	r3,60(r2)

                if( pxCurrentTCB->uxCriticalNesting == 0U )
 4006000:	d0a6ad17 	ldw	r2,-25932(gp)
 4006004:	10800f17 	ldw	r2,60(r2)
 4006008:	1000051e 	bne	r2,zero,4006020 <vTaskExitCritical+0x50>
 400600c:	00800044 	movi	r2,1
 4006010:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 4006014:	e0bfff17 	ldw	r2,-4(fp)
 4006018:	1001703a 	wrctl	status,r2
#endif
}
 400601c:	0001883a 	nop
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
 4006020:	0001883a 	nop
 4006024:	e037883a 	mov	sp,fp
 4006028:	df000017 	ldw	fp,0(sp)
 400602c:	dec00104 	addi	sp,sp,4
 4006030:	f800283a 	ret

04006034 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
 4006034:	defffe04 	addi	sp,sp,-8
 4006038:	df000115 	stw	fp,4(sp)
 400603c:	df000104 	addi	fp,sp,4
    TickType_t uxReturn;

    uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
 4006040:	d0a6ad17 	ldw	r2,-25932(gp)
 4006044:	10800617 	ldw	r2,24(r2)
 4006048:	e0bfff15 	stw	r2,-4(fp)

    /* Reset the event list item to its normal value - so it can be used with
     * queues and semaphores. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 400604c:	d0a6ad17 	ldw	r2,-25932(gp)
 4006050:	10c00b17 	ldw	r3,44(r2)
 4006054:	d0a6ad17 	ldw	r2,-25932(gp)
 4006058:	01000144 	movi	r4,5
 400605c:	20c7c83a 	sub	r3,r4,r3
 4006060:	10c00615 	stw	r3,24(r2)

    return uxReturn;
 4006064:	e0bfff17 	ldw	r2,-4(fp)
}
 4006068:	e037883a 	mov	sp,fp
 400606c:	df000017 	ldw	fp,0(sp)
 4006070:	dec00104 	addi	sp,sp,4
 4006074:	f800283a 	ret

04006078 <pvTaskIncrementMutexHeldCount>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    TaskHandle_t pvTaskIncrementMutexHeldCount( void )
    {
 4006078:	deffff04 	addi	sp,sp,-4
 400607c:	df000015 	stw	fp,0(sp)
 4006080:	d839883a 	mov	fp,sp
        /* If xSemaphoreCreateMutex() is called before any tasks have been created
         * then pxCurrentTCB will be NULL. */
        if( pxCurrentTCB != NULL )
 4006084:	d0a6ad17 	ldw	r2,-25932(gp)
 4006088:	10000426 	beq	r2,zero,400609c <pvTaskIncrementMutexHeldCount+0x24>
        {
            ( pxCurrentTCB->uxMutexesHeld )++;
 400608c:	d0a6ad17 	ldw	r2,-25932(gp)
 4006090:	10c01117 	ldw	r3,68(r2)
 4006094:	18c00044 	addi	r3,r3,1
 4006098:	10c01115 	stw	r3,68(r2)
        }

        return pxCurrentTCB;
 400609c:	d0a6ad17 	ldw	r2,-25932(gp)
    }
 40060a0:	e037883a 	mov	sp,fp
 40060a4:	df000017 	ldw	fp,0(sp)
 40060a8:	dec00104 	addi	sp,sp,4
 40060ac:	f800283a 	ret

040060b0 <ulTaskGenericNotifyTake>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyTake( UBaseType_t uxIndexToWait,
                                      BaseType_t xClearCountOnExit,
                                      TickType_t xTicksToWait )
    {
 40060b0:	defffa04 	addi	sp,sp,-24
 40060b4:	dfc00515 	stw	ra,20(sp)
 40060b8:	df000415 	stw	fp,16(sp)
 40060bc:	df000404 	addi	fp,sp,16
 40060c0:	e13ffe15 	stw	r4,-8(fp)
 40060c4:	e17ffd15 	stw	r5,-12(fp)
 40060c8:	e1bffc15 	stw	r6,-16(fp)
        uint32_t ulReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
 40060cc:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
        {
            /* Only block if the notification count is not already non-zero. */
            if( pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] == 0UL )
 40060d0:	d0e6ad17 	ldw	r3,-25932(gp)
 40060d4:	e0bffe17 	ldw	r2,-8(fp)
 40060d8:	10800484 	addi	r2,r2,18
 40060dc:	100490ba 	slli	r2,r2,2
 40060e0:	1885883a 	add	r2,r3,r2
 40060e4:	10800017 	ldw	r2,0(r2)
 40060e8:	10000b1e 	bne	r2,zero,4006118 <ulTaskGenericNotifyTake+0x68>
            {
                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
 40060ec:	d0e6ad17 	ldw	r3,-25932(gp)
 40060f0:	e0bffe17 	ldw	r2,-8(fp)
 40060f4:	1885883a 	add	r2,r3,r2
 40060f8:	00c00044 	movi	r3,1
 40060fc:	10c01305 	stb	r3,76(r2)

                if( xTicksToWait > ( TickType_t ) 0 )
 4006100:	e0bffc17 	ldw	r2,-16(fp)
 4006104:	10000426 	beq	r2,zero,4006118 <ulTaskGenericNotifyTake+0x68>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 4006108:	01400044 	movi	r5,1
 400610c:	e13ffc17 	ldw	r4,-16(fp)
 4006110:	4006e3c0 	call	4006e3c <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
 4006114:	003b683a 	trap	0
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
 4006118:	4005fd00 	call	4005fd0 <vTaskExitCritical>

        taskENTER_CRITICAL();
 400611c:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
        {
            traceTASK_NOTIFY_TAKE( uxIndexToWait );
            ulReturn = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
 4006120:	d0e6ad17 	ldw	r3,-25932(gp)
 4006124:	e0bffe17 	ldw	r2,-8(fp)
 4006128:	10800484 	addi	r2,r2,18
 400612c:	100490ba 	slli	r2,r2,2
 4006130:	1885883a 	add	r2,r3,r2
 4006134:	10800017 	ldw	r2,0(r2)
 4006138:	e0bfff15 	stw	r2,-4(fp)

            if( ulReturn != 0UL )
 400613c:	e0bfff17 	ldw	r2,-4(fp)
 4006140:	10001126 	beq	r2,zero,4006188 <ulTaskGenericNotifyTake+0xd8>
            {
                if( xClearCountOnExit != pdFALSE )
 4006144:	e0bffd17 	ldw	r2,-12(fp)
 4006148:	10000726 	beq	r2,zero,4006168 <ulTaskGenericNotifyTake+0xb8>
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = 0UL;
 400614c:	d0e6ad17 	ldw	r3,-25932(gp)
 4006150:	e0bffe17 	ldw	r2,-8(fp)
 4006154:	10800484 	addi	r2,r2,18
 4006158:	100490ba 	slli	r2,r2,2
 400615c:	1885883a 	add	r2,r3,r2
 4006160:	10000015 	stw	zero,0(r2)
 4006164:	00000806 	br	4006188 <ulTaskGenericNotifyTake+0xd8>
                }
                else
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = ulReturn - ( uint32_t ) 1;
 4006168:	d126ad17 	ldw	r4,-25932(gp)
 400616c:	e0bfff17 	ldw	r2,-4(fp)
 4006170:	10ffffc4 	addi	r3,r2,-1
 4006174:	e0bffe17 	ldw	r2,-8(fp)
 4006178:	10800484 	addi	r2,r2,18
 400617c:	100490ba 	slli	r2,r2,2
 4006180:	2085883a 	add	r2,r4,r2
 4006184:	10c00015 	stw	r3,0(r2)
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
 4006188:	d0e6ad17 	ldw	r3,-25932(gp)
 400618c:	e0bffe17 	ldw	r2,-8(fp)
 4006190:	1885883a 	add	r2,r3,r2
 4006194:	10001305 	stb	zero,76(r2)
        }
        taskEXIT_CRITICAL();
 4006198:	4005fd00 	call	4005fd0 <vTaskExitCritical>

        return ulReturn;
 400619c:	e0bfff17 	ldw	r2,-4(fp)
    }
 40061a0:	e037883a 	mov	sp,fp
 40061a4:	dfc00117 	ldw	ra,4(sp)
 40061a8:	df000017 	ldw	fp,0(sp)
 40061ac:	dec00204 	addi	sp,sp,8
 40061b0:	f800283a 	ret

040061b4 <xTaskGenericNotifyWait>:
    BaseType_t xTaskGenericNotifyWait( UBaseType_t uxIndexToWait,
                                       uint32_t ulBitsToClearOnEntry,
                                       uint32_t ulBitsToClearOnExit,
                                       uint32_t * pulNotificationValue,
                                       TickType_t xTicksToWait )
    {
 40061b4:	defff904 	addi	sp,sp,-28
 40061b8:	dfc00615 	stw	ra,24(sp)
 40061bc:	df000515 	stw	fp,20(sp)
 40061c0:	df000504 	addi	fp,sp,20
 40061c4:	e13ffe15 	stw	r4,-8(fp)
 40061c8:	e17ffd15 	stw	r5,-12(fp)
 40061cc:	e1bffc15 	stw	r6,-16(fp)
 40061d0:	e1fffb15 	stw	r7,-20(fp)
        BaseType_t xReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
 40061d4:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
        {
            /* Only block if a notification is not already pending. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
 40061d8:	d0e6ad17 	ldw	r3,-25932(gp)
 40061dc:	e0bffe17 	ldw	r2,-8(fp)
 40061e0:	1885883a 	add	r2,r3,r2
 40061e4:	10801303 	ldbu	r2,76(r2)
 40061e8:	10803fcc 	andi	r2,r2,255
 40061ec:	108000a0 	cmpeqi	r2,r2,2
 40061f0:	1000191e 	bne	r2,zero,4006258 <xTaskGenericNotifyWait+0xa4>
            {
                /* Clear bits in the task's notification value as bits may get
                 * set  by the notifying task or interrupt.  This can be used to
                 * clear the value to zero. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnEntry;
 40061f4:	d0a6ad17 	ldw	r2,-25932(gp)
 40061f8:	e0fffe17 	ldw	r3,-8(fp)
 40061fc:	18c00484 	addi	r3,r3,18
 4006200:	180690ba 	slli	r3,r3,2
 4006204:	10c7883a 	add	r3,r2,r3
 4006208:	19000017 	ldw	r4,0(r3)
 400620c:	e0fffd17 	ldw	r3,-12(fp)
 4006210:	00c6303a 	nor	r3,zero,r3
 4006214:	20c6703a 	and	r3,r4,r3
 4006218:	e13ffe17 	ldw	r4,-8(fp)
 400621c:	21000484 	addi	r4,r4,18
 4006220:	200890ba 	slli	r4,r4,2
 4006224:	1105883a 	add	r2,r2,r4
 4006228:	10c00015 	stw	r3,0(r2)

                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
 400622c:	d0e6ad17 	ldw	r3,-25932(gp)
 4006230:	e0bffe17 	ldw	r2,-8(fp)
 4006234:	1885883a 	add	r2,r3,r2
 4006238:	00c00044 	movi	r3,1
 400623c:	10c01305 	stb	r3,76(r2)

                if( xTicksToWait > ( TickType_t ) 0 )
 4006240:	e0800217 	ldw	r2,8(fp)
 4006244:	10000426 	beq	r2,zero,4006258 <xTaskGenericNotifyWait+0xa4>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 4006248:	01400044 	movi	r5,1
 400624c:	e1000217 	ldw	r4,8(fp)
 4006250:	4006e3c0 	call	4006e3c <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
 4006254:	003b683a 	trap	0
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
 4006258:	4005fd00 	call	4005fd0 <vTaskExitCritical>

        taskENTER_CRITICAL();
 400625c:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
        {
            traceTASK_NOTIFY_WAIT( uxIndexToWait );

            if( pulNotificationValue != NULL )
 4006260:	e0bffb17 	ldw	r2,-20(fp)
 4006264:	10000826 	beq	r2,zero,4006288 <xTaskGenericNotifyWait+0xd4>
            {
                /* Output the current notification value, which may or may not
                 * have changed. */
                *pulNotificationValue = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
 4006268:	d0e6ad17 	ldw	r3,-25932(gp)
 400626c:	e0bffe17 	ldw	r2,-8(fp)
 4006270:	10800484 	addi	r2,r2,18
 4006274:	100490ba 	slli	r2,r2,2
 4006278:	1885883a 	add	r2,r3,r2
 400627c:	10c00017 	ldw	r3,0(r2)
 4006280:	e0bffb17 	ldw	r2,-20(fp)
 4006284:	10c00015 	stw	r3,0(r2)

            /* If ucNotifyValue is set then either the task never entered the
             * blocked state (because a notification was already pending) or the
             * task unblocked because of a notification.  Otherwise the task
             * unblocked because of a timeout. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
 4006288:	d0e6ad17 	ldw	r3,-25932(gp)
 400628c:	e0bffe17 	ldw	r2,-8(fp)
 4006290:	1885883a 	add	r2,r3,r2
 4006294:	10801303 	ldbu	r2,76(r2)
 4006298:	10803fcc 	andi	r2,r2,255
 400629c:	108000a0 	cmpeqi	r2,r2,2
 40062a0:	1000021e 	bne	r2,zero,40062ac <xTaskGenericNotifyWait+0xf8>
            {
                /* A notification was not received. */
                xReturn = pdFALSE;
 40062a4:	e03fff15 	stw	zero,-4(fp)
 40062a8:	00001006 	br	40062ec <xTaskGenericNotifyWait+0x138>
            }
            else
            {
                /* A notification was already pending or a notification was
                 * received while the task was waiting. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnExit;
 40062ac:	d0a6ad17 	ldw	r2,-25932(gp)
 40062b0:	e0fffe17 	ldw	r3,-8(fp)
 40062b4:	18c00484 	addi	r3,r3,18
 40062b8:	180690ba 	slli	r3,r3,2
 40062bc:	10c7883a 	add	r3,r2,r3
 40062c0:	19000017 	ldw	r4,0(r3)
 40062c4:	e0fffc17 	ldw	r3,-16(fp)
 40062c8:	00c6303a 	nor	r3,zero,r3
 40062cc:	20c6703a 	and	r3,r4,r3
 40062d0:	e13ffe17 	ldw	r4,-8(fp)
 40062d4:	21000484 	addi	r4,r4,18
 40062d8:	200890ba 	slli	r4,r4,2
 40062dc:	1105883a 	add	r2,r2,r4
 40062e0:	10c00015 	stw	r3,0(r2)
                xReturn = pdTRUE;
 40062e4:	00800044 	movi	r2,1
 40062e8:	e0bfff15 	stw	r2,-4(fp)
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
 40062ec:	d0e6ad17 	ldw	r3,-25932(gp)
 40062f0:	e0bffe17 	ldw	r2,-8(fp)
 40062f4:	1885883a 	add	r2,r3,r2
 40062f8:	10001305 	stb	zero,76(r2)
        }
        taskEXIT_CRITICAL();
 40062fc:	4005fd00 	call	4005fd0 <vTaskExitCritical>

        return xReturn;
 4006300:	e0bfff17 	ldw	r2,-4(fp)
    }
 4006304:	e037883a 	mov	sp,fp
 4006308:	dfc00117 	ldw	ra,4(sp)
 400630c:	df000017 	ldw	fp,0(sp)
 4006310:	dec00204 	addi	sp,sp,8
 4006314:	f800283a 	ret

04006318 <xTaskGenericNotify>:
    BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify,
                                   UBaseType_t uxIndexToNotify,
                                   uint32_t ulValue,
                                   eNotifyAction eAction,
                                   uint32_t * pulPreviousNotificationValue )
    {
 4006318:	defff304 	addi	sp,sp,-52
 400631c:	dfc00c15 	stw	ra,48(sp)
 4006320:	df000b15 	stw	fp,44(sp)
 4006324:	dc400a15 	stw	r17,40(sp)
 4006328:	dc000915 	stw	r16,36(sp)
 400632c:	df000b04 	addi	fp,sp,44
 4006330:	e13ff815 	stw	r4,-32(fp)
 4006334:	e17ff715 	stw	r5,-36(fp)
 4006338:	e1bff615 	stw	r6,-40(fp)
 400633c:	e1fff515 	stw	r7,-44(fp)
        TCB_t * pxTCB;
        BaseType_t xReturn = pdPASS;
 4006340:	00800044 	movi	r2,1
 4006344:	e0bffd15 	stw	r2,-12(fp)
        uint8_t ucOriginalNotifyState;

        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
        configASSERT( xTaskToNotify );
        pxTCB = xTaskToNotify;
 4006348:	e0bff817 	ldw	r2,-32(fp)
 400634c:	e0bffc15 	stw	r2,-16(fp)

        taskENTER_CRITICAL();
 4006350:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
        {
            if( pulPreviousNotificationValue != NULL )
 4006354:	e0800217 	ldw	r2,8(fp)
 4006358:	10000826 	beq	r2,zero,400637c <xTaskGenericNotify+0x64>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
 400635c:	e0fffc17 	ldw	r3,-16(fp)
 4006360:	e0bff717 	ldw	r2,-36(fp)
 4006364:	10800484 	addi	r2,r2,18
 4006368:	100490ba 	slli	r2,r2,2
 400636c:	1885883a 	add	r2,r3,r2
 4006370:	10c00017 	ldw	r3,0(r2)
 4006374:	e0800217 	ldw	r2,8(fp)
 4006378:	10c00015 	stw	r3,0(r2)
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
 400637c:	e0fffc17 	ldw	r3,-16(fp)
 4006380:	e0bff717 	ldw	r2,-36(fp)
 4006384:	1885883a 	add	r2,r3,r2
 4006388:	10801303 	ldbu	r2,76(r2)
 400638c:	e0bffbc5 	stb	r2,-17(fp)

            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
 4006390:	e0fffc17 	ldw	r3,-16(fp)
 4006394:	e0bff717 	ldw	r2,-36(fp)
 4006398:	1885883a 	add	r2,r3,r2
 400639c:	00c00084 	movi	r3,2
 40063a0:	10c01305 	stb	r3,76(r2)

            switch( eAction )
 40063a4:	e0bff517 	ldw	r2,-44(fp)
 40063a8:	10800168 	cmpgeui	r2,r2,5
 40063ac:	10003d1e 	bne	r2,zero,40064a4 <xTaskGenericNotify+0x18c>
 40063b0:	e0bff517 	ldw	r2,-44(fp)
 40063b4:	100690ba 	slli	r3,r2,2
 40063b8:	00810034 	movhi	r2,1024
 40063bc:	1885883a 	add	r2,r3,r2
 40063c0:	1098f217 	ldw	r2,25544(r2)
 40063c4:	1000683a 	jmp	r2
 40063c8:	040064ac 	andhi	r16,zero,402
 40063cc:	040063dc 	xori	r16,zero,399
 40063d0:	04006418 	cmpnei	r16,zero,400
 40063d4:	04006450 	cmplti	r16,zero,401
 40063d8:	04006470 	cmpltui	r16,zero,401
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
 40063dc:	e0fffc17 	ldw	r3,-16(fp)
 40063e0:	e0bff717 	ldw	r2,-36(fp)
 40063e4:	10800484 	addi	r2,r2,18
 40063e8:	100490ba 	slli	r2,r2,2
 40063ec:	1885883a 	add	r2,r3,r2
 40063f0:	10c00017 	ldw	r3,0(r2)
 40063f4:	e0bff617 	ldw	r2,-40(fp)
 40063f8:	1886b03a 	or	r3,r3,r2
 40063fc:	e13ffc17 	ldw	r4,-16(fp)
 4006400:	e0bff717 	ldw	r2,-36(fp)
 4006404:	10800484 	addi	r2,r2,18
 4006408:	100490ba 	slli	r2,r2,2
 400640c:	2085883a 	add	r2,r4,r2
 4006410:	10c00015 	stw	r3,0(r2)
                    break;
 4006414:	00002606 	br	40064b0 <xTaskGenericNotify+0x198>

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
 4006418:	e0fffc17 	ldw	r3,-16(fp)
 400641c:	e0bff717 	ldw	r2,-36(fp)
 4006420:	10800484 	addi	r2,r2,18
 4006424:	100490ba 	slli	r2,r2,2
 4006428:	1885883a 	add	r2,r3,r2
 400642c:	10800017 	ldw	r2,0(r2)
 4006430:	10c00044 	addi	r3,r2,1
 4006434:	e13ffc17 	ldw	r4,-16(fp)
 4006438:	e0bff717 	ldw	r2,-36(fp)
 400643c:	10800484 	addi	r2,r2,18
 4006440:	100490ba 	slli	r2,r2,2
 4006444:	2085883a 	add	r2,r4,r2
 4006448:	10c00015 	stw	r3,0(r2)
                    break;
 400644c:	00001806 	br	40064b0 <xTaskGenericNotify+0x198>

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
 4006450:	e0fffc17 	ldw	r3,-16(fp)
 4006454:	e0bff717 	ldw	r2,-36(fp)
 4006458:	10800484 	addi	r2,r2,18
 400645c:	100490ba 	slli	r2,r2,2
 4006460:	1885883a 	add	r2,r3,r2
 4006464:	e0fff617 	ldw	r3,-40(fp)
 4006468:	10c00015 	stw	r3,0(r2)
                    break;
 400646c:	00001006 	br	40064b0 <xTaskGenericNotify+0x198>

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
 4006470:	e0bffbc3 	ldbu	r2,-17(fp)
 4006474:	108000a0 	cmpeqi	r2,r2,2
 4006478:	1000081e 	bne	r2,zero,400649c <xTaskGenericNotify+0x184>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
 400647c:	e0fffc17 	ldw	r3,-16(fp)
 4006480:	e0bff717 	ldw	r2,-36(fp)
 4006484:	10800484 	addi	r2,r2,18
 4006488:	100490ba 	slli	r2,r2,2
 400648c:	1885883a 	add	r2,r3,r2
 4006490:	e0fff617 	ldw	r3,-40(fp)
 4006494:	10c00015 	stw	r3,0(r2)
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
                    }

                    break;
 4006498:	00000506 	br	40064b0 <xTaskGenericNotify+0x198>
                        xReturn = pdFAIL;
 400649c:	e03ffd15 	stw	zero,-12(fp)
                    break;
 40064a0:	00000306 	br	40064b0 <xTaskGenericNotify+0x198>
                    /* Should not get here if all enums are handled.
                     * Artificially force an assert by testing a value the
                     * compiler can't assume is const. */
                    configASSERT( xTickCount == ( TickType_t ) 0 );

                    break;
 40064a4:	0001883a 	nop
 40064a8:	00000106 	br	40064b0 <xTaskGenericNotify+0x198>
                    break;
 40064ac:	0001883a 	nop

            traceTASK_NOTIFY( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 40064b0:	e0bffbc3 	ldbu	r2,-17(fp)
 40064b4:	10800058 	cmpnei	r2,r2,1
 40064b8:	1000601e 	bne	r2,zero,400663c <xTaskGenericNotify+0x324>
            {
                listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 40064bc:	e0bffc17 	ldw	r2,-16(fp)
 40064c0:	10800517 	ldw	r2,20(r2)
 40064c4:	e0bffa15 	stw	r2,-24(fp)
 40064c8:	e0bffc17 	ldw	r2,-16(fp)
 40064cc:	10800217 	ldw	r2,8(r2)
 40064d0:	e0fffc17 	ldw	r3,-16(fp)
 40064d4:	18c00317 	ldw	r3,12(r3)
 40064d8:	10c00215 	stw	r3,8(r2)
 40064dc:	e0bffc17 	ldw	r2,-16(fp)
 40064e0:	10800317 	ldw	r2,12(r2)
 40064e4:	e0fffc17 	ldw	r3,-16(fp)
 40064e8:	18c00217 	ldw	r3,8(r3)
 40064ec:	10c00115 	stw	r3,4(r2)
 40064f0:	e0bffa17 	ldw	r2,-24(fp)
 40064f4:	10c00117 	ldw	r3,4(r2)
 40064f8:	e0bffc17 	ldw	r2,-16(fp)
 40064fc:	10800104 	addi	r2,r2,4
 4006500:	1880041e 	bne	r3,r2,4006514 <xTaskGenericNotify+0x1fc>
 4006504:	e0bffc17 	ldw	r2,-16(fp)
 4006508:	10c00317 	ldw	r3,12(r2)
 400650c:	e0bffa17 	ldw	r2,-24(fp)
 4006510:	10c00115 	stw	r3,4(r2)
 4006514:	e0bffc17 	ldw	r2,-16(fp)
 4006518:	10000515 	stw	zero,20(r2)
 400651c:	e0bffa17 	ldw	r2,-24(fp)
 4006520:	10800017 	ldw	r2,0(r2)
 4006524:	10ffffc4 	addi	r3,r2,-1
 4006528:	e0bffa17 	ldw	r2,-24(fp)
 400652c:	10c00015 	stw	r3,0(r2)
                prvAddTaskToReadyList( pxTCB );
 4006530:	e0bffc17 	ldw	r2,-16(fp)
 4006534:	10800b17 	ldw	r2,44(r2)
 4006538:	d0e6b317 	ldw	r3,-25908(gp)
 400653c:	1880032e 	bgeu	r3,r2,400654c <xTaskGenericNotify+0x234>
 4006540:	e0bffc17 	ldw	r2,-16(fp)
 4006544:	10800b17 	ldw	r2,44(r2)
 4006548:	d0a6b315 	stw	r2,-25908(gp)
 400654c:	e0bffc17 	ldw	r2,-16(fp)
 4006550:	10800b17 	ldw	r2,44(r2)
 4006554:	01400504 	movi	r5,20
 4006558:	1009883a 	mov	r4,r2
 400655c:	40078580 	call	4007858 <__mulsi3>
 4006560:	1007883a 	mov	r3,r2
 4006564:	00812074 	movhi	r2,1153
 4006568:	1885883a 	add	r2,r3,r2
 400656c:	10807717 	ldw	r2,476(r2)
 4006570:	e0bff915 	stw	r2,-28(fp)
 4006574:	e0bffc17 	ldw	r2,-16(fp)
 4006578:	e0fff917 	ldw	r3,-28(fp)
 400657c:	10c00215 	stw	r3,8(r2)
 4006580:	e0bff917 	ldw	r2,-28(fp)
 4006584:	10c00217 	ldw	r3,8(r2)
 4006588:	e0bffc17 	ldw	r2,-16(fp)
 400658c:	10c00315 	stw	r3,12(r2)
 4006590:	e0bff917 	ldw	r2,-28(fp)
 4006594:	10800217 	ldw	r2,8(r2)
 4006598:	e0fffc17 	ldw	r3,-16(fp)
 400659c:	18c00104 	addi	r3,r3,4
 40065a0:	10c00115 	stw	r3,4(r2)
 40065a4:	e0bffc17 	ldw	r2,-16(fp)
 40065a8:	10c00104 	addi	r3,r2,4
 40065ac:	e0bff917 	ldw	r2,-28(fp)
 40065b0:	10c00215 	stw	r3,8(r2)
 40065b4:	e0bffc17 	ldw	r2,-16(fp)
 40065b8:	10800b17 	ldw	r2,44(r2)
 40065bc:	01400504 	movi	r5,20
 40065c0:	1009883a 	mov	r4,r2
 40065c4:	40078580 	call	4007858 <__mulsi3>
 40065c8:	1007883a 	mov	r3,r2
 40065cc:	00812074 	movhi	r2,1153
 40065d0:	10807604 	addi	r2,r2,472
 40065d4:	1887883a 	add	r3,r3,r2
 40065d8:	e0bffc17 	ldw	r2,-16(fp)
 40065dc:	10c00515 	stw	r3,20(r2)
 40065e0:	e0bffc17 	ldw	r2,-16(fp)
 40065e4:	14400b17 	ldw	r17,44(r2)
 40065e8:	01400504 	movi	r5,20
 40065ec:	8809883a 	mov	r4,r17
 40065f0:	40078580 	call	4007858 <__mulsi3>
 40065f4:	1007883a 	mov	r3,r2
 40065f8:	00812074 	movhi	r2,1153
 40065fc:	1885883a 	add	r2,r3,r2
 4006600:	10807617 	ldw	r2,472(r2)
 4006604:	14000044 	addi	r16,r2,1
 4006608:	01400504 	movi	r5,20
 400660c:	8809883a 	mov	r4,r17
 4006610:	40078580 	call	4007858 <__mulsi3>
 4006614:	1007883a 	mov	r3,r2
 4006618:	00812074 	movhi	r2,1153
 400661c:	1885883a 	add	r2,r3,r2
 4006620:	14007615 	stw	r16,472(r2)
                     * earliest possible time. */
                    prvResetNextTaskUnblockTime();
                }
                #endif

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 4006624:	e0bffc17 	ldw	r2,-16(fp)
 4006628:	10800b17 	ldw	r2,44(r2)
 400662c:	d0e6ad17 	ldw	r3,-25932(gp)
 4006630:	18c00b17 	ldw	r3,44(r3)
 4006634:	1880012e 	bgeu	r3,r2,400663c <xTaskGenericNotify+0x324>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    taskYIELD_IF_USING_PREEMPTION();
 4006638:	003b683a 	trap	0
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
 400663c:	4005fd00 	call	4005fd0 <vTaskExitCritical>

        return xReturn;
 4006640:	e0bffd17 	ldw	r2,-12(fp)
    }
 4006644:	e6fffe04 	addi	sp,fp,-8
 4006648:	dfc00317 	ldw	ra,12(sp)
 400664c:	df000217 	ldw	fp,8(sp)
 4006650:	dc400117 	ldw	r17,4(sp)
 4006654:	dc000017 	ldw	r16,0(sp)
 4006658:	dec00404 	addi	sp,sp,16
 400665c:	f800283a 	ret

04006660 <xTaskGenericNotifyFromISR>:
                                          UBaseType_t uxIndexToNotify,
                                          uint32_t ulValue,
                                          eNotifyAction eAction,
                                          uint32_t * pulPreviousNotificationValue,
                                          BaseType_t * pxHigherPriorityTaskWoken )
    {
 4006660:	defff104 	addi	sp,sp,-60
 4006664:	dfc00e15 	stw	ra,56(sp)
 4006668:	df000d15 	stw	fp,52(sp)
 400666c:	dc400c15 	stw	r17,48(sp)
 4006670:	dc000b15 	stw	r16,44(sp)
 4006674:	df000d04 	addi	fp,sp,52
 4006678:	e13ff615 	stw	r4,-40(fp)
 400667c:	e17ff515 	stw	r5,-44(fp)
 4006680:	e1bff415 	stw	r6,-48(fp)
 4006684:	e1fff315 	stw	r7,-52(fp)
        TCB_t * pxTCB;
        uint8_t ucOriginalNotifyState;
        BaseType_t xReturn = pdPASS;
 4006688:	00800044 	movi	r2,1
 400668c:	e0bffd15 	stw	r2,-12(fp)
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;
 4006690:	e0bff617 	ldw	r2,-40(fp)
 4006694:	e0bffc15 	stw	r2,-16(fp)

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 4006698:	e03ffb15 	stw	zero,-20(fp)
        {
            if( pulPreviousNotificationValue != NULL )
 400669c:	e0800217 	ldw	r2,8(fp)
 40066a0:	10000826 	beq	r2,zero,40066c4 <xTaskGenericNotifyFromISR+0x64>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
 40066a4:	e0fffc17 	ldw	r3,-16(fp)
 40066a8:	e0bff517 	ldw	r2,-44(fp)
 40066ac:	10800484 	addi	r2,r2,18
 40066b0:	100490ba 	slli	r2,r2,2
 40066b4:	1885883a 	add	r2,r3,r2
 40066b8:	10c00017 	ldw	r3,0(r2)
 40066bc:	e0800217 	ldw	r2,8(fp)
 40066c0:	10c00015 	stw	r3,0(r2)
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
 40066c4:	e0fffc17 	ldw	r3,-16(fp)
 40066c8:	e0bff517 	ldw	r2,-44(fp)
 40066cc:	1885883a 	add	r2,r3,r2
 40066d0:	10801303 	ldbu	r2,76(r2)
 40066d4:	e0bffac5 	stb	r2,-21(fp)
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
 40066d8:	e0fffc17 	ldw	r3,-16(fp)
 40066dc:	e0bff517 	ldw	r2,-44(fp)
 40066e0:	1885883a 	add	r2,r3,r2
 40066e4:	00c00084 	movi	r3,2
 40066e8:	10c01305 	stb	r3,76(r2)

            switch( eAction )
 40066ec:	e0bff317 	ldw	r2,-52(fp)
 40066f0:	10800168 	cmpgeui	r2,r2,5
 40066f4:	10003d1e 	bne	r2,zero,40067ec <xTaskGenericNotifyFromISR+0x18c>
 40066f8:	e0bff317 	ldw	r2,-52(fp)
 40066fc:	100690ba 	slli	r3,r2,2
 4006700:	00810034 	movhi	r2,1024
 4006704:	1885883a 	add	r2,r3,r2
 4006708:	1099c417 	ldw	r2,26384(r2)
 400670c:	1000683a 	jmp	r2
 4006710:	040067f4 	movhi	r16,415
 4006714:	04006724 	muli	r16,zero,412
 4006718:	04006760 	cmpeqi	r16,zero,413
 400671c:	04006798 	cmpnei	r16,zero,414
 4006720:	040067b8 	rdprs	r16,zero,414
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
 4006724:	e0fffc17 	ldw	r3,-16(fp)
 4006728:	e0bff517 	ldw	r2,-44(fp)
 400672c:	10800484 	addi	r2,r2,18
 4006730:	100490ba 	slli	r2,r2,2
 4006734:	1885883a 	add	r2,r3,r2
 4006738:	10c00017 	ldw	r3,0(r2)
 400673c:	e0bff417 	ldw	r2,-48(fp)
 4006740:	1886b03a 	or	r3,r3,r2
 4006744:	e13ffc17 	ldw	r4,-16(fp)
 4006748:	e0bff517 	ldw	r2,-44(fp)
 400674c:	10800484 	addi	r2,r2,18
 4006750:	100490ba 	slli	r2,r2,2
 4006754:	2085883a 	add	r2,r4,r2
 4006758:	10c00015 	stw	r3,0(r2)
                    break;
 400675c:	00002606 	br	40067f8 <xTaskGenericNotifyFromISR+0x198>

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
 4006760:	e0fffc17 	ldw	r3,-16(fp)
 4006764:	e0bff517 	ldw	r2,-44(fp)
 4006768:	10800484 	addi	r2,r2,18
 400676c:	100490ba 	slli	r2,r2,2
 4006770:	1885883a 	add	r2,r3,r2
 4006774:	10800017 	ldw	r2,0(r2)
 4006778:	10c00044 	addi	r3,r2,1
 400677c:	e13ffc17 	ldw	r4,-16(fp)
 4006780:	e0bff517 	ldw	r2,-44(fp)
 4006784:	10800484 	addi	r2,r2,18
 4006788:	100490ba 	slli	r2,r2,2
 400678c:	2085883a 	add	r2,r4,r2
 4006790:	10c00015 	stw	r3,0(r2)
                    break;
 4006794:	00001806 	br	40067f8 <xTaskGenericNotifyFromISR+0x198>

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
 4006798:	e0fffc17 	ldw	r3,-16(fp)
 400679c:	e0bff517 	ldw	r2,-44(fp)
 40067a0:	10800484 	addi	r2,r2,18
 40067a4:	100490ba 	slli	r2,r2,2
 40067a8:	1885883a 	add	r2,r3,r2
 40067ac:	e0fff417 	ldw	r3,-48(fp)
 40067b0:	10c00015 	stw	r3,0(r2)
                    break;
 40067b4:	00001006 	br	40067f8 <xTaskGenericNotifyFromISR+0x198>

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
 40067b8:	e0bffac3 	ldbu	r2,-21(fp)
 40067bc:	108000a0 	cmpeqi	r2,r2,2
 40067c0:	1000081e 	bne	r2,zero,40067e4 <xTaskGenericNotifyFromISR+0x184>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
 40067c4:	e0fffc17 	ldw	r3,-16(fp)
 40067c8:	e0bff517 	ldw	r2,-44(fp)
 40067cc:	10800484 	addi	r2,r2,18
 40067d0:	100490ba 	slli	r2,r2,2
 40067d4:	1885883a 	add	r2,r3,r2
 40067d8:	e0fff417 	ldw	r3,-48(fp)
 40067dc:	10c00015 	stw	r3,0(r2)
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
                    }

                    break;
 40067e0:	00000506 	br	40067f8 <xTaskGenericNotifyFromISR+0x198>
                        xReturn = pdFAIL;
 40067e4:	e03ffd15 	stw	zero,-12(fp)
                    break;
 40067e8:	00000306 	br	40067f8 <xTaskGenericNotifyFromISR+0x198>

                    /* Should not get here if all enums are handled.
                     * Artificially force an assert by testing a value the
                     * compiler can't assume is const. */
                    configASSERT( xTickCount == ( TickType_t ) 0 );
                    break;
 40067ec:	0001883a 	nop
 40067f0:	00000106 	br	40067f8 <xTaskGenericNotifyFromISR+0x198>
                    break;
 40067f4:	0001883a 	nop

            traceTASK_NOTIFY_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 40067f8:	e0bffac3 	ldbu	r2,-21(fp)
 40067fc:	10800058 	cmpnei	r2,r2,1
 4006800:	1000851e 	bne	r2,zero,4006a18 <xTaskGenericNotifyFromISR+0x3b8>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 4006804:	d0a6bb17 	ldw	r2,-25876(gp)
 4006808:	10005b1e 	bne	r2,zero,4006978 <xTaskGenericNotifyFromISR+0x318>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 400680c:	e0bffc17 	ldw	r2,-16(fp)
 4006810:	10800517 	ldw	r2,20(r2)
 4006814:	e0bff815 	stw	r2,-32(fp)
 4006818:	e0bffc17 	ldw	r2,-16(fp)
 400681c:	10800217 	ldw	r2,8(r2)
 4006820:	e0fffc17 	ldw	r3,-16(fp)
 4006824:	18c00317 	ldw	r3,12(r3)
 4006828:	10c00215 	stw	r3,8(r2)
 400682c:	e0bffc17 	ldw	r2,-16(fp)
 4006830:	10800317 	ldw	r2,12(r2)
 4006834:	e0fffc17 	ldw	r3,-16(fp)
 4006838:	18c00217 	ldw	r3,8(r3)
 400683c:	10c00115 	stw	r3,4(r2)
 4006840:	e0bff817 	ldw	r2,-32(fp)
 4006844:	10c00117 	ldw	r3,4(r2)
 4006848:	e0bffc17 	ldw	r2,-16(fp)
 400684c:	10800104 	addi	r2,r2,4
 4006850:	1880041e 	bne	r3,r2,4006864 <xTaskGenericNotifyFromISR+0x204>
 4006854:	e0bffc17 	ldw	r2,-16(fp)
 4006858:	10c00317 	ldw	r3,12(r2)
 400685c:	e0bff817 	ldw	r2,-32(fp)
 4006860:	10c00115 	stw	r3,4(r2)
 4006864:	e0bffc17 	ldw	r2,-16(fp)
 4006868:	10000515 	stw	zero,20(r2)
 400686c:	e0bff817 	ldw	r2,-32(fp)
 4006870:	10800017 	ldw	r2,0(r2)
 4006874:	10ffffc4 	addi	r3,r2,-1
 4006878:	e0bff817 	ldw	r2,-32(fp)
 400687c:	10c00015 	stw	r3,0(r2)
                    prvAddTaskToReadyList( pxTCB );
 4006880:	e0bffc17 	ldw	r2,-16(fp)
 4006884:	10800b17 	ldw	r2,44(r2)
 4006888:	d0e6b317 	ldw	r3,-25908(gp)
 400688c:	1880032e 	bgeu	r3,r2,400689c <xTaskGenericNotifyFromISR+0x23c>
 4006890:	e0bffc17 	ldw	r2,-16(fp)
 4006894:	10800b17 	ldw	r2,44(r2)
 4006898:	d0a6b315 	stw	r2,-25908(gp)
 400689c:	e0bffc17 	ldw	r2,-16(fp)
 40068a0:	10800b17 	ldw	r2,44(r2)
 40068a4:	01400504 	movi	r5,20
 40068a8:	1009883a 	mov	r4,r2
 40068ac:	40078580 	call	4007858 <__mulsi3>
 40068b0:	1007883a 	mov	r3,r2
 40068b4:	00812074 	movhi	r2,1153
 40068b8:	1885883a 	add	r2,r3,r2
 40068bc:	10807717 	ldw	r2,476(r2)
 40068c0:	e0bff715 	stw	r2,-36(fp)
 40068c4:	e0bffc17 	ldw	r2,-16(fp)
 40068c8:	e0fff717 	ldw	r3,-36(fp)
 40068cc:	10c00215 	stw	r3,8(r2)
 40068d0:	e0bff717 	ldw	r2,-36(fp)
 40068d4:	10c00217 	ldw	r3,8(r2)
 40068d8:	e0bffc17 	ldw	r2,-16(fp)
 40068dc:	10c00315 	stw	r3,12(r2)
 40068e0:	e0bff717 	ldw	r2,-36(fp)
 40068e4:	10800217 	ldw	r2,8(r2)
 40068e8:	e0fffc17 	ldw	r3,-16(fp)
 40068ec:	18c00104 	addi	r3,r3,4
 40068f0:	10c00115 	stw	r3,4(r2)
 40068f4:	e0bffc17 	ldw	r2,-16(fp)
 40068f8:	10c00104 	addi	r3,r2,4
 40068fc:	e0bff717 	ldw	r2,-36(fp)
 4006900:	10c00215 	stw	r3,8(r2)
 4006904:	e0bffc17 	ldw	r2,-16(fp)
 4006908:	10800b17 	ldw	r2,44(r2)
 400690c:	01400504 	movi	r5,20
 4006910:	1009883a 	mov	r4,r2
 4006914:	40078580 	call	4007858 <__mulsi3>
 4006918:	1007883a 	mov	r3,r2
 400691c:	00812074 	movhi	r2,1153
 4006920:	10807604 	addi	r2,r2,472
 4006924:	1887883a 	add	r3,r3,r2
 4006928:	e0bffc17 	ldw	r2,-16(fp)
 400692c:	10c00515 	stw	r3,20(r2)
 4006930:	e0bffc17 	ldw	r2,-16(fp)
 4006934:	14400b17 	ldw	r17,44(r2)
 4006938:	01400504 	movi	r5,20
 400693c:	8809883a 	mov	r4,r17
 4006940:	40078580 	call	4007858 <__mulsi3>
 4006944:	1007883a 	mov	r3,r2
 4006948:	00812074 	movhi	r2,1153
 400694c:	1885883a 	add	r2,r3,r2
 4006950:	10807617 	ldw	r2,472(r2)
 4006954:	14000044 	addi	r16,r2,1
 4006958:	01400504 	movi	r5,20
 400695c:	8809883a 	mov	r4,r17
 4006960:	40078580 	call	4007858 <__mulsi3>
 4006964:	1007883a 	mov	r3,r2
 4006968:	00812074 	movhi	r2,1153
 400696c:	1885883a 	add	r2,r3,r2
 4006970:	14007615 	stw	r16,472(r2)
 4006974:	00001c06 	br	40069e8 <xTaskGenericNotifyFromISR+0x388>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 4006978:	00812074 	movhi	r2,1153
 400697c:	10809a17 	ldw	r2,616(r2)
 4006980:	e0bff915 	stw	r2,-28(fp)
 4006984:	e0bffc17 	ldw	r2,-16(fp)
 4006988:	e0fff917 	ldw	r3,-28(fp)
 400698c:	10c00715 	stw	r3,28(r2)
 4006990:	e0bff917 	ldw	r2,-28(fp)
 4006994:	10c00217 	ldw	r3,8(r2)
 4006998:	e0bffc17 	ldw	r2,-16(fp)
 400699c:	10c00815 	stw	r3,32(r2)
 40069a0:	e0bff917 	ldw	r2,-28(fp)
 40069a4:	10800217 	ldw	r2,8(r2)
 40069a8:	e0fffc17 	ldw	r3,-16(fp)
 40069ac:	18c00604 	addi	r3,r3,24
 40069b0:	10c00115 	stw	r3,4(r2)
 40069b4:	e0bffc17 	ldw	r2,-16(fp)
 40069b8:	10c00604 	addi	r3,r2,24
 40069bc:	e0bff917 	ldw	r2,-28(fp)
 40069c0:	10c00215 	stw	r3,8(r2)
 40069c4:	e0fffc17 	ldw	r3,-16(fp)
 40069c8:	00812074 	movhi	r2,1153
 40069cc:	10809904 	addi	r2,r2,612
 40069d0:	18800a15 	stw	r2,40(r3)
 40069d4:	00812074 	movhi	r2,1153
 40069d8:	10809917 	ldw	r2,612(r2)
 40069dc:	10c00044 	addi	r3,r2,1
 40069e0:	00812074 	movhi	r2,1153
 40069e4:	10c09915 	stw	r3,612(r2)
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 40069e8:	e0bffc17 	ldw	r2,-16(fp)
 40069ec:	10800b17 	ldw	r2,44(r2)
 40069f0:	d0e6ad17 	ldw	r3,-25932(gp)
 40069f4:	18c00b17 	ldw	r3,44(r3)
 40069f8:	1880072e 	bgeu	r3,r2,4006a18 <xTaskGenericNotifyFromISR+0x3b8>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
 40069fc:	e0800317 	ldw	r2,12(fp)
 4006a00:	10000326 	beq	r2,zero,4006a10 <xTaskGenericNotifyFromISR+0x3b0>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
 4006a04:	e0800317 	ldw	r2,12(fp)
 4006a08:	00c00044 	movi	r3,1
 4006a0c:	10c00015 	stw	r3,0(r2)
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter to an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
 4006a10:	00800044 	movi	r2,1
 4006a14:	d0a6b615 	stw	r2,-25896(gp)
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

        return xReturn;
 4006a18:	e0bffd17 	ldw	r2,-12(fp)
    }
 4006a1c:	e6fffe04 	addi	sp,fp,-8
 4006a20:	dfc00317 	ldw	ra,12(sp)
 4006a24:	df000217 	ldw	fp,8(sp)
 4006a28:	dc400117 	ldw	r17,4(sp)
 4006a2c:	dc000017 	ldw	r16,0(sp)
 4006a30:	dec00404 	addi	sp,sp,16
 4006a34:	f800283a 	ret

04006a38 <vTaskGenericNotifyGiveFromISR>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    void vTaskGenericNotifyGiveFromISR( TaskHandle_t xTaskToNotify,
                                        UBaseType_t uxIndexToNotify,
                                        BaseType_t * pxHigherPriorityTaskWoken )
    {
 4006a38:	defff304 	addi	sp,sp,-52
 4006a3c:	dfc00c15 	stw	ra,48(sp)
 4006a40:	df000b15 	stw	fp,44(sp)
 4006a44:	dc400a15 	stw	r17,40(sp)
 4006a48:	dc000915 	stw	r16,36(sp)
 4006a4c:	df000b04 	addi	fp,sp,44
 4006a50:	e13ff715 	stw	r4,-36(fp)
 4006a54:	e17ff615 	stw	r5,-40(fp)
 4006a58:	e1bff515 	stw	r6,-44(fp)
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;
 4006a5c:	e0bff717 	ldw	r2,-36(fp)
 4006a60:	e0bffd15 	stw	r2,-12(fp)

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 4006a64:	e03ffc15 	stw	zero,-16(fp)
        {
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
 4006a68:	e0fffd17 	ldw	r3,-12(fp)
 4006a6c:	e0bff617 	ldw	r2,-40(fp)
 4006a70:	1885883a 	add	r2,r3,r2
 4006a74:	10801303 	ldbu	r2,76(r2)
 4006a78:	e0bffbc5 	stb	r2,-17(fp)
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
 4006a7c:	e0fffd17 	ldw	r3,-12(fp)
 4006a80:	e0bff617 	ldw	r2,-40(fp)
 4006a84:	1885883a 	add	r2,r3,r2
 4006a88:	00c00084 	movi	r3,2
 4006a8c:	10c01305 	stb	r3,76(r2)

            /* 'Giving' is equivalent to incrementing a count in a counting
             * semaphore. */
            ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
 4006a90:	e0fffd17 	ldw	r3,-12(fp)
 4006a94:	e0bff617 	ldw	r2,-40(fp)
 4006a98:	10800484 	addi	r2,r2,18
 4006a9c:	100490ba 	slli	r2,r2,2
 4006aa0:	1885883a 	add	r2,r3,r2
 4006aa4:	10800017 	ldw	r2,0(r2)
 4006aa8:	10c00044 	addi	r3,r2,1
 4006aac:	e13ffd17 	ldw	r4,-12(fp)
 4006ab0:	e0bff617 	ldw	r2,-40(fp)
 4006ab4:	10800484 	addi	r2,r2,18
 4006ab8:	100490ba 	slli	r2,r2,2
 4006abc:	2085883a 	add	r2,r4,r2
 4006ac0:	10c00015 	stw	r3,0(r2)

            traceTASK_NOTIFY_GIVE_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 4006ac4:	e0bffbc3 	ldbu	r2,-17(fp)
 4006ac8:	10800058 	cmpnei	r2,r2,1
 4006acc:	1000851e 	bne	r2,zero,4006ce4 <vTaskGenericNotifyGiveFromISR+0x2ac>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 4006ad0:	d0a6bb17 	ldw	r2,-25876(gp)
 4006ad4:	10005b1e 	bne	r2,zero,4006c44 <vTaskGenericNotifyGiveFromISR+0x20c>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 4006ad8:	e0bffd17 	ldw	r2,-12(fp)
 4006adc:	10800517 	ldw	r2,20(r2)
 4006ae0:	e0bff915 	stw	r2,-28(fp)
 4006ae4:	e0bffd17 	ldw	r2,-12(fp)
 4006ae8:	10800217 	ldw	r2,8(r2)
 4006aec:	e0fffd17 	ldw	r3,-12(fp)
 4006af0:	18c00317 	ldw	r3,12(r3)
 4006af4:	10c00215 	stw	r3,8(r2)
 4006af8:	e0bffd17 	ldw	r2,-12(fp)
 4006afc:	10800317 	ldw	r2,12(r2)
 4006b00:	e0fffd17 	ldw	r3,-12(fp)
 4006b04:	18c00217 	ldw	r3,8(r3)
 4006b08:	10c00115 	stw	r3,4(r2)
 4006b0c:	e0bff917 	ldw	r2,-28(fp)
 4006b10:	10c00117 	ldw	r3,4(r2)
 4006b14:	e0bffd17 	ldw	r2,-12(fp)
 4006b18:	10800104 	addi	r2,r2,4
 4006b1c:	1880041e 	bne	r3,r2,4006b30 <vTaskGenericNotifyGiveFromISR+0xf8>
 4006b20:	e0bffd17 	ldw	r2,-12(fp)
 4006b24:	10c00317 	ldw	r3,12(r2)
 4006b28:	e0bff917 	ldw	r2,-28(fp)
 4006b2c:	10c00115 	stw	r3,4(r2)
 4006b30:	e0bffd17 	ldw	r2,-12(fp)
 4006b34:	10000515 	stw	zero,20(r2)
 4006b38:	e0bff917 	ldw	r2,-28(fp)
 4006b3c:	10800017 	ldw	r2,0(r2)
 4006b40:	10ffffc4 	addi	r3,r2,-1
 4006b44:	e0bff917 	ldw	r2,-28(fp)
 4006b48:	10c00015 	stw	r3,0(r2)
                    prvAddTaskToReadyList( pxTCB );
 4006b4c:	e0bffd17 	ldw	r2,-12(fp)
 4006b50:	10800b17 	ldw	r2,44(r2)
 4006b54:	d0e6b317 	ldw	r3,-25908(gp)
 4006b58:	1880032e 	bgeu	r3,r2,4006b68 <vTaskGenericNotifyGiveFromISR+0x130>
 4006b5c:	e0bffd17 	ldw	r2,-12(fp)
 4006b60:	10800b17 	ldw	r2,44(r2)
 4006b64:	d0a6b315 	stw	r2,-25908(gp)
 4006b68:	e0bffd17 	ldw	r2,-12(fp)
 4006b6c:	10800b17 	ldw	r2,44(r2)
 4006b70:	01400504 	movi	r5,20
 4006b74:	1009883a 	mov	r4,r2
 4006b78:	40078580 	call	4007858 <__mulsi3>
 4006b7c:	1007883a 	mov	r3,r2
 4006b80:	00812074 	movhi	r2,1153
 4006b84:	1885883a 	add	r2,r3,r2
 4006b88:	10807717 	ldw	r2,476(r2)
 4006b8c:	e0bff815 	stw	r2,-32(fp)
 4006b90:	e0bffd17 	ldw	r2,-12(fp)
 4006b94:	e0fff817 	ldw	r3,-32(fp)
 4006b98:	10c00215 	stw	r3,8(r2)
 4006b9c:	e0bff817 	ldw	r2,-32(fp)
 4006ba0:	10c00217 	ldw	r3,8(r2)
 4006ba4:	e0bffd17 	ldw	r2,-12(fp)
 4006ba8:	10c00315 	stw	r3,12(r2)
 4006bac:	e0bff817 	ldw	r2,-32(fp)
 4006bb0:	10800217 	ldw	r2,8(r2)
 4006bb4:	e0fffd17 	ldw	r3,-12(fp)
 4006bb8:	18c00104 	addi	r3,r3,4
 4006bbc:	10c00115 	stw	r3,4(r2)
 4006bc0:	e0bffd17 	ldw	r2,-12(fp)
 4006bc4:	10c00104 	addi	r3,r2,4
 4006bc8:	e0bff817 	ldw	r2,-32(fp)
 4006bcc:	10c00215 	stw	r3,8(r2)
 4006bd0:	e0bffd17 	ldw	r2,-12(fp)
 4006bd4:	10800b17 	ldw	r2,44(r2)
 4006bd8:	01400504 	movi	r5,20
 4006bdc:	1009883a 	mov	r4,r2
 4006be0:	40078580 	call	4007858 <__mulsi3>
 4006be4:	1007883a 	mov	r3,r2
 4006be8:	00812074 	movhi	r2,1153
 4006bec:	10807604 	addi	r2,r2,472
 4006bf0:	1887883a 	add	r3,r3,r2
 4006bf4:	e0bffd17 	ldw	r2,-12(fp)
 4006bf8:	10c00515 	stw	r3,20(r2)
 4006bfc:	e0bffd17 	ldw	r2,-12(fp)
 4006c00:	14400b17 	ldw	r17,44(r2)
 4006c04:	01400504 	movi	r5,20
 4006c08:	8809883a 	mov	r4,r17
 4006c0c:	40078580 	call	4007858 <__mulsi3>
 4006c10:	1007883a 	mov	r3,r2
 4006c14:	00812074 	movhi	r2,1153
 4006c18:	1885883a 	add	r2,r3,r2
 4006c1c:	10807617 	ldw	r2,472(r2)
 4006c20:	14000044 	addi	r16,r2,1
 4006c24:	01400504 	movi	r5,20
 4006c28:	8809883a 	mov	r4,r17
 4006c2c:	40078580 	call	4007858 <__mulsi3>
 4006c30:	1007883a 	mov	r3,r2
 4006c34:	00812074 	movhi	r2,1153
 4006c38:	1885883a 	add	r2,r3,r2
 4006c3c:	14007615 	stw	r16,472(r2)
 4006c40:	00001c06 	br	4006cb4 <vTaskGenericNotifyGiveFromISR+0x27c>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 4006c44:	00812074 	movhi	r2,1153
 4006c48:	10809a17 	ldw	r2,616(r2)
 4006c4c:	e0bffa15 	stw	r2,-24(fp)
 4006c50:	e0bffd17 	ldw	r2,-12(fp)
 4006c54:	e0fffa17 	ldw	r3,-24(fp)
 4006c58:	10c00715 	stw	r3,28(r2)
 4006c5c:	e0bffa17 	ldw	r2,-24(fp)
 4006c60:	10c00217 	ldw	r3,8(r2)
 4006c64:	e0bffd17 	ldw	r2,-12(fp)
 4006c68:	10c00815 	stw	r3,32(r2)
 4006c6c:	e0bffa17 	ldw	r2,-24(fp)
 4006c70:	10800217 	ldw	r2,8(r2)
 4006c74:	e0fffd17 	ldw	r3,-12(fp)
 4006c78:	18c00604 	addi	r3,r3,24
 4006c7c:	10c00115 	stw	r3,4(r2)
 4006c80:	e0bffd17 	ldw	r2,-12(fp)
 4006c84:	10c00604 	addi	r3,r2,24
 4006c88:	e0bffa17 	ldw	r2,-24(fp)
 4006c8c:	10c00215 	stw	r3,8(r2)
 4006c90:	e0fffd17 	ldw	r3,-12(fp)
 4006c94:	00812074 	movhi	r2,1153
 4006c98:	10809904 	addi	r2,r2,612
 4006c9c:	18800a15 	stw	r2,40(r3)
 4006ca0:	00812074 	movhi	r2,1153
 4006ca4:	10809917 	ldw	r2,612(r2)
 4006ca8:	10c00044 	addi	r3,r2,1
 4006cac:	00812074 	movhi	r2,1153
 4006cb0:	10c09915 	stw	r3,612(r2)
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 4006cb4:	e0bffd17 	ldw	r2,-12(fp)
 4006cb8:	10800b17 	ldw	r2,44(r2)
 4006cbc:	d0e6ad17 	ldw	r3,-25932(gp)
 4006cc0:	18c00b17 	ldw	r3,44(r3)
 4006cc4:	1880072e 	bgeu	r3,r2,4006ce4 <vTaskGenericNotifyGiveFromISR+0x2ac>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
 4006cc8:	e0bff517 	ldw	r2,-44(fp)
 4006ccc:	10000326 	beq	r2,zero,4006cdc <vTaskGenericNotifyGiveFromISR+0x2a4>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
 4006cd0:	e0bff517 	ldw	r2,-44(fp)
 4006cd4:	00c00044 	movi	r3,1
 4006cd8:	10c00015 	stw	r3,0(r2)
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter in an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
 4006cdc:	00800044 	movi	r2,1
 4006ce0:	d0a6b615 	stw	r2,-25896(gp)
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
    }
 4006ce4:	0001883a 	nop
 4006ce8:	e6fffe04 	addi	sp,fp,-8
 4006cec:	dfc00317 	ldw	ra,12(sp)
 4006cf0:	df000217 	ldw	fp,8(sp)
 4006cf4:	dc400117 	ldw	r17,4(sp)
 4006cf8:	dc000017 	ldw	r16,0(sp)
 4006cfc:	dec00404 	addi	sp,sp,16
 4006d00:	f800283a 	ret

04006d04 <xTaskGenericNotifyStateClear>:

#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    BaseType_t xTaskGenericNotifyStateClear( TaskHandle_t xTask,
                                             UBaseType_t uxIndexToClear )
    {
 4006d04:	defffa04 	addi	sp,sp,-24
 4006d08:	dfc00515 	stw	ra,20(sp)
 4006d0c:	df000415 	stw	fp,16(sp)
 4006d10:	df000404 	addi	fp,sp,16
 4006d14:	e13ffd15 	stw	r4,-12(fp)
 4006d18:	e17ffc15 	stw	r5,-16(fp)

        configASSERT( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
 4006d1c:	e0bffd17 	ldw	r2,-12(fp)
 4006d20:	1000021e 	bne	r2,zero,4006d2c <xTaskGenericNotifyStateClear+0x28>
 4006d24:	d0a6ad17 	ldw	r2,-25932(gp)
 4006d28:	00000106 	br	4006d30 <xTaskGenericNotifyStateClear+0x2c>
 4006d2c:	e0bffd17 	ldw	r2,-12(fp)
 4006d30:	e0bffe15 	stw	r2,-8(fp)

        taskENTER_CRITICAL();
 4006d34:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
        {
            if( pxTCB->ucNotifyState[ uxIndexToClear ] == taskNOTIFICATION_RECEIVED )
 4006d38:	e0fffe17 	ldw	r3,-8(fp)
 4006d3c:	e0bffc17 	ldw	r2,-16(fp)
 4006d40:	1885883a 	add	r2,r3,r2
 4006d44:	10801303 	ldbu	r2,76(r2)
 4006d48:	10803fcc 	andi	r2,r2,255
 4006d4c:	10800098 	cmpnei	r2,r2,2
 4006d50:	1000071e 	bne	r2,zero,4006d70 <xTaskGenericNotifyStateClear+0x6c>
            {
                pxTCB->ucNotifyState[ uxIndexToClear ] = taskNOT_WAITING_NOTIFICATION;
 4006d54:	e0fffe17 	ldw	r3,-8(fp)
 4006d58:	e0bffc17 	ldw	r2,-16(fp)
 4006d5c:	1885883a 	add	r2,r3,r2
 4006d60:	10001305 	stb	zero,76(r2)
                xReturn = pdPASS;
 4006d64:	00800044 	movi	r2,1
 4006d68:	e0bfff15 	stw	r2,-4(fp)
 4006d6c:	00000106 	br	4006d74 <xTaskGenericNotifyStateClear+0x70>
            }
            else
            {
                xReturn = pdFAIL;
 4006d70:	e03fff15 	stw	zero,-4(fp)
            }
        }
        taskEXIT_CRITICAL();
 4006d74:	4005fd00 	call	4005fd0 <vTaskExitCritical>

        return xReturn;
 4006d78:	e0bfff17 	ldw	r2,-4(fp)
    }
 4006d7c:	e037883a 	mov	sp,fp
 4006d80:	dfc00117 	ldw	ra,4(sp)
 4006d84:	df000017 	ldw	fp,0(sp)
 4006d88:	dec00204 	addi	sp,sp,8
 4006d8c:	f800283a 	ret

04006d90 <ulTaskGenericNotifyValueClear>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyValueClear( TaskHandle_t xTask,
                                            UBaseType_t uxIndexToClear,
                                            uint32_t ulBitsToClear )
    {
 4006d90:	defff904 	addi	sp,sp,-28
 4006d94:	dfc00615 	stw	ra,24(sp)
 4006d98:	df000515 	stw	fp,20(sp)
 4006d9c:	df000504 	addi	fp,sp,20
 4006da0:	e13ffd15 	stw	r4,-12(fp)
 4006da4:	e17ffc15 	stw	r5,-16(fp)
 4006da8:	e1bffb15 	stw	r6,-20(fp)
        TCB_t * pxTCB;
        uint32_t ulReturn;

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
 4006dac:	e0bffd17 	ldw	r2,-12(fp)
 4006db0:	1000021e 	bne	r2,zero,4006dbc <ulTaskGenericNotifyValueClear+0x2c>
 4006db4:	d0a6ad17 	ldw	r2,-25932(gp)
 4006db8:	00000106 	br	4006dc0 <ulTaskGenericNotifyValueClear+0x30>
 4006dbc:	e0bffd17 	ldw	r2,-12(fp)
 4006dc0:	e0bfff15 	stw	r2,-4(fp)

        taskENTER_CRITICAL();
 4006dc4:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
        {
            /* Return the notification as it was before the bits were cleared,
             * then clear the bit mask. */
            ulReturn = pxTCB->ulNotifiedValue[ uxIndexToClear ];
 4006dc8:	e0ffff17 	ldw	r3,-4(fp)
 4006dcc:	e0bffc17 	ldw	r2,-16(fp)
 4006dd0:	10800484 	addi	r2,r2,18
 4006dd4:	100490ba 	slli	r2,r2,2
 4006dd8:	1885883a 	add	r2,r3,r2
 4006ddc:	10800017 	ldw	r2,0(r2)
 4006de0:	e0bffe15 	stw	r2,-8(fp)
            pxTCB->ulNotifiedValue[ uxIndexToClear ] &= ~ulBitsToClear;
 4006de4:	e0ffff17 	ldw	r3,-4(fp)
 4006de8:	e0bffc17 	ldw	r2,-16(fp)
 4006dec:	10800484 	addi	r2,r2,18
 4006df0:	100490ba 	slli	r2,r2,2
 4006df4:	1885883a 	add	r2,r3,r2
 4006df8:	10c00017 	ldw	r3,0(r2)
 4006dfc:	e0bffb17 	ldw	r2,-20(fp)
 4006e00:	0084303a 	nor	r2,zero,r2
 4006e04:	1886703a 	and	r3,r3,r2
 4006e08:	e13fff17 	ldw	r4,-4(fp)
 4006e0c:	e0bffc17 	ldw	r2,-16(fp)
 4006e10:	10800484 	addi	r2,r2,18
 4006e14:	100490ba 	slli	r2,r2,2
 4006e18:	2085883a 	add	r2,r4,r2
 4006e1c:	10c00015 	stw	r3,0(r2)
        }
        taskEXIT_CRITICAL();
 4006e20:	4005fd00 	call	4005fd0 <vTaskExitCritical>

        return ulReturn;
 4006e24:	e0bffe17 	ldw	r2,-8(fp)
    }
 4006e28:	e037883a 	mov	sp,fp
 4006e2c:	dfc00117 	ldw	ra,4(sp)
 4006e30:	df000017 	ldw	fp,0(sp)
 4006e34:	dec00204 	addi	sp,sp,8
 4006e38:	f800283a 	ret

04006e3c <prvAddCurrentTaskToDelayedList>:
#endif /* if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) ) */
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
                                            const BaseType_t xCanBlockIndefinitely )
{
 4006e3c:	defff904 	addi	sp,sp,-28
 4006e40:	dfc00615 	stw	ra,24(sp)
 4006e44:	df000515 	stw	fp,20(sp)
 4006e48:	df000504 	addi	fp,sp,20
 4006e4c:	e13ffc15 	stw	r4,-16(fp)
 4006e50:	e17ffb15 	stw	r5,-20(fp)
    TickType_t xTimeToWake;
    const TickType_t xConstTickCount = xTickCount;
 4006e54:	d0a6b217 	ldw	r2,-25912(gp)
 4006e58:	e0bfff15 	stw	r2,-4(fp)
    }
    #endif

    /* Remove the task from the ready list before adding it to the blocked list
     * as the same list item is used for both lists. */
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 4006e5c:	d0a6ad17 	ldw	r2,-25932(gp)
 4006e60:	10800104 	addi	r2,r2,4
 4006e64:	1009883a 	mov	r4,r2
 4006e68:	4000c980 	call	4000c98 <uxListRemove>
        mtCOVERAGE_TEST_MARKER();
    }

    #if ( INCLUDE_vTaskSuspend == 1 )
    {
        if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 4006e6c:	e0bffc17 	ldw	r2,-16(fp)
 4006e70:	10bfffd8 	cmpnei	r2,r2,-1
 4006e74:	1000201e 	bne	r2,zero,4006ef8 <prvAddCurrentTaskToDelayedList+0xbc>
 4006e78:	e0bffb17 	ldw	r2,-20(fp)
 4006e7c:	10001e26 	beq	r2,zero,4006ef8 <prvAddCurrentTaskToDelayedList+0xbc>
        {
            /* Add the task to the suspended task list instead of a delayed task
             * list to ensure it is not woken by a timing event.  It will block
             * indefinitely. */
            listINSERT_END( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 4006e80:	00812074 	movhi	r2,1153
 4006e84:	1080a417 	ldw	r2,656(r2)
 4006e88:	e0bffe15 	stw	r2,-8(fp)
 4006e8c:	d0a6ad17 	ldw	r2,-25932(gp)
 4006e90:	e0fffe17 	ldw	r3,-8(fp)
 4006e94:	10c00215 	stw	r3,8(r2)
 4006e98:	d0a6ad17 	ldw	r2,-25932(gp)
 4006e9c:	e0fffe17 	ldw	r3,-8(fp)
 4006ea0:	18c00217 	ldw	r3,8(r3)
 4006ea4:	10c00315 	stw	r3,12(r2)
 4006ea8:	d0e6ad17 	ldw	r3,-25932(gp)
 4006eac:	e0bffe17 	ldw	r2,-8(fp)
 4006eb0:	10800217 	ldw	r2,8(r2)
 4006eb4:	18c00104 	addi	r3,r3,4
 4006eb8:	10c00115 	stw	r3,4(r2)
 4006ebc:	d0a6ad17 	ldw	r2,-25932(gp)
 4006ec0:	10c00104 	addi	r3,r2,4
 4006ec4:	e0bffe17 	ldw	r2,-8(fp)
 4006ec8:	10c00215 	stw	r3,8(r2)
 4006ecc:	d0e6ad17 	ldw	r3,-25932(gp)
 4006ed0:	00812074 	movhi	r2,1153
 4006ed4:	1080a304 	addi	r2,r2,652
 4006ed8:	18800515 	stw	r2,20(r3)
 4006edc:	00812074 	movhi	r2,1153
 4006ee0:	1080a317 	ldw	r2,652(r2)
 4006ee4:	10c00044 	addi	r3,r2,1
 4006ee8:	00812074 	movhi	r2,1153
 4006eec:	10c0a315 	stw	r3,652(r2)
 4006ef0:	0001883a 	nop

        /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
        ( void ) xCanBlockIndefinitely;
    }
    #endif /* INCLUDE_vTaskSuspend */
}
 4006ef4:	00001c06 	br	4006f68 <prvAddCurrentTaskToDelayedList+0x12c>
            xTimeToWake = xConstTickCount + xTicksToWait;
 4006ef8:	e0ffff17 	ldw	r3,-4(fp)
 4006efc:	e0bffc17 	ldw	r2,-16(fp)
 4006f00:	1885883a 	add	r2,r3,r2
 4006f04:	e0bffd15 	stw	r2,-12(fp)
            listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 4006f08:	d0a6ad17 	ldw	r2,-25932(gp)
 4006f0c:	e0fffd17 	ldw	r3,-12(fp)
 4006f10:	10c00115 	stw	r3,4(r2)
            if( xTimeToWake < xConstTickCount )
 4006f14:	e0fffd17 	ldw	r3,-12(fp)
 4006f18:	e0bfff17 	ldw	r2,-4(fp)
 4006f1c:	1880072e 	bgeu	r3,r2,4006f3c <prvAddCurrentTaskToDelayedList+0x100>
                vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 4006f20:	d0e6af17 	ldw	r3,-25924(gp)
 4006f24:	d0a6ad17 	ldw	r2,-25932(gp)
 4006f28:	10800104 	addi	r2,r2,4
 4006f2c:	100b883a 	mov	r5,r2
 4006f30:	1809883a 	mov	r4,r3
 4006f34:	4000bc00 	call	4000bc0 <vListInsert>
}
 4006f38:	00000b06 	br	4006f68 <prvAddCurrentTaskToDelayedList+0x12c>
                vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 4006f3c:	d0e6ae17 	ldw	r3,-25928(gp)
 4006f40:	d0a6ad17 	ldw	r2,-25932(gp)
 4006f44:	10800104 	addi	r2,r2,4
 4006f48:	100b883a 	mov	r5,r2
 4006f4c:	1809883a 	mov	r4,r3
 4006f50:	4000bc00 	call	4000bc0 <vListInsert>
                if( xTimeToWake < xNextTaskUnblockTime )
 4006f54:	d0a6b917 	ldw	r2,-25884(gp)
 4006f58:	e0fffd17 	ldw	r3,-12(fp)
 4006f5c:	1880022e 	bgeu	r3,r2,4006f68 <prvAddCurrentTaskToDelayedList+0x12c>
                    xNextTaskUnblockTime = xTimeToWake;
 4006f60:	e0bffd17 	ldw	r2,-12(fp)
 4006f64:	d0a6b915 	stw	r2,-25884(gp)
}
 4006f68:	0001883a 	nop
 4006f6c:	e037883a 	mov	sp,fp
 4006f70:	dfc00117 	ldw	ra,4(sp)
 4006f74:	df000017 	ldw	fp,0(sp)
 4006f78:	dec00204 	addi	sp,sp,8
 4006f7c:	f800283a 	ret

04006f80 <main>:
	uint8_t result;		//result of operation
	uint8_t operation;	//code of operation
};

int main()
{
 4006f80:	defffc04 	addi	sp,sp,-16
 4006f84:	dfc00315 	stw	ra,12(sp)
 4006f88:	df000215 	stw	fp,8(sp)
 4006f8c:	df000204 	addi	fp,sp,8
  printf("Hello from Nios II running FreeRTOS!\n");
 4006f90:	01010074 	movhi	r4,1025
 4006f94:	2132fc04 	addi	r4,r4,-13328
 4006f98:	4007b900 	call	4007b90 <puts>

  //Create Queues
  pushbutton_queue = xQueueCreate(1, sizeof(uint8_t));
 4006f9c:	000d883a 	mov	r6,zero
 4006fa0:	01400044 	movi	r5,1
 4006fa4:	01000044 	movi	r4,1
 4006fa8:	40013d80 	call	40013d8 <xQueueGenericCreate>
 4006fac:	d0a6bc15 	stw	r2,-25872(gp)
  switch_queue = xQueueCreate(1, sizeof(struct hex_results));
 4006fb0:	000d883a 	mov	r6,zero
 4006fb4:	01400104 	movi	r5,4
 4006fb8:	01000044 	movi	r4,1
 4006fbc:	40013d80 	call	40013d8 <xQueueGenericCreate>
 4006fc0:	d0a6bd15 	stw	r2,-25868(gp)

  //Create Tasks
  xTaskCreate(taskLEDControl, "LED Task", 512, NULL, 2, NULL);
 4006fc4:	d8000115 	stw	zero,4(sp)
 4006fc8:	00800084 	movi	r2,2
 4006fcc:	d8800015 	stw	r2,0(sp)
 4006fd0:	000f883a 	mov	r7,zero
 4006fd4:	01808004 	movi	r6,512
 4006fd8:	01410074 	movhi	r5,1025
 4006fdc:	29730604 	addi	r5,r5,-13288
 4006fe0:	01010034 	movhi	r4,1024
 4006fe4:	211cfc04 	addi	r4,r4,29680
 4006fe8:	40037b40 	call	40037b4 <xTaskCreate>
  xTaskCreate(taskReadPBs, "Pushbutton Task", 512, NULL, 2, NULL);
 4006fec:	d8000115 	stw	zero,4(sp)
 4006ff0:	00800084 	movi	r2,2
 4006ff4:	d8800015 	stw	r2,0(sp)
 4006ff8:	000f883a 	mov	r7,zero
 4006ffc:	01808004 	movi	r6,512
 4007000:	01410074 	movhi	r5,1025
 4007004:	29730904 	addi	r5,r5,-13276
 4007008:	01010034 	movhi	r4,1024
 400700c:	211cdb04 	addi	r4,r4,29548
 4007010:	40037b40 	call	40037b4 <xTaskCreate>
  xTaskCreate(taskReadSWs, "Switch Task", 512, NULL, 2, NULL);
 4007014:	d8000115 	stw	zero,4(sp)
 4007018:	00800084 	movi	r2,2
 400701c:	d8800015 	stw	r2,0(sp)
 4007020:	000f883a 	mov	r7,zero
 4007024:	01808004 	movi	r6,512
 4007028:	01410074 	movhi	r5,1025
 400702c:	29730d04 	addi	r5,r5,-13260
 4007030:	01010034 	movhi	r4,1024
 4007034:	211c9304 	addi	r4,r4,29260
 4007038:	40037b40 	call	40037b4 <xTaskCreate>
  xTaskCreate(taskDisplaySevenSeg, "7Seg Display Task", 512, NULL, 2, NULL);
 400703c:	d8000115 	stw	zero,4(sp)
 4007040:	00800084 	movi	r2,2
 4007044:	d8800015 	stw	r2,0(sp)
 4007048:	000f883a 	mov	r7,zero
 400704c:	01808004 	movi	r6,512
 4007050:	01410074 	movhi	r5,1025
 4007054:	29731004 	addi	r5,r5,-13248
 4007058:	01010034 	movhi	r4,1024
 400705c:	211c1c04 	addi	r4,r4,28784
 4007060:	40037b40 	call	40037b4 <xTaskCreate>

  //Start Scheduler
  vTaskStartScheduler();
 4007064:	40046140 	call	4004614 <vTaskStartScheduler>

  while(1)//Should not reach here
 4007068:	0001883a 	nop
 400706c:	003ffe06 	br	4007068 <main+0xe8>

04007070 <taskDisplaySevenSeg>:
* Postcondition:
*		   Decodes values less than 99 to decimal values and
*		   sends them to 7-deg display. Values > 99 are displayed as hex.
************************************************************************/
void taskDisplaySevenSeg(void* p)
{
 4007070:	defff904 	addi	sp,sp,-28
 4007074:	dfc00615 	stw	ra,24(sp)
 4007078:	df000515 	stw	fp,20(sp)
 400707c:	df000504 	addi	fp,sp,20
 4007080:	e13ffb15 	stw	r4,-20(fp)
	struct hex_results msg = {0, 0, 0, 0};		//Struct to store values to send to queue
 4007084:	e03ffe05 	stb	zero,-8(fp)
 4007088:	e03ffe45 	stb	zero,-7(fp)
 400708c:	e03ffe85 	stb	zero,-6(fp)
 4007090:	e03ffec5 	stb	zero,-5(fp)
	uint8_t displayVals[6] = {0};				//Values to send to 7-seg displays
 4007094:	e03ffc8d 	sth	zero,-14(fp)
 4007098:	e03ffd0d 	sth	zero,-12(fp)
 400709c:	e03ffd8d 	sth	zero,-10(fp)

	while(1)
	{
		if(xQueueReceive(switch_queue, &msg, 0))//Receive from queue
 40070a0:	d0a6bd17 	ldw	r2,-25868(gp)
 40070a4:	e0fffe04 	addi	r3,fp,-8
 40070a8:	000d883a 	mov	r6,zero
 40070ac:	180b883a 	mov	r5,r3
 40070b0:	1009883a 	mov	r4,r2
 40070b4:	4001c040 	call	4001c04 <xQueueReceive>
 40070b8:	10006126 	beq	r2,zero,4007240 <taskDisplaySevenSeg+0x1d0>
		{

			if(msg.operation > 0)
 40070bc:	e0bffec3 	ldbu	r2,-5(fp)
 40070c0:	10803fcc 	andi	r2,r2,255
 40070c4:	10003a26 	beq	r2,zero,40071b0 <taskDisplaySevenSeg+0x140>
			{
				displayVals[4] = msg.num1 % 10;
 40070c8:	e0bffe03 	ldbu	r2,-8(fp)
 40070cc:	10803fcc 	andi	r2,r2,255
 40070d0:	01400284 	movi	r5,10
 40070d4:	1009883a 	mov	r4,r2
 40070d8:	40077fc0 	call	40077fc <__umodsi3>
 40070dc:	e0bffd85 	stb	r2,-10(fp)
				displayVals[5] = msg.num1/10;
 40070e0:	e0bffe03 	ldbu	r2,-8(fp)
 40070e4:	10803fcc 	andi	r2,r2,255
 40070e8:	01400284 	movi	r5,10
 40070ec:	1009883a 	mov	r4,r2
 40070f0:	40077980 	call	4007798 <__udivsi3>
 40070f4:	e0bffdc5 	stb	r2,-9(fp)
				displayVals[2] = msg.num2 % 10;
 40070f8:	e0bffe43 	ldbu	r2,-7(fp)
 40070fc:	10803fcc 	andi	r2,r2,255
 4007100:	01400284 	movi	r5,10
 4007104:	1009883a 	mov	r4,r2
 4007108:	40077fc0 	call	40077fc <__umodsi3>
 400710c:	e0bffd05 	stb	r2,-12(fp)
				displayVals[3] = msg.num2/10;
 4007110:	e0bffe43 	ldbu	r2,-7(fp)
 4007114:	10803fcc 	andi	r2,r2,255
 4007118:	01400284 	movi	r5,10
 400711c:	1009883a 	mov	r4,r2
 4007120:	40077980 	call	4007798 <__udivsi3>
 4007124:	e0bffd45 	stb	r2,-11(fp)

				displayVals[0] = msg.result % 10;
 4007128:	e0bffe83 	ldbu	r2,-6(fp)
 400712c:	10803fcc 	andi	r2,r2,255
 4007130:	01400284 	movi	r5,10
 4007134:	1009883a 	mov	r4,r2
 4007138:	40077fc0 	call	40077fc <__umodsi3>
 400713c:	e0bffc85 	stb	r2,-14(fp)
				if(msg.result >= 100)//2x 7-segs cannot display decimal value > 99
 4007140:	e0bffe83 	ldbu	r2,-6(fp)
 4007144:	10803fcc 	andi	r2,r2,255
 4007148:	10801930 	cmpltui	r2,r2,100
 400714c:	10000b1e 	bne	r2,zero,400717c <taskDisplaySevenSeg+0x10c>
				{
					//displayVals[0] = (msg.result & 0x0F);//Displays hex value instead
					//displayVals[1] = (msg.result >> 4);
					displayVals[1] = ((int)(msg.result/10))%10;//Display lowest two digits
 4007150:	e0bffe83 	ldbu	r2,-6(fp)
 4007154:	10803fcc 	andi	r2,r2,255
 4007158:	01400284 	movi	r5,10
 400715c:	1009883a 	mov	r4,r2
 4007160:	40077980 	call	4007798 <__udivsi3>
 4007164:	10803fcc 	andi	r2,r2,255
 4007168:	01400284 	movi	r5,10
 400716c:	1009883a 	mov	r4,r2
 4007170:	40077fc0 	call	40077fc <__umodsi3>
 4007174:	e0bffcc5 	stb	r2,-13(fp)
 4007178:	00001906 	br	40071e0 <taskDisplaySevenSeg+0x170>
					//Most significant value = msg.result / 100
				}
				else
				{
					displayVals[0] = msg.result % 10;//Display values <= 99 in decimal
 400717c:	e0bffe83 	ldbu	r2,-6(fp)
 4007180:	10803fcc 	andi	r2,r2,255
 4007184:	01400284 	movi	r5,10
 4007188:	1009883a 	mov	r4,r2
 400718c:	40077fc0 	call	40077fc <__umodsi3>
 4007190:	e0bffc85 	stb	r2,-14(fp)
					displayVals[1] = msg.result/10;
 4007194:	e0bffe83 	ldbu	r2,-6(fp)
 4007198:	10803fcc 	andi	r2,r2,255
 400719c:	01400284 	movi	r5,10
 40071a0:	1009883a 	mov	r4,r2
 40071a4:	40077980 	call	4007798 <__udivsi3>
 40071a8:	e0bffcc5 	stb	r2,-13(fp)
 40071ac:	00000c06 	br	40071e0 <taskDisplaySevenSeg+0x170>
				}
			}
			else
			{
				for(int displayIndex = 0; displayIndex < 6; ++displayIndex)
 40071b0:	e03fff15 	stw	zero,-4(fp)
 40071b4:	00000706 	br	40071d4 <taskDisplaySevenSeg+0x164>
				{
					displayVals[displayIndex] = 16;
 40071b8:	e0bfff17 	ldw	r2,-4(fp)
 40071bc:	e085883a 	add	r2,fp,r2
 40071c0:	00c00404 	movi	r3,16
 40071c4:	10fffc85 	stb	r3,-14(r2)
				for(int displayIndex = 0; displayIndex < 6; ++displayIndex)
 40071c8:	e0bfff17 	ldw	r2,-4(fp)
 40071cc:	10800044 	addi	r2,r2,1
 40071d0:	e0bfff15 	stw	r2,-4(fp)
 40071d4:	e0bfff17 	ldw	r2,-4(fp)
 40071d8:	10800190 	cmplti	r2,r2,6
 40071dc:	103ff61e 	bne	r2,zero,40071b8 <taskDisplaySevenSeg+0x148>
				}
			}

			IOWR(SEVENSEGDECODER_0_BASE, 0, displayVals[0]);
 40071e0:	e0bffc83 	ldbu	r2,-14(fp)
 40071e4:	10c03fcc 	andi	r3,r2,255
 40071e8:	00820034 	movhi	r2,2048
 40071ec:	10c40835 	stwio	r3,4128(r2)
			IOWR(SEVENSEGDECODER_1_BASE, 0, displayVals[1]);
 40071f0:	e0bffcc3 	ldbu	r2,-13(fp)
 40071f4:	10c03fcc 	andi	r3,r2,255
 40071f8:	00820034 	movhi	r2,2048
 40071fc:	10c41c35 	stwio	r3,4208(r2)
			IOWR(SEVENSEGDECODER_2_BASE, 0, displayVals[2]);
 4007200:	e0bffd03 	ldbu	r2,-12(fp)
 4007204:	10c03fcc 	andi	r3,r2,255
 4007208:	00820034 	movhi	r2,2048
 400720c:	10c41835 	stwio	r3,4192(r2)
			IOWR(SEVENSEGDECODER_3_BASE, 0, displayVals[3]);
 4007210:	e0bffd43 	ldbu	r2,-11(fp)
 4007214:	10c03fcc 	andi	r3,r2,255
 4007218:	00820034 	movhi	r2,2048
 400721c:	10c40c35 	stwio	r3,4144(r2)
			IOWR(SEVENSEGDECODER_4_BASE, 0, displayVals[4]);
 4007220:	e0bffd83 	ldbu	r2,-10(fp)
 4007224:	10c03fcc 	andi	r3,r2,255
 4007228:	00820034 	movhi	r2,2048
 400722c:	10c41435 	stwio	r3,4176(r2)
			IOWR(SEVENSEGDECODER_5_BASE, 0, displayVals[5]);
 4007230:	e0bffdc3 	ldbu	r2,-9(fp)
 4007234:	10c03fcc 	andi	r3,r2,255
 4007238:	00820034 	movhi	r2,2048
 400723c:	10c41035 	stwio	r3,4160(r2)
		}
		vTaskDelay(30);
 4007240:	01000784 	movi	r4,30
 4007244:	4003df00 	call	4003df0 <vTaskDelay>
		if(xQueueReceive(switch_queue, &msg, 0))//Receive from queue
 4007248:	003f9506 	br	40070a0 <taskDisplaySevenSeg+0x30>

0400724c <taskReadSWs>:
* Postcondition:
*		   Records 10-bit value of which switches are active and sends them
*		   to a queue.
************************************************************************/
void taskReadSWs (void* p)
{
 400724c:	defffb04 	addi	sp,sp,-20
 4007250:	dfc00415 	stw	ra,16(sp)
 4007254:	df000315 	stw	fp,12(sp)
 4007258:	df000304 	addi	fp,sp,12
 400725c:	e13ffd15 	stw	r4,-12(fp)
	struct hex_results msg = {0,0,0,0};		//Var to store queue messages
 4007260:	e03ffe85 	stb	zero,-6(fp)
 4007264:	e03ffec5 	stb	zero,-5(fp)
 4007268:	e03fff05 	stb	zero,-4(fp)
 400726c:	e03fff45 	stb	zero,-3(fp)
	uint16_t switches = 0;					//Var to store values of switches
 4007270:	e03fff8d 	sth	zero,-2(fp)

	while (1)
	{
		//Read switches
		switches = IORD(SWITCHES_0_BASE, 0);
 4007274:	00820034 	movhi	r2,2048
 4007278:	10842437 	ldwio	r2,4240(r2)
 400727c:	e0bfff8d 	sth	r2,-2(fp)
		vTaskDelay(30);
 4007280:	01000784 	movi	r4,30
 4007284:	4003df00 	call	4003df0 <vTaskDelay>
		if(switches == IORD(SWITCHES_0_BASE, 0))//Debounce
 4007288:	e0ffff8b 	ldhu	r3,-2(fp)
 400728c:	00820034 	movhi	r2,2048
 4007290:	10842437 	ldwio	r2,4240(r2)
 4007294:	18802b1e 	bne	r3,r2,4007344 <taskReadSWs+0xf8>
		{
			//Parse 0-3 into num1 and 4-7 into num2
			msg.num1 = (switches & 0x00F);
 4007298:	e0bfff8b 	ldhu	r2,-2(fp)
 400729c:	108003cc 	andi	r2,r2,15
 40072a0:	e0bffe85 	stb	r2,-6(fp)
			msg.num2 = ((switches >> 4) & 0x00F);
 40072a4:	e0bfff8b 	ldhu	r2,-2(fp)
 40072a8:	1004d13a 	srli	r2,r2,4
 40072ac:	108003cc 	andi	r2,r2,15
 40072b0:	e0bffec5 	stb	r2,-5(fp)

			//Parse operation (SW8-9)
			msg.operation = ((switches >> 8) & 0x003);
 40072b4:	e0bfff8b 	ldhu	r2,-2(fp)
 40072b8:	1004d23a 	srli	r2,r2,8
 40072bc:	108000cc 	andi	r2,r2,3
 40072c0:	e0bfff45 	stb	r2,-3(fp)

			//Perform operation and store numbers and result
			switch(msg.operation)
 40072c4:	e0bfff43 	ldbu	r2,-3(fp)
 40072c8:	10803fcc 	andi	r2,r2,255
 40072cc:	10c000e0 	cmpeqi	r3,r2,3
 40072d0:	1800151e 	bne	r3,zero,4007328 <taskReadSWs+0xdc>
 40072d4:	10c00108 	cmpgei	r3,r2,4
 40072d8:	18001a1e 	bne	r3,zero,4007344 <taskReadSWs+0xf8>
 40072dc:	10c00060 	cmpeqi	r3,r2,1
 40072e0:	1800031e 	bne	r3,zero,40072f0 <taskReadSWs+0xa4>
 40072e4:	108000a0 	cmpeqi	r2,r2,2
 40072e8:	1000061e 	bne	r2,zero,4007304 <taskReadSWs+0xb8>
 40072ec:	00001506 	br	4007344 <taskReadSWs+0xf8>
			{
			case 1:		//Add
				msg.result = msg.num1 + msg.num2;
 40072f0:	e0fffe83 	ldbu	r3,-6(fp)
 40072f4:	e0bffec3 	ldbu	r2,-5(fp)
 40072f8:	1885883a 	add	r2,r3,r2
 40072fc:	e0bfff05 	stb	r2,-4(fp)
				break;
 4007300:	00001006 	br	4007344 <taskReadSWs+0xf8>
			case 2:		//Subtract
				msg.result = (abs(msg.num1 - msg.num2));
 4007304:	e0bffe83 	ldbu	r2,-6(fp)
 4007308:	10c03fcc 	andi	r3,r2,255
 400730c:	e0bffec3 	ldbu	r2,-5(fp)
 4007310:	10803fcc 	andi	r2,r2,255
 4007314:	1885c83a 	sub	r2,r3,r2
 4007318:	1000010e 	bge	r2,zero,4007320 <taskReadSWs+0xd4>
 400731c:	0085c83a 	sub	r2,zero,r2
 4007320:	e0bfff05 	stb	r2,-4(fp)
				break;
 4007324:	00000706 	br	4007344 <taskReadSWs+0xf8>
			case 3:	    //Multiply
				msg.result = msg.num1 * msg.num2;
 4007328:	e0bffe83 	ldbu	r2,-6(fp)
 400732c:	e0fffec3 	ldbu	r3,-5(fp)
 4007330:	180b883a 	mov	r5,r3
 4007334:	1009883a 	mov	r4,r2
 4007338:	40078580 	call	4007858 <__mulsi3>
 400733c:	e0bfff05 	stb	r2,-4(fp)
				break;
 4007340:	0001883a 	nop
			}
		}

		//Send struct to hex task
		xQueueSendToBack(switch_queue, &msg, 0);
 4007344:	d0a6bd17 	ldw	r2,-25868(gp)
 4007348:	e0fffe84 	addi	r3,fp,-6
 400734c:	000f883a 	mov	r7,zero
 4007350:	000d883a 	mov	r6,zero
 4007354:	180b883a 	mov	r5,r3
 4007358:	1009883a 	mov	r4,r2
 400735c:	40018580 	call	4001858 <xQueueGenericSend>
		vTaskDelay(100);
 4007360:	01001904 	movi	r4,100
 4007364:	4003df00 	call	4003df0 <vTaskDelay>
		switches = IORD(SWITCHES_0_BASE, 0);
 4007368:	003fc206 	br	4007274 <taskReadSWs+0x28>

0400736c <taskReadPBs>:
* Postcondition:
*		   Records 4-bit value of which buttons are pressed and sends them
*		   to a queue.
************************************************************************/
void taskReadPBs (void* p)
{
 400736c:	defffc04 	addi	sp,sp,-16
 4007370:	dfc00315 	stw	ra,12(sp)
 4007374:	df000215 	stw	fp,8(sp)
 4007378:	df000204 	addi	fp,sp,8
 400737c:	e13ffe15 	stw	r4,-8(fp)
	//PBs are already debounced
	uint8_t pb_num = 0;				//Number to store PB values
 4007380:	e03fffc5 	stb	zero,-1(fp)

	while(1)
	{
		//Scan PBs, negate, and send to queue
		pb_num = (0x0F & (~(IORD(PUSHBUTTONS_0_BASE, 0))));//PBs are active low
 4007384:	00820034 	movhi	r2,2048
 4007388:	10842037 	ldwio	r2,4224(r2)
 400738c:	0084303a 	nor	r2,zero,r2
 4007390:	108003cc 	andi	r2,r2,15
 4007394:	e0bfffc5 	stb	r2,-1(fp)
		while((0x0F & (~(IORD(PUSHBUTTONS_0_BASE, 0))) && pb_num))
 4007398:	0001883a 	nop
 400739c:	00820034 	movhi	r2,2048
 40073a0:	10842037 	ldwio	r2,4224(r2)
 40073a4:	0084303a 	nor	r2,zero,r2
 40073a8:	108003cc 	andi	r2,r2,15
 40073ac:	10000326 	beq	r2,zero,40073bc <taskReadPBs+0x50>
 40073b0:	e0bfffc3 	ldbu	r2,-1(fp)
 40073b4:	10803fcc 	andi	r2,r2,255
 40073b8:	103ff81e 	bne	r2,zero,400739c <taskReadPBs+0x30>
		{}

		if(pb_num != 0)
 40073bc:	e0bfffc3 	ldbu	r2,-1(fp)
 40073c0:	10803fcc 	andi	r2,r2,255
 40073c4:	10000726 	beq	r2,zero,40073e4 <taskReadPBs+0x78>
			xQueueSendToBack(pushbutton_queue, &pb_num, 0);
 40073c8:	d0a6bc17 	ldw	r2,-25872(gp)
 40073cc:	e0ffffc4 	addi	r3,fp,-1
 40073d0:	000f883a 	mov	r7,zero
 40073d4:	000d883a 	mov	r6,zero
 40073d8:	180b883a 	mov	r5,r3
 40073dc:	1009883a 	mov	r4,r2
 40073e0:	40018580 	call	4001858 <xQueueGenericSend>
		vTaskDelay(100);
 40073e4:	01001904 	movi	r4,100
 40073e8:	4003df00 	call	4003df0 <vTaskDelay>
		pb_num = (0x0F & (~(IORD(PUSHBUTTONS_0_BASE, 0))));//PBs are active low
 40073ec:	003fe506 	br	4007384 <taskReadPBs+0x18>

040073f0 <taskLEDControl>:
* Postcondition:
*		   Illuminates LEDs in cylon, up counter, or custom.
*		   Otherwise, LEDs will be off.
************************************************************************/
void taskLEDControl (void* p)
{
 40073f0:	defff904 	addi	sp,sp,-28
 40073f4:	dfc00615 	stw	ra,24(sp)
 40073f8:	df000515 	stw	fp,20(sp)
 40073fc:	df000504 	addi	fp,sp,20
 4007400:	e13ffb15 	stw	r4,-20(fp)
	uint8_t pb_num = 0;			//Var to store queue PB value
 4007404:	e03ffcc5 	stb	zero,-13(fp)
	uint8_t cur_seq = 0;		//Var to store current LED pattern
 4007408:	e03fffc5 	stb	zero,-1(fp)
	uint16_t displayVal = 0;	//Var to store LED values to be written
 400740c:	e03fff0d 	sth	zero,-4(fp)
	uint8_t startSeq = 1;		//Var to track initial start of patterns
 4007410:	00800044 	movi	r2,1
 4007414:	e0bffec5 	stb	r2,-5(fp)
	uint8_t seqFlags = 1;		//Var to track cases within patters (i.e. cylon traveling left/right)
 4007418:	00800044 	movi	r2,1
 400741c:	e0bffe85 	stb	r2,-6(fp)
	uint16_t SeqL = 0;			//Var to store custom pattern for left LEDs
 4007420:	e03ffe0d 	sth	zero,-8(fp)
	uint16_t SeqR = 0;			//Var to store custom pattern for right LEDs
 4007424:	e03ffd8d 	sth	zero,-10(fp)
	uint16_t delay = 0; 		//Var to store delay values
 4007428:	e03ffd0d 	sth	zero,-12(fp)

	while(1)
	{
		if(xQueueReceive(pushbutton_queue, &pb_num, 0))//Receive from queue
 400742c:	d0a6bc17 	ldw	r2,-25872(gp)
 4007430:	e0fffcc4 	addi	r3,fp,-13
 4007434:	000d883a 	mov	r6,zero
 4007438:	180b883a 	mov	r5,r3
 400743c:	1009883a 	mov	r4,r2
 4007440:	4001c040 	call	4001c04 <xQueueReceive>
 4007444:	10000926 	beq	r2,zero,400746c <taskLEDControl+0x7c>
		{
			if(!(pb_num & cur_seq))
 4007448:	e0bffcc3 	ldbu	r2,-13(fp)
 400744c:	e0ffffc3 	ldbu	r3,-1(fp)
 4007450:	1884703a 	and	r2,r3,r2
 4007454:	10803fcc 	andi	r2,r2,255
 4007458:	1000041e 	bne	r2,zero,400746c <taskLEDControl+0x7c>
			{
				cur_seq = pb_num;
 400745c:	e0bffcc3 	ldbu	r2,-13(fp)
 4007460:	e0bfffc5 	stb	r2,-1(fp)
				startSeq = 1;
 4007464:	00800044 	movi	r2,1
 4007468:	e0bffec5 	stb	r2,-5(fp)
			}
		}

		switch(cur_seq)//Run specified pattern
 400746c:	e0bfffc3 	ldbu	r2,-1(fp)
 4007470:	10c00220 	cmpeqi	r3,r2,8
 4007474:	1800371e 	bne	r3,zero,4007554 <taskLEDControl+0x164>
 4007478:	10c00248 	cmpgei	r3,r2,9
 400747c:	1800811e 	bne	r3,zero,4007684 <taskLEDControl+0x294>
 4007480:	10c000a0 	cmpeqi	r3,r2,2
 4007484:	1800031e 	bne	r3,zero,4007494 <taskLEDControl+0xa4>
 4007488:	10800120 	cmpeqi	r2,r2,4
 400748c:	1000201e 	bne	r2,zero,4007510 <taskLEDControl+0x120>
 4007490:	00007c06 	br	4007684 <taskLEDControl+0x294>
		{
		case 2:	//0010 --> Cylon
			if(startSeq)
 4007494:	e0bffec3 	ldbu	r2,-5(fp)
 4007498:	10000526 	beq	r2,zero,40074b0 <taskLEDControl+0xc0>
			{
				displayVal = 3;
 400749c:	008000c4 	movi	r2,3
 40074a0:	e0bfff0d 	sth	r2,-4(fp)
				startSeq = 0;
 40074a4:	e03ffec5 	stb	zero,-5(fp)
				seqFlags = 1;
 40074a8:	00800044 	movi	r2,1
 40074ac:	e0bffe85 	stb	r2,-6(fp)
			}

			IOWR(LEDS_0_BASE, 0, displayVal);
 40074b0:	e0ffff0b 	ldhu	r3,-4(fp)
 40074b4:	00820034 	movhi	r2,2048
 40074b8:	10c42835 	stwio	r3,4256(r2)

			if(seqFlags)//Travel left
 40074bc:	e0bffe83 	ldbu	r2,-6(fp)
 40074c0:	10000826 	beq	r2,zero,40074e4 <taskLEDControl+0xf4>
			{
				displayVal = (displayVal << 1);
 40074c4:	e0bfff0b 	ldhu	r2,-4(fp)
 40074c8:	1085883a 	add	r2,r2,r2
 40074cc:	e0bfff0d 	sth	r2,-4(fp)
				if(displayVal == 0x300)
 40074d0:	e0bfff0b 	ldhu	r2,-4(fp)
 40074d4:	1080c018 	cmpnei	r2,r2,768
 40074d8:	10000a1e 	bne	r2,zero,4007504 <taskLEDControl+0x114>
					seqFlags = 0;
 40074dc:	e03ffe85 	stb	zero,-6(fp)
 40074e0:	00000806 	br	4007504 <taskLEDControl+0x114>
			}
			else		//Travel right
			{
				displayVal = (displayVal >> 1);
 40074e4:	e0bfff0b 	ldhu	r2,-4(fp)
 40074e8:	1004d07a 	srli	r2,r2,1
 40074ec:	e0bfff0d 	sth	r2,-4(fp)
				if(displayVal == 3)
 40074f0:	e0bfff0b 	ldhu	r2,-4(fp)
 40074f4:	108000d8 	cmpnei	r2,r2,3
 40074f8:	1000021e 	bne	r2,zero,4007504 <taskLEDControl+0x114>
					seqFlags = 1;
 40074fc:	00800044 	movi	r2,1
 4007500:	e0bffe85 	stb	r2,-6(fp)
			}
			vTaskDelay(75);
 4007504:	010012c4 	movi	r4,75
 4007508:	4003df00 	call	4003df0 <vTaskDelay>
			break;
 400750c:	00006406 	br	40076a0 <taskLEDControl+0x2b0>
		case 4:	//0100 --> Up Counter
			if(startSeq)
 4007510:	e0bffec3 	ldbu	r2,-5(fp)
 4007514:	10000226 	beq	r2,zero,4007520 <taskLEDControl+0x130>
			{
				startSeq = 0;
 4007518:	e03ffec5 	stb	zero,-5(fp)
				displayVal = 0;
 400751c:	e03fff0d 	sth	zero,-4(fp)
			}

			IOWR(LEDS_0_BASE, 0, displayVal);
 4007520:	e0ffff0b 	ldhu	r3,-4(fp)
 4007524:	00820034 	movhi	r2,2048
 4007528:	10c42835 	stwio	r3,4256(r2)

			displayVal++;
 400752c:	e0bfff0b 	ldhu	r2,-4(fp)
 4007530:	10800044 	addi	r2,r2,1
 4007534:	e0bfff0d 	sth	r2,-4(fp)
			if(displayVal == 0x3FF)//Reset counter
 4007538:	e0bfff0b 	ldhu	r2,-4(fp)
 400753c:	1080ffd8 	cmpnei	r2,r2,1023
 4007540:	1000011e 	bne	r2,zero,4007548 <taskLEDControl+0x158>
			{
				displayVal = 0;
 4007544:	e03fff0d 	sth	zero,-4(fp)
			}
			vTaskDelay(15);
 4007548:	010003c4 	movi	r4,15
 400754c:	4003df00 	call	4003df0 <vTaskDelay>
			break;
 4007550:	00005306 	br	40076a0 <taskLEDControl+0x2b0>
		case 8:	//1000 --> Custom Sequence
			if(startSeq == 1)
 4007554:	e0bffec3 	ldbu	r2,-5(fp)
 4007558:	10800058 	cmpnei	r2,r2,1
 400755c:	1000081e 	bne	r2,zero,4007580 <taskLEDControl+0x190>
			{
				startSeq = 0;
 4007560:	e03ffec5 	stb	zero,-5(fp)
				displayVal = 0;
 4007564:	e03fff0d 	sth	zero,-4(fp)
				seqFlags = 1;
 4007568:	00800044 	movi	r2,1
 400756c:	e0bffe85 	stb	r2,-6(fp)
				SeqL = 0;
 4007570:	e03ffe0d 	sth	zero,-8(fp)
				SeqR = 0;
 4007574:	e03ffd8d 	sth	zero,-10(fp)
				delay = 100;
 4007578:	00801904 	movi	r2,100
 400757c:	e0bffd0d 	sth	r2,-12(fp)
			}
			if(SeqR < 0b10101 && SeqL < 0x2a0)
 4007580:	e0bffd8b 	ldhu	r2,-10(fp)
 4007584:	10800568 	cmpgeui	r2,r2,21
 4007588:	1000161e 	bne	r2,zero,40075e4 <taskLEDControl+0x1f4>
 400758c:	e0bffe0b 	ldhu	r2,-8(fp)
 4007590:	1080a828 	cmpgeui	r2,r2,672
 4007594:	1000131e 	bne	r2,zero,40075e4 <taskLEDControl+0x1f4>
			{
				SeqR = ((SeqR << 1) | seqFlags);//00001 -> 00101 -> 10101
 4007598:	e0bffd8b 	ldhu	r2,-10(fp)
 400759c:	1085883a 	add	r2,r2,r2
 40075a0:	1007883a 	mov	r3,r2
 40075a4:	e0bffe83 	ldbu	r2,-6(fp)
 40075a8:	1884b03a 	or	r2,r3,r2
 40075ac:	e0bffd8d 	sth	r2,-10(fp)
				SeqL = ((SeqL >> 1) | (seqFlags << 9));//1000000000 -> 1010000000 -> 1010100000
 40075b0:	e0bffe0b 	ldhu	r2,-8(fp)
 40075b4:	1004d07a 	srli	r2,r2,1
 40075b8:	1007883a 	mov	r3,r2
 40075bc:	e0bffe83 	ldbu	r2,-6(fp)
 40075c0:	1004927a 	slli	r2,r2,9
 40075c4:	1884b03a 	or	r2,r3,r2
 40075c8:	e0bffe0d 	sth	r2,-8(fp)
				seqFlags = (seqFlags ^ 0b1);
 40075cc:	e0bffe83 	ldbu	r2,-6(fp)
 40075d0:	1080005c 	xori	r2,r2,1
 40075d4:	e0bffe85 	stb	r2,-6(fp)
				delay = 100;
 40075d8:	00801904 	movi	r2,100
 40075dc:	e0bffd0d 	sth	r2,-12(fp)
 40075e0:	00001d06 	br	4007658 <taskLEDControl+0x268>
			}
			else if(SeqL > 1 && (SeqR & 0x3FF) <= 0x2000)
 40075e4:	e0bffe0b 	ldhu	r2,-8(fp)
 40075e8:	108000b0 	cmpltui	r2,r2,2
 40075ec:	1000161e 	bne	r2,zero,4007648 <taskLEDControl+0x258>
 40075f0:	e0bffd8b 	ldhu	r2,-10(fp)
 40075f4:	1080ffcc 	andi	r2,r2,1023
 40075f8:	10880048 	cmpgei	r2,r2,8193
 40075fc:	1000121e 	bne	r2,zero,4007648 <taskLEDControl+0x258>
			{
				SeqR = (SeqR << 1);
 4007600:	e0bffd8b 	ldhu	r2,-10(fp)
 4007604:	1085883a 	add	r2,r2,r2
 4007608:	e0bffd8d 	sth	r2,-10(fp)
				SeqL = (SeqL >> 1);
 400760c:	e0bffe0b 	ldhu	r2,-8(fp)
 4007610:	1004d07a 	srli	r2,r2,1
 4007614:	e0bffe0d 	sth	r2,-8(fp)
				if((SeqR | SeqL) == 0b0011111100)
 4007618:	e0fffd8b 	ldhu	r3,-10(fp)
 400761c:	e0bffe0b 	ldhu	r2,-8(fp)
 4007620:	1884b03a 	or	r2,r3,r2
 4007624:	10bfffcc 	andi	r2,r2,65535
 4007628:	10803f18 	cmpnei	r2,r2,252
 400762c:	1000031e 	bne	r2,zero,400763c <taskLEDControl+0x24c>
					delay = 50;
 4007630:	00800c84 	movi	r2,50
 4007634:	e0bffd0d 	sth	r2,-12(fp)
				if((SeqR | SeqL) == 0b0011111100)
 4007638:	00000706 	br	4007658 <taskLEDControl+0x268>
				else
					delay = 100;
 400763c:	00801904 	movi	r2,100
 4007640:	e0bffd0d 	sth	r2,-12(fp)
				if((SeqR | SeqL) == 0b0011111100)
 4007644:	00000406 	br	4007658 <taskLEDControl+0x268>

			}
			else
			{
				startSeq = 1;
 4007648:	00800044 	movi	r2,1
 400764c:	e0bffec5 	stb	r2,-5(fp)
				delay = 50;
 4007650:	00800c84 	movi	r2,50
 4007654:	e0bffd0d 	sth	r2,-12(fp)
			}

			displayVal = (SeqL | SeqR);
 4007658:	e0fffe0b 	ldhu	r3,-8(fp)
 400765c:	e0bffd8b 	ldhu	r2,-10(fp)
 4007660:	1884b03a 	or	r2,r3,r2
 4007664:	e0bfff0d 	sth	r2,-4(fp)
			IOWR(LEDS_0_BASE, 0, displayVal);
 4007668:	e0ffff0b 	ldhu	r3,-4(fp)
 400766c:	00820034 	movhi	r2,2048
 4007670:	10c42835 	stwio	r3,4256(r2)

			vTaskDelay(delay);
 4007674:	e0bffd0b 	ldhu	r2,-12(fp)
 4007678:	1009883a 	mov	r4,r2
 400767c:	4003df00 	call	4003df0 <vTaskDelay>
			break;
 4007680:	00000706 	br	40076a0 <taskLEDControl+0x2b0>
		default:
			displayVal = 0;
 4007684:	e03fff0d 	sth	zero,-4(fp)
			IOWR(LEDS_0_BASE, 0, displayVal);
 4007688:	e0ffff0b 	ldhu	r3,-4(fp)
 400768c:	00820034 	movhi	r2,2048
 4007690:	10c42835 	stwio	r3,4256(r2)
			vTaskDelay(200);
 4007694:	01003204 	movi	r4,200
 4007698:	4003df00 	call	4003df0 <vTaskDelay>
			break;
 400769c:	0001883a 	nop
		if(xQueueReceive(pushbutton_queue, &pb_num, 0))//Receive from queue
 40076a0:	003f6206 	br	400742c <taskLEDControl+0x3c>

040076a4 <__divsi3>:
 40076a4:	20001a16 	blt	r4,zero,4007710 <__divsi3+0x6c>
 40076a8:	000f883a 	mov	r7,zero
 40076ac:	2800020e 	bge	r5,zero,40076b8 <__divsi3+0x14>
 40076b0:	014bc83a 	sub	r5,zero,r5
 40076b4:	39c0005c 	xori	r7,r7,1
 40076b8:	200d883a 	mov	r6,r4
 40076bc:	00c00044 	movi	r3,1
 40076c0:	2900092e 	bgeu	r5,r4,40076e8 <__divsi3+0x44>
 40076c4:	00800804 	movi	r2,32
 40076c8:	00c00044 	movi	r3,1
 40076cc:	00000106 	br	40076d4 <__divsi3+0x30>
 40076d0:	10001226 	beq	r2,zero,400771c <__divsi3+0x78>
 40076d4:	294b883a 	add	r5,r5,r5
 40076d8:	10bfffc4 	addi	r2,r2,-1
 40076dc:	18c7883a 	add	r3,r3,r3
 40076e0:	293ffb36 	bltu	r5,r4,40076d0 <__divsi3+0x2c>
 40076e4:	18000d26 	beq	r3,zero,400771c <__divsi3+0x78>
 40076e8:	0005883a 	mov	r2,zero
 40076ec:	31400236 	bltu	r6,r5,40076f8 <__divsi3+0x54>
 40076f0:	314dc83a 	sub	r6,r6,r5
 40076f4:	10c4b03a 	or	r2,r2,r3
 40076f8:	1806d07a 	srli	r3,r3,1
 40076fc:	280ad07a 	srli	r5,r5,1
 4007700:	183ffa1e 	bne	r3,zero,40076ec <__divsi3+0x48>
 4007704:	38000126 	beq	r7,zero,400770c <__divsi3+0x68>
 4007708:	0085c83a 	sub	r2,zero,r2
 400770c:	f800283a 	ret
 4007710:	0109c83a 	sub	r4,zero,r4
 4007714:	01c00044 	movi	r7,1
 4007718:	003fe406 	br	40076ac <__divsi3+0x8>
 400771c:	0005883a 	mov	r2,zero
 4007720:	003ff806 	br	4007704 <__divsi3+0x60>

04007724 <__modsi3>:
 4007724:	20001716 	blt	r4,zero,4007784 <__modsi3+0x60>
 4007728:	000f883a 	mov	r7,zero
 400772c:	2005883a 	mov	r2,r4
 4007730:	2800010e 	bge	r5,zero,4007738 <__modsi3+0x14>
 4007734:	014bc83a 	sub	r5,zero,r5
 4007738:	00c00044 	movi	r3,1
 400773c:	2900092e 	bgeu	r5,r4,4007764 <__modsi3+0x40>
 4007740:	01800804 	movi	r6,32
 4007744:	00c00044 	movi	r3,1
 4007748:	00000106 	br	4007750 <__modsi3+0x2c>
 400774c:	30001026 	beq	r6,zero,4007790 <__modsi3+0x6c>
 4007750:	294b883a 	add	r5,r5,r5
 4007754:	31bfffc4 	addi	r6,r6,-1
 4007758:	18c7883a 	add	r3,r3,r3
 400775c:	293ffb36 	bltu	r5,r4,400774c <__modsi3+0x28>
 4007760:	18000b26 	beq	r3,zero,4007790 <__modsi3+0x6c>
 4007764:	1806d07a 	srli	r3,r3,1
 4007768:	11400136 	bltu	r2,r5,4007770 <__modsi3+0x4c>
 400776c:	1145c83a 	sub	r2,r2,r5
 4007770:	280ad07a 	srli	r5,r5,1
 4007774:	183ffb1e 	bne	r3,zero,4007764 <__modsi3+0x40>
 4007778:	38000126 	beq	r7,zero,4007780 <__modsi3+0x5c>
 400777c:	0085c83a 	sub	r2,zero,r2
 4007780:	f800283a 	ret
 4007784:	0109c83a 	sub	r4,zero,r4
 4007788:	01c00044 	movi	r7,1
 400778c:	003fe706 	br	400772c <__modsi3+0x8>
 4007790:	2005883a 	mov	r2,r4
 4007794:	003ff806 	br	4007778 <__modsi3+0x54>

04007798 <__udivsi3>:
 4007798:	200d883a 	mov	r6,r4
 400779c:	2900152e 	bgeu	r5,r4,40077f4 <__udivsi3+0x5c>
 40077a0:	28001416 	blt	r5,zero,40077f4 <__udivsi3+0x5c>
 40077a4:	00800804 	movi	r2,32
 40077a8:	00c00044 	movi	r3,1
 40077ac:	00000206 	br	40077b8 <__udivsi3+0x20>
 40077b0:	10000e26 	beq	r2,zero,40077ec <__udivsi3+0x54>
 40077b4:	28000416 	blt	r5,zero,40077c8 <__udivsi3+0x30>
 40077b8:	294b883a 	add	r5,r5,r5
 40077bc:	10bfffc4 	addi	r2,r2,-1
 40077c0:	18c7883a 	add	r3,r3,r3
 40077c4:	293ffa36 	bltu	r5,r4,40077b0 <__udivsi3+0x18>
 40077c8:	18000826 	beq	r3,zero,40077ec <__udivsi3+0x54>
 40077cc:	0005883a 	mov	r2,zero
 40077d0:	31400236 	bltu	r6,r5,40077dc <__udivsi3+0x44>
 40077d4:	314dc83a 	sub	r6,r6,r5
 40077d8:	10c4b03a 	or	r2,r2,r3
 40077dc:	1806d07a 	srli	r3,r3,1
 40077e0:	280ad07a 	srli	r5,r5,1
 40077e4:	183ffa1e 	bne	r3,zero,40077d0 <__udivsi3+0x38>
 40077e8:	f800283a 	ret
 40077ec:	0005883a 	mov	r2,zero
 40077f0:	f800283a 	ret
 40077f4:	00c00044 	movi	r3,1
 40077f8:	003ff406 	br	40077cc <__udivsi3+0x34>

040077fc <__umodsi3>:
 40077fc:	2005883a 	mov	r2,r4
 4007800:	2900132e 	bgeu	r5,r4,4007850 <__umodsi3+0x54>
 4007804:	28001216 	blt	r5,zero,4007850 <__umodsi3+0x54>
 4007808:	01800804 	movi	r6,32
 400780c:	00c00044 	movi	r3,1
 4007810:	00000206 	br	400781c <__umodsi3+0x20>
 4007814:	30000c26 	beq	r6,zero,4007848 <__umodsi3+0x4c>
 4007818:	28000416 	blt	r5,zero,400782c <__umodsi3+0x30>
 400781c:	294b883a 	add	r5,r5,r5
 4007820:	31bfffc4 	addi	r6,r6,-1
 4007824:	18c7883a 	add	r3,r3,r3
 4007828:	293ffa36 	bltu	r5,r4,4007814 <__umodsi3+0x18>
 400782c:	18000626 	beq	r3,zero,4007848 <__umodsi3+0x4c>
 4007830:	1806d07a 	srli	r3,r3,1
 4007834:	11400136 	bltu	r2,r5,400783c <__umodsi3+0x40>
 4007838:	1145c83a 	sub	r2,r2,r5
 400783c:	280ad07a 	srli	r5,r5,1
 4007840:	183ffb1e 	bne	r3,zero,4007830 <__umodsi3+0x34>
 4007844:	f800283a 	ret
 4007848:	2005883a 	mov	r2,r4
 400784c:	f800283a 	ret
 4007850:	00c00044 	movi	r3,1
 4007854:	003ff606 	br	4007830 <__umodsi3+0x34>

04007858 <__mulsi3>:
 4007858:	0005883a 	mov	r2,zero
 400785c:	20000726 	beq	r4,zero,400787c <__mulsi3+0x24>
 4007860:	20c0004c 	andi	r3,r4,1
 4007864:	2008d07a 	srli	r4,r4,1
 4007868:	18000126 	beq	r3,zero,4007870 <__mulsi3+0x18>
 400786c:	1145883a 	add	r2,r2,r5
 4007870:	294b883a 	add	r5,r5,r5
 4007874:	203ffa1e 	bne	r4,zero,4007860 <__mulsi3+0x8>
 4007878:	f800283a 	ret
 400787c:	f800283a 	ret

04007880 <memcpy>:
 4007880:	30c00428 	cmpgeui	r3,r6,16
 4007884:	2005883a 	mov	r2,r4
 4007888:	18000b1e 	bne	r3,zero,40078b8 <memcpy+0x38>
 400788c:	2007883a 	mov	r3,r4
 4007890:	31ffffc4 	addi	r7,r6,-1
 4007894:	30003426 	beq	r6,zero,4007968 <memcpy+0xe8>
 4007898:	39c00044 	addi	r7,r7,1
 400789c:	19cf883a 	add	r7,r3,r7
 40078a0:	29800003 	ldbu	r6,0(r5)
 40078a4:	18c00044 	addi	r3,r3,1
 40078a8:	29400044 	addi	r5,r5,1
 40078ac:	19bfffc5 	stb	r6,-1(r3)
 40078b0:	19fffb1e 	bne	r3,r7,40078a0 <memcpy+0x20>
 40078b4:	f800283a 	ret
 40078b8:	2146b03a 	or	r3,r4,r5
 40078bc:	18c000cc 	andi	r3,r3,3
 40078c0:	18002a1e 	bne	r3,zero,400796c <memcpy+0xec>
 40078c4:	333ffc04 	addi	r12,r6,-16
 40078c8:	6018d13a 	srli	r12,r12,4
 40078cc:	2811883a 	mov	r8,r5
 40078d0:	200f883a 	mov	r7,r4
 40078d4:	63000044 	addi	r12,r12,1
 40078d8:	6018913a 	slli	r12,r12,4
 40078dc:	2307883a 	add	r3,r4,r12
 40078e0:	42c00017 	ldw	r11,0(r8)
 40078e4:	42800117 	ldw	r10,4(r8)
 40078e8:	42400217 	ldw	r9,8(r8)
 40078ec:	41000317 	ldw	r4,12(r8)
 40078f0:	39c00404 	addi	r7,r7,16
 40078f4:	3afffc15 	stw	r11,-16(r7)
 40078f8:	3abffd15 	stw	r10,-12(r7)
 40078fc:	3a7ffe15 	stw	r9,-8(r7)
 4007900:	393fff15 	stw	r4,-4(r7)
 4007904:	42000404 	addi	r8,r8,16
 4007908:	38fff51e 	bne	r7,r3,40078e0 <memcpy+0x60>
 400790c:	3100030c 	andi	r4,r6,12
 4007910:	2b0b883a 	add	r5,r5,r12
 4007914:	324003cc 	andi	r9,r6,15
 4007918:	20001726 	beq	r4,zero,4007978 <memcpy+0xf8>
 400791c:	2811883a 	mov	r8,r5
 4007920:	1809883a 	mov	r4,r3
 4007924:	1a57883a 	add	r11,r3,r9
 4007928:	42800017 	ldw	r10,0(r8)
 400792c:	21000104 	addi	r4,r4,4
 4007930:	590fc83a 	sub	r7,r11,r4
 4007934:	39c00128 	cmpgeui	r7,r7,4
 4007938:	22bfff15 	stw	r10,-4(r4)
 400793c:	42000104 	addi	r8,r8,4
 4007940:	383ff91e 	bne	r7,zero,4007928 <memcpy+0xa8>
 4007944:	493fff04 	addi	r4,r9,-4
 4007948:	2008d0ba 	srli	r4,r4,2
 400794c:	318000cc 	andi	r6,r6,3
 4007950:	31ffffc4 	addi	r7,r6,-1
 4007954:	21000044 	addi	r4,r4,1
 4007958:	200890ba 	slli	r4,r4,2
 400795c:	1907883a 	add	r3,r3,r4
 4007960:	290b883a 	add	r5,r5,r4
 4007964:	303fcc1e 	bne	r6,zero,4007898 <memcpy+0x18>
 4007968:	f800283a 	ret
 400796c:	31ffffc4 	addi	r7,r6,-1
 4007970:	2007883a 	mov	r3,r4
 4007974:	003fc806 	br	4007898 <memcpy+0x18>
 4007978:	480d883a 	mov	r6,r9
 400797c:	003fc406 	br	4007890 <memcpy+0x10>

04007980 <memset>:
 4007980:	defffb04 	addi	sp,sp,-20
 4007984:	dc800215 	stw	r18,8(sp)
 4007988:	dc400115 	stw	r17,4(sp)
 400798c:	dfc00415 	stw	ra,16(sp)
 4007990:	dcc00315 	stw	r19,12(sp)
 4007994:	dc000015 	stw	r16,0(sp)
 4007998:	208000cc 	andi	r2,r4,3
 400799c:	2023883a 	mov	r17,r4
 40079a0:	2825883a 	mov	r18,r5
 40079a4:	10004026 	beq	r2,zero,4007aa8 <memset+0x128>
 40079a8:	34ffffc4 	addi	r19,r6,-1
 40079ac:	30003326 	beq	r6,zero,4007a7c <memset+0xfc>
 40079b0:	280f883a 	mov	r7,r5
 40079b4:	2021883a 	mov	r16,r4
 40079b8:	00000306 	br	40079c8 <memset+0x48>
 40079bc:	9cffffc4 	addi	r19,r19,-1
 40079c0:	99bfffe0 	cmpeqi	r6,r19,-1
 40079c4:	30002d1e 	bne	r6,zero,4007a7c <memset+0xfc>
 40079c8:	84000044 	addi	r16,r16,1
 40079cc:	818000cc 	andi	r6,r16,3
 40079d0:	81ffffc5 	stb	r7,-1(r16)
 40079d4:	303ff91e 	bne	r6,zero,40079bc <memset+0x3c>
 40079d8:	98800128 	cmpgeui	r2,r19,4
 40079dc:	10002126 	beq	r2,zero,4007a64 <memset+0xe4>
 40079e0:	01404074 	movhi	r5,257
 40079e4:	29404044 	addi	r5,r5,257
 40079e8:	91003fcc 	andi	r4,r18,255
 40079ec:	40078580 	call	4007858 <__mulsi3>
 40079f0:	98c00430 	cmpltui	r3,r19,16
 40079f4:	18002f1e 	bne	r3,zero,4007ab4 <memset+0x134>
 40079f8:	99bffc04 	addi	r6,r19,-16
 40079fc:	300cd13a 	srli	r6,r6,4
 4007a00:	31800044 	addi	r6,r6,1
 4007a04:	300c913a 	slli	r6,r6,4
 4007a08:	818d883a 	add	r6,r16,r6
 4007a0c:	80800015 	stw	r2,0(r16)
 4007a10:	80800115 	stw	r2,4(r16)
 4007a14:	80800215 	stw	r2,8(r16)
 4007a18:	80800315 	stw	r2,12(r16)
 4007a1c:	84000404 	addi	r16,r16,16
 4007a20:	81bffa1e 	bne	r16,r6,4007a0c <memset+0x8c>
 4007a24:	9900030c 	andi	r4,r19,12
 4007a28:	98c003cc 	andi	r3,r19,15
 4007a2c:	20001b26 	beq	r4,zero,4007a9c <memset+0x11c>
 4007a30:	3009883a 	mov	r4,r6
 4007a34:	30cb883a 	add	r5,r6,r3
 4007a38:	21000104 	addi	r4,r4,4
 4007a3c:	290fc83a 	sub	r7,r5,r4
 4007a40:	39c00128 	cmpgeui	r7,r7,4
 4007a44:	20bfff15 	stw	r2,-4(r4)
 4007a48:	383ffb1e 	bne	r7,zero,4007a38 <memset+0xb8>
 4007a4c:	1c3fff04 	addi	r16,r3,-4
 4007a50:	8020d0ba 	srli	r16,r16,2
 4007a54:	1cc000cc 	andi	r19,r3,3
 4007a58:	84000044 	addi	r16,r16,1
 4007a5c:	802090ba 	slli	r16,r16,2
 4007a60:	3421883a 	add	r16,r6,r16
 4007a64:	98000526 	beq	r19,zero,4007a7c <memset+0xfc>
 4007a68:	900b883a 	mov	r5,r18
 4007a6c:	84c7883a 	add	r3,r16,r19
 4007a70:	84000044 	addi	r16,r16,1
 4007a74:	817fffc5 	stb	r5,-1(r16)
 4007a78:	1c3ffd1e 	bne	r3,r16,4007a70 <memset+0xf0>
 4007a7c:	8805883a 	mov	r2,r17
 4007a80:	dfc00417 	ldw	ra,16(sp)
 4007a84:	dcc00317 	ldw	r19,12(sp)
 4007a88:	dc800217 	ldw	r18,8(sp)
 4007a8c:	dc400117 	ldw	r17,4(sp)
 4007a90:	dc000017 	ldw	r16,0(sp)
 4007a94:	dec00504 	addi	sp,sp,20
 4007a98:	f800283a 	ret
 4007a9c:	1827883a 	mov	r19,r3
 4007aa0:	983ff11e 	bne	r19,zero,4007a68 <memset+0xe8>
 4007aa4:	003ff506 	br	4007a7c <memset+0xfc>
 4007aa8:	2021883a 	mov	r16,r4
 4007aac:	3027883a 	mov	r19,r6
 4007ab0:	003fc906 	br	40079d8 <memset+0x58>
 4007ab4:	800d883a 	mov	r6,r16
 4007ab8:	9807883a 	mov	r3,r19
 4007abc:	003fdc06 	br	4007a30 <memset+0xb0>

04007ac0 <_puts_r>:
 4007ac0:	defff504 	addi	sp,sp,-44
 4007ac4:	dc000815 	stw	r16,32(sp)
 4007ac8:	2021883a 	mov	r16,r4
 4007acc:	2809883a 	mov	r4,r5
 4007ad0:	dc400915 	stw	r17,36(sp)
 4007ad4:	dfc00a15 	stw	ra,40(sp)
 4007ad8:	2823883a 	mov	r17,r5
 4007adc:	4007ba00 	call	4007ba0 <strlen>
 4007ae0:	11000044 	addi	r4,r2,1
 4007ae4:	d8800515 	stw	r2,20(sp)
 4007ae8:	00800044 	movi	r2,1
 4007aec:	00c10074 	movhi	r3,1025
 4007af0:	d8800715 	stw	r2,28(sp)
 4007af4:	d8800404 	addi	r2,sp,16
 4007af8:	18f31504 	addi	r3,r3,-13228
 4007afc:	d8800115 	stw	r2,4(sp)
 4007b00:	00800084 	movi	r2,2
 4007b04:	dc400415 	stw	r17,16(sp)
 4007b08:	d8c00615 	stw	r3,24(sp)
 4007b0c:	d9000315 	stw	r4,12(sp)
 4007b10:	d8800215 	stw	r2,8(sp)
 4007b14:	81400217 	ldw	r5,8(r16)
 4007b18:	80000226 	beq	r16,zero,4007b24 <_puts_r+0x64>
 4007b1c:	80800e17 	ldw	r2,56(r16)
 4007b20:	10001426 	beq	r2,zero,4007b74 <_puts_r+0xb4>
 4007b24:	2880030b 	ldhu	r2,12(r5)
 4007b28:	10c8000c 	andi	r3,r2,8192
 4007b2c:	1800061e 	bne	r3,zero,4007b48 <_puts_r+0x88>
 4007b30:	28c01917 	ldw	r3,100(r5)
 4007b34:	0137ffc4 	movi	r4,-8193
 4007b38:	10880014 	ori	r2,r2,8192
 4007b3c:	1906703a 	and	r3,r3,r4
 4007b40:	2880030d 	sth	r2,12(r5)
 4007b44:	28c01915 	stw	r3,100(r5)
 4007b48:	d9800104 	addi	r6,sp,4
 4007b4c:	8009883a 	mov	r4,r16
 4007b50:	4007fc40 	call	4007fc4 <__sfvwrite_r>
 4007b54:	1007883a 	mov	r3,r2
 4007b58:	00800284 	movi	r2,10
 4007b5c:	18000a1e 	bne	r3,zero,4007b88 <_puts_r+0xc8>
 4007b60:	dfc00a17 	ldw	ra,40(sp)
 4007b64:	dc400917 	ldw	r17,36(sp)
 4007b68:	dc000817 	ldw	r16,32(sp)
 4007b6c:	dec00b04 	addi	sp,sp,44
 4007b70:	f800283a 	ret
 4007b74:	8009883a 	mov	r4,r16
 4007b78:	d9400015 	stw	r5,0(sp)
 4007b7c:	4007f7c0 	call	4007f7c <__sinit>
 4007b80:	d9400017 	ldw	r5,0(sp)
 4007b84:	003fe706 	br	4007b24 <_puts_r+0x64>
 4007b88:	00bfffc4 	movi	r2,-1
 4007b8c:	003ff406 	br	4007b60 <_puts_r+0xa0>

04007b90 <puts>:
 4007b90:	00810074 	movhi	r2,1025
 4007b94:	200b883a 	mov	r5,r4
 4007b98:	1139ae17 	ldw	r4,-6472(r2)
 4007b9c:	4007ac01 	jmpi	4007ac0 <_puts_r>

04007ba0 <strlen>:
 4007ba0:	208000cc 	andi	r2,r4,3
 4007ba4:	10000926 	beq	r2,zero,4007bcc <strlen+0x2c>
 4007ba8:	2005883a 	mov	r2,r4
 4007bac:	00000306 	br	4007bbc <strlen+0x1c>
 4007bb0:	10800044 	addi	r2,r2,1
 4007bb4:	10c000cc 	andi	r3,r2,3
 4007bb8:	18000526 	beq	r3,zero,4007bd0 <strlen+0x30>
 4007bbc:	10c00007 	ldb	r3,0(r2)
 4007bc0:	183ffb1e 	bne	r3,zero,4007bb0 <strlen+0x10>
 4007bc4:	1105c83a 	sub	r2,r2,r4
 4007bc8:	f800283a 	ret
 4007bcc:	2005883a 	mov	r2,r4
 4007bd0:	11400017 	ldw	r5,0(r2)
 4007bd4:	01ffbff4 	movhi	r7,65279
 4007bd8:	39ffbfc4 	addi	r7,r7,-257
 4007bdc:	29c7883a 	add	r3,r5,r7
 4007be0:	01a02074 	movhi	r6,32897
 4007be4:	014a303a 	nor	r5,zero,r5
 4007be8:	1946703a 	and	r3,r3,r5
 4007bec:	31a02004 	addi	r6,r6,-32640
 4007bf0:	1986703a 	and	r3,r3,r6
 4007bf4:	1800071e 	bne	r3,zero,4007c14 <strlen+0x74>
 4007bf8:	11400117 	ldw	r5,4(r2)
 4007bfc:	10800104 	addi	r2,r2,4
 4007c00:	29c7883a 	add	r3,r5,r7
 4007c04:	014a303a 	nor	r5,zero,r5
 4007c08:	1946703a 	and	r3,r3,r5
 4007c0c:	1986703a 	and	r3,r3,r6
 4007c10:	183ff926 	beq	r3,zero,4007bf8 <strlen+0x58>
 4007c14:	10c00007 	ldb	r3,0(r2)
 4007c18:	183fea26 	beq	r3,zero,4007bc4 <strlen+0x24>
 4007c1c:	10c00047 	ldb	r3,1(r2)
 4007c20:	10800044 	addi	r2,r2,1
 4007c24:	183fe726 	beq	r3,zero,4007bc4 <strlen+0x24>
 4007c28:	10c00047 	ldb	r3,1(r2)
 4007c2c:	10800044 	addi	r2,r2,1
 4007c30:	183ffa1e 	bne	r3,zero,4007c1c <strlen+0x7c>
 4007c34:	003fe306 	br	4007bc4 <strlen+0x24>

04007c38 <__fp_lock>:
 4007c38:	0005883a 	mov	r2,zero
 4007c3c:	f800283a 	ret

04007c40 <_cleanup_r>:
 4007c40:	01410074 	movhi	r5,1025
 4007c44:	29664604 	addi	r5,r5,-26344
 4007c48:	40085041 	jmpi	4008504 <_fwalk_reent>

04007c4c <__fp_unlock>:
 4007c4c:	0005883a 	mov	r2,zero
 4007c50:	f800283a 	ret

04007c54 <__sinit.part.0>:
 4007c54:	00c10034 	movhi	r3,1024
 4007c58:	20800117 	ldw	r2,4(r4)
 4007c5c:	18df1004 	addi	r3,r3,31808
 4007c60:	20c00f15 	stw	r3,60(r4)
 4007c64:	2140bb04 	addi	r5,r4,748
 4007c68:	00c000c4 	movi	r3,3
 4007c6c:	20c0b915 	stw	r3,740(r4)
 4007c70:	2140ba15 	stw	r5,744(r4)
 4007c74:	2000b815 	stw	zero,736(r4)
 4007c78:	10001705 	stb	zero,92(r2)
 4007c7c:	10001745 	stb	zero,93(r2)
 4007c80:	10001785 	stb	zero,94(r2)
 4007c84:	100017c5 	stb	zero,95(r2)
 4007c88:	10001805 	stb	zero,96(r2)
 4007c8c:	10001845 	stb	zero,97(r2)
 4007c90:	10001885 	stb	zero,98(r2)
 4007c94:	100018c5 	stb	zero,99(r2)
 4007c98:	00c00104 	movi	r3,4
 4007c9c:	10c00315 	stw	r3,12(r2)
 4007ca0:	02010074 	movhi	r8,1025
 4007ca4:	20c00217 	ldw	r3,8(r4)
 4007ca8:	01c10074 	movhi	r7,1025
 4007cac:	01810074 	movhi	r6,1025
 4007cb0:	01410074 	movhi	r5,1025
 4007cb4:	42257404 	addi	r8,r8,-27184
 4007cb8:	39e58b04 	addi	r7,r7,-27092
 4007cbc:	31a5ab04 	addi	r6,r6,-26964
 4007cc0:	2965c204 	addi	r5,r5,-26872
 4007cc4:	02400074 	movhi	r9,1
 4007cc8:	10000015 	stw	zero,0(r2)
 4007ccc:	10000115 	stw	zero,4(r2)
 4007cd0:	10000215 	stw	zero,8(r2)
 4007cd4:	10001915 	stw	zero,100(r2)
 4007cd8:	10000415 	stw	zero,16(r2)
 4007cdc:	10000515 	stw	zero,20(r2)
 4007ce0:	10000615 	stw	zero,24(r2)
 4007ce4:	10800715 	stw	r2,28(r2)
 4007ce8:	12000815 	stw	r8,32(r2)
 4007cec:	11c00915 	stw	r7,36(r2)
 4007cf0:	11800a15 	stw	r6,40(r2)
 4007cf4:	11400b15 	stw	r5,44(r2)
 4007cf8:	4a400284 	addi	r9,r9,10
 4007cfc:	1a400315 	stw	r9,12(r3)
 4007d00:	18000015 	stw	zero,0(r3)
 4007d04:	18000115 	stw	zero,4(r3)
 4007d08:	18000215 	stw	zero,8(r3)
 4007d0c:	18001915 	stw	zero,100(r3)
 4007d10:	18000415 	stw	zero,16(r3)
 4007d14:	18001705 	stb	zero,92(r3)
 4007d18:	18001745 	stb	zero,93(r3)
 4007d1c:	18001785 	stb	zero,94(r3)
 4007d20:	180017c5 	stb	zero,95(r3)
 4007d24:	18001805 	stb	zero,96(r3)
 4007d28:	18001845 	stb	zero,97(r3)
 4007d2c:	18001885 	stb	zero,98(r3)
 4007d30:	180018c5 	stb	zero,99(r3)
 4007d34:	20800317 	ldw	r2,12(r4)
 4007d38:	024000b4 	movhi	r9,2
 4007d3c:	18000515 	stw	zero,20(r3)
 4007d40:	18000615 	stw	zero,24(r3)
 4007d44:	18c00715 	stw	r3,28(r3)
 4007d48:	1a000815 	stw	r8,32(r3)
 4007d4c:	19c00915 	stw	r7,36(r3)
 4007d50:	19800a15 	stw	r6,40(r3)
 4007d54:	19400b15 	stw	r5,44(r3)
 4007d58:	4a400484 	addi	r9,r9,18
 4007d5c:	10000015 	stw	zero,0(r2)
 4007d60:	10000115 	stw	zero,4(r2)
 4007d64:	10000215 	stw	zero,8(r2)
 4007d68:	10001915 	stw	zero,100(r2)
 4007d6c:	12400315 	stw	r9,12(r2)
 4007d70:	10000415 	stw	zero,16(r2)
 4007d74:	10000515 	stw	zero,20(r2)
 4007d78:	10000615 	stw	zero,24(r2)
 4007d7c:	10001705 	stb	zero,92(r2)
 4007d80:	10001745 	stb	zero,93(r2)
 4007d84:	10001785 	stb	zero,94(r2)
 4007d88:	100017c5 	stb	zero,95(r2)
 4007d8c:	10001805 	stb	zero,96(r2)
 4007d90:	10001845 	stb	zero,97(r2)
 4007d94:	10001885 	stb	zero,98(r2)
 4007d98:	100018c5 	stb	zero,99(r2)
 4007d9c:	10800715 	stw	r2,28(r2)
 4007da0:	12000815 	stw	r8,32(r2)
 4007da4:	11c00915 	stw	r7,36(r2)
 4007da8:	11800a15 	stw	r6,40(r2)
 4007dac:	11400b15 	stw	r5,44(r2)
 4007db0:	00800044 	movi	r2,1
 4007db4:	20800e15 	stw	r2,56(r4)
 4007db8:	f800283a 	ret

04007dbc <__sfmoreglue>:
 4007dbc:	defffc04 	addi	sp,sp,-16
 4007dc0:	dc800215 	stw	r18,8(sp)
 4007dc4:	2825883a 	mov	r18,r5
 4007dc8:	dc000015 	stw	r16,0(sp)
 4007dcc:	01401a04 	movi	r5,104
 4007dd0:	2021883a 	mov	r16,r4
 4007dd4:	913fffc4 	addi	r4,r18,-1
 4007dd8:	dfc00315 	stw	ra,12(sp)
 4007ddc:	dc400115 	stw	r17,4(sp)
 4007de0:	40078580 	call	4007858 <__mulsi3>
 4007de4:	8009883a 	mov	r4,r16
 4007de8:	11401d04 	addi	r5,r2,116
 4007dec:	1023883a 	mov	r17,r2
 4007df0:	40085ac0 	call	40085ac <_malloc_r>
 4007df4:	1021883a 	mov	r16,r2
 4007df8:	10000726 	beq	r2,zero,4007e18 <__sfmoreglue+0x5c>
 4007dfc:	11000304 	addi	r4,r2,12
 4007e00:	10000015 	stw	zero,0(r2)
 4007e04:	14800115 	stw	r18,4(r2)
 4007e08:	11000215 	stw	r4,8(r2)
 4007e0c:	89801a04 	addi	r6,r17,104
 4007e10:	000b883a 	mov	r5,zero
 4007e14:	40079800 	call	4007980 <memset>
 4007e18:	8005883a 	mov	r2,r16
 4007e1c:	dfc00317 	ldw	ra,12(sp)
 4007e20:	dc800217 	ldw	r18,8(sp)
 4007e24:	dc400117 	ldw	r17,4(sp)
 4007e28:	dc000017 	ldw	r16,0(sp)
 4007e2c:	dec00404 	addi	sp,sp,16
 4007e30:	f800283a 	ret

04007e34 <__sfp>:
 4007e34:	defffc04 	addi	sp,sp,-16
 4007e38:	00810074 	movhi	r2,1025
 4007e3c:	dc400115 	stw	r17,4(sp)
 4007e40:	1479ad17 	ldw	r17,-6476(r2)
 4007e44:	dc800215 	stw	r18,8(sp)
 4007e48:	dfc00315 	stw	ra,12(sp)
 4007e4c:	88800e17 	ldw	r2,56(r17)
 4007e50:	dc000015 	stw	r16,0(sp)
 4007e54:	2025883a 	mov	r18,r4
 4007e58:	10002d26 	beq	r2,zero,4007f10 <__sfp+0xdc>
 4007e5c:	8c40b804 	addi	r17,r17,736
 4007e60:	88800117 	ldw	r2,4(r17)
 4007e64:	8c000217 	ldw	r16,8(r17)
 4007e68:	10bfffc4 	addi	r2,r2,-1
 4007e6c:	1000030e 	bge	r2,zero,4007e7c <__sfp+0x48>
 4007e70:	00002306 	br	4007f00 <__sfp+0xcc>
 4007e74:	84001a04 	addi	r16,r16,104
 4007e78:	28002126 	beq	r5,zero,4007f00 <__sfp+0xcc>
 4007e7c:	80c0030f 	ldh	r3,12(r16)
 4007e80:	10bfffc4 	addi	r2,r2,-1
 4007e84:	117fffd8 	cmpnei	r5,r2,-1
 4007e88:	183ffa1e 	bne	r3,zero,4007e74 <__sfp+0x40>
 4007e8c:	00bffff4 	movhi	r2,65535
 4007e90:	10800044 	addi	r2,r2,1
 4007e94:	80800315 	stw	r2,12(r16)
 4007e98:	80001915 	stw	zero,100(r16)
 4007e9c:	80000015 	stw	zero,0(r16)
 4007ea0:	80000215 	stw	zero,8(r16)
 4007ea4:	80000115 	stw	zero,4(r16)
 4007ea8:	80000415 	stw	zero,16(r16)
 4007eac:	80000515 	stw	zero,20(r16)
 4007eb0:	80000615 	stw	zero,24(r16)
 4007eb4:	80001705 	stb	zero,92(r16)
 4007eb8:	80001745 	stb	zero,93(r16)
 4007ebc:	80001785 	stb	zero,94(r16)
 4007ec0:	800017c5 	stb	zero,95(r16)
 4007ec4:	80001805 	stb	zero,96(r16)
 4007ec8:	80001845 	stb	zero,97(r16)
 4007ecc:	80001885 	stb	zero,98(r16)
 4007ed0:	800018c5 	stb	zero,99(r16)
 4007ed4:	80000c15 	stw	zero,48(r16)
 4007ed8:	80000d15 	stw	zero,52(r16)
 4007edc:	80001115 	stw	zero,68(r16)
 4007ee0:	80001215 	stw	zero,72(r16)
 4007ee4:	8005883a 	mov	r2,r16
 4007ee8:	dfc00317 	ldw	ra,12(sp)
 4007eec:	dc800217 	ldw	r18,8(sp)
 4007ef0:	dc400117 	ldw	r17,4(sp)
 4007ef4:	dc000017 	ldw	r16,0(sp)
 4007ef8:	dec00404 	addi	sp,sp,16
 4007efc:	f800283a 	ret
 4007f00:	8c000017 	ldw	r16,0(r17)
 4007f04:	80000526 	beq	r16,zero,4007f1c <__sfp+0xe8>
 4007f08:	8023883a 	mov	r17,r16
 4007f0c:	003fd406 	br	4007e60 <__sfp+0x2c>
 4007f10:	8809883a 	mov	r4,r17
 4007f14:	4007c540 	call	4007c54 <__sinit.part.0>
 4007f18:	003fd006 	br	4007e5c <__sfp+0x28>
 4007f1c:	01406b04 	movi	r5,428
 4007f20:	9009883a 	mov	r4,r18
 4007f24:	40085ac0 	call	40085ac <_malloc_r>
 4007f28:	1021883a 	mov	r16,r2
 4007f2c:	10000a26 	beq	r2,zero,4007f58 <__sfp+0x124>
 4007f30:	10000015 	stw	zero,0(r2)
 4007f34:	11000304 	addi	r4,r2,12
 4007f38:	00800104 	movi	r2,4
 4007f3c:	80800115 	stw	r2,4(r16)
 4007f40:	81000215 	stw	r4,8(r16)
 4007f44:	01806804 	movi	r6,416
 4007f48:	000b883a 	mov	r5,zero
 4007f4c:	40079800 	call	4007980 <memset>
 4007f50:	8c000015 	stw	r16,0(r17)
 4007f54:	003fec06 	br	4007f08 <__sfp+0xd4>
 4007f58:	88000015 	stw	zero,0(r17)
 4007f5c:	00800304 	movi	r2,12
 4007f60:	90800015 	stw	r2,0(r18)
 4007f64:	003fdf06 	br	4007ee4 <__sfp+0xb0>

04007f68 <_cleanup>:
 4007f68:	00810074 	movhi	r2,1025
 4007f6c:	1139ad17 	ldw	r4,-6476(r2)
 4007f70:	01410074 	movhi	r5,1025
 4007f74:	29664604 	addi	r5,r5,-26344
 4007f78:	40085041 	jmpi	4008504 <_fwalk_reent>

04007f7c <__sinit>:
 4007f7c:	20800e17 	ldw	r2,56(r4)
 4007f80:	10000126 	beq	r2,zero,4007f88 <__sinit+0xc>
 4007f84:	f800283a 	ret
 4007f88:	4007c541 	jmpi	4007c54 <__sinit.part.0>

04007f8c <__sfp_lock_acquire>:
 4007f8c:	f800283a 	ret

04007f90 <__sfp_lock_release>:
 4007f90:	f800283a 	ret

04007f94 <__sinit_lock_acquire>:
 4007f94:	f800283a 	ret

04007f98 <__sinit_lock_release>:
 4007f98:	f800283a 	ret

04007f9c <__fp_lock_all>:
 4007f9c:	00810074 	movhi	r2,1025
 4007fa0:	1139ae17 	ldw	r4,-6472(r2)
 4007fa4:	01410034 	movhi	r5,1024
 4007fa8:	295f0e04 	addi	r5,r5,31800
 4007fac:	400846c1 	jmpi	400846c <_fwalk>

04007fb0 <__fp_unlock_all>:
 4007fb0:	00810074 	movhi	r2,1025
 4007fb4:	1139ae17 	ldw	r4,-6472(r2)
 4007fb8:	01410034 	movhi	r5,1024
 4007fbc:	295f1304 	addi	r5,r5,31820
 4007fc0:	400846c1 	jmpi	400846c <_fwalk>

04007fc4 <__sfvwrite_r>:
 4007fc4:	30800217 	ldw	r2,8(r6)
 4007fc8:	1000c426 	beq	r2,zero,40082dc <__sfvwrite_r+0x318>
 4007fcc:	2a80030b 	ldhu	r10,12(r5)
 4007fd0:	defff504 	addi	sp,sp,-44
 4007fd4:	df000915 	stw	fp,36(sp)
 4007fd8:	dcc00415 	stw	r19,16(sp)
 4007fdc:	dc000115 	stw	r16,4(sp)
 4007fe0:	dfc00a15 	stw	ra,40(sp)
 4007fe4:	ddc00815 	stw	r23,32(sp)
 4007fe8:	dd800715 	stw	r22,28(sp)
 4007fec:	dd400615 	stw	r21,24(sp)
 4007ff0:	dd000515 	stw	r20,20(sp)
 4007ff4:	dc800315 	stw	r18,12(sp)
 4007ff8:	dc400215 	stw	r17,8(sp)
 4007ffc:	5080020c 	andi	r2,r10,8
 4008000:	3039883a 	mov	fp,r6
 4008004:	2027883a 	mov	r19,r4
 4008008:	2821883a 	mov	r16,r5
 400800c:	10002226 	beq	r2,zero,4008098 <__sfvwrite_r+0xd4>
 4008010:	28800417 	ldw	r2,16(r5)
 4008014:	10002026 	beq	r2,zero,4008098 <__sfvwrite_r+0xd4>
 4008018:	5080008c 	andi	r2,r10,2
 400801c:	e4400017 	ldw	r17,0(fp)
 4008020:	10002526 	beq	r2,zero,40080b8 <__sfvwrite_r+0xf4>
 4008024:	80800917 	ldw	r2,36(r16)
 4008028:	81400717 	ldw	r5,28(r16)
 400802c:	05600034 	movhi	r21,32768
 4008030:	0029883a 	mov	r20,zero
 4008034:	0025883a 	mov	r18,zero
 4008038:	ad7f0004 	addi	r21,r21,-1024
 400803c:	a00d883a 	mov	r6,r20
 4008040:	9809883a 	mov	r4,r19
 4008044:	90001026 	beq	r18,zero,4008088 <__sfvwrite_r+0xc4>
 4008048:	900f883a 	mov	r7,r18
 400804c:	ac80012e 	bgeu	r21,r18,4008054 <__sfvwrite_r+0x90>
 4008050:	a80f883a 	mov	r7,r21
 4008054:	103ee83a 	callr	r2
 4008058:	00809b0e 	bge	zero,r2,40082c8 <__sfvwrite_r+0x304>
 400805c:	e0c00217 	ldw	r3,8(fp)
 4008060:	a0a9883a 	add	r20,r20,r2
 4008064:	90a5c83a 	sub	r18,r18,r2
 4008068:	1885c83a 	sub	r2,r3,r2
 400806c:	e0800215 	stw	r2,8(fp)
 4008070:	10008426 	beq	r2,zero,4008284 <__sfvwrite_r+0x2c0>
 4008074:	80800917 	ldw	r2,36(r16)
 4008078:	81400717 	ldw	r5,28(r16)
 400807c:	a00d883a 	mov	r6,r20
 4008080:	9809883a 	mov	r4,r19
 4008084:	903ff01e 	bne	r18,zero,4008048 <__sfvwrite_r+0x84>
 4008088:	8d000017 	ldw	r20,0(r17)
 400808c:	8c800117 	ldw	r18,4(r17)
 4008090:	8c400204 	addi	r17,r17,8
 4008094:	003fe906 	br	400803c <__sfvwrite_r+0x78>
 4008098:	800b883a 	mov	r5,r16
 400809c:	9809883a 	mov	r4,r19
 40080a0:	40097740 	call	4009774 <__swsetup_r>
 40080a4:	10008b1e 	bne	r2,zero,40082d4 <__sfvwrite_r+0x310>
 40080a8:	8280030b 	ldhu	r10,12(r16)
 40080ac:	e4400017 	ldw	r17,0(fp)
 40080b0:	5080008c 	andi	r2,r10,2
 40080b4:	103fdb1e 	bne	r2,zero,4008024 <__sfvwrite_r+0x60>
 40080b8:	5080004c 	andi	r2,r10,1
 40080bc:	10004f1e 	bne	r2,zero,40081fc <__sfvwrite_r+0x238>
 40080c0:	00a00034 	movhi	r2,32768
 40080c4:	81c00017 	ldw	r7,0(r16)
 40080c8:	80c00217 	ldw	r3,8(r16)
 40080cc:	10bfffc4 	addi	r2,r2,-1
 40080d0:	002d883a 	mov	r22,zero
 40080d4:	0025883a 	mov	r18,zero
 40080d8:	d8800015 	stw	r2,0(sp)
 40080dc:	3809883a 	mov	r4,r7
 40080e0:	1829883a 	mov	r20,r3
 40080e4:	90004126 	beq	r18,zero,40081ec <__sfvwrite_r+0x228>
 40080e8:	5080800c 	andi	r2,r10,512
 40080ec:	10009526 	beq	r2,zero,4008344 <__sfvwrite_r+0x380>
 40080f0:	182b883a 	mov	r21,r3
 40080f4:	90c0ba36 	bltu	r18,r3,40083e0 <__sfvwrite_r+0x41c>
 40080f8:	5081200c 	andi	r2,r10,1152
 40080fc:	10002526 	beq	r2,zero,4008194 <__sfvwrite_r+0x1d0>
 4008100:	80c00517 	ldw	r3,20(r16)
 4008104:	81000417 	ldw	r4,16(r16)
 4008108:	18c5883a 	add	r2,r3,r3
 400810c:	10c5883a 	add	r2,r2,r3
 4008110:	1012d7fa 	srli	r9,r2,31
 4008114:	392fc83a 	sub	r23,r7,r4
 4008118:	b8c00044 	addi	r3,r23,1
 400811c:	4893883a 	add	r9,r9,r2
 4008120:	4829d07a 	srai	r20,r9,1
 4008124:	1c85883a 	add	r2,r3,r18
 4008128:	a00b883a 	mov	r5,r20
 400812c:	a080022e 	bgeu	r20,r2,4008138 <__sfvwrite_r+0x174>
 4008130:	1029883a 	mov	r20,r2
 4008134:	100b883a 	mov	r5,r2
 4008138:	5281000c 	andi	r10,r10,1024
 400813c:	5000b926 	beq	r10,zero,4008424 <__sfvwrite_r+0x460>
 4008140:	9809883a 	mov	r4,r19
 4008144:	40085ac0 	call	40085ac <_malloc_r>
 4008148:	1000c426 	beq	r2,zero,400845c <__sfvwrite_r+0x498>
 400814c:	81400417 	ldw	r5,16(r16)
 4008150:	1009883a 	mov	r4,r2
 4008154:	b80d883a 	mov	r6,r23
 4008158:	40078800 	call	4007880 <memcpy>
 400815c:	1007883a 	mov	r3,r2
 4008160:	8080030b 	ldhu	r2,12(r16)
 4008164:	013edfc4 	movi	r4,-1153
 4008168:	1104703a 	and	r2,r2,r4
 400816c:	10802014 	ori	r2,r2,128
 4008170:	8080030d 	sth	r2,12(r16)
 4008174:	a5cfc83a 	sub	r7,r20,r23
 4008178:	1dc9883a 	add	r4,r3,r23
 400817c:	85000515 	stw	r20,20(r16)
 4008180:	80c00415 	stw	r3,16(r16)
 4008184:	81000015 	stw	r4,0(r16)
 4008188:	9029883a 	mov	r20,r18
 400818c:	81c00215 	stw	r7,8(r16)
 4008190:	902b883a 	mov	r21,r18
 4008194:	a80d883a 	mov	r6,r21
 4008198:	b00b883a 	mov	r5,r22
 400819c:	4008e5c0 	call	4008e5c <memmove>
 40081a0:	80c00217 	ldw	r3,8(r16)
 40081a4:	81c00017 	ldw	r7,0(r16)
 40081a8:	902f883a 	mov	r23,r18
 40081ac:	1d07c83a 	sub	r3,r3,r20
 40081b0:	3d4d883a 	add	r6,r7,r21
 40081b4:	80c00215 	stw	r3,8(r16)
 40081b8:	81800015 	stw	r6,0(r16)
 40081bc:	0025883a 	mov	r18,zero
 40081c0:	e0800217 	ldw	r2,8(fp)
 40081c4:	b5ed883a 	add	r22,r22,r23
 40081c8:	15c5c83a 	sub	r2,r2,r23
 40081cc:	e0800215 	stw	r2,8(fp)
 40081d0:	10002c26 	beq	r2,zero,4008284 <__sfvwrite_r+0x2c0>
 40081d4:	81c00017 	ldw	r7,0(r16)
 40081d8:	80c00217 	ldw	r3,8(r16)
 40081dc:	8280030b 	ldhu	r10,12(r16)
 40081e0:	3809883a 	mov	r4,r7
 40081e4:	1829883a 	mov	r20,r3
 40081e8:	903fbf1e 	bne	r18,zero,40080e8 <__sfvwrite_r+0x124>
 40081ec:	8d800017 	ldw	r22,0(r17)
 40081f0:	8c800117 	ldw	r18,4(r17)
 40081f4:	8c400204 	addi	r17,r17,8
 40081f8:	003fb806 	br	40080dc <__sfvwrite_r+0x118>
 40081fc:	002f883a 	mov	r23,zero
 4008200:	0005883a 	mov	r2,zero
 4008204:	002b883a 	mov	r21,zero
 4008208:	0029883a 	mov	r20,zero
 400820c:	a0003526 	beq	r20,zero,40082e4 <__sfvwrite_r+0x320>
 4008210:	10003926 	beq	r2,zero,40082f8 <__sfvwrite_r+0x334>
 4008214:	b805883a 	mov	r2,r23
 4008218:	a02d883a 	mov	r22,r20
 400821c:	1500012e 	bgeu	r2,r20,4008224 <__sfvwrite_r+0x260>
 4008220:	102d883a 	mov	r22,r2
 4008224:	81000017 	ldw	r4,0(r16)
 4008228:	80800417 	ldw	r2,16(r16)
 400822c:	84800217 	ldw	r18,8(r16)
 4008230:	81c00517 	ldw	r7,20(r16)
 4008234:	1100022e 	bgeu	r2,r4,4008240 <__sfvwrite_r+0x27c>
 4008238:	91e5883a 	add	r18,r18,r7
 400823c:	95803616 	blt	r18,r22,4008318 <__sfvwrite_r+0x354>
 4008240:	b1c06a16 	blt	r22,r7,40083ec <__sfvwrite_r+0x428>
 4008244:	80800917 	ldw	r2,36(r16)
 4008248:	81400717 	ldw	r5,28(r16)
 400824c:	a80d883a 	mov	r6,r21
 4008250:	9809883a 	mov	r4,r19
 4008254:	103ee83a 	callr	r2
 4008258:	1025883a 	mov	r18,r2
 400825c:	00801a0e 	bge	zero,r2,40082c8 <__sfvwrite_r+0x304>
 4008260:	bcafc83a 	sub	r23,r23,r18
 4008264:	b8001426 	beq	r23,zero,40082b8 <__sfvwrite_r+0x2f4>
 4008268:	00800044 	movi	r2,1
 400826c:	e0c00217 	ldw	r3,8(fp)
 4008270:	acab883a 	add	r21,r21,r18
 4008274:	a4a9c83a 	sub	r20,r20,r18
 4008278:	1c87c83a 	sub	r3,r3,r18
 400827c:	e0c00215 	stw	r3,8(fp)
 4008280:	183fe21e 	bne	r3,zero,400820c <__sfvwrite_r+0x248>
 4008284:	0005883a 	mov	r2,zero
 4008288:	dfc00a17 	ldw	ra,40(sp)
 400828c:	df000917 	ldw	fp,36(sp)
 4008290:	ddc00817 	ldw	r23,32(sp)
 4008294:	dd800717 	ldw	r22,28(sp)
 4008298:	dd400617 	ldw	r21,24(sp)
 400829c:	dd000517 	ldw	r20,20(sp)
 40082a0:	dcc00417 	ldw	r19,16(sp)
 40082a4:	dc800317 	ldw	r18,12(sp)
 40082a8:	dc400217 	ldw	r17,8(sp)
 40082ac:	dc000117 	ldw	r16,4(sp)
 40082b0:	dec00b04 	addi	sp,sp,44
 40082b4:	f800283a 	ret
 40082b8:	800b883a 	mov	r5,r16
 40082bc:	9809883a 	mov	r4,r19
 40082c0:	4009c280 	call	4009c28 <_fflush_r>
 40082c4:	103fe926 	beq	r2,zero,400826c <__sfvwrite_r+0x2a8>
 40082c8:	8080030b 	ldhu	r2,12(r16)
 40082cc:	10801014 	ori	r2,r2,64
 40082d0:	8080030d 	sth	r2,12(r16)
 40082d4:	00bfffc4 	movi	r2,-1
 40082d8:	003feb06 	br	4008288 <__sfvwrite_r+0x2c4>
 40082dc:	0005883a 	mov	r2,zero
 40082e0:	f800283a 	ret
 40082e4:	8d000117 	ldw	r20,4(r17)
 40082e8:	8805883a 	mov	r2,r17
 40082ec:	8c400204 	addi	r17,r17,8
 40082f0:	a03ffc26 	beq	r20,zero,40082e4 <__sfvwrite_r+0x320>
 40082f4:	15400017 	ldw	r21,0(r2)
 40082f8:	a00d883a 	mov	r6,r20
 40082fc:	01400284 	movi	r5,10
 4008300:	a809883a 	mov	r4,r21
 4008304:	4008d600 	call	4008d60 <memchr>
 4008308:	10004326 	beq	r2,zero,4008418 <__sfvwrite_r+0x454>
 400830c:	10800044 	addi	r2,r2,1
 4008310:	156fc83a 	sub	r23,r2,r21
 4008314:	003fbf06 	br	4008214 <__sfvwrite_r+0x250>
 4008318:	a80b883a 	mov	r5,r21
 400831c:	900d883a 	mov	r6,r18
 4008320:	4008e5c0 	call	4008e5c <memmove>
 4008324:	80800017 	ldw	r2,0(r16)
 4008328:	800b883a 	mov	r5,r16
 400832c:	9809883a 	mov	r4,r19
 4008330:	1485883a 	add	r2,r2,r18
 4008334:	80800015 	stw	r2,0(r16)
 4008338:	4009c280 	call	4009c28 <_fflush_r>
 400833c:	103fc826 	beq	r2,zero,4008260 <__sfvwrite_r+0x29c>
 4008340:	003fe106 	br	40082c8 <__sfvwrite_r+0x304>
 4008344:	80800417 	ldw	r2,16(r16)
 4008348:	11c01236 	bltu	r2,r7,4008394 <__sfvwrite_r+0x3d0>
 400834c:	81400517 	ldw	r5,20(r16)
 4008350:	91401036 	bltu	r18,r5,4008394 <__sfvwrite_r+0x3d0>
 4008354:	00a00034 	movhi	r2,32768
 4008358:	902f883a 	mov	r23,r18
 400835c:	90800136 	bltu	r18,r2,4008364 <__sfvwrite_r+0x3a0>
 4008360:	ddc00017 	ldw	r23,0(sp)
 4008364:	b809883a 	mov	r4,r23
 4008368:	40077240 	call	4007724 <__modsi3>
 400836c:	80c00917 	ldw	r3,36(r16)
 4008370:	81400717 	ldw	r5,28(r16)
 4008374:	b88fc83a 	sub	r7,r23,r2
 4008378:	b00d883a 	mov	r6,r22
 400837c:	9809883a 	mov	r4,r19
 4008380:	183ee83a 	callr	r3
 4008384:	102f883a 	mov	r23,r2
 4008388:	00bfcf0e 	bge	zero,r2,40082c8 <__sfvwrite_r+0x304>
 400838c:	95e5c83a 	sub	r18,r18,r23
 4008390:	003f8b06 	br	40081c0 <__sfvwrite_r+0x1fc>
 4008394:	182f883a 	mov	r23,r3
 4008398:	90c0012e 	bgeu	r18,r3,40083a0 <__sfvwrite_r+0x3dc>
 400839c:	902f883a 	mov	r23,r18
 40083a0:	3809883a 	mov	r4,r7
 40083a4:	b80d883a 	mov	r6,r23
 40083a8:	b00b883a 	mov	r5,r22
 40083ac:	4008e5c0 	call	4008e5c <memmove>
 40083b0:	80c00217 	ldw	r3,8(r16)
 40083b4:	81c00017 	ldw	r7,0(r16)
 40083b8:	1dc7c83a 	sub	r3,r3,r23
 40083bc:	3dcf883a 	add	r7,r7,r23
 40083c0:	80c00215 	stw	r3,8(r16)
 40083c4:	81c00015 	stw	r7,0(r16)
 40083c8:	183ff01e 	bne	r3,zero,400838c <__sfvwrite_r+0x3c8>
 40083cc:	800b883a 	mov	r5,r16
 40083d0:	9809883a 	mov	r4,r19
 40083d4:	4009c280 	call	4009c28 <_fflush_r>
 40083d8:	103fec26 	beq	r2,zero,400838c <__sfvwrite_r+0x3c8>
 40083dc:	003fba06 	br	40082c8 <__sfvwrite_r+0x304>
 40083e0:	9029883a 	mov	r20,r18
 40083e4:	902b883a 	mov	r21,r18
 40083e8:	003f6a06 	br	4008194 <__sfvwrite_r+0x1d0>
 40083ec:	b00d883a 	mov	r6,r22
 40083f0:	a80b883a 	mov	r5,r21
 40083f4:	4008e5c0 	call	4008e5c <memmove>
 40083f8:	80c00217 	ldw	r3,8(r16)
 40083fc:	80800017 	ldw	r2,0(r16)
 4008400:	b025883a 	mov	r18,r22
 4008404:	1d87c83a 	sub	r3,r3,r22
 4008408:	1585883a 	add	r2,r2,r22
 400840c:	80c00215 	stw	r3,8(r16)
 4008410:	80800015 	stw	r2,0(r16)
 4008414:	003f9206 	br	4008260 <__sfvwrite_r+0x29c>
 4008418:	a0800044 	addi	r2,r20,1
 400841c:	102f883a 	mov	r23,r2
 4008420:	003f7d06 	br	4008218 <__sfvwrite_r+0x254>
 4008424:	280d883a 	mov	r6,r5
 4008428:	200b883a 	mov	r5,r4
 400842c:	9809883a 	mov	r4,r19
 4008430:	4008f840 	call	4008f84 <_realloc_r>
 4008434:	1007883a 	mov	r3,r2
 4008438:	103f4e1e 	bne	r2,zero,4008174 <__sfvwrite_r+0x1b0>
 400843c:	81400417 	ldw	r5,16(r16)
 4008440:	9809883a 	mov	r4,r19
 4008444:	4009e300 	call	4009e30 <_free_r>
 4008448:	8080030b 	ldhu	r2,12(r16)
 400844c:	00c00304 	movi	r3,12
 4008450:	98c00015 	stw	r3,0(r19)
 4008454:	10bfdfcc 	andi	r2,r2,65407
 4008458:	003f9c06 	br	40082cc <__sfvwrite_r+0x308>
 400845c:	00c00304 	movi	r3,12
 4008460:	8080030b 	ldhu	r2,12(r16)
 4008464:	98c00015 	stw	r3,0(r19)
 4008468:	003f9806 	br	40082cc <__sfvwrite_r+0x308>

0400846c <_fwalk>:
 400846c:	defffa04 	addi	sp,sp,-24
 4008470:	dd000415 	stw	r20,16(sp)
 4008474:	dcc00315 	stw	r19,12(sp)
 4008478:	dc800215 	stw	r18,8(sp)
 400847c:	dfc00515 	stw	ra,20(sp)
 4008480:	dc400115 	stw	r17,4(sp)
 4008484:	dc000015 	stw	r16,0(sp)
 4008488:	2827883a 	mov	r19,r5
 400848c:	2480b804 	addi	r18,r4,736
 4008490:	0029883a 	mov	r20,zero
 4008494:	94400117 	ldw	r17,4(r18)
 4008498:	94000217 	ldw	r16,8(r18)
 400849c:	8c7fffc4 	addi	r17,r17,-1
 40084a0:	88000d16 	blt	r17,zero,40084d8 <_fwalk+0x6c>
 40084a4:	8080030b 	ldhu	r2,12(r16)
 40084a8:	8c7fffc4 	addi	r17,r17,-1
 40084ac:	108000b0 	cmpltui	r2,r2,2
 40084b0:	1000061e 	bne	r2,zero,40084cc <_fwalk+0x60>
 40084b4:	8080038f 	ldh	r2,14(r16)
 40084b8:	8009883a 	mov	r4,r16
 40084bc:	10bfffe0 	cmpeqi	r2,r2,-1
 40084c0:	1000021e 	bne	r2,zero,40084cc <_fwalk+0x60>
 40084c4:	983ee83a 	callr	r19
 40084c8:	a0a8b03a 	or	r20,r20,r2
 40084cc:	88bfffd8 	cmpnei	r2,r17,-1
 40084d0:	84001a04 	addi	r16,r16,104
 40084d4:	103ff31e 	bne	r2,zero,40084a4 <_fwalk+0x38>
 40084d8:	94800017 	ldw	r18,0(r18)
 40084dc:	903fed1e 	bne	r18,zero,4008494 <_fwalk+0x28>
 40084e0:	a005883a 	mov	r2,r20
 40084e4:	dfc00517 	ldw	ra,20(sp)
 40084e8:	dd000417 	ldw	r20,16(sp)
 40084ec:	dcc00317 	ldw	r19,12(sp)
 40084f0:	dc800217 	ldw	r18,8(sp)
 40084f4:	dc400117 	ldw	r17,4(sp)
 40084f8:	dc000017 	ldw	r16,0(sp)
 40084fc:	dec00604 	addi	sp,sp,24
 4008500:	f800283a 	ret

04008504 <_fwalk_reent>:
 4008504:	defff904 	addi	sp,sp,-28
 4008508:	dd400515 	stw	r21,20(sp)
 400850c:	dd000415 	stw	r20,16(sp)
 4008510:	dcc00315 	stw	r19,12(sp)
 4008514:	dc800215 	stw	r18,8(sp)
 4008518:	dfc00615 	stw	ra,24(sp)
 400851c:	dc400115 	stw	r17,4(sp)
 4008520:	dc000015 	stw	r16,0(sp)
 4008524:	2025883a 	mov	r18,r4
 4008528:	2829883a 	mov	r20,r5
 400852c:	24c0b804 	addi	r19,r4,736
 4008530:	002b883a 	mov	r21,zero
 4008534:	9c400117 	ldw	r17,4(r19)
 4008538:	9c000217 	ldw	r16,8(r19)
 400853c:	8c7fffc4 	addi	r17,r17,-1
 4008540:	88000e16 	blt	r17,zero,400857c <_fwalk_reent+0x78>
 4008544:	8080030b 	ldhu	r2,12(r16)
 4008548:	8c7fffc4 	addi	r17,r17,-1
 400854c:	108000b0 	cmpltui	r2,r2,2
 4008550:	1000071e 	bne	r2,zero,4008570 <_fwalk_reent+0x6c>
 4008554:	8080038f 	ldh	r2,14(r16)
 4008558:	800b883a 	mov	r5,r16
 400855c:	9009883a 	mov	r4,r18
 4008560:	10bfffe0 	cmpeqi	r2,r2,-1
 4008564:	1000021e 	bne	r2,zero,4008570 <_fwalk_reent+0x6c>
 4008568:	a03ee83a 	callr	r20
 400856c:	a8aab03a 	or	r21,r21,r2
 4008570:	88bfffd8 	cmpnei	r2,r17,-1
 4008574:	84001a04 	addi	r16,r16,104
 4008578:	103ff21e 	bne	r2,zero,4008544 <_fwalk_reent+0x40>
 400857c:	9cc00017 	ldw	r19,0(r19)
 4008580:	983fec1e 	bne	r19,zero,4008534 <_fwalk_reent+0x30>
 4008584:	a805883a 	mov	r2,r21
 4008588:	dfc00617 	ldw	ra,24(sp)
 400858c:	dd400517 	ldw	r21,20(sp)
 4008590:	dd000417 	ldw	r20,16(sp)
 4008594:	dcc00317 	ldw	r19,12(sp)
 4008598:	dc800217 	ldw	r18,8(sp)
 400859c:	dc400117 	ldw	r17,4(sp)
 40085a0:	dc000017 	ldw	r16,0(sp)
 40085a4:	dec00704 	addi	sp,sp,28
 40085a8:	f800283a 	ret

040085ac <_malloc_r>:
 40085ac:	defff604 	addi	sp,sp,-40
 40085b0:	dc400115 	stw	r17,4(sp)
 40085b4:	2c4002c4 	addi	r17,r5,11
 40085b8:	dc800215 	stw	r18,8(sp)
 40085bc:	dfc00915 	stw	ra,36(sp)
 40085c0:	df000815 	stw	fp,32(sp)
 40085c4:	ddc00715 	stw	r23,28(sp)
 40085c8:	dd800615 	stw	r22,24(sp)
 40085cc:	dd400515 	stw	r21,20(sp)
 40085d0:	dd000415 	stw	r20,16(sp)
 40085d4:	dcc00315 	stw	r19,12(sp)
 40085d8:	dc000015 	stw	r16,0(sp)
 40085dc:	888005e8 	cmpgeui	r2,r17,23
 40085e0:	2025883a 	mov	r18,r4
 40085e4:	1000261e 	bne	r2,zero,4008680 <_malloc_r+0xd4>
 40085e8:	29400468 	cmpgeui	r5,r5,17
 40085ec:	28008d1e 	bne	r5,zero,4008824 <_malloc_r+0x278>
 40085f0:	400ad280 	call	400ad28 <__malloc_lock>
 40085f4:	04400404 	movi	r17,16
 40085f8:	00800604 	movi	r2,24
 40085fc:	01c00084 	movi	r7,2
 4008600:	04c10074 	movhi	r19,1025
 4008604:	9cf42804 	addi	r19,r19,-12128
 4008608:	9885883a 	add	r2,r19,r2
 400860c:	14000117 	ldw	r16,4(r2)
 4008610:	10fffe04 	addi	r3,r2,-8
 4008614:	80c0cb26 	beq	r16,r3,4008944 <_malloc_r+0x398>
 4008618:	80800117 	ldw	r2,4(r16)
 400861c:	81000317 	ldw	r4,12(r16)
 4008620:	00ffff04 	movi	r3,-4
 4008624:	10c4703a 	and	r2,r2,r3
 4008628:	81400217 	ldw	r5,8(r16)
 400862c:	8085883a 	add	r2,r16,r2
 4008630:	10c00117 	ldw	r3,4(r2)
 4008634:	29000315 	stw	r4,12(r5)
 4008638:	21400215 	stw	r5,8(r4)
 400863c:	18c00054 	ori	r3,r3,1
 4008640:	10c00115 	stw	r3,4(r2)
 4008644:	9009883a 	mov	r4,r18
 4008648:	400ad4c0 	call	400ad4c <__malloc_unlock>
 400864c:	80800204 	addi	r2,r16,8
 4008650:	dfc00917 	ldw	ra,36(sp)
 4008654:	df000817 	ldw	fp,32(sp)
 4008658:	ddc00717 	ldw	r23,28(sp)
 400865c:	dd800617 	ldw	r22,24(sp)
 4008660:	dd400517 	ldw	r21,20(sp)
 4008664:	dd000417 	ldw	r20,16(sp)
 4008668:	dcc00317 	ldw	r19,12(sp)
 400866c:	dc800217 	ldw	r18,8(sp)
 4008670:	dc400117 	ldw	r17,4(sp)
 4008674:	dc000017 	ldw	r16,0(sp)
 4008678:	dec00a04 	addi	sp,sp,40
 400867c:	f800283a 	ret
 4008680:	00bffe04 	movi	r2,-8
 4008684:	88a2703a 	and	r17,r17,r2
 4008688:	88006616 	blt	r17,zero,4008824 <_malloc_r+0x278>
 400868c:	89406536 	bltu	r17,r5,4008824 <_malloc_r+0x278>
 4008690:	400ad280 	call	400ad28 <__malloc_lock>
 4008694:	88807e28 	cmpgeui	r2,r17,504
 4008698:	1000ef26 	beq	r2,zero,4008a58 <_malloc_r+0x4ac>
 400869c:	8804d27a 	srli	r2,r17,9
 40086a0:	10006426 	beq	r2,zero,4008834 <_malloc_r+0x288>
 40086a4:	10c00168 	cmpgeui	r3,r2,5
 40086a8:	1800c31e 	bne	r3,zero,40089b8 <_malloc_r+0x40c>
 40086ac:	8804d1ba 	srli	r2,r17,6
 40086b0:	11c00e44 	addi	r7,r2,57
 40086b4:	380890fa 	slli	r4,r7,3
 40086b8:	12000e04 	addi	r8,r2,56
 40086bc:	04c10074 	movhi	r19,1025
 40086c0:	9cf42804 	addi	r19,r19,-12128
 40086c4:	9909883a 	add	r4,r19,r4
 40086c8:	24000117 	ldw	r16,4(r4)
 40086cc:	213ffe04 	addi	r4,r4,-8
 40086d0:	24000b26 	beq	r4,r16,4008700 <_malloc_r+0x154>
 40086d4:	01bfff04 	movi	r6,-4
 40086d8:	00000306 	br	40086e8 <_malloc_r+0x13c>
 40086dc:	1800970e 	bge	r3,zero,400893c <_malloc_r+0x390>
 40086e0:	84000317 	ldw	r16,12(r16)
 40086e4:	24000626 	beq	r4,r16,4008700 <_malloc_r+0x154>
 40086e8:	80800117 	ldw	r2,4(r16)
 40086ec:	1184703a 	and	r2,r2,r6
 40086f0:	1447c83a 	sub	r3,r2,r17
 40086f4:	19400408 	cmpgei	r5,r3,16
 40086f8:	283ff826 	beq	r5,zero,40086dc <_malloc_r+0x130>
 40086fc:	400f883a 	mov	r7,r8
 4008700:	9c000417 	ldw	r16,16(r19)
 4008704:	02410074 	movhi	r9,1025
 4008708:	4a742a04 	addi	r9,r9,-12120
 400870c:	82407f26 	beq	r16,r9,400890c <_malloc_r+0x360>
 4008710:	80800117 	ldw	r2,4(r16)
 4008714:	00ffff04 	movi	r3,-4
 4008718:	10c4703a 	and	r2,r2,r3
 400871c:	1447c83a 	sub	r3,r2,r17
 4008720:	19000410 	cmplti	r4,r3,16
 4008724:	2000cf26 	beq	r4,zero,4008a64 <_malloc_r+0x4b8>
 4008728:	9a400515 	stw	r9,20(r19)
 400872c:	9a400415 	stw	r9,16(r19)
 4008730:	1800c10e 	bge	r3,zero,4008a38 <_malloc_r+0x48c>
 4008734:	10c08028 	cmpgeui	r3,r2,512
 4008738:	99400117 	ldw	r5,4(r19)
 400873c:	1800851e 	bne	r3,zero,4008954 <_malloc_r+0x3a8>
 4008740:	1006d0fa 	srli	r3,r2,3
 4008744:	1008d17a 	srli	r4,r2,5
 4008748:	18800044 	addi	r2,r3,1
 400874c:	100490fa 	slli	r2,r2,3
 4008750:	00c00044 	movi	r3,1
 4008754:	1906983a 	sll	r3,r3,r4
 4008758:	9885883a 	add	r2,r19,r2
 400875c:	11000017 	ldw	r4,0(r2)
 4008760:	28cab03a 	or	r5,r5,r3
 4008764:	10fffe04 	addi	r3,r2,-8
 4008768:	80c00315 	stw	r3,12(r16)
 400876c:	81000215 	stw	r4,8(r16)
 4008770:	99400115 	stw	r5,4(r19)
 4008774:	14000015 	stw	r16,0(r2)
 4008778:	24000315 	stw	r16,12(r4)
 400877c:	3805d0ba 	srai	r2,r7,2
 4008780:	01000044 	movi	r4,1
 4008784:	2088983a 	sll	r4,r4,r2
 4008788:	29002e36 	bltu	r5,r4,4008844 <_malloc_r+0x298>
 400878c:	2144703a 	and	r2,r4,r5
 4008790:	10000a1e 	bne	r2,zero,40087bc <_malloc_r+0x210>
 4008794:	2109883a 	add	r4,r4,r4
 4008798:	00bfff04 	movi	r2,-4
 400879c:	3884703a 	and	r2,r7,r2
 40087a0:	2146703a 	and	r3,r4,r5
 40087a4:	11c00104 	addi	r7,r2,4
 40087a8:	1800041e 	bne	r3,zero,40087bc <_malloc_r+0x210>
 40087ac:	2109883a 	add	r4,r4,r4
 40087b0:	2144703a 	and	r2,r4,r5
 40087b4:	39c00104 	addi	r7,r7,4
 40087b8:	103ffc26 	beq	r2,zero,40087ac <_malloc_r+0x200>
 40087bc:	02bfff04 	movi	r10,-4
 40087c0:	381690fa 	slli	r11,r7,3
 40087c4:	3819883a 	mov	r12,r7
 40087c8:	9ad7883a 	add	r11,r19,r11
 40087cc:	5811883a 	mov	r8,r11
 40087d0:	40800317 	ldw	r2,12(r8)
 40087d4:	40808126 	beq	r8,r2,40089dc <_malloc_r+0x430>
 40087d8:	10c00117 	ldw	r3,4(r2)
 40087dc:	1021883a 	mov	r16,r2
 40087e0:	10800317 	ldw	r2,12(r2)
 40087e4:	1a86703a 	and	r3,r3,r10
 40087e8:	1c4bc83a 	sub	r5,r3,r17
 40087ec:	29800410 	cmplti	r6,r5,16
 40087f0:	30007f26 	beq	r6,zero,40089f0 <_malloc_r+0x444>
 40087f4:	283ff716 	blt	r5,zero,40087d4 <_malloc_r+0x228>
 40087f8:	80c7883a 	add	r3,r16,r3
 40087fc:	19400117 	ldw	r5,4(r3)
 4008800:	81800217 	ldw	r6,8(r16)
 4008804:	9009883a 	mov	r4,r18
 4008808:	29400054 	ori	r5,r5,1
 400880c:	19400115 	stw	r5,4(r3)
 4008810:	30800315 	stw	r2,12(r6)
 4008814:	11800215 	stw	r6,8(r2)
 4008818:	400ad4c0 	call	400ad4c <__malloc_unlock>
 400881c:	80800204 	addi	r2,r16,8
 4008820:	003f8b06 	br	4008650 <_malloc_r+0xa4>
 4008824:	00800304 	movi	r2,12
 4008828:	90800015 	stw	r2,0(r18)
 400882c:	0005883a 	mov	r2,zero
 4008830:	003f8706 	br	4008650 <_malloc_r+0xa4>
 4008834:	01008004 	movi	r4,512
 4008838:	01c01004 	movi	r7,64
 400883c:	02000fc4 	movi	r8,63
 4008840:	003f9e06 	br	40086bc <_malloc_r+0x110>
 4008844:	9c000217 	ldw	r16,8(r19)
 4008848:	00bfff04 	movi	r2,-4
 400884c:	80c00117 	ldw	r3,4(r16)
 4008850:	18aa703a 	and	r21,r3,r2
 4008854:	ac400336 	bltu	r21,r17,4008864 <_malloc_r+0x2b8>
 4008858:	ac47c83a 	sub	r3,r21,r17
 400885c:	18800408 	cmpgei	r2,r3,16
 4008860:	10002c1e 	bne	r2,zero,4008914 <_malloc_r+0x368>
 4008864:	00810074 	movhi	r2,1025
 4008868:	10b9af17 	ldw	r2,-6468(r2)
 400886c:	00c10074 	movhi	r3,1025
 4008870:	1d006c17 	ldw	r20,432(r3)
 4008874:	10bfffd8 	cmpnei	r2,r2,-1
 4008878:	856f883a 	add	r23,r16,r21
 400887c:	8d29883a 	add	r20,r17,r20
 4008880:	1000e726 	beq	r2,zero,4008c20 <_malloc_r+0x674>
 4008884:	a50403c4 	addi	r20,r20,4111
 4008888:	00bc0004 	movi	r2,-4096
 400888c:	a0a8703a 	and	r20,r20,r2
 4008890:	a00b883a 	mov	r5,r20
 4008894:	9009883a 	mov	r4,r18
 4008898:	40095780 	call	4009578 <_sbrk_r>
 400889c:	102d883a 	mov	r22,r2
 40088a0:	10bfffd8 	cmpnei	r2,r2,-1
 40088a4:	10008426 	beq	r2,zero,4008ab8 <_malloc_r+0x50c>
 40088a8:	b5c08236 	bltu	r22,r23,4008ab4 <_malloc_r+0x508>
 40088ac:	00812074 	movhi	r2,1153
 40088b0:	1100a817 	ldw	r4,672(r2)
 40088b4:	a109883a 	add	r4,r20,r4
 40088b8:	1100a815 	stw	r4,672(r2)
 40088bc:	2007883a 	mov	r3,r4
 40088c0:	bd80a51e 	bne	r23,r22,4008b58 <_malloc_r+0x5ac>
 40088c4:	b083ffcc 	andi	r2,r22,4095
 40088c8:	1000a31e 	bne	r2,zero,4008b58 <_malloc_r+0x5ac>
 40088cc:	9d800217 	ldw	r22,8(r19)
 40088d0:	ad07883a 	add	r3,r21,r20
 40088d4:	18c00054 	ori	r3,r3,1
 40088d8:	b0c00115 	stw	r3,4(r22)
 40088dc:	00810074 	movhi	r2,1025
 40088e0:	10806b17 	ldw	r2,428(r2)
 40088e4:	1100022e 	bgeu	r2,r4,40088f0 <_malloc_r+0x344>
 40088e8:	00810074 	movhi	r2,1025
 40088ec:	11006b15 	stw	r4,428(r2)
 40088f0:	00810074 	movhi	r2,1025
 40088f4:	10806a17 	ldw	r2,424(r2)
 40088f8:	1100022e 	bgeu	r2,r4,4008904 <_malloc_r+0x358>
 40088fc:	00810074 	movhi	r2,1025
 4008900:	11006a15 	stw	r4,424(r2)
 4008904:	b021883a 	mov	r16,r22
 4008908:	00006d06 	br	4008ac0 <_malloc_r+0x514>
 400890c:	99400117 	ldw	r5,4(r19)
 4008910:	003f9a06 	br	400877c <_malloc_r+0x1d0>
 4008914:	88800054 	ori	r2,r17,1
 4008918:	80800115 	stw	r2,4(r16)
 400891c:	8463883a 	add	r17,r16,r17
 4008920:	9c400215 	stw	r17,8(r19)
 4008924:	18c00054 	ori	r3,r3,1
 4008928:	88c00115 	stw	r3,4(r17)
 400892c:	9009883a 	mov	r4,r18
 4008930:	400ad4c0 	call	400ad4c <__malloc_unlock>
 4008934:	80800204 	addi	r2,r16,8
 4008938:	003f4506 	br	4008650 <_malloc_r+0xa4>
 400893c:	81000317 	ldw	r4,12(r16)
 4008940:	003f3906 	br	4008628 <_malloc_r+0x7c>
 4008944:	14000317 	ldw	r16,12(r2)
 4008948:	143f331e 	bne	r2,r16,4008618 <_malloc_r+0x6c>
 400894c:	39c00084 	addi	r7,r7,2
 4008950:	003f6b06 	br	4008700 <_malloc_r+0x154>
 4008954:	1006d27a 	srli	r3,r2,9
 4008958:	19000168 	cmpgeui	r4,r3,5
 400895c:	20005026 	beq	r4,zero,4008aa0 <_malloc_r+0x4f4>
 4008960:	19000568 	cmpgeui	r4,r3,21
 4008964:	2000c01e 	bne	r4,zero,4008c68 <_malloc_r+0x6bc>
 4008968:	19801704 	addi	r6,r3,92
 400896c:	300c90fa 	slli	r6,r6,3
 4008970:	190016c4 	addi	r4,r3,91
 4008974:	998d883a 	add	r6,r19,r6
 4008978:	30c00017 	ldw	r3,0(r6)
 400897c:	31bffe04 	addi	r6,r6,-8
 4008980:	30c0a926 	beq	r6,r3,4008c28 <_malloc_r+0x67c>
 4008984:	023fff04 	movi	r8,-4
 4008988:	00000206 	br	4008994 <_malloc_r+0x3e8>
 400898c:	18c00217 	ldw	r3,8(r3)
 4008990:	30c00326 	beq	r6,r3,40089a0 <_malloc_r+0x3f4>
 4008994:	19000117 	ldw	r4,4(r3)
 4008998:	2208703a 	and	r4,r4,r8
 400899c:	113ffb36 	bltu	r2,r4,400898c <_malloc_r+0x3e0>
 40089a0:	19800317 	ldw	r6,12(r3)
 40089a4:	81800315 	stw	r6,12(r16)
 40089a8:	80c00215 	stw	r3,8(r16)
 40089ac:	34000215 	stw	r16,8(r6)
 40089b0:	1c000315 	stw	r16,12(r3)
 40089b4:	003f7106 	br	400877c <_malloc_r+0x1d0>
 40089b8:	10c00568 	cmpgeui	r3,r2,21
 40089bc:	18004926 	beq	r3,zero,4008ae4 <_malloc_r+0x538>
 40089c0:	10c01568 	cmpgeui	r3,r2,85
 40089c4:	1800af1e 	bne	r3,zero,4008c84 <_malloc_r+0x6d8>
 40089c8:	8804d33a 	srli	r2,r17,12
 40089cc:	11c01bc4 	addi	r7,r2,111
 40089d0:	380890fa 	slli	r4,r7,3
 40089d4:	12001b84 	addi	r8,r2,110
 40089d8:	003f3806 	br	40086bc <_malloc_r+0x110>
 40089dc:	63000044 	addi	r12,r12,1
 40089e0:	608000cc 	andi	r2,r12,3
 40089e4:	42000204 	addi	r8,r8,8
 40089e8:	103f791e 	bne	r2,zero,40087d0 <_malloc_r+0x224>
 40089ec:	00004406 	br	4008b00 <_malloc_r+0x554>
 40089f0:	81000217 	ldw	r4,8(r16)
 40089f4:	89800054 	ori	r6,r17,1
 40089f8:	81800115 	stw	r6,4(r16)
 40089fc:	20800315 	stw	r2,12(r4)
 4008a00:	11000215 	stw	r4,8(r2)
 4008a04:	8463883a 	add	r17,r16,r17
 4008a08:	9c400515 	stw	r17,20(r19)
 4008a0c:	9c400415 	stw	r17,16(r19)
 4008a10:	28800054 	ori	r2,r5,1
 4008a14:	88800115 	stw	r2,4(r17)
 4008a18:	8a400315 	stw	r9,12(r17)
 4008a1c:	8a400215 	stw	r9,8(r17)
 4008a20:	80c7883a 	add	r3,r16,r3
 4008a24:	19400015 	stw	r5,0(r3)
 4008a28:	9009883a 	mov	r4,r18
 4008a2c:	400ad4c0 	call	400ad4c <__malloc_unlock>
 4008a30:	80800204 	addi	r2,r16,8
 4008a34:	003f0606 	br	4008650 <_malloc_r+0xa4>
 4008a38:	8085883a 	add	r2,r16,r2
 4008a3c:	10c00117 	ldw	r3,4(r2)
 4008a40:	9009883a 	mov	r4,r18
 4008a44:	18c00054 	ori	r3,r3,1
 4008a48:	10c00115 	stw	r3,4(r2)
 4008a4c:	400ad4c0 	call	400ad4c <__malloc_unlock>
 4008a50:	80800204 	addi	r2,r16,8
 4008a54:	003efe06 	br	4008650 <_malloc_r+0xa4>
 4008a58:	880ed0fa 	srli	r7,r17,3
 4008a5c:	88800204 	addi	r2,r17,8
 4008a60:	003ee706 	br	4008600 <_malloc_r+0x54>
 4008a64:	89000054 	ori	r4,r17,1
 4008a68:	81000115 	stw	r4,4(r16)
 4008a6c:	8463883a 	add	r17,r16,r17
 4008a70:	9c400515 	stw	r17,20(r19)
 4008a74:	9c400415 	stw	r17,16(r19)
 4008a78:	19000054 	ori	r4,r3,1
 4008a7c:	89000115 	stw	r4,4(r17)
 4008a80:	8085883a 	add	r2,r16,r2
 4008a84:	8a400315 	stw	r9,12(r17)
 4008a88:	8a400215 	stw	r9,8(r17)
 4008a8c:	10c00015 	stw	r3,0(r2)
 4008a90:	9009883a 	mov	r4,r18
 4008a94:	400ad4c0 	call	400ad4c <__malloc_unlock>
 4008a98:	80800204 	addi	r2,r16,8
 4008a9c:	003eec06 	br	4008650 <_malloc_r+0xa4>
 4008aa0:	1006d1ba 	srli	r3,r2,6
 4008aa4:	19800e44 	addi	r6,r3,57
 4008aa8:	300c90fa 	slli	r6,r6,3
 4008aac:	19000e04 	addi	r4,r3,56
 4008ab0:	003fb006 	br	4008974 <_malloc_r+0x3c8>
 4008ab4:	84c02426 	beq	r16,r19,4008b48 <_malloc_r+0x59c>
 4008ab8:	9c000217 	ldw	r16,8(r19)
 4008abc:	80c00117 	ldw	r3,4(r16)
 4008ac0:	00bfff04 	movi	r2,-4
 4008ac4:	1884703a 	and	r2,r3,r2
 4008ac8:	1447c83a 	sub	r3,r2,r17
 4008acc:	14400236 	bltu	r2,r17,4008ad8 <_malloc_r+0x52c>
 4008ad0:	18800408 	cmpgei	r2,r3,16
 4008ad4:	103f8f1e 	bne	r2,zero,4008914 <_malloc_r+0x368>
 4008ad8:	9009883a 	mov	r4,r18
 4008adc:	400ad4c0 	call	400ad4c <__malloc_unlock>
 4008ae0:	003f5206 	br	400882c <_malloc_r+0x280>
 4008ae4:	11c01704 	addi	r7,r2,92
 4008ae8:	380890fa 	slli	r4,r7,3
 4008aec:	120016c4 	addi	r8,r2,91
 4008af0:	003ef206 	br	40086bc <_malloc_r+0x110>
 4008af4:	58800217 	ldw	r2,8(r11)
 4008af8:	39ffffc4 	addi	r7,r7,-1
 4008afc:	12c0961e 	bne	r2,r11,4008d58 <_malloc_r+0x7ac>
 4008b00:	388000cc 	andi	r2,r7,3
 4008b04:	5afffe04 	addi	r11,r11,-8
 4008b08:	103ffa1e 	bne	r2,zero,4008af4 <_malloc_r+0x548>
 4008b0c:	98c00117 	ldw	r3,4(r19)
 4008b10:	0104303a 	nor	r2,zero,r4
 4008b14:	10c4703a 	and	r2,r2,r3
 4008b18:	98800115 	stw	r2,4(r19)
 4008b1c:	2109883a 	add	r4,r4,r4
 4008b20:	113f4836 	bltu	r2,r4,4008844 <_malloc_r+0x298>
 4008b24:	203f4726 	beq	r4,zero,4008844 <_malloc_r+0x298>
 4008b28:	2086703a 	and	r3,r4,r2
 4008b2c:	1800041e 	bne	r3,zero,4008b40 <_malloc_r+0x594>
 4008b30:	2109883a 	add	r4,r4,r4
 4008b34:	2086703a 	and	r3,r4,r2
 4008b38:	63000104 	addi	r12,r12,4
 4008b3c:	183ffc26 	beq	r3,zero,4008b30 <_malloc_r+0x584>
 4008b40:	600f883a 	mov	r7,r12
 4008b44:	003f1e06 	br	40087c0 <_malloc_r+0x214>
 4008b48:	00812074 	movhi	r2,1153
 4008b4c:	10c0a817 	ldw	r3,672(r2)
 4008b50:	a0c7883a 	add	r3,r20,r3
 4008b54:	10c0a815 	stw	r3,672(r2)
 4008b58:	00810074 	movhi	r2,1025
 4008b5c:	10b9af17 	ldw	r2,-6468(r2)
 4008b60:	10bfffd8 	cmpnei	r2,r2,-1
 4008b64:	10004e26 	beq	r2,zero,4008ca0 <_malloc_r+0x6f4>
 4008b68:	b5c5c83a 	sub	r2,r22,r23
 4008b6c:	10c5883a 	add	r2,r2,r3
 4008b70:	00c12074 	movhi	r3,1153
 4008b74:	1880a815 	stw	r2,672(r3)
 4008b78:	b70001cc 	andi	fp,r22,7
 4008b7c:	e0003026 	beq	fp,zero,4008c40 <_malloc_r+0x694>
 4008b80:	b72dc83a 	sub	r22,r22,fp
 4008b84:	b5800204 	addi	r22,r22,8
 4008b88:	01040204 	movi	r4,4104
 4008b8c:	2709c83a 	sub	r4,r4,fp
 4008b90:	b529883a 	add	r20,r22,r20
 4008b94:	2509c83a 	sub	r4,r4,r20
 4008b98:	25c3ffcc 	andi	r23,r4,4095
 4008b9c:	b80b883a 	mov	r5,r23
 4008ba0:	9009883a 	mov	r4,r18
 4008ba4:	40095780 	call	4009578 <_sbrk_r>
 4008ba8:	10ffffe0 	cmpeqi	r3,r2,-1
 4008bac:	1800501e 	bne	r3,zero,4008cf0 <_malloc_r+0x744>
 4008bb0:	1585c83a 	sub	r2,r2,r22
 4008bb4:	15e9883a 	add	r20,r2,r23
 4008bb8:	00812074 	movhi	r2,1153
 4008bbc:	1080a817 	ldw	r2,672(r2)
 4008bc0:	9d800215 	stw	r22,8(r19)
 4008bc4:	a0c00054 	ori	r3,r20,1
 4008bc8:	b889883a 	add	r4,r23,r2
 4008bcc:	00812074 	movhi	r2,1153
 4008bd0:	1100a815 	stw	r4,672(r2)
 4008bd4:	b0c00115 	stw	r3,4(r22)
 4008bd8:	84ff4026 	beq	r16,r19,40088dc <_malloc_r+0x330>
 4008bdc:	a8800428 	cmpgeui	r2,r21,16
 4008be0:	10003226 	beq	r2,zero,4008cac <_malloc_r+0x700>
 4008be4:	80800117 	ldw	r2,4(r16)
 4008be8:	017ffe04 	movi	r5,-8
 4008bec:	a8fffd04 	addi	r3,r21,-12
 4008bf0:	1946703a 	and	r3,r3,r5
 4008bf4:	1080004c 	andi	r2,r2,1
 4008bf8:	10c4b03a 	or	r2,r2,r3
 4008bfc:	80800115 	stw	r2,4(r16)
 4008c00:	01400144 	movi	r5,5
 4008c04:	80c5883a 	add	r2,r16,r3
 4008c08:	11400115 	stw	r5,4(r2)
 4008c0c:	11400215 	stw	r5,8(r2)
 4008c10:	18c00428 	cmpgeui	r3,r3,16
 4008c14:	18003b1e 	bne	r3,zero,4008d04 <_malloc_r+0x758>
 4008c18:	b0c00117 	ldw	r3,4(r22)
 4008c1c:	003f2f06 	br	40088dc <_malloc_r+0x330>
 4008c20:	a5000404 	addi	r20,r20,16
 4008c24:	003f1a06 	br	4008890 <_malloc_r+0x2e4>
 4008c28:	2009d0ba 	srai	r4,r4,2
 4008c2c:	00800044 	movi	r2,1
 4008c30:	1104983a 	sll	r2,r2,r4
 4008c34:	288ab03a 	or	r5,r5,r2
 4008c38:	99400115 	stw	r5,4(r19)
 4008c3c:	003f5906 	br	40089a4 <_malloc_r+0x3f8>
 4008c40:	b509883a 	add	r4,r22,r20
 4008c44:	0109c83a 	sub	r4,zero,r4
 4008c48:	25c3ffcc 	andi	r23,r4,4095
 4008c4c:	b80b883a 	mov	r5,r23
 4008c50:	9009883a 	mov	r4,r18
 4008c54:	40095780 	call	4009578 <_sbrk_r>
 4008c58:	10ffffe0 	cmpeqi	r3,r2,-1
 4008c5c:	183fd426 	beq	r3,zero,4008bb0 <_malloc_r+0x604>
 4008c60:	002f883a 	mov	r23,zero
 4008c64:	003fd406 	br	4008bb8 <_malloc_r+0x60c>
 4008c68:	19001568 	cmpgeui	r4,r3,85
 4008c6c:	2000121e 	bne	r4,zero,4008cb8 <_malloc_r+0x70c>
 4008c70:	1006d33a 	srli	r3,r2,12
 4008c74:	19801bc4 	addi	r6,r3,111
 4008c78:	300c90fa 	slli	r6,r6,3
 4008c7c:	19001b84 	addi	r4,r3,110
 4008c80:	003f3c06 	br	4008974 <_malloc_r+0x3c8>
 4008c84:	10c05568 	cmpgeui	r3,r2,341
 4008c88:	1800121e 	bne	r3,zero,4008cd4 <_malloc_r+0x728>
 4008c8c:	8804d3fa 	srli	r2,r17,15
 4008c90:	11c01e04 	addi	r7,r2,120
 4008c94:	380890fa 	slli	r4,r7,3
 4008c98:	12001dc4 	addi	r8,r2,119
 4008c9c:	003e8706 	br	40086bc <_malloc_r+0x110>
 4008ca0:	00810074 	movhi	r2,1025
 4008ca4:	15b9af15 	stw	r22,-6468(r2)
 4008ca8:	003fb306 	br	4008b78 <_malloc_r+0x5cc>
 4008cac:	00800044 	movi	r2,1
 4008cb0:	b0800115 	stw	r2,4(r22)
 4008cb4:	003f8806 	br	4008ad8 <_malloc_r+0x52c>
 4008cb8:	19005568 	cmpgeui	r4,r3,341
 4008cbc:	2000181e 	bne	r4,zero,4008d20 <_malloc_r+0x774>
 4008cc0:	1006d3fa 	srli	r3,r2,15
 4008cc4:	19801e04 	addi	r6,r3,120
 4008cc8:	300c90fa 	slli	r6,r6,3
 4008ccc:	19001dc4 	addi	r4,r3,119
 4008cd0:	003f2806 	br	4008974 <_malloc_r+0x3c8>
 4008cd4:	10815568 	cmpgeui	r2,r2,1365
 4008cd8:	1000181e 	bne	r2,zero,4008d3c <_malloc_r+0x790>
 4008cdc:	8804d4ba 	srli	r2,r17,18
 4008ce0:	11c01f44 	addi	r7,r2,125
 4008ce4:	380890fa 	slli	r4,r7,3
 4008ce8:	12001f04 	addi	r8,r2,124
 4008cec:	003e7306 	br	40086bc <_malloc_r+0x110>
 4008cf0:	e73ffe04 	addi	fp,fp,-8
 4008cf4:	a729883a 	add	r20,r20,fp
 4008cf8:	a5a9c83a 	sub	r20,r20,r22
 4008cfc:	002f883a 	mov	r23,zero
 4008d00:	003fad06 	br	4008bb8 <_malloc_r+0x60c>
 4008d04:	9009883a 	mov	r4,r18
 4008d08:	81400204 	addi	r5,r16,8
 4008d0c:	4009e300 	call	4009e30 <_free_r>
 4008d10:	00812074 	movhi	r2,1153
 4008d14:	9d800217 	ldw	r22,8(r19)
 4008d18:	1100a817 	ldw	r4,672(r2)
 4008d1c:	003fbe06 	br	4008c18 <_malloc_r+0x66c>
 4008d20:	18c15568 	cmpgeui	r3,r3,1365
 4008d24:	1800091e 	bne	r3,zero,4008d4c <_malloc_r+0x7a0>
 4008d28:	1006d4ba 	srli	r3,r2,18
 4008d2c:	19801f44 	addi	r6,r3,125
 4008d30:	300c90fa 	slli	r6,r6,3
 4008d34:	19001f04 	addi	r4,r3,124
 4008d38:	003f0e06 	br	4008974 <_malloc_r+0x3c8>
 4008d3c:	0100fe04 	movi	r4,1016
 4008d40:	01c01fc4 	movi	r7,127
 4008d44:	02001f84 	movi	r8,126
 4008d48:	003e5c06 	br	40086bc <_malloc_r+0x110>
 4008d4c:	0180fe04 	movi	r6,1016
 4008d50:	01001f84 	movi	r4,126
 4008d54:	003f0706 	br	4008974 <_malloc_r+0x3c8>
 4008d58:	98800117 	ldw	r2,4(r19)
 4008d5c:	003f6f06 	br	4008b1c <_malloc_r+0x570>

04008d60 <memchr>:
 4008d60:	defffc04 	addi	sp,sp,-16
 4008d64:	dc000015 	stw	r16,0(sp)
 4008d68:	2021883a 	mov	r16,r4
 4008d6c:	dc800215 	stw	r18,8(sp)
 4008d70:	dfc00315 	stw	ra,12(sp)
 4008d74:	dc400115 	stw	r17,4(sp)
 4008d78:	808000cc 	andi	r2,r16,3
 4008d7c:	2809883a 	mov	r4,r5
 4008d80:	2825883a 	mov	r18,r5
 4008d84:	10000e26 	beq	r2,zero,4008dc0 <memchr+0x60>
 4008d88:	347fffc4 	addi	r17,r6,-1
 4008d8c:	30001726 	beq	r6,zero,4008dec <memchr+0x8c>
 4008d90:	28c03fcc 	andi	r3,r5,255
 4008d94:	00000606 	br	4008db0 <memchr+0x50>
 4008d98:	84000044 	addi	r16,r16,1
 4008d9c:	808000cc 	andi	r2,r16,3
 4008da0:	10000826 	beq	r2,zero,4008dc4 <memchr+0x64>
 4008da4:	8c7fffc4 	addi	r17,r17,-1
 4008da8:	88bfffe0 	cmpeqi	r2,r17,-1
 4008dac:	10000f1e 	bne	r2,zero,4008dec <memchr+0x8c>
 4008db0:	80800003 	ldbu	r2,0(r16)
 4008db4:	10fff81e 	bne	r2,r3,4008d98 <memchr+0x38>
 4008db8:	8005883a 	mov	r2,r16
 4008dbc:	00000c06 	br	4008df0 <memchr+0x90>
 4008dc0:	3023883a 	mov	r17,r6
 4008dc4:	88800130 	cmpltui	r2,r17,4
 4008dc8:	10000f26 	beq	r2,zero,4008e08 <memchr+0xa8>
 4008dcc:	88000726 	beq	r17,zero,4008dec <memchr+0x8c>
 4008dd0:	8463883a 	add	r17,r16,r17
 4008dd4:	8005883a 	mov	r2,r16
 4008dd8:	90c03fcc 	andi	r3,r18,255
 4008ddc:	11000003 	ldbu	r4,0(r2)
 4008de0:	20c00326 	beq	r4,r3,4008df0 <memchr+0x90>
 4008de4:	10800044 	addi	r2,r2,1
 4008de8:	88bffc1e 	bne	r17,r2,4008ddc <memchr+0x7c>
 4008dec:	0005883a 	mov	r2,zero
 4008df0:	dfc00317 	ldw	ra,12(sp)
 4008df4:	dc800217 	ldw	r18,8(sp)
 4008df8:	dc400117 	ldw	r17,4(sp)
 4008dfc:	dc000017 	ldw	r16,0(sp)
 4008e00:	dec00404 	addi	sp,sp,16
 4008e04:	f800283a 	ret
 4008e08:	01404074 	movhi	r5,257
 4008e0c:	29404044 	addi	r5,r5,257
 4008e10:	21003fcc 	andi	r4,r4,255
 4008e14:	40078580 	call	4007858 <__mulsi3>
 4008e18:	01bfbff4 	movhi	r6,65279
 4008e1c:	01602074 	movhi	r5,32897
 4008e20:	31bfbfc4 	addi	r6,r6,-257
 4008e24:	29602004 	addi	r5,r5,-32640
 4008e28:	00000406 	br	4008e3c <memchr+0xdc>
 4008e2c:	8c7fff04 	addi	r17,r17,-4
 4008e30:	88c00128 	cmpgeui	r3,r17,4
 4008e34:	84000104 	addi	r16,r16,4
 4008e38:	183fe426 	beq	r3,zero,4008dcc <memchr+0x6c>
 4008e3c:	80c00017 	ldw	r3,0(r16)
 4008e40:	10c6f03a 	xor	r3,r2,r3
 4008e44:	1989883a 	add	r4,r3,r6
 4008e48:	00c6303a 	nor	r3,zero,r3
 4008e4c:	20c6703a 	and	r3,r4,r3
 4008e50:	1946703a 	and	r3,r3,r5
 4008e54:	183ff526 	beq	r3,zero,4008e2c <memchr+0xcc>
 4008e58:	003fdc06 	br	4008dcc <memchr+0x6c>

04008e5c <memmove>:
 4008e5c:	2005883a 	mov	r2,r4
 4008e60:	29000a2e 	bgeu	r5,r4,4008e8c <memmove+0x30>
 4008e64:	298f883a 	add	r7,r5,r6
 4008e68:	21c0082e 	bgeu	r4,r7,4008e8c <memmove+0x30>
 4008e6c:	2187883a 	add	r3,r4,r6
 4008e70:	30001226 	beq	r6,zero,4008ebc <memmove+0x60>
 4008e74:	397fffc3 	ldbu	r5,-1(r7)
 4008e78:	18ffffc4 	addi	r3,r3,-1
 4008e7c:	39ffffc4 	addi	r7,r7,-1
 4008e80:	19400005 	stb	r5,0(r3)
 4008e84:	10fffb1e 	bne	r2,r3,4008e74 <memmove+0x18>
 4008e88:	f800283a 	ret
 4008e8c:	30c00428 	cmpgeui	r3,r6,16
 4008e90:	18000b1e 	bne	r3,zero,4008ec0 <memmove+0x64>
 4008e94:	1007883a 	mov	r3,r2
 4008e98:	31ffffc4 	addi	r7,r6,-1
 4008e9c:	30003626 	beq	r6,zero,4008f78 <memmove+0x11c>
 4008ea0:	39c00044 	addi	r7,r7,1
 4008ea4:	19cf883a 	add	r7,r3,r7
 4008ea8:	29800003 	ldbu	r6,0(r5)
 4008eac:	18c00044 	addi	r3,r3,1
 4008eb0:	29400044 	addi	r5,r5,1
 4008eb4:	19bfffc5 	stb	r6,-1(r3)
 4008eb8:	19fffb1e 	bne	r3,r7,4008ea8 <memmove+0x4c>
 4008ebc:	f800283a 	ret
 4008ec0:	1146b03a 	or	r3,r2,r5
 4008ec4:	18c000cc 	andi	r3,r3,3
 4008ec8:	1800281e 	bne	r3,zero,4008f6c <memmove+0x110>
 4008ecc:	313ffc04 	addi	r4,r6,-16
 4008ed0:	2008d13a 	srli	r4,r4,4
 4008ed4:	2811883a 	mov	r8,r5
 4008ed8:	100f883a 	mov	r7,r2
 4008edc:	21000044 	addi	r4,r4,1
 4008ee0:	2008913a 	slli	r4,r4,4
 4008ee4:	1107883a 	add	r3,r2,r4
 4008ee8:	42400017 	ldw	r9,0(r8)
 4008eec:	42000404 	addi	r8,r8,16
 4008ef0:	39c00404 	addi	r7,r7,16
 4008ef4:	3a7ffc15 	stw	r9,-16(r7)
 4008ef8:	427ffd17 	ldw	r9,-12(r8)
 4008efc:	3a7ffd15 	stw	r9,-12(r7)
 4008f00:	427ffe17 	ldw	r9,-8(r8)
 4008f04:	3a7ffe15 	stw	r9,-8(r7)
 4008f08:	427fff17 	ldw	r9,-4(r8)
 4008f0c:	3a7fff15 	stw	r9,-4(r7)
 4008f10:	38fff51e 	bne	r7,r3,4008ee8 <memmove+0x8c>
 4008f14:	31c0030c 	andi	r7,r6,12
 4008f18:	290b883a 	add	r5,r5,r4
 4008f1c:	324003cc 	andi	r9,r6,15
 4008f20:	38001626 	beq	r7,zero,4008f7c <memmove+0x120>
 4008f24:	2809883a 	mov	r4,r5
 4008f28:	180f883a 	mov	r7,r3
 4008f2c:	1a57883a 	add	r11,r3,r9
 4008f30:	22800017 	ldw	r10,0(r4)
 4008f34:	39c00104 	addi	r7,r7,4
 4008f38:	59d1c83a 	sub	r8,r11,r7
 4008f3c:	42000128 	cmpgeui	r8,r8,4
 4008f40:	3abfff15 	stw	r10,-4(r7)
 4008f44:	21000104 	addi	r4,r4,4
 4008f48:	403ff91e 	bne	r8,zero,4008f30 <memmove+0xd4>
 4008f4c:	493fff04 	addi	r4,r9,-4
 4008f50:	2008d0ba 	srli	r4,r4,2
 4008f54:	318000cc 	andi	r6,r6,3
 4008f58:	21000044 	addi	r4,r4,1
 4008f5c:	200890ba 	slli	r4,r4,2
 4008f60:	1907883a 	add	r3,r3,r4
 4008f64:	290b883a 	add	r5,r5,r4
 4008f68:	003fcb06 	br	4008e98 <memmove+0x3c>
 4008f6c:	31ffffc4 	addi	r7,r6,-1
 4008f70:	1007883a 	mov	r3,r2
 4008f74:	003fca06 	br	4008ea0 <memmove+0x44>
 4008f78:	f800283a 	ret
 4008f7c:	480d883a 	mov	r6,r9
 4008f80:	003fc506 	br	4008e98 <memmove+0x3c>

04008f84 <_realloc_r>:
 4008f84:	defff504 	addi	sp,sp,-44
 4008f88:	dd000515 	stw	r20,20(sp)
 4008f8c:	dfc00a15 	stw	ra,40(sp)
 4008f90:	df000915 	stw	fp,36(sp)
 4008f94:	ddc00815 	stw	r23,32(sp)
 4008f98:	dd800715 	stw	r22,28(sp)
 4008f9c:	dd400615 	stw	r21,24(sp)
 4008fa0:	dcc00415 	stw	r19,16(sp)
 4008fa4:	dc800315 	stw	r18,12(sp)
 4008fa8:	dc400215 	stw	r17,8(sp)
 4008fac:	dc000115 	stw	r16,4(sp)
 4008fb0:	3029883a 	mov	r20,r6
 4008fb4:	28008a26 	beq	r5,zero,40091e0 <_realloc_r+0x25c>
 4008fb8:	2821883a 	mov	r16,r5
 4008fbc:	202b883a 	mov	r21,r4
 4008fc0:	400ad280 	call	400ad28 <__malloc_lock>
 4008fc4:	84ffff17 	ldw	r19,-4(r16)
 4008fc8:	a44002c4 	addi	r17,r20,11
 4008fcc:	04bfff04 	movi	r18,-4
 4008fd0:	888005f0 	cmpltui	r2,r17,23
 4008fd4:	85bffe04 	addi	r22,r16,-8
 4008fd8:	9ca4703a 	and	r18,r19,r18
 4008fdc:	10005a1e 	bne	r2,zero,4009148 <_realloc_r+0x1c4>
 4008fe0:	00bffe04 	movi	r2,-8
 4008fe4:	88a2703a 	and	r17,r17,r2
 4008fe8:	88005916 	blt	r17,zero,4009150 <_realloc_r+0x1cc>
 4008fec:	8d005836 	bltu	r17,r20,4009150 <_realloc_r+0x1cc>
 4008ff0:	94403b0e 	bge	r18,r17,40090e0 <_realloc_r+0x15c>
 4008ff4:	05c10074 	movhi	r23,1025
 4008ff8:	bdf42804 	addi	r23,r23,-12128
 4008ffc:	b9400217 	ldw	r5,8(r23)
 4009000:	b489883a 	add	r4,r22,r18
 4009004:	20800117 	ldw	r2,4(r4)
 4009008:	29008e26 	beq	r5,r4,4009244 <_realloc_r+0x2c0>
 400900c:	00ffff84 	movi	r3,-2
 4009010:	10c6703a 	and	r3,r2,r3
 4009014:	20c7883a 	add	r3,r4,r3
 4009018:	18c00117 	ldw	r3,4(r3)
 400901c:	18c0004c 	andi	r3,r3,1
 4009020:	18004f1e 	bne	r3,zero,4009160 <_realloc_r+0x1dc>
 4009024:	00ffff04 	movi	r3,-4
 4009028:	10c4703a 	and	r2,r2,r3
 400902c:	9087883a 	add	r3,r18,r2
 4009030:	1c40c30e 	bge	r3,r17,4009340 <_realloc_r+0x3bc>
 4009034:	9cc0004c 	andi	r19,r19,1
 4009038:	98004b1e 	bne	r19,zero,4009168 <_realloc_r+0x1e4>
 400903c:	873ffe17 	ldw	fp,-8(r16)
 4009040:	00ffff04 	movi	r3,-4
 4009044:	b739c83a 	sub	fp,r22,fp
 4009048:	e4c00117 	ldw	r19,4(fp)
 400904c:	98c6703a 	and	r3,r19,r3
 4009050:	20000426 	beq	r4,zero,4009064 <_realloc_r+0xe0>
 4009054:	90cf883a 	add	r7,r18,r3
 4009058:	388f883a 	add	r7,r7,r2
 400905c:	2900c226 	beq	r5,r4,4009368 <_realloc_r+0x3e4>
 4009060:	3c409e0e 	bge	r7,r17,40092dc <_realloc_r+0x358>
 4009064:	e0004026 	beq	fp,zero,4009168 <_realloc_r+0x1e4>
 4009068:	90ef883a 	add	r23,r18,r3
 400906c:	bc403e16 	blt	r23,r17,4009168 <_realloc_r+0x1e4>
 4009070:	e0800317 	ldw	r2,12(fp)
 4009074:	e0c00217 	ldw	r3,8(fp)
 4009078:	91bfff04 	addi	r6,r18,-4
 400907c:	31400968 	cmpgeui	r5,r6,37
 4009080:	18800315 	stw	r2,12(r3)
 4009084:	10c00215 	stw	r3,8(r2)
 4009088:	e1000204 	addi	r4,fp,8
 400908c:	2800e71e 	bne	r5,zero,400942c <_realloc_r+0x4a8>
 4009090:	30800530 	cmpltui	r2,r6,20
 4009094:	1000e31e 	bne	r2,zero,4009424 <_realloc_r+0x4a0>
 4009098:	80c00017 	ldw	r3,0(r16)
 400909c:	30800728 	cmpgeui	r2,r6,28
 40090a0:	e0c00215 	stw	r3,8(fp)
 40090a4:	80c00117 	ldw	r3,4(r16)
 40090a8:	e0c00315 	stw	r3,12(fp)
 40090ac:	1000fa1e 	bne	r2,zero,4009498 <_realloc_r+0x514>
 40090b0:	84000204 	addi	r16,r16,8
 40090b4:	e0800404 	addi	r2,fp,16
 40090b8:	80c00017 	ldw	r3,0(r16)
 40090bc:	b825883a 	mov	r18,r23
 40090c0:	10c00015 	stw	r3,0(r2)
 40090c4:	80c00117 	ldw	r3,4(r16)
 40090c8:	e02d883a 	mov	r22,fp
 40090cc:	10c00115 	stw	r3,4(r2)
 40090d0:	80c00217 	ldw	r3,8(r16)
 40090d4:	2021883a 	mov	r16,r4
 40090d8:	10c00215 	stw	r3,8(r2)
 40090dc:	e4c00117 	ldw	r19,4(fp)
 40090e0:	9447c83a 	sub	r3,r18,r17
 40090e4:	19000430 	cmpltui	r4,r3,16
 40090e8:	9cc0004c 	andi	r19,r19,1
 40090ec:	b485883a 	add	r2,r22,r18
 40090f0:	20004826 	beq	r4,zero,4009214 <_realloc_r+0x290>
 40090f4:	94e6b03a 	or	r19,r18,r19
 40090f8:	b4c00115 	stw	r19,4(r22)
 40090fc:	10c00117 	ldw	r3,4(r2)
 4009100:	18c00054 	ori	r3,r3,1
 4009104:	10c00115 	stw	r3,4(r2)
 4009108:	a809883a 	mov	r4,r21
 400910c:	400ad4c0 	call	400ad4c <__malloc_unlock>
 4009110:	8029883a 	mov	r20,r16
 4009114:	a005883a 	mov	r2,r20
 4009118:	dfc00a17 	ldw	ra,40(sp)
 400911c:	df000917 	ldw	fp,36(sp)
 4009120:	ddc00817 	ldw	r23,32(sp)
 4009124:	dd800717 	ldw	r22,28(sp)
 4009128:	dd400617 	ldw	r21,24(sp)
 400912c:	dd000517 	ldw	r20,20(sp)
 4009130:	dcc00417 	ldw	r19,16(sp)
 4009134:	dc800317 	ldw	r18,12(sp)
 4009138:	dc400217 	ldw	r17,8(sp)
 400913c:	dc000117 	ldw	r16,4(sp)
 4009140:	dec00b04 	addi	sp,sp,44
 4009144:	f800283a 	ret
 4009148:	04400404 	movi	r17,16
 400914c:	8d3fa82e 	bgeu	r17,r20,4008ff0 <_realloc_r+0x6c>
 4009150:	00800304 	movi	r2,12
 4009154:	a8800015 	stw	r2,0(r21)
 4009158:	0029883a 	mov	r20,zero
 400915c:	003fed06 	br	4009114 <_realloc_r+0x190>
 4009160:	9cc0004c 	andi	r19,r19,1
 4009164:	98004e26 	beq	r19,zero,40092a0 <_realloc_r+0x31c>
 4009168:	a00b883a 	mov	r5,r20
 400916c:	a809883a 	mov	r4,r21
 4009170:	40085ac0 	call	40085ac <_malloc_r>
 4009174:	1029883a 	mov	r20,r2
 4009178:	1000bd26 	beq	r2,zero,4009470 <_realloc_r+0x4ec>
 400917c:	84ffff17 	ldw	r19,-4(r16)
 4009180:	10fffe04 	addi	r3,r2,-8
 4009184:	00bfff84 	movi	r2,-2
 4009188:	9884703a 	and	r2,r19,r2
 400918c:	b085883a 	add	r2,r22,r2
 4009190:	10c03e26 	beq	r2,r3,400928c <_realloc_r+0x308>
 4009194:	91bfff04 	addi	r6,r18,-4
 4009198:	30800968 	cmpgeui	r2,r6,37
 400919c:	10006e1e 	bne	r2,zero,4009358 <_realloc_r+0x3d4>
 40091a0:	30800530 	cmpltui	r2,r6,20
 40091a4:	10004426 	beq	r2,zero,40092b8 <_realloc_r+0x334>
 40091a8:	a005883a 	mov	r2,r20
 40091ac:	8007883a 	mov	r3,r16
 40091b0:	19000017 	ldw	r4,0(r3)
 40091b4:	11000015 	stw	r4,0(r2)
 40091b8:	19000117 	ldw	r4,4(r3)
 40091bc:	11000115 	stw	r4,4(r2)
 40091c0:	18c00217 	ldw	r3,8(r3)
 40091c4:	10c00215 	stw	r3,8(r2)
 40091c8:	a809883a 	mov	r4,r21
 40091cc:	800b883a 	mov	r5,r16
 40091d0:	4009e300 	call	4009e30 <_free_r>
 40091d4:	a809883a 	mov	r4,r21
 40091d8:	400ad4c0 	call	400ad4c <__malloc_unlock>
 40091dc:	003fcd06 	br	4009114 <_realloc_r+0x190>
 40091e0:	300b883a 	mov	r5,r6
 40091e4:	dfc00a17 	ldw	ra,40(sp)
 40091e8:	df000917 	ldw	fp,36(sp)
 40091ec:	ddc00817 	ldw	r23,32(sp)
 40091f0:	dd800717 	ldw	r22,28(sp)
 40091f4:	dd400617 	ldw	r21,24(sp)
 40091f8:	dd000517 	ldw	r20,20(sp)
 40091fc:	dcc00417 	ldw	r19,16(sp)
 4009200:	dc800317 	ldw	r18,12(sp)
 4009204:	dc400217 	ldw	r17,8(sp)
 4009208:	dc000117 	ldw	r16,4(sp)
 400920c:	dec00b04 	addi	sp,sp,44
 4009210:	40085ac1 	jmpi	40085ac <_malloc_r>
 4009214:	8ce6b03a 	or	r19,r17,r19
 4009218:	b4c00115 	stw	r19,4(r22)
 400921c:	b44b883a 	add	r5,r22,r17
 4009220:	18c00054 	ori	r3,r3,1
 4009224:	28c00115 	stw	r3,4(r5)
 4009228:	10c00117 	ldw	r3,4(r2)
 400922c:	29400204 	addi	r5,r5,8
 4009230:	a809883a 	mov	r4,r21
 4009234:	18c00054 	ori	r3,r3,1
 4009238:	10c00115 	stw	r3,4(r2)
 400923c:	4009e300 	call	4009e30 <_free_r>
 4009240:	003fb106 	br	4009108 <_realloc_r+0x184>
 4009244:	00ffff04 	movi	r3,-4
 4009248:	10c4703a 	and	r2,r2,r3
 400924c:	1487883a 	add	r3,r2,r18
 4009250:	89800404 	addi	r6,r17,16
 4009254:	19bf7716 	blt	r3,r6,4009034 <_realloc_r+0xb0>
 4009258:	b46d883a 	add	r22,r22,r17
 400925c:	1c45c83a 	sub	r2,r3,r17
 4009260:	bd800215 	stw	r22,8(r23)
 4009264:	10800054 	ori	r2,r2,1
 4009268:	b0800115 	stw	r2,4(r22)
 400926c:	80bfff17 	ldw	r2,-4(r16)
 4009270:	a809883a 	mov	r4,r21
 4009274:	8029883a 	mov	r20,r16
 4009278:	1080004c 	andi	r2,r2,1
 400927c:	1444b03a 	or	r2,r2,r17
 4009280:	80bfff15 	stw	r2,-4(r16)
 4009284:	400ad4c0 	call	400ad4c <__malloc_unlock>
 4009288:	003fa206 	br	4009114 <_realloc_r+0x190>
 400928c:	a0bfff17 	ldw	r2,-4(r20)
 4009290:	00ffff04 	movi	r3,-4
 4009294:	10c4703a 	and	r2,r2,r3
 4009298:	90a5883a 	add	r18,r18,r2
 400929c:	003f9006 	br	40090e0 <_realloc_r+0x15c>
 40092a0:	873ffe17 	ldw	fp,-8(r16)
 40092a4:	00bfff04 	movi	r2,-4
 40092a8:	b739c83a 	sub	fp,r22,fp
 40092ac:	e0c00117 	ldw	r3,4(fp)
 40092b0:	1886703a 	and	r3,r3,r2
 40092b4:	003f6b06 	br	4009064 <_realloc_r+0xe0>
 40092b8:	80c00017 	ldw	r3,0(r16)
 40092bc:	30800728 	cmpgeui	r2,r6,28
 40092c0:	a0c00015 	stw	r3,0(r20)
 40092c4:	80c00117 	ldw	r3,4(r16)
 40092c8:	a0c00115 	stw	r3,4(r20)
 40092cc:	10004c1e 	bne	r2,zero,4009400 <_realloc_r+0x47c>
 40092d0:	80c00204 	addi	r3,r16,8
 40092d4:	a0800204 	addi	r2,r20,8
 40092d8:	003fb506 	br	40091b0 <_realloc_r+0x22c>
 40092dc:	20800317 	ldw	r2,12(r4)
 40092e0:	20c00217 	ldw	r3,8(r4)
 40092e4:	91bfff04 	addi	r6,r18,-4
 40092e8:	31400968 	cmpgeui	r5,r6,37
 40092ec:	18800315 	stw	r2,12(r3)
 40092f0:	10c00215 	stw	r3,8(r2)
 40092f4:	e0c00217 	ldw	r3,8(fp)
 40092f8:	e0800317 	ldw	r2,12(fp)
 40092fc:	e1000204 	addi	r4,fp,8
 4009300:	18800315 	stw	r2,12(r3)
 4009304:	10c00215 	stw	r3,8(r2)
 4009308:	2800511e 	bne	r5,zero,4009450 <_realloc_r+0x4cc>
 400930c:	30800530 	cmpltui	r2,r6,20
 4009310:	10004d1e 	bne	r2,zero,4009448 <_realloc_r+0x4c4>
 4009314:	80c00017 	ldw	r3,0(r16)
 4009318:	30800728 	cmpgeui	r2,r6,28
 400931c:	e0c00215 	stw	r3,8(fp)
 4009320:	80c00117 	ldw	r3,4(r16)
 4009324:	e0c00315 	stw	r3,12(fp)
 4009328:	1000641e 	bne	r2,zero,40094bc <_realloc_r+0x538>
 400932c:	84000204 	addi	r16,r16,8
 4009330:	e0800404 	addi	r2,fp,16
 4009334:	80c00017 	ldw	r3,0(r16)
 4009338:	3825883a 	mov	r18,r7
 400933c:	003f6006 	br	40090c0 <_realloc_r+0x13c>
 4009340:	20800317 	ldw	r2,12(r4)
 4009344:	21000217 	ldw	r4,8(r4)
 4009348:	1825883a 	mov	r18,r3
 400934c:	20800315 	stw	r2,12(r4)
 4009350:	11000215 	stw	r4,8(r2)
 4009354:	003f6206 	br	40090e0 <_realloc_r+0x15c>
 4009358:	800b883a 	mov	r5,r16
 400935c:	a009883a 	mov	r4,r20
 4009360:	4008e5c0 	call	4008e5c <memmove>
 4009364:	003f9806 	br	40091c8 <_realloc_r+0x244>
 4009368:	88800404 	addi	r2,r17,16
 400936c:	38bf3d16 	blt	r7,r2,4009064 <_realloc_r+0xe0>
 4009370:	e0800317 	ldw	r2,12(fp)
 4009374:	e0c00217 	ldw	r3,8(fp)
 4009378:	91bfff04 	addi	r6,r18,-4
 400937c:	31000968 	cmpgeui	r4,r6,37
 4009380:	18800315 	stw	r2,12(r3)
 4009384:	10c00215 	stw	r3,8(r2)
 4009388:	e5000204 	addi	r20,fp,8
 400938c:	2000561e 	bne	r4,zero,40094e8 <_realloc_r+0x564>
 4009390:	30800530 	cmpltui	r2,r6,20
 4009394:	1000521e 	bne	r2,zero,40094e0 <_realloc_r+0x55c>
 4009398:	80c00017 	ldw	r3,0(r16)
 400939c:	30800728 	cmpgeui	r2,r6,28
 40093a0:	e0c00215 	stw	r3,8(fp)
 40093a4:	80c00117 	ldw	r3,4(r16)
 40093a8:	e0c00315 	stw	r3,12(fp)
 40093ac:	1000541e 	bne	r2,zero,4009500 <_realloc_r+0x57c>
 40093b0:	84000204 	addi	r16,r16,8
 40093b4:	e0800404 	addi	r2,fp,16
 40093b8:	80c00017 	ldw	r3,0(r16)
 40093bc:	10c00015 	stw	r3,0(r2)
 40093c0:	80c00117 	ldw	r3,4(r16)
 40093c4:	10c00115 	stw	r3,4(r2)
 40093c8:	80c00217 	ldw	r3,8(r16)
 40093cc:	10c00215 	stw	r3,8(r2)
 40093d0:	e447883a 	add	r3,fp,r17
 40093d4:	3c45c83a 	sub	r2,r7,r17
 40093d8:	b8c00215 	stw	r3,8(r23)
 40093dc:	10800054 	ori	r2,r2,1
 40093e0:	18800115 	stw	r2,4(r3)
 40093e4:	e0800117 	ldw	r2,4(fp)
 40093e8:	a809883a 	mov	r4,r21
 40093ec:	1080004c 	andi	r2,r2,1
 40093f0:	1444b03a 	or	r2,r2,r17
 40093f4:	e0800115 	stw	r2,4(fp)
 40093f8:	400ad4c0 	call	400ad4c <__malloc_unlock>
 40093fc:	003f4506 	br	4009114 <_realloc_r+0x190>
 4009400:	80800217 	ldw	r2,8(r16)
 4009404:	31800920 	cmpeqi	r6,r6,36
 4009408:	a0800215 	stw	r2,8(r20)
 400940c:	80800317 	ldw	r2,12(r16)
 4009410:	a0800315 	stw	r2,12(r20)
 4009414:	3000191e 	bne	r6,zero,400947c <_realloc_r+0x4f8>
 4009418:	80c00404 	addi	r3,r16,16
 400941c:	a0800404 	addi	r2,r20,16
 4009420:	003f6306 	br	40091b0 <_realloc_r+0x22c>
 4009424:	2005883a 	mov	r2,r4
 4009428:	003f2306 	br	40090b8 <_realloc_r+0x134>
 400942c:	800b883a 	mov	r5,r16
 4009430:	4008e5c0 	call	4008e5c <memmove>
 4009434:	1021883a 	mov	r16,r2
 4009438:	e4c00117 	ldw	r19,4(fp)
 400943c:	b825883a 	mov	r18,r23
 4009440:	e02d883a 	mov	r22,fp
 4009444:	003f2606 	br	40090e0 <_realloc_r+0x15c>
 4009448:	2005883a 	mov	r2,r4
 400944c:	003fb906 	br	4009334 <_realloc_r+0x3b0>
 4009450:	800b883a 	mov	r5,r16
 4009454:	d9c00015 	stw	r7,0(sp)
 4009458:	4008e5c0 	call	4008e5c <memmove>
 400945c:	d9c00017 	ldw	r7,0(sp)
 4009460:	1021883a 	mov	r16,r2
 4009464:	e02d883a 	mov	r22,fp
 4009468:	3825883a 	mov	r18,r7
 400946c:	003f1c06 	br	40090e0 <_realloc_r+0x15c>
 4009470:	a809883a 	mov	r4,r21
 4009474:	400ad4c0 	call	400ad4c <__malloc_unlock>
 4009478:	003f3706 	br	4009158 <_realloc_r+0x1d4>
 400947c:	81000417 	ldw	r4,16(r16)
 4009480:	80c00604 	addi	r3,r16,24
 4009484:	a0800604 	addi	r2,r20,24
 4009488:	a1000415 	stw	r4,16(r20)
 400948c:	81000517 	ldw	r4,20(r16)
 4009490:	a1000515 	stw	r4,20(r20)
 4009494:	003f4606 	br	40091b0 <_realloc_r+0x22c>
 4009498:	80800217 	ldw	r2,8(r16)
 400949c:	31800920 	cmpeqi	r6,r6,36
 40094a0:	e0800415 	stw	r2,16(fp)
 40094a4:	80800317 	ldw	r2,12(r16)
 40094a8:	e0800515 	stw	r2,20(fp)
 40094ac:	30001d1e 	bne	r6,zero,4009524 <_realloc_r+0x5a0>
 40094b0:	84000404 	addi	r16,r16,16
 40094b4:	e0800604 	addi	r2,fp,24
 40094b8:	003eff06 	br	40090b8 <_realloc_r+0x134>
 40094bc:	80800217 	ldw	r2,8(r16)
 40094c0:	31800920 	cmpeqi	r6,r6,36
 40094c4:	e0800415 	stw	r2,16(fp)
 40094c8:	80800317 	ldw	r2,12(r16)
 40094cc:	e0800515 	stw	r2,20(fp)
 40094d0:	30001b1e 	bne	r6,zero,4009540 <_realloc_r+0x5bc>
 40094d4:	84000404 	addi	r16,r16,16
 40094d8:	e0800604 	addi	r2,fp,24
 40094dc:	003f9506 	br	4009334 <_realloc_r+0x3b0>
 40094e0:	a005883a 	mov	r2,r20
 40094e4:	003fb406 	br	40093b8 <_realloc_r+0x434>
 40094e8:	800b883a 	mov	r5,r16
 40094ec:	a009883a 	mov	r4,r20
 40094f0:	d9c00015 	stw	r7,0(sp)
 40094f4:	4008e5c0 	call	4008e5c <memmove>
 40094f8:	d9c00017 	ldw	r7,0(sp)
 40094fc:	003fb406 	br	40093d0 <_realloc_r+0x44c>
 4009500:	80800217 	ldw	r2,8(r16)
 4009504:	31800920 	cmpeqi	r6,r6,36
 4009508:	e0800415 	stw	r2,16(fp)
 400950c:	80800317 	ldw	r2,12(r16)
 4009510:	e0800515 	stw	r2,20(fp)
 4009514:	3000111e 	bne	r6,zero,400955c <_realloc_r+0x5d8>
 4009518:	84000404 	addi	r16,r16,16
 400951c:	e0800604 	addi	r2,fp,24
 4009520:	003fa506 	br	40093b8 <_realloc_r+0x434>
 4009524:	80c00417 	ldw	r3,16(r16)
 4009528:	84000604 	addi	r16,r16,24
 400952c:	e0800804 	addi	r2,fp,32
 4009530:	e0c00615 	stw	r3,24(fp)
 4009534:	80ffff17 	ldw	r3,-4(r16)
 4009538:	e0c00715 	stw	r3,28(fp)
 400953c:	003ede06 	br	40090b8 <_realloc_r+0x134>
 4009540:	80c00417 	ldw	r3,16(r16)
 4009544:	84000604 	addi	r16,r16,24
 4009548:	e0800804 	addi	r2,fp,32
 400954c:	e0c00615 	stw	r3,24(fp)
 4009550:	80ffff17 	ldw	r3,-4(r16)
 4009554:	e0c00715 	stw	r3,28(fp)
 4009558:	003f7606 	br	4009334 <_realloc_r+0x3b0>
 400955c:	80c00417 	ldw	r3,16(r16)
 4009560:	84000604 	addi	r16,r16,24
 4009564:	e0800804 	addi	r2,fp,32
 4009568:	e0c00615 	stw	r3,24(fp)
 400956c:	80ffff17 	ldw	r3,-4(r16)
 4009570:	e0c00715 	stw	r3,28(fp)
 4009574:	003f9006 	br	40093b8 <_realloc_r+0x434>

04009578 <_sbrk_r>:
 4009578:	defffe04 	addi	sp,sp,-8
 400957c:	dc000015 	stw	r16,0(sp)
 4009580:	00810074 	movhi	r2,1025
 4009584:	2021883a 	mov	r16,r4
 4009588:	2809883a 	mov	r4,r5
 400958c:	dfc00115 	stw	ra,4(sp)
 4009590:	10006d15 	stw	zero,436(r2)
 4009594:	400af240 	call	400af24 <sbrk>
 4009598:	10ffffd8 	cmpnei	r3,r2,-1
 400959c:	18000426 	beq	r3,zero,40095b0 <_sbrk_r+0x38>
 40095a0:	dfc00117 	ldw	ra,4(sp)
 40095a4:	dc000017 	ldw	r16,0(sp)
 40095a8:	dec00204 	addi	sp,sp,8
 40095ac:	f800283a 	ret
 40095b0:	00c10074 	movhi	r3,1025
 40095b4:	18c06d17 	ldw	r3,436(r3)
 40095b8:	183ff926 	beq	r3,zero,40095a0 <_sbrk_r+0x28>
 40095bc:	80c00015 	stw	r3,0(r16)
 40095c0:	dfc00117 	ldw	ra,4(sp)
 40095c4:	dc000017 	ldw	r16,0(sp)
 40095c8:	dec00204 	addi	sp,sp,8
 40095cc:	f800283a 	ret

040095d0 <__sread>:
 40095d0:	defffe04 	addi	sp,sp,-8
 40095d4:	dc000015 	stw	r16,0(sp)
 40095d8:	2821883a 	mov	r16,r5
 40095dc:	2940038f 	ldh	r5,14(r5)
 40095e0:	dfc00115 	stw	ra,4(sp)
 40095e4:	400a3c80 	call	400a3c8 <_read_r>
 40095e8:	10000716 	blt	r2,zero,4009608 <__sread+0x38>
 40095ec:	80c01417 	ldw	r3,80(r16)
 40095f0:	1887883a 	add	r3,r3,r2
 40095f4:	80c01415 	stw	r3,80(r16)
 40095f8:	dfc00117 	ldw	ra,4(sp)
 40095fc:	dc000017 	ldw	r16,0(sp)
 4009600:	dec00204 	addi	sp,sp,8
 4009604:	f800283a 	ret
 4009608:	80c0030b 	ldhu	r3,12(r16)
 400960c:	18fbffcc 	andi	r3,r3,61439
 4009610:	80c0030d 	sth	r3,12(r16)
 4009614:	dfc00117 	ldw	ra,4(sp)
 4009618:	dc000017 	ldw	r16,0(sp)
 400961c:	dec00204 	addi	sp,sp,8
 4009620:	f800283a 	ret

04009624 <__seofread>:
 4009624:	0005883a 	mov	r2,zero
 4009628:	f800283a 	ret

0400962c <__swrite>:
 400962c:	2880030b 	ldhu	r2,12(r5)
 4009630:	defffb04 	addi	sp,sp,-20
 4009634:	dcc00315 	stw	r19,12(sp)
 4009638:	dc800215 	stw	r18,8(sp)
 400963c:	dc400115 	stw	r17,4(sp)
 4009640:	dc000015 	stw	r16,0(sp)
 4009644:	dfc00415 	stw	ra,16(sp)
 4009648:	10c0400c 	andi	r3,r2,256
 400964c:	2821883a 	mov	r16,r5
 4009650:	2023883a 	mov	r17,r4
 4009654:	3025883a 	mov	r18,r6
 4009658:	3827883a 	mov	r19,r7
 400965c:	18000d1e 	bne	r3,zero,4009694 <__swrite+0x68>
 4009660:	8140038f 	ldh	r5,14(r16)
 4009664:	10bbffcc 	andi	r2,r2,61439
 4009668:	980f883a 	mov	r7,r19
 400966c:	900d883a 	mov	r6,r18
 4009670:	8809883a 	mov	r4,r17
 4009674:	8080030d 	sth	r2,12(r16)
 4009678:	dfc00417 	ldw	ra,16(sp)
 400967c:	dcc00317 	ldw	r19,12(sp)
 4009680:	dc800217 	ldw	r18,8(sp)
 4009684:	dc400117 	ldw	r17,4(sp)
 4009688:	dc000017 	ldw	r16,0(sp)
 400968c:	dec00504 	addi	sp,sp,20
 4009690:	40097101 	jmpi	4009710 <_write_r>
 4009694:	2940038f 	ldh	r5,14(r5)
 4009698:	01c00084 	movi	r7,2
 400969c:	000d883a 	mov	r6,zero
 40096a0:	400a1380 	call	400a138 <_lseek_r>
 40096a4:	8080030b 	ldhu	r2,12(r16)
 40096a8:	003fed06 	br	4009660 <__swrite+0x34>

040096ac <__sseek>:
 40096ac:	defffe04 	addi	sp,sp,-8
 40096b0:	dc000015 	stw	r16,0(sp)
 40096b4:	2821883a 	mov	r16,r5
 40096b8:	2940038f 	ldh	r5,14(r5)
 40096bc:	dfc00115 	stw	ra,4(sp)
 40096c0:	400a1380 	call	400a138 <_lseek_r>
 40096c4:	10ffffd8 	cmpnei	r3,r2,-1
 40096c8:	18000826 	beq	r3,zero,40096ec <__sseek+0x40>
 40096cc:	80c0030b 	ldhu	r3,12(r16)
 40096d0:	80801415 	stw	r2,80(r16)
 40096d4:	18c40014 	ori	r3,r3,4096
 40096d8:	80c0030d 	sth	r3,12(r16)
 40096dc:	dfc00117 	ldw	ra,4(sp)
 40096e0:	dc000017 	ldw	r16,0(sp)
 40096e4:	dec00204 	addi	sp,sp,8
 40096e8:	f800283a 	ret
 40096ec:	80c0030b 	ldhu	r3,12(r16)
 40096f0:	18fbffcc 	andi	r3,r3,61439
 40096f4:	80c0030d 	sth	r3,12(r16)
 40096f8:	dfc00117 	ldw	ra,4(sp)
 40096fc:	dc000017 	ldw	r16,0(sp)
 4009700:	dec00204 	addi	sp,sp,8
 4009704:	f800283a 	ret

04009708 <__sclose>:
 4009708:	2940038f 	ldh	r5,14(r5)
 400970c:	40098c01 	jmpi	40098c0 <_close_r>

04009710 <_write_r>:
 4009710:	2807883a 	mov	r3,r5
 4009714:	defffe04 	addi	sp,sp,-8
 4009718:	dc000015 	stw	r16,0(sp)
 400971c:	300b883a 	mov	r5,r6
 4009720:	00810074 	movhi	r2,1025
 4009724:	380d883a 	mov	r6,r7
 4009728:	2021883a 	mov	r16,r4
 400972c:	1809883a 	mov	r4,r3
 4009730:	dfc00115 	stw	ra,4(sp)
 4009734:	10006d15 	stw	zero,436(r2)
 4009738:	400b0180 	call	400b018 <write>
 400973c:	10ffffd8 	cmpnei	r3,r2,-1
 4009740:	18000426 	beq	r3,zero,4009754 <_write_r+0x44>
 4009744:	dfc00117 	ldw	ra,4(sp)
 4009748:	dc000017 	ldw	r16,0(sp)
 400974c:	dec00204 	addi	sp,sp,8
 4009750:	f800283a 	ret
 4009754:	00c10074 	movhi	r3,1025
 4009758:	18c06d17 	ldw	r3,436(r3)
 400975c:	183ff926 	beq	r3,zero,4009744 <_write_r+0x34>
 4009760:	80c00015 	stw	r3,0(r16)
 4009764:	dfc00117 	ldw	ra,4(sp)
 4009768:	dc000017 	ldw	r16,0(sp)
 400976c:	dec00204 	addi	sp,sp,8
 4009770:	f800283a 	ret

04009774 <__swsetup_r>:
 4009774:	00810074 	movhi	r2,1025
 4009778:	10b9ae17 	ldw	r2,-6472(r2)
 400977c:	defffd04 	addi	sp,sp,-12
 4009780:	dc400115 	stw	r17,4(sp)
 4009784:	dc000015 	stw	r16,0(sp)
 4009788:	dfc00215 	stw	ra,8(sp)
 400978c:	2023883a 	mov	r17,r4
 4009790:	2821883a 	mov	r16,r5
 4009794:	10000226 	beq	r2,zero,40097a0 <__swsetup_r+0x2c>
 4009798:	10c00e17 	ldw	r3,56(r2)
 400979c:	18001d26 	beq	r3,zero,4009814 <__swsetup_r+0xa0>
 40097a0:	80c0030b 	ldhu	r3,12(r16)
 40097a4:	1880020c 	andi	r2,r3,8
 40097a8:	10001f26 	beq	r2,zero,4009828 <__swsetup_r+0xb4>
 40097ac:	80800417 	ldw	r2,16(r16)
 40097b0:	10002626 	beq	r2,zero,400984c <__swsetup_r+0xd8>
 40097b4:	1900004c 	andi	r4,r3,1
 40097b8:	20000b1e 	bne	r4,zero,40097e8 <__swsetup_r+0x74>
 40097bc:	1900008c 	andi	r4,r3,2
 40097c0:	20002b1e 	bne	r4,zero,4009870 <__swsetup_r+0xfc>
 40097c4:	81000517 	ldw	r4,20(r16)
 40097c8:	81000215 	stw	r4,8(r16)
 40097cc:	10000b26 	beq	r2,zero,40097fc <__swsetup_r+0x88>
 40097d0:	0005883a 	mov	r2,zero
 40097d4:	dfc00217 	ldw	ra,8(sp)
 40097d8:	dc400117 	ldw	r17,4(sp)
 40097dc:	dc000017 	ldw	r16,0(sp)
 40097e0:	dec00304 	addi	sp,sp,12
 40097e4:	f800283a 	ret
 40097e8:	81000517 	ldw	r4,20(r16)
 40097ec:	80000215 	stw	zero,8(r16)
 40097f0:	0109c83a 	sub	r4,zero,r4
 40097f4:	81000615 	stw	r4,24(r16)
 40097f8:	103ff51e 	bne	r2,zero,40097d0 <__swsetup_r+0x5c>
 40097fc:	1900200c 	andi	r4,r3,128
 4009800:	203ff426 	beq	r4,zero,40097d4 <__swsetup_r+0x60>
 4009804:	18c01014 	ori	r3,r3,64
 4009808:	80c0030d 	sth	r3,12(r16)
 400980c:	00bfffc4 	movi	r2,-1
 4009810:	003ff006 	br	40097d4 <__swsetup_r+0x60>
 4009814:	1009883a 	mov	r4,r2
 4009818:	4007f7c0 	call	4007f7c <__sinit>
 400981c:	80c0030b 	ldhu	r3,12(r16)
 4009820:	1880020c 	andi	r2,r3,8
 4009824:	103fe11e 	bne	r2,zero,40097ac <__swsetup_r+0x38>
 4009828:	1880040c 	andi	r2,r3,16
 400982c:	10002026 	beq	r2,zero,40098b0 <__swsetup_r+0x13c>
 4009830:	1880010c 	andi	r2,r3,4
 4009834:	1000101e 	bne	r2,zero,4009878 <__swsetup_r+0x104>
 4009838:	80800417 	ldw	r2,16(r16)
 400983c:	19000214 	ori	r4,r3,8
 4009840:	8100030d 	sth	r4,12(r16)
 4009844:	2007883a 	mov	r3,r4
 4009848:	103fda1e 	bne	r2,zero,40097b4 <__swsetup_r+0x40>
 400984c:	1900a00c 	andi	r4,r3,640
 4009850:	21008020 	cmpeqi	r4,r4,512
 4009854:	203fd71e 	bne	r4,zero,40097b4 <__swsetup_r+0x40>
 4009858:	800b883a 	mov	r5,r16
 400985c:	8809883a 	mov	r4,r17
 4009860:	400a19c0 	call	400a19c <__smakebuf_r>
 4009864:	80c0030b 	ldhu	r3,12(r16)
 4009868:	80800417 	ldw	r2,16(r16)
 400986c:	003fd106 	br	40097b4 <__swsetup_r+0x40>
 4009870:	0009883a 	mov	r4,zero
 4009874:	003fd406 	br	40097c8 <__swsetup_r+0x54>
 4009878:	81400c17 	ldw	r5,48(r16)
 400987c:	28000626 	beq	r5,zero,4009898 <__swsetup_r+0x124>
 4009880:	80801004 	addi	r2,r16,64
 4009884:	28800326 	beq	r5,r2,4009894 <__swsetup_r+0x120>
 4009888:	8809883a 	mov	r4,r17
 400988c:	4009e300 	call	4009e30 <_free_r>
 4009890:	80c0030b 	ldhu	r3,12(r16)
 4009894:	80000c15 	stw	zero,48(r16)
 4009898:	80800417 	ldw	r2,16(r16)
 400989c:	013ff6c4 	movi	r4,-37
 40098a0:	20c6703a 	and	r3,r4,r3
 40098a4:	80000115 	stw	zero,4(r16)
 40098a8:	80800015 	stw	r2,0(r16)
 40098ac:	003fe306 	br	400983c <__swsetup_r+0xc8>
 40098b0:	00800244 	movi	r2,9
 40098b4:	88800015 	stw	r2,0(r17)
 40098b8:	18c01014 	ori	r3,r3,64
 40098bc:	003fd206 	br	4009808 <__swsetup_r+0x94>

040098c0 <_close_r>:
 40098c0:	defffe04 	addi	sp,sp,-8
 40098c4:	dc000015 	stw	r16,0(sp)
 40098c8:	00810074 	movhi	r2,1025
 40098cc:	2021883a 	mov	r16,r4
 40098d0:	2809883a 	mov	r4,r5
 40098d4:	dfc00115 	stw	ra,4(sp)
 40098d8:	10006d15 	stw	zero,436(r2)
 40098dc:	400a5200 	call	400a520 <close>
 40098e0:	10ffffd8 	cmpnei	r3,r2,-1
 40098e4:	18000426 	beq	r3,zero,40098f8 <_close_r+0x38>
 40098e8:	dfc00117 	ldw	ra,4(sp)
 40098ec:	dc000017 	ldw	r16,0(sp)
 40098f0:	dec00204 	addi	sp,sp,8
 40098f4:	f800283a 	ret
 40098f8:	00c10074 	movhi	r3,1025
 40098fc:	18c06d17 	ldw	r3,436(r3)
 4009900:	183ff926 	beq	r3,zero,40098e8 <_close_r+0x28>
 4009904:	80c00015 	stw	r3,0(r16)
 4009908:	dfc00117 	ldw	ra,4(sp)
 400990c:	dc000017 	ldw	r16,0(sp)
 4009910:	dec00204 	addi	sp,sp,8
 4009914:	f800283a 	ret

04009918 <_fclose_r>:
 4009918:	defffc04 	addi	sp,sp,-16
 400991c:	dfc00315 	stw	ra,12(sp)
 4009920:	dc800215 	stw	r18,8(sp)
 4009924:	dc400115 	stw	r17,4(sp)
 4009928:	dc000015 	stw	r16,0(sp)
 400992c:	28000726 	beq	r5,zero,400994c <_fclose_r+0x34>
 4009930:	2821883a 	mov	r16,r5
 4009934:	2023883a 	mov	r17,r4
 4009938:	20000226 	beq	r4,zero,4009944 <_fclose_r+0x2c>
 400993c:	20800e17 	ldw	r2,56(r4)
 4009940:	10002726 	beq	r2,zero,40099e0 <_fclose_r+0xc8>
 4009944:	8080030f 	ldh	r2,12(r16)
 4009948:	1000081e 	bne	r2,zero,400996c <_fclose_r+0x54>
 400994c:	0025883a 	mov	r18,zero
 4009950:	9005883a 	mov	r2,r18
 4009954:	dfc00317 	ldw	ra,12(sp)
 4009958:	dc800217 	ldw	r18,8(sp)
 400995c:	dc400117 	ldw	r17,4(sp)
 4009960:	dc000017 	ldw	r16,0(sp)
 4009964:	dec00404 	addi	sp,sp,16
 4009968:	f800283a 	ret
 400996c:	800b883a 	mov	r5,r16
 4009970:	8809883a 	mov	r4,r17
 4009974:	4009a200 	call	4009a20 <__sflush_r>
 4009978:	80c00b17 	ldw	r3,44(r16)
 400997c:	1025883a 	mov	r18,r2
 4009980:	18000426 	beq	r3,zero,4009994 <_fclose_r+0x7c>
 4009984:	81400717 	ldw	r5,28(r16)
 4009988:	8809883a 	mov	r4,r17
 400998c:	183ee83a 	callr	r3
 4009990:	10001716 	blt	r2,zero,40099f0 <_fclose_r+0xd8>
 4009994:	8080030b 	ldhu	r2,12(r16)
 4009998:	1080200c 	andi	r2,r2,128
 400999c:	1000181e 	bne	r2,zero,4009a00 <_fclose_r+0xe8>
 40099a0:	81400c17 	ldw	r5,48(r16)
 40099a4:	28000526 	beq	r5,zero,40099bc <_fclose_r+0xa4>
 40099a8:	80801004 	addi	r2,r16,64
 40099ac:	28800226 	beq	r5,r2,40099b8 <_fclose_r+0xa0>
 40099b0:	8809883a 	mov	r4,r17
 40099b4:	4009e300 	call	4009e30 <_free_r>
 40099b8:	80000c15 	stw	zero,48(r16)
 40099bc:	81401117 	ldw	r5,68(r16)
 40099c0:	28000326 	beq	r5,zero,40099d0 <_fclose_r+0xb8>
 40099c4:	8809883a 	mov	r4,r17
 40099c8:	4009e300 	call	4009e30 <_free_r>
 40099cc:	80001115 	stw	zero,68(r16)
 40099d0:	4007f8c0 	call	4007f8c <__sfp_lock_acquire>
 40099d4:	8000030d 	sth	zero,12(r16)
 40099d8:	4007f900 	call	4007f90 <__sfp_lock_release>
 40099dc:	003fdc06 	br	4009950 <_fclose_r+0x38>
 40099e0:	4007f7c0 	call	4007f7c <__sinit>
 40099e4:	8080030f 	ldh	r2,12(r16)
 40099e8:	103fd826 	beq	r2,zero,400994c <_fclose_r+0x34>
 40099ec:	003fdf06 	br	400996c <_fclose_r+0x54>
 40099f0:	8080030b 	ldhu	r2,12(r16)
 40099f4:	04bfffc4 	movi	r18,-1
 40099f8:	1080200c 	andi	r2,r2,128
 40099fc:	103fe826 	beq	r2,zero,40099a0 <_fclose_r+0x88>
 4009a00:	81400417 	ldw	r5,16(r16)
 4009a04:	8809883a 	mov	r4,r17
 4009a08:	4009e300 	call	4009e30 <_free_r>
 4009a0c:	003fe406 	br	40099a0 <_fclose_r+0x88>

04009a10 <fclose>:
 4009a10:	00810074 	movhi	r2,1025
 4009a14:	200b883a 	mov	r5,r4
 4009a18:	1139ae17 	ldw	r4,-6472(r2)
 4009a1c:	40099181 	jmpi	4009918 <_fclose_r>

04009a20 <__sflush_r>:
 4009a20:	2880030b 	ldhu	r2,12(r5)
 4009a24:	defffb04 	addi	sp,sp,-20
 4009a28:	dcc00315 	stw	r19,12(sp)
 4009a2c:	dc000015 	stw	r16,0(sp)
 4009a30:	dfc00415 	stw	ra,16(sp)
 4009a34:	dc800215 	stw	r18,8(sp)
 4009a38:	dc400115 	stw	r17,4(sp)
 4009a3c:	10c0020c 	andi	r3,r2,8
 4009a40:	2821883a 	mov	r16,r5
 4009a44:	2027883a 	mov	r19,r4
 4009a48:	18003c1e 	bne	r3,zero,4009b3c <__sflush_r+0x11c>
 4009a4c:	29000117 	ldw	r4,4(r5)
 4009a50:	10c20014 	ori	r3,r2,2048
 4009a54:	28c0030d 	sth	r3,12(r5)
 4009a58:	0100580e 	bge	zero,r4,4009bbc <__sflush_r+0x19c>
 4009a5c:	82000a17 	ldw	r8,40(r16)
 4009a60:	40003426 	beq	r8,zero,4009b34 <__sflush_r+0x114>
 4009a64:	9c400017 	ldw	r17,0(r19)
 4009a68:	1084000c 	andi	r2,r2,4096
 4009a6c:	98000015 	stw	zero,0(r19)
 4009a70:	81400717 	ldw	r5,28(r16)
 4009a74:	1000561e 	bne	r2,zero,4009bd0 <__sflush_r+0x1b0>
 4009a78:	000d883a 	mov	r6,zero
 4009a7c:	01c00044 	movi	r7,1
 4009a80:	9809883a 	mov	r4,r19
 4009a84:	403ee83a 	callr	r8
 4009a88:	100d883a 	mov	r6,r2
 4009a8c:	10bfffd8 	cmpnei	r2,r2,-1
 4009a90:	10005b26 	beq	r2,zero,4009c00 <__sflush_r+0x1e0>
 4009a94:	80c0030b 	ldhu	r3,12(r16)
 4009a98:	82000a17 	ldw	r8,40(r16)
 4009a9c:	18c0010c 	andi	r3,r3,4
 4009aa0:	18000626 	beq	r3,zero,4009abc <__sflush_r+0x9c>
 4009aa4:	80c00117 	ldw	r3,4(r16)
 4009aa8:	80800c17 	ldw	r2,48(r16)
 4009aac:	30cdc83a 	sub	r6,r6,r3
 4009ab0:	10000226 	beq	r2,zero,4009abc <__sflush_r+0x9c>
 4009ab4:	80800f17 	ldw	r2,60(r16)
 4009ab8:	308dc83a 	sub	r6,r6,r2
 4009abc:	81400717 	ldw	r5,28(r16)
 4009ac0:	000f883a 	mov	r7,zero
 4009ac4:	9809883a 	mov	r4,r19
 4009ac8:	403ee83a 	callr	r8
 4009acc:	10ffffd8 	cmpnei	r3,r2,-1
 4009ad0:	1800411e 	bne	r3,zero,4009bd8 <__sflush_r+0x1b8>
 4009ad4:	99400017 	ldw	r5,0(r19)
 4009ad8:	28c007b0 	cmpltui	r3,r5,30
 4009adc:	18002c26 	beq	r3,zero,4009b90 <__sflush_r+0x170>
 4009ae0:	00f7f034 	movhi	r3,57280
 4009ae4:	18ffff84 	addi	r3,r3,-2
 4009ae8:	1949d83a 	sra	r4,r3,r5
 4009aec:	80c0030b 	ldhu	r3,12(r16)
 4009af0:	2100004c 	andi	r4,r4,1
 4009af4:	2000271e 	bne	r4,zero,4009b94 <__sflush_r+0x174>
 4009af8:	81000417 	ldw	r4,16(r16)
 4009afc:	19bdffcc 	andi	r6,r3,63487
 4009b00:	8180030d 	sth	r6,12(r16)
 4009b04:	80000115 	stw	zero,4(r16)
 4009b08:	81000015 	stw	r4,0(r16)
 4009b0c:	18c4000c 	andi	r3,r3,4096
 4009b10:	1800431e 	bne	r3,zero,4009c20 <__sflush_r+0x200>
 4009b14:	81400c17 	ldw	r5,48(r16)
 4009b18:	9c400015 	stw	r17,0(r19)
 4009b1c:	28000526 	beq	r5,zero,4009b34 <__sflush_r+0x114>
 4009b20:	80801004 	addi	r2,r16,64
 4009b24:	28800226 	beq	r5,r2,4009b30 <__sflush_r+0x110>
 4009b28:	9809883a 	mov	r4,r19
 4009b2c:	4009e300 	call	4009e30 <_free_r>
 4009b30:	80000c15 	stw	zero,48(r16)
 4009b34:	0005883a 	mov	r2,zero
 4009b38:	00001906 	br	4009ba0 <__sflush_r+0x180>
 4009b3c:	2c800417 	ldw	r18,16(r5)
 4009b40:	903ffc26 	beq	r18,zero,4009b34 <__sflush_r+0x114>
 4009b44:	2c400017 	ldw	r17,0(r5)
 4009b48:	108000cc 	andi	r2,r2,3
 4009b4c:	2c800015 	stw	r18,0(r5)
 4009b50:	8ca3c83a 	sub	r17,r17,r18
 4009b54:	10001c1e 	bne	r2,zero,4009bc8 <__sflush_r+0x1a8>
 4009b58:	28800517 	ldw	r2,20(r5)
 4009b5c:	80800215 	stw	r2,8(r16)
 4009b60:	04400316 	blt	zero,r17,4009b70 <__sflush_r+0x150>
 4009b64:	003ff306 	br	4009b34 <__sflush_r+0x114>
 4009b68:	90a5883a 	add	r18,r18,r2
 4009b6c:	047ff10e 	bge	zero,r17,4009b34 <__sflush_r+0x114>
 4009b70:	80800917 	ldw	r2,36(r16)
 4009b74:	81400717 	ldw	r5,28(r16)
 4009b78:	880f883a 	mov	r7,r17
 4009b7c:	900d883a 	mov	r6,r18
 4009b80:	9809883a 	mov	r4,r19
 4009b84:	103ee83a 	callr	r2
 4009b88:	88a3c83a 	sub	r17,r17,r2
 4009b8c:	00bff616 	blt	zero,r2,4009b68 <__sflush_r+0x148>
 4009b90:	80c0030b 	ldhu	r3,12(r16)
 4009b94:	18c01014 	ori	r3,r3,64
 4009b98:	80c0030d 	sth	r3,12(r16)
 4009b9c:	00bfffc4 	movi	r2,-1
 4009ba0:	dfc00417 	ldw	ra,16(sp)
 4009ba4:	dcc00317 	ldw	r19,12(sp)
 4009ba8:	dc800217 	ldw	r18,8(sp)
 4009bac:	dc400117 	ldw	r17,4(sp)
 4009bb0:	dc000017 	ldw	r16,0(sp)
 4009bb4:	dec00504 	addi	sp,sp,20
 4009bb8:	f800283a 	ret
 4009bbc:	29000f17 	ldw	r4,60(r5)
 4009bc0:	013fa616 	blt	zero,r4,4009a5c <__sflush_r+0x3c>
 4009bc4:	003fdb06 	br	4009b34 <__sflush_r+0x114>
 4009bc8:	0005883a 	mov	r2,zero
 4009bcc:	003fe306 	br	4009b5c <__sflush_r+0x13c>
 4009bd0:	81801417 	ldw	r6,80(r16)
 4009bd4:	003fb106 	br	4009a9c <__sflush_r+0x7c>
 4009bd8:	80c0030b 	ldhu	r3,12(r16)
 4009bdc:	81000417 	ldw	r4,16(r16)
 4009be0:	80000115 	stw	zero,4(r16)
 4009be4:	197dffcc 	andi	r5,r3,63487
 4009be8:	8140030d 	sth	r5,12(r16)
 4009bec:	81000015 	stw	r4,0(r16)
 4009bf0:	18c4000c 	andi	r3,r3,4096
 4009bf4:	183fc726 	beq	r3,zero,4009b14 <__sflush_r+0xf4>
 4009bf8:	80801415 	stw	r2,80(r16)
 4009bfc:	003fc506 	br	4009b14 <__sflush_r+0xf4>
 4009c00:	98800017 	ldw	r2,0(r19)
 4009c04:	103fa326 	beq	r2,zero,4009a94 <__sflush_r+0x74>
 4009c08:	10c00760 	cmpeqi	r3,r2,29
 4009c0c:	1800021e 	bne	r3,zero,4009c18 <__sflush_r+0x1f8>
 4009c10:	10800598 	cmpnei	r2,r2,22
 4009c14:	103fde1e 	bne	r2,zero,4009b90 <__sflush_r+0x170>
 4009c18:	9c400015 	stw	r17,0(r19)
 4009c1c:	003fc506 	br	4009b34 <__sflush_r+0x114>
 4009c20:	283fbc1e 	bne	r5,zero,4009b14 <__sflush_r+0xf4>
 4009c24:	003ff406 	br	4009bf8 <__sflush_r+0x1d8>

04009c28 <_fflush_r>:
 4009c28:	defffd04 	addi	sp,sp,-12
 4009c2c:	dc000115 	stw	r16,4(sp)
 4009c30:	dfc00215 	stw	ra,8(sp)
 4009c34:	2021883a 	mov	r16,r4
 4009c38:	20000226 	beq	r4,zero,4009c44 <_fflush_r+0x1c>
 4009c3c:	20800e17 	ldw	r2,56(r4)
 4009c40:	10000726 	beq	r2,zero,4009c60 <_fflush_r+0x38>
 4009c44:	2880030f 	ldh	r2,12(r5)
 4009c48:	10000a1e 	bne	r2,zero,4009c74 <_fflush_r+0x4c>
 4009c4c:	0005883a 	mov	r2,zero
 4009c50:	dfc00217 	ldw	ra,8(sp)
 4009c54:	dc000117 	ldw	r16,4(sp)
 4009c58:	dec00304 	addi	sp,sp,12
 4009c5c:	f800283a 	ret
 4009c60:	d9400015 	stw	r5,0(sp)
 4009c64:	4007f7c0 	call	4007f7c <__sinit>
 4009c68:	d9400017 	ldw	r5,0(sp)
 4009c6c:	2880030f 	ldh	r2,12(r5)
 4009c70:	103ff626 	beq	r2,zero,4009c4c <_fflush_r+0x24>
 4009c74:	8009883a 	mov	r4,r16
 4009c78:	dfc00217 	ldw	ra,8(sp)
 4009c7c:	dc000117 	ldw	r16,4(sp)
 4009c80:	dec00304 	addi	sp,sp,12
 4009c84:	4009a201 	jmpi	4009a20 <__sflush_r>

04009c88 <fflush>:
 4009c88:	20001726 	beq	r4,zero,4009ce8 <fflush+0x60>
 4009c8c:	00810074 	movhi	r2,1025
 4009c90:	200b883a 	mov	r5,r4
 4009c94:	1139ae17 	ldw	r4,-6472(r2)
 4009c98:	20000226 	beq	r4,zero,4009ca4 <fflush+0x1c>
 4009c9c:	20800e17 	ldw	r2,56(r4)
 4009ca0:	10000526 	beq	r2,zero,4009cb8 <fflush+0x30>
 4009ca4:	2880030f 	ldh	r2,12(r5)
 4009ca8:	1000021e 	bne	r2,zero,4009cb4 <fflush+0x2c>
 4009cac:	0005883a 	mov	r2,zero
 4009cb0:	f800283a 	ret
 4009cb4:	4009a201 	jmpi	4009a20 <__sflush_r>
 4009cb8:	defffd04 	addi	sp,sp,-12
 4009cbc:	d9400115 	stw	r5,4(sp)
 4009cc0:	d9000015 	stw	r4,0(sp)
 4009cc4:	dfc00215 	stw	ra,8(sp)
 4009cc8:	4007f7c0 	call	4007f7c <__sinit>
 4009ccc:	d9400117 	ldw	r5,4(sp)
 4009cd0:	d9000017 	ldw	r4,0(sp)
 4009cd4:	2880030f 	ldh	r2,12(r5)
 4009cd8:	10000826 	beq	r2,zero,4009cfc <fflush+0x74>
 4009cdc:	dfc00217 	ldw	ra,8(sp)
 4009ce0:	dec00304 	addi	sp,sp,12
 4009ce4:	4009a201 	jmpi	4009a20 <__sflush_r>
 4009ce8:	00810074 	movhi	r2,1025
 4009cec:	1139ad17 	ldw	r4,-6476(r2)
 4009cf0:	01410074 	movhi	r5,1025
 4009cf4:	29670a04 	addi	r5,r5,-25560
 4009cf8:	40085041 	jmpi	4008504 <_fwalk_reent>
 4009cfc:	0005883a 	mov	r2,zero
 4009d00:	dfc00217 	ldw	ra,8(sp)
 4009d04:	dec00304 	addi	sp,sp,12
 4009d08:	f800283a 	ret

04009d0c <_malloc_trim_r>:
 4009d0c:	defffa04 	addi	sp,sp,-24
 4009d10:	dcc00315 	stw	r19,12(sp)
 4009d14:	04c10074 	movhi	r19,1025
 4009d18:	dd000415 	stw	r20,16(sp)
 4009d1c:	dc800215 	stw	r18,8(sp)
 4009d20:	dc400115 	stw	r17,4(sp)
 4009d24:	dc000015 	stw	r16,0(sp)
 4009d28:	2829883a 	mov	r20,r5
 4009d2c:	dfc00515 	stw	ra,20(sp)
 4009d30:	9cf42804 	addi	r19,r19,-12128
 4009d34:	2025883a 	mov	r18,r4
 4009d38:	400ad280 	call	400ad28 <__malloc_lock>
 4009d3c:	98800217 	ldw	r2,8(r19)
 4009d40:	14400117 	ldw	r17,4(r2)
 4009d44:	00bfff04 	movi	r2,-4
 4009d48:	88a2703a 	and	r17,r17,r2
 4009d4c:	8c03fbc4 	addi	r16,r17,4079
 4009d50:	8521c83a 	sub	r16,r16,r20
 4009d54:	8020d33a 	srli	r16,r16,12
 4009d58:	843fffc4 	addi	r16,r16,-1
 4009d5c:	8020933a 	slli	r16,r16,12
 4009d60:	80840008 	cmpgei	r2,r16,4096
 4009d64:	10000626 	beq	r2,zero,4009d80 <_malloc_trim_r+0x74>
 4009d68:	000b883a 	mov	r5,zero
 4009d6c:	9009883a 	mov	r4,r18
 4009d70:	40095780 	call	4009578 <_sbrk_r>
 4009d74:	98c00217 	ldw	r3,8(r19)
 4009d78:	1c47883a 	add	r3,r3,r17
 4009d7c:	10c00b26 	beq	r2,r3,4009dac <_malloc_trim_r+0xa0>
 4009d80:	9009883a 	mov	r4,r18
 4009d84:	400ad4c0 	call	400ad4c <__malloc_unlock>
 4009d88:	0005883a 	mov	r2,zero
 4009d8c:	dfc00517 	ldw	ra,20(sp)
 4009d90:	dd000417 	ldw	r20,16(sp)
 4009d94:	dcc00317 	ldw	r19,12(sp)
 4009d98:	dc800217 	ldw	r18,8(sp)
 4009d9c:	dc400117 	ldw	r17,4(sp)
 4009da0:	dc000017 	ldw	r16,0(sp)
 4009da4:	dec00604 	addi	sp,sp,24
 4009da8:	f800283a 	ret
 4009dac:	040bc83a 	sub	r5,zero,r16
 4009db0:	9009883a 	mov	r4,r18
 4009db4:	40095780 	call	4009578 <_sbrk_r>
 4009db8:	10bfffd8 	cmpnei	r2,r2,-1
 4009dbc:	10000d26 	beq	r2,zero,4009df4 <_malloc_trim_r+0xe8>
 4009dc0:	00812074 	movhi	r2,1153
 4009dc4:	1080a817 	ldw	r2,672(r2)
 4009dc8:	98c00217 	ldw	r3,8(r19)
 4009dcc:	8c23c83a 	sub	r17,r17,r16
 4009dd0:	8c400054 	ori	r17,r17,1
 4009dd4:	1405c83a 	sub	r2,r2,r16
 4009dd8:	1c400115 	stw	r17,4(r3)
 4009ddc:	9009883a 	mov	r4,r18
 4009de0:	00c12074 	movhi	r3,1153
 4009de4:	1880a815 	stw	r2,672(r3)
 4009de8:	400ad4c0 	call	400ad4c <__malloc_unlock>
 4009dec:	00800044 	movi	r2,1
 4009df0:	003fe606 	br	4009d8c <_malloc_trim_r+0x80>
 4009df4:	000b883a 	mov	r5,zero
 4009df8:	9009883a 	mov	r4,r18
 4009dfc:	40095780 	call	4009578 <_sbrk_r>
 4009e00:	99000217 	ldw	r4,8(r19)
 4009e04:	1107c83a 	sub	r3,r2,r4
 4009e08:	19400410 	cmplti	r5,r3,16
 4009e0c:	283fdc1e 	bne	r5,zero,4009d80 <_malloc_trim_r+0x74>
 4009e10:	01410074 	movhi	r5,1025
 4009e14:	2979af17 	ldw	r5,-6468(r5)
 4009e18:	18c00054 	ori	r3,r3,1
 4009e1c:	20c00115 	stw	r3,4(r4)
 4009e20:	1145c83a 	sub	r2,r2,r5
 4009e24:	01412074 	movhi	r5,1153
 4009e28:	2880a815 	stw	r2,672(r5)
 4009e2c:	003fd406 	br	4009d80 <_malloc_trim_r+0x74>

04009e30 <_free_r>:
 4009e30:	28005f26 	beq	r5,zero,4009fb0 <_free_r+0x180>
 4009e34:	defffd04 	addi	sp,sp,-12
 4009e38:	dc400115 	stw	r17,4(sp)
 4009e3c:	dc000015 	stw	r16,0(sp)
 4009e40:	2023883a 	mov	r17,r4
 4009e44:	2821883a 	mov	r16,r5
 4009e48:	dfc00215 	stw	ra,8(sp)
 4009e4c:	400ad280 	call	400ad28 <__malloc_lock>
 4009e50:	81ffff17 	ldw	r7,-4(r16)
 4009e54:	00bfff84 	movi	r2,-2
 4009e58:	80fffe04 	addi	r3,r16,-8
 4009e5c:	3884703a 	and	r2,r7,r2
 4009e60:	01810074 	movhi	r6,1025
 4009e64:	1889883a 	add	r4,r3,r2
 4009e68:	31b42804 	addi	r6,r6,-12128
 4009e6c:	21400117 	ldw	r5,4(r4)
 4009e70:	32000217 	ldw	r8,8(r6)
 4009e74:	027fff04 	movi	r9,-4
 4009e78:	2a4a703a 	and	r5,r5,r9
 4009e7c:	41006526 	beq	r8,r4,400a014 <_free_r+0x1e4>
 4009e80:	21400115 	stw	r5,4(r4)
 4009e84:	39c0004c 	andi	r7,r7,1
 4009e88:	2151883a 	add	r8,r4,r5
 4009e8c:	3800281e 	bne	r7,zero,4009f30 <_free_r+0x100>
 4009e90:	82bffe17 	ldw	r10,-8(r16)
 4009e94:	42000117 	ldw	r8,4(r8)
 4009e98:	01c10074 	movhi	r7,1025
 4009e9c:	1a87c83a 	sub	r3,r3,r10
 4009ea0:	1a400217 	ldw	r9,8(r3)
 4009ea4:	39f42a04 	addi	r7,r7,-12120
 4009ea8:	1285883a 	add	r2,r2,r10
 4009eac:	4200004c 	andi	r8,r8,1
 4009eb0:	49c04d26 	beq	r9,r7,4009fe8 <_free_r+0x1b8>
 4009eb4:	1a800317 	ldw	r10,12(r3)
 4009eb8:	4a800315 	stw	r10,12(r9)
 4009ebc:	52400215 	stw	r9,8(r10)
 4009ec0:	40006926 	beq	r8,zero,400a068 <_free_r+0x238>
 4009ec4:	11400054 	ori	r5,r2,1
 4009ec8:	19400115 	stw	r5,4(r3)
 4009ecc:	20800015 	stw	r2,0(r4)
 4009ed0:	11008028 	cmpgeui	r4,r2,512
 4009ed4:	20001e1e 	bne	r4,zero,4009f50 <_free_r+0x120>
 4009ed8:	1008d0fa 	srli	r4,r2,3
 4009edc:	100ad17a 	srli	r5,r2,5
 4009ee0:	31c00117 	ldw	r7,4(r6)
 4009ee4:	20800044 	addi	r2,r4,1
 4009ee8:	100490fa 	slli	r2,r2,3
 4009eec:	01000044 	movi	r4,1
 4009ef0:	2148983a 	sll	r4,r4,r5
 4009ef4:	3085883a 	add	r2,r6,r2
 4009ef8:	11400017 	ldw	r5,0(r2)
 4009efc:	21c8b03a 	or	r4,r4,r7
 4009f00:	11fffe04 	addi	r7,r2,-8
 4009f04:	19c00315 	stw	r7,12(r3)
 4009f08:	19400215 	stw	r5,8(r3)
 4009f0c:	31000115 	stw	r4,4(r6)
 4009f10:	10c00015 	stw	r3,0(r2)
 4009f14:	28c00315 	stw	r3,12(r5)
 4009f18:	8809883a 	mov	r4,r17
 4009f1c:	dfc00217 	ldw	ra,8(sp)
 4009f20:	dc400117 	ldw	r17,4(sp)
 4009f24:	dc000017 	ldw	r16,0(sp)
 4009f28:	dec00304 	addi	sp,sp,12
 4009f2c:	400ad4c1 	jmpi	400ad4c <__malloc_unlock>
 4009f30:	41c00117 	ldw	r7,4(r8)
 4009f34:	39c0004c 	andi	r7,r7,1
 4009f38:	38001e26 	beq	r7,zero,4009fb4 <_free_r+0x184>
 4009f3c:	11400054 	ori	r5,r2,1
 4009f40:	817fff15 	stw	r5,-4(r16)
 4009f44:	20800015 	stw	r2,0(r4)
 4009f48:	11008028 	cmpgeui	r4,r2,512
 4009f4c:	203fe226 	beq	r4,zero,4009ed8 <_free_r+0xa8>
 4009f50:	1008d27a 	srli	r4,r2,9
 4009f54:	21400168 	cmpgeui	r5,r4,5
 4009f58:	2800451e 	bne	r5,zero,400a070 <_free_r+0x240>
 4009f5c:	1008d1ba 	srli	r4,r2,6
 4009f60:	21c00e44 	addi	r7,r4,57
 4009f64:	380e90fa 	slli	r7,r7,3
 4009f68:	21000e04 	addi	r4,r4,56
 4009f6c:	31cf883a 	add	r7,r6,r7
 4009f70:	39400017 	ldw	r5,0(r7)
 4009f74:	39fffe04 	addi	r7,r7,-8
 4009f78:	39405326 	beq	r7,r5,400a0c8 <_free_r+0x298>
 4009f7c:	01bfff04 	movi	r6,-4
 4009f80:	00000206 	br	4009f8c <_free_r+0x15c>
 4009f84:	29400217 	ldw	r5,8(r5)
 4009f88:	39400326 	beq	r7,r5,4009f98 <_free_r+0x168>
 4009f8c:	29000117 	ldw	r4,4(r5)
 4009f90:	2188703a 	and	r4,r4,r6
 4009f94:	113ffb36 	bltu	r2,r4,4009f84 <_free_r+0x154>
 4009f98:	29c00317 	ldw	r7,12(r5)
 4009f9c:	19c00315 	stw	r7,12(r3)
 4009fa0:	19400215 	stw	r5,8(r3)
 4009fa4:	38c00215 	stw	r3,8(r7)
 4009fa8:	28c00315 	stw	r3,12(r5)
 4009fac:	003fda06 	br	4009f18 <_free_r+0xe8>
 4009fb0:	f800283a 	ret
 4009fb4:	01c10074 	movhi	r7,1025
 4009fb8:	1145883a 	add	r2,r2,r5
 4009fbc:	39f42a04 	addi	r7,r7,-12120
 4009fc0:	21400217 	ldw	r5,8(r4)
 4009fc4:	29c03726 	beq	r5,r7,400a0a4 <_free_r+0x274>
 4009fc8:	22000317 	ldw	r8,12(r4)
 4009fcc:	11c00054 	ori	r7,r2,1
 4009fd0:	1889883a 	add	r4,r3,r2
 4009fd4:	2a000315 	stw	r8,12(r5)
 4009fd8:	41400215 	stw	r5,8(r8)
 4009fdc:	19c00115 	stw	r7,4(r3)
 4009fe0:	20800015 	stw	r2,0(r4)
 4009fe4:	003fba06 	br	4009ed0 <_free_r+0xa0>
 4009fe8:	40004f1e 	bne	r8,zero,400a128 <_free_r+0x2f8>
 4009fec:	21800217 	ldw	r6,8(r4)
 4009ff0:	21000317 	ldw	r4,12(r4)
 4009ff4:	288b883a 	add	r5,r5,r2
 4009ff8:	28800054 	ori	r2,r5,1
 4009ffc:	31000315 	stw	r4,12(r6)
 400a000:	21800215 	stw	r6,8(r4)
 400a004:	18800115 	stw	r2,4(r3)
 400a008:	1947883a 	add	r3,r3,r5
 400a00c:	19400015 	stw	r5,0(r3)
 400a010:	003fc106 	br	4009f18 <_free_r+0xe8>
 400a014:	39c0004c 	andi	r7,r7,1
 400a018:	114b883a 	add	r5,r2,r5
 400a01c:	3800071e 	bne	r7,zero,400a03c <_free_r+0x20c>
 400a020:	81fffe17 	ldw	r7,-8(r16)
 400a024:	19c7c83a 	sub	r3,r3,r7
 400a028:	18800317 	ldw	r2,12(r3)
 400a02c:	19000217 	ldw	r4,8(r3)
 400a030:	29cb883a 	add	r5,r5,r7
 400a034:	20800315 	stw	r2,12(r4)
 400a038:	11000215 	stw	r4,8(r2)
 400a03c:	00810074 	movhi	r2,1025
 400a040:	29000054 	ori	r4,r5,1
 400a044:	10b9b017 	ldw	r2,-6464(r2)
 400a048:	19000115 	stw	r4,4(r3)
 400a04c:	30c00215 	stw	r3,8(r6)
 400a050:	28bfb136 	bltu	r5,r2,4009f18 <_free_r+0xe8>
 400a054:	00810074 	movhi	r2,1025
 400a058:	11406c17 	ldw	r5,432(r2)
 400a05c:	8809883a 	mov	r4,r17
 400a060:	4009d0c0 	call	4009d0c <_malloc_trim_r>
 400a064:	003fac06 	br	4009f18 <_free_r+0xe8>
 400a068:	1145883a 	add	r2,r2,r5
 400a06c:	003fd406 	br	4009fc0 <_free_r+0x190>
 400a070:	21400568 	cmpgeui	r5,r4,21
 400a074:	28000726 	beq	r5,zero,400a094 <_free_r+0x264>
 400a078:	21401568 	cmpgeui	r5,r4,85
 400a07c:	2800191e 	bne	r5,zero,400a0e4 <_free_r+0x2b4>
 400a080:	1008d33a 	srli	r4,r2,12
 400a084:	21c01bc4 	addi	r7,r4,111
 400a088:	380e90fa 	slli	r7,r7,3
 400a08c:	21001b84 	addi	r4,r4,110
 400a090:	003fb606 	br	4009f6c <_free_r+0x13c>
 400a094:	21c01704 	addi	r7,r4,92
 400a098:	380e90fa 	slli	r7,r7,3
 400a09c:	210016c4 	addi	r4,r4,91
 400a0a0:	003fb206 	br	4009f6c <_free_r+0x13c>
 400a0a4:	30c00515 	stw	r3,20(r6)
 400a0a8:	30c00415 	stw	r3,16(r6)
 400a0ac:	11000054 	ori	r4,r2,1
 400a0b0:	19c00315 	stw	r7,12(r3)
 400a0b4:	19c00215 	stw	r7,8(r3)
 400a0b8:	19000115 	stw	r4,4(r3)
 400a0bc:	1887883a 	add	r3,r3,r2
 400a0c0:	18800015 	stw	r2,0(r3)
 400a0c4:	003f9406 	br	4009f18 <_free_r+0xe8>
 400a0c8:	2009d0ba 	srai	r4,r4,2
 400a0cc:	00800044 	movi	r2,1
 400a0d0:	32000117 	ldw	r8,4(r6)
 400a0d4:	1104983a 	sll	r2,r2,r4
 400a0d8:	1204b03a 	or	r2,r2,r8
 400a0dc:	30800115 	stw	r2,4(r6)
 400a0e0:	003fae06 	br	4009f9c <_free_r+0x16c>
 400a0e4:	21405568 	cmpgeui	r5,r4,341
 400a0e8:	2800051e 	bne	r5,zero,400a100 <_free_r+0x2d0>
 400a0ec:	1008d3fa 	srli	r4,r2,15
 400a0f0:	21c01e04 	addi	r7,r4,120
 400a0f4:	380e90fa 	slli	r7,r7,3
 400a0f8:	21001dc4 	addi	r4,r4,119
 400a0fc:	003f9b06 	br	4009f6c <_free_r+0x13c>
 400a100:	21015568 	cmpgeui	r4,r4,1365
 400a104:	2000051e 	bne	r4,zero,400a11c <_free_r+0x2ec>
 400a108:	1008d4ba 	srli	r4,r2,18
 400a10c:	21c01f44 	addi	r7,r4,125
 400a110:	380e90fa 	slli	r7,r7,3
 400a114:	21001f04 	addi	r4,r4,124
 400a118:	003f9406 	br	4009f6c <_free_r+0x13c>
 400a11c:	01c0fe04 	movi	r7,1016
 400a120:	01001f84 	movi	r4,126
 400a124:	003f9106 	br	4009f6c <_free_r+0x13c>
 400a128:	11400054 	ori	r5,r2,1
 400a12c:	19400115 	stw	r5,4(r3)
 400a130:	20800015 	stw	r2,0(r4)
 400a134:	003f7806 	br	4009f18 <_free_r+0xe8>

0400a138 <_lseek_r>:
 400a138:	2807883a 	mov	r3,r5
 400a13c:	defffe04 	addi	sp,sp,-8
 400a140:	dc000015 	stw	r16,0(sp)
 400a144:	300b883a 	mov	r5,r6
 400a148:	00810074 	movhi	r2,1025
 400a14c:	380d883a 	mov	r6,r7
 400a150:	2021883a 	mov	r16,r4
 400a154:	1809883a 	mov	r4,r3
 400a158:	dfc00115 	stw	ra,4(sp)
 400a15c:	10006d15 	stw	zero,436(r2)
 400a160:	400abcc0 	call	400abcc <lseek>
 400a164:	10ffffd8 	cmpnei	r3,r2,-1
 400a168:	18000426 	beq	r3,zero,400a17c <_lseek_r+0x44>
 400a16c:	dfc00117 	ldw	ra,4(sp)
 400a170:	dc000017 	ldw	r16,0(sp)
 400a174:	dec00204 	addi	sp,sp,8
 400a178:	f800283a 	ret
 400a17c:	00c10074 	movhi	r3,1025
 400a180:	18c06d17 	ldw	r3,436(r3)
 400a184:	183ff926 	beq	r3,zero,400a16c <_lseek_r+0x34>
 400a188:	80c00015 	stw	r3,0(r16)
 400a18c:	dfc00117 	ldw	ra,4(sp)
 400a190:	dc000017 	ldw	r16,0(sp)
 400a194:	dec00204 	addi	sp,sp,8
 400a198:	f800283a 	ret

0400a19c <__smakebuf_r>:
 400a19c:	2880030b 	ldhu	r2,12(r5)
 400a1a0:	deffe804 	addi	sp,sp,-96
 400a1a4:	dc001215 	stw	r16,72(sp)
 400a1a8:	dfc01715 	stw	ra,92(sp)
 400a1ac:	dd001615 	stw	r20,88(sp)
 400a1b0:	dcc01515 	stw	r19,84(sp)
 400a1b4:	dc801415 	stw	r18,80(sp)
 400a1b8:	dc401315 	stw	r17,76(sp)
 400a1bc:	10c0008c 	andi	r3,r2,2
 400a1c0:	2821883a 	mov	r16,r5
 400a1c4:	18000d26 	beq	r3,zero,400a1fc <__smakebuf_r+0x60>
 400a1c8:	288010c4 	addi	r2,r5,67
 400a1cc:	28800015 	stw	r2,0(r5)
 400a1d0:	28800415 	stw	r2,16(r5)
 400a1d4:	00800044 	movi	r2,1
 400a1d8:	28800515 	stw	r2,20(r5)
 400a1dc:	dfc01717 	ldw	ra,92(sp)
 400a1e0:	dd001617 	ldw	r20,88(sp)
 400a1e4:	dcc01517 	ldw	r19,84(sp)
 400a1e8:	dc801417 	ldw	r18,80(sp)
 400a1ec:	dc401317 	ldw	r17,76(sp)
 400a1f0:	dc001217 	ldw	r16,72(sp)
 400a1f4:	dec01804 	addi	sp,sp,96
 400a1f8:	f800283a 	ret
 400a1fc:	2940038f 	ldh	r5,14(r5)
 400a200:	2023883a 	mov	r17,r4
 400a204:	28002816 	blt	r5,zero,400a2a8 <__smakebuf_r+0x10c>
 400a208:	d80d883a 	mov	r6,sp
 400a20c:	400a42c0 	call	400a42c <_fstat_r>
 400a210:	10002416 	blt	r2,zero,400a2a4 <__smakebuf_r+0x108>
 400a214:	d8800117 	ldw	r2,4(sp)
 400a218:	10bc000c 	andi	r2,r2,61440
 400a21c:	10880018 	cmpnei	r2,r2,8192
 400a220:	1000421e 	bne	r2,zero,400a32c <__smakebuf_r+0x190>
 400a224:	8140038f 	ldh	r5,14(r16)
 400a228:	8809883a 	mov	r4,r17
 400a22c:	400a48c0 	call	400a48c <_isatty_r>
 400a230:	10000826 	beq	r2,zero,400a254 <__smakebuf_r+0xb8>
 400a234:	8080030b 	ldhu	r2,12(r16)
 400a238:	80c010c4 	addi	r3,r16,67
 400a23c:	80c00015 	stw	r3,0(r16)
 400a240:	10800054 	ori	r2,r2,1
 400a244:	8080030d 	sth	r2,12(r16)
 400a248:	00800044 	movi	r2,1
 400a24c:	80c00415 	stw	r3,16(r16)
 400a250:	80800515 	stw	r2,20(r16)
 400a254:	04c00044 	movi	r19,1
 400a258:	05010004 	movi	r20,1024
 400a25c:	04820004 	movi	r18,2048
 400a260:	a00b883a 	mov	r5,r20
 400a264:	8809883a 	mov	r4,r17
 400a268:	40085ac0 	call	40085ac <_malloc_r>
 400a26c:	10001726 	beq	r2,zero,400a2cc <__smakebuf_r+0x130>
 400a270:	80c0030b 	ldhu	r3,12(r16)
 400a274:	01010034 	movhi	r4,1024
 400a278:	211f1004 	addi	r4,r4,31808
 400a27c:	89000f15 	stw	r4,60(r17)
 400a280:	18c02014 	ori	r3,r3,128
 400a284:	80c0030d 	sth	r3,12(r16)
 400a288:	80800015 	stw	r2,0(r16)
 400a28c:	80800415 	stw	r2,16(r16)
 400a290:	85000515 	stw	r20,20(r16)
 400a294:	98001d1e 	bne	r19,zero,400a30c <__smakebuf_r+0x170>
 400a298:	90e4b03a 	or	r18,r18,r3
 400a29c:	8480030d 	sth	r18,12(r16)
 400a2a0:	003fce06 	br	400a1dc <__smakebuf_r+0x40>
 400a2a4:	8080030b 	ldhu	r2,12(r16)
 400a2a8:	1080200c 	andi	r2,r2,128
 400a2ac:	0027883a 	mov	r19,zero
 400a2b0:	10001326 	beq	r2,zero,400a300 <__smakebuf_r+0x164>
 400a2b4:	05001004 	movi	r20,64
 400a2b8:	a00b883a 	mov	r5,r20
 400a2bc:	8809883a 	mov	r4,r17
 400a2c0:	0025883a 	mov	r18,zero
 400a2c4:	40085ac0 	call	40085ac <_malloc_r>
 400a2c8:	103fe91e 	bne	r2,zero,400a270 <__smakebuf_r+0xd4>
 400a2cc:	8080030b 	ldhu	r2,12(r16)
 400a2d0:	10c0800c 	andi	r3,r2,512
 400a2d4:	183fc11e 	bne	r3,zero,400a1dc <__smakebuf_r+0x40>
 400a2d8:	00ffff04 	movi	r3,-4
 400a2dc:	10c4703a 	and	r2,r2,r3
 400a2e0:	10800094 	ori	r2,r2,2
 400a2e4:	80c010c4 	addi	r3,r16,67
 400a2e8:	8080030d 	sth	r2,12(r16)
 400a2ec:	00800044 	movi	r2,1
 400a2f0:	80c00015 	stw	r3,0(r16)
 400a2f4:	80c00415 	stw	r3,16(r16)
 400a2f8:	80800515 	stw	r2,20(r16)
 400a2fc:	003fb706 	br	400a1dc <__smakebuf_r+0x40>
 400a300:	05010004 	movi	r20,1024
 400a304:	0025883a 	mov	r18,zero
 400a308:	003fd506 	br	400a260 <__smakebuf_r+0xc4>
 400a30c:	8140038f 	ldh	r5,14(r16)
 400a310:	8809883a 	mov	r4,r17
 400a314:	400a48c0 	call	400a48c <_isatty_r>
 400a318:	80c0030b 	ldhu	r3,12(r16)
 400a31c:	103fde26 	beq	r2,zero,400a298 <__smakebuf_r+0xfc>
 400a320:	18ffff0c 	andi	r3,r3,65532
 400a324:	18c00054 	ori	r3,r3,1
 400a328:	003fdb06 	br	400a298 <__smakebuf_r+0xfc>
 400a32c:	0027883a 	mov	r19,zero
 400a330:	05010004 	movi	r20,1024
 400a334:	04820004 	movi	r18,2048
 400a338:	003fc906 	br	400a260 <__smakebuf_r+0xc4>

0400a33c <__swhatbuf_r>:
 400a33c:	deffea04 	addi	sp,sp,-88
 400a340:	dc001215 	stw	r16,72(sp)
 400a344:	2821883a 	mov	r16,r5
 400a348:	2940038f 	ldh	r5,14(r5)
 400a34c:	dc801415 	stw	r18,80(sp)
 400a350:	dc401315 	stw	r17,76(sp)
 400a354:	dfc01515 	stw	ra,84(sp)
 400a358:	3023883a 	mov	r17,r6
 400a35c:	3825883a 	mov	r18,r7
 400a360:	28001016 	blt	r5,zero,400a3a4 <__swhatbuf_r+0x68>
 400a364:	d80d883a 	mov	r6,sp
 400a368:	400a42c0 	call	400a42c <_fstat_r>
 400a36c:	10000d16 	blt	r2,zero,400a3a4 <__swhatbuf_r+0x68>
 400a370:	d8c00117 	ldw	r3,4(sp)
 400a374:	01010004 	movi	r4,1024
 400a378:	00820004 	movi	r2,2048
 400a37c:	18fc000c 	andi	r3,r3,61440
 400a380:	18c80020 	cmpeqi	r3,r3,8192
 400a384:	90c00015 	stw	r3,0(r18)
 400a388:	89000015 	stw	r4,0(r17)
 400a38c:	dfc01517 	ldw	ra,84(sp)
 400a390:	dc801417 	ldw	r18,80(sp)
 400a394:	dc401317 	ldw	r17,76(sp)
 400a398:	dc001217 	ldw	r16,72(sp)
 400a39c:	dec01604 	addi	sp,sp,88
 400a3a0:	f800283a 	ret
 400a3a4:	8080030b 	ldhu	r2,12(r16)
 400a3a8:	0007883a 	mov	r3,zero
 400a3ac:	1080200c 	andi	r2,r2,128
 400a3b0:	10000326 	beq	r2,zero,400a3c0 <__swhatbuf_r+0x84>
 400a3b4:	01001004 	movi	r4,64
 400a3b8:	0005883a 	mov	r2,zero
 400a3bc:	003ff106 	br	400a384 <__swhatbuf_r+0x48>
 400a3c0:	01010004 	movi	r4,1024
 400a3c4:	003fef06 	br	400a384 <__swhatbuf_r+0x48>

0400a3c8 <_read_r>:
 400a3c8:	2807883a 	mov	r3,r5
 400a3cc:	defffe04 	addi	sp,sp,-8
 400a3d0:	dc000015 	stw	r16,0(sp)
 400a3d4:	300b883a 	mov	r5,r6
 400a3d8:	00810074 	movhi	r2,1025
 400a3dc:	380d883a 	mov	r6,r7
 400a3e0:	2021883a 	mov	r16,r4
 400a3e4:	1809883a 	mov	r4,r3
 400a3e8:	dfc00115 	stw	ra,4(sp)
 400a3ec:	10006d15 	stw	zero,436(r2)
 400a3f0:	400adac0 	call	400adac <read>
 400a3f4:	10ffffd8 	cmpnei	r3,r2,-1
 400a3f8:	18000426 	beq	r3,zero,400a40c <_read_r+0x44>
 400a3fc:	dfc00117 	ldw	ra,4(sp)
 400a400:	dc000017 	ldw	r16,0(sp)
 400a404:	dec00204 	addi	sp,sp,8
 400a408:	f800283a 	ret
 400a40c:	00c10074 	movhi	r3,1025
 400a410:	18c06d17 	ldw	r3,436(r3)
 400a414:	183ff926 	beq	r3,zero,400a3fc <_read_r+0x34>
 400a418:	80c00015 	stw	r3,0(r16)
 400a41c:	dfc00117 	ldw	ra,4(sp)
 400a420:	dc000017 	ldw	r16,0(sp)
 400a424:	dec00204 	addi	sp,sp,8
 400a428:	f800283a 	ret

0400a42c <_fstat_r>:
 400a42c:	2807883a 	mov	r3,r5
 400a430:	defffe04 	addi	sp,sp,-8
 400a434:	dc000015 	stw	r16,0(sp)
 400a438:	00810074 	movhi	r2,1025
 400a43c:	300b883a 	mov	r5,r6
 400a440:	2021883a 	mov	r16,r4
 400a444:	1809883a 	mov	r4,r3
 400a448:	dfc00115 	stw	ra,4(sp)
 400a44c:	10006d15 	stw	zero,436(r2)
 400a450:	400a6640 	call	400a664 <fstat>
 400a454:	10ffffd8 	cmpnei	r3,r2,-1
 400a458:	18000426 	beq	r3,zero,400a46c <_fstat_r+0x40>
 400a45c:	dfc00117 	ldw	ra,4(sp)
 400a460:	dc000017 	ldw	r16,0(sp)
 400a464:	dec00204 	addi	sp,sp,8
 400a468:	f800283a 	ret
 400a46c:	00c10074 	movhi	r3,1025
 400a470:	18c06d17 	ldw	r3,436(r3)
 400a474:	183ff926 	beq	r3,zero,400a45c <_fstat_r+0x30>
 400a478:	80c00015 	stw	r3,0(r16)
 400a47c:	dfc00117 	ldw	ra,4(sp)
 400a480:	dc000017 	ldw	r16,0(sp)
 400a484:	dec00204 	addi	sp,sp,8
 400a488:	f800283a 	ret

0400a48c <_isatty_r>:
 400a48c:	defffe04 	addi	sp,sp,-8
 400a490:	dc000015 	stw	r16,0(sp)
 400a494:	00810074 	movhi	r2,1025
 400a498:	2021883a 	mov	r16,r4
 400a49c:	2809883a 	mov	r4,r5
 400a4a0:	dfc00115 	stw	ra,4(sp)
 400a4a4:	10006d15 	stw	zero,436(r2)
 400a4a8:	400a9f40 	call	400a9f4 <isatty>
 400a4ac:	10ffffd8 	cmpnei	r3,r2,-1
 400a4b0:	18000426 	beq	r3,zero,400a4c4 <_isatty_r+0x38>
 400a4b4:	dfc00117 	ldw	ra,4(sp)
 400a4b8:	dc000017 	ldw	r16,0(sp)
 400a4bc:	dec00204 	addi	sp,sp,8
 400a4c0:	f800283a 	ret
 400a4c4:	00c10074 	movhi	r3,1025
 400a4c8:	18c06d17 	ldw	r3,436(r3)
 400a4cc:	183ff926 	beq	r3,zero,400a4b4 <_isatty_r+0x28>
 400a4d0:	80c00015 	stw	r3,0(r16)
 400a4d4:	dfc00117 	ldw	ra,4(sp)
 400a4d8:	dc000017 	ldw	r16,0(sp)
 400a4dc:	dec00204 	addi	sp,sp,8
 400a4e0:	f800283a 	ret

0400a4e4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 400a4e4:	defffe04 	addi	sp,sp,-8
 400a4e8:	dfc00115 	stw	ra,4(sp)
 400a4ec:	df000015 	stw	fp,0(sp)
 400a4f0:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 400a4f4:	d0a00a17 	ldw	r2,-32728(gp)
 400a4f8:	10000326 	beq	r2,zero,400a508 <alt_get_errno+0x24>
 400a4fc:	d0a00a17 	ldw	r2,-32728(gp)
 400a500:	103ee83a 	callr	r2
 400a504:	00000106 	br	400a50c <alt_get_errno+0x28>
 400a508:	d0a6c104 	addi	r2,gp,-25852
}
 400a50c:	e037883a 	mov	sp,fp
 400a510:	dfc00117 	ldw	ra,4(sp)
 400a514:	df000017 	ldw	fp,0(sp)
 400a518:	dec00204 	addi	sp,sp,8
 400a51c:	f800283a 	ret

0400a520 <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
 400a520:	defffb04 	addi	sp,sp,-20
 400a524:	dfc00415 	stw	ra,16(sp)
 400a528:	df000315 	stw	fp,12(sp)
 400a52c:	df000304 	addi	fp,sp,12
 400a530:	e13ffd15 	stw	r4,-12(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
 400a534:	e0bffd17 	ldw	r2,-12(fp)
 400a538:	10000916 	blt	r2,zero,400a560 <close+0x40>
 400a53c:	e0fffd17 	ldw	r3,-12(fp)
 400a540:	1805883a 	mov	r2,r3
 400a544:	1085883a 	add	r2,r2,r2
 400a548:	10c5883a 	add	r2,r2,r3
 400a54c:	100490ba 	slli	r2,r2,2
 400a550:	00c10074 	movhi	r3,1025
 400a554:	18f53404 	addi	r3,r3,-11056
 400a558:	10c5883a 	add	r2,r2,r3
 400a55c:	00000106 	br	400a564 <close+0x44>
 400a560:	0005883a 	mov	r2,zero
 400a564:	e0bfff15 	stw	r2,-4(fp)

  if (fd)
 400a568:	e0bfff17 	ldw	r2,-4(fp)
 400a56c:	10001926 	beq	r2,zero,400a5d4 <close+0xb4>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
 400a570:	e0bfff17 	ldw	r2,-4(fp)
 400a574:	10800017 	ldw	r2,0(r2)
 400a578:	10800417 	ldw	r2,16(r2)
 400a57c:	10000626 	beq	r2,zero,400a598 <close+0x78>
 400a580:	e0bfff17 	ldw	r2,-4(fp)
 400a584:	10800017 	ldw	r2,0(r2)
 400a588:	10800417 	ldw	r2,16(r2)
 400a58c:	e13fff17 	ldw	r4,-4(fp)
 400a590:	103ee83a 	callr	r2
 400a594:	00000106 	br	400a59c <close+0x7c>
 400a598:	0005883a 	mov	r2,zero
 400a59c:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
 400a5a0:	e13ffd17 	ldw	r4,-12(fp)
 400a5a4:	400aeb40 	call	400aeb4 <alt_release_fd>
    if (rval < 0)
 400a5a8:	e0bffe17 	ldw	r2,-8(fp)
 400a5ac:	1000070e 	bge	r2,zero,400a5cc <close+0xac>
    {
      ALT_ERRNO = -rval;
 400a5b0:	400a4e40 	call	400a4e4 <alt_get_errno>
 400a5b4:	1007883a 	mov	r3,r2
 400a5b8:	e0bffe17 	ldw	r2,-8(fp)
 400a5bc:	0085c83a 	sub	r2,zero,r2
 400a5c0:	18800015 	stw	r2,0(r3)
      return -1;
 400a5c4:	00bfffc4 	movi	r2,-1
 400a5c8:	00000706 	br	400a5e8 <close+0xc8>
    }
    return 0;
 400a5cc:	0005883a 	mov	r2,zero
 400a5d0:	00000506 	br	400a5e8 <close+0xc8>
  }
  else
  {
    ALT_ERRNO = EBADFD;
 400a5d4:	400a4e40 	call	400a4e4 <alt_get_errno>
 400a5d8:	1007883a 	mov	r3,r2
 400a5dc:	00801444 	movi	r2,81
 400a5e0:	18800015 	stw	r2,0(r3)
    return -1;
 400a5e4:	00bfffc4 	movi	r2,-1
  }
}
 400a5e8:	e037883a 	mov	sp,fp
 400a5ec:	dfc00117 	ldw	ra,4(sp)
 400a5f0:	df000017 	ldw	fp,0(sp)
 400a5f4:	dec00204 	addi	sp,sp,8
 400a5f8:	f800283a 	ret

0400a5fc <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
 400a5fc:	defffc04 	addi	sp,sp,-16
 400a600:	df000315 	stw	fp,12(sp)
 400a604:	df000304 	addi	fp,sp,12
 400a608:	e13fff15 	stw	r4,-4(fp)
 400a60c:	e17ffe15 	stw	r5,-8(fp)
 400a610:	e1bffd15 	stw	r6,-12(fp)
  return len;
 400a614:	e0bffd17 	ldw	r2,-12(fp)
}
 400a618:	e037883a 	mov	sp,fp
 400a61c:	df000017 	ldw	fp,0(sp)
 400a620:	dec00104 	addi	sp,sp,4
 400a624:	f800283a 	ret

0400a628 <alt_get_errno>:
{
 400a628:	defffe04 	addi	sp,sp,-8
 400a62c:	dfc00115 	stw	ra,4(sp)
 400a630:	df000015 	stw	fp,0(sp)
 400a634:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 400a638:	d0a00a17 	ldw	r2,-32728(gp)
 400a63c:	10000326 	beq	r2,zero,400a64c <alt_get_errno+0x24>
 400a640:	d0a00a17 	ldw	r2,-32728(gp)
 400a644:	103ee83a 	callr	r2
 400a648:	00000106 	br	400a650 <alt_get_errno+0x28>
 400a64c:	d0a6c104 	addi	r2,gp,-25852
}
 400a650:	e037883a 	mov	sp,fp
 400a654:	dfc00117 	ldw	ra,4(sp)
 400a658:	df000017 	ldw	fp,0(sp)
 400a65c:	dec00204 	addi	sp,sp,8
 400a660:	f800283a 	ret

0400a664 <fstat>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_FSTAT (int file, struct stat *st)
{
 400a664:	defffb04 	addi	sp,sp,-20
 400a668:	dfc00415 	stw	ra,16(sp)
 400a66c:	df000315 	stw	fp,12(sp)
 400a670:	df000304 	addi	fp,sp,12
 400a674:	e13ffe15 	stw	r4,-8(fp)
 400a678:	e17ffd15 	stw	r5,-12(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 400a67c:	e0bffe17 	ldw	r2,-8(fp)
 400a680:	10000916 	blt	r2,zero,400a6a8 <fstat+0x44>
 400a684:	e0fffe17 	ldw	r3,-8(fp)
 400a688:	1805883a 	mov	r2,r3
 400a68c:	1085883a 	add	r2,r2,r2
 400a690:	10c5883a 	add	r2,r2,r3
 400a694:	100490ba 	slli	r2,r2,2
 400a698:	00c10074 	movhi	r3,1025
 400a69c:	18f53404 	addi	r3,r3,-11056
 400a6a0:	10c5883a 	add	r2,r2,r3
 400a6a4:	00000106 	br	400a6ac <fstat+0x48>
 400a6a8:	0005883a 	mov	r2,zero
 400a6ac:	e0bfff15 	stw	r2,-4(fp)
  
  if (fd)
 400a6b0:	e0bfff17 	ldw	r2,-4(fp)
 400a6b4:	10001026 	beq	r2,zero,400a6f8 <fstat+0x94>
  {
    /* Call the drivers fstat() function to fill out the "st" structure. */

    if (fd->dev->fstat)
 400a6b8:	e0bfff17 	ldw	r2,-4(fp)
 400a6bc:	10800017 	ldw	r2,0(r2)
 400a6c0:	10800817 	ldw	r2,32(r2)
 400a6c4:	10000726 	beq	r2,zero,400a6e4 <fstat+0x80>
    {
      return fd->dev->fstat(fd, st);
 400a6c8:	e0bfff17 	ldw	r2,-4(fp)
 400a6cc:	10800017 	ldw	r2,0(r2)
 400a6d0:	10800817 	ldw	r2,32(r2)
 400a6d4:	e17ffd17 	ldw	r5,-12(fp)
 400a6d8:	e13fff17 	ldw	r4,-4(fp)
 400a6dc:	103ee83a 	callr	r2
 400a6e0:	00000a06 	br	400a70c <fstat+0xa8>
     * device.
     */
 
    else
    {
      st->st_mode = _IFCHR;
 400a6e4:	e0bffd17 	ldw	r2,-12(fp)
 400a6e8:	00c80004 	movi	r3,8192
 400a6ec:	10c00115 	stw	r3,4(r2)
      return 0;
 400a6f0:	0005883a 	mov	r2,zero
 400a6f4:	00000506 	br	400a70c <fstat+0xa8>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
 400a6f8:	400a6280 	call	400a628 <alt_get_errno>
 400a6fc:	1007883a 	mov	r3,r2
 400a700:	00801444 	movi	r2,81
 400a704:	18800015 	stw	r2,0(r3)
    return -1;
 400a708:	00bfffc4 	movi	r2,-1
  }
}
 400a70c:	e037883a 	mov	sp,fp
 400a710:	dfc00117 	ldw	ra,4(sp)
 400a714:	df000017 	ldw	fp,0(sp)
 400a718:	dec00204 	addi	sp,sp,8
 400a71c:	f800283a 	ret

0400a720 <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
 400a720:	defff904 	addi	sp,sp,-28
 400a724:	dfc00615 	stw	ra,24(sp)
 400a728:	df000515 	stw	fp,20(sp)
 400a72c:	df000504 	addi	fp,sp,20
 400a730:	e13fff15 	stw	r4,-4(fp)
 400a734:	e17ffe15 	stw	r5,-8(fp)
 400a738:	e1bffd15 	stw	r6,-12(fp)
 400a73c:	e1fffc15 	stw	r7,-16(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
 400a740:	e0800217 	ldw	r2,8(fp)
 400a744:	d8800015 	stw	r2,0(sp)
 400a748:	e1fffc17 	ldw	r7,-16(fp)
 400a74c:	e1bffd17 	ldw	r6,-12(fp)
 400a750:	e17ffe17 	ldw	r5,-8(fp)
 400a754:	e13fff17 	ldw	r4,-4(fp)
 400a758:	400a8d00 	call	400a8d0 <alt_iic_isr_register>
}  
 400a75c:	e037883a 	mov	sp,fp
 400a760:	dfc00117 	ldw	ra,4(sp)
 400a764:	df000017 	ldw	fp,0(sp)
 400a768:	dec00204 	addi	sp,sp,8
 400a76c:	f800283a 	ret

0400a770 <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
 400a770:	defff904 	addi	sp,sp,-28
 400a774:	df000615 	stw	fp,24(sp)
 400a778:	df000604 	addi	fp,sp,24
 400a77c:	e13ffb15 	stw	r4,-20(fp)
 400a780:	e17ffa15 	stw	r5,-24(fp)
 400a784:	e0bffa17 	ldw	r2,-24(fp)
 400a788:	e0bfff15 	stw	r2,-4(fp)
  NIOS2_READ_STATUS (context);
 400a78c:	0005303a 	rdctl	r2,status
 400a790:	e0bffe15 	stw	r2,-8(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 400a794:	e0fffe17 	ldw	r3,-8(fp)
 400a798:	00bfff84 	movi	r2,-2
 400a79c:	1884703a 	and	r2,r3,r2
 400a7a0:	1001703a 	wrctl	status,r2
  return context;
 400a7a4:	e0bffe17 	ldw	r2,-8(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 400a7a8:	e0bffd15 	stw	r2,-12(fp)

  alt_irq_active |= (1 << id);
 400a7ac:	00c00044 	movi	r3,1
 400a7b0:	e0bfff17 	ldw	r2,-4(fp)
 400a7b4:	1884983a 	sll	r2,r3,r2
 400a7b8:	1007883a 	mov	r3,r2
 400a7bc:	d0a6c217 	ldw	r2,-25848(gp)
 400a7c0:	1884b03a 	or	r2,r3,r2
 400a7c4:	d0a6c215 	stw	r2,-25848(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 400a7c8:	d0a6c217 	ldw	r2,-25848(gp)
 400a7cc:	100170fa 	wrctl	ienable,r2
 400a7d0:	e0bffd17 	ldw	r2,-12(fp)
 400a7d4:	e0bffc15 	stw	r2,-16(fp)
  NIOS2_WRITE_STATUS (context);
 400a7d8:	e0bffc17 	ldw	r2,-16(fp)
 400a7dc:	1001703a 	wrctl	status,r2
}
 400a7e0:	0001883a 	nop

  alt_irq_enable_all(status);

  return 0;
 400a7e4:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
}
 400a7e8:	e037883a 	mov	sp,fp
 400a7ec:	df000017 	ldw	fp,0(sp)
 400a7f0:	dec00104 	addi	sp,sp,4
 400a7f4:	f800283a 	ret

0400a7f8 <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
 400a7f8:	defff904 	addi	sp,sp,-28
 400a7fc:	df000615 	stw	fp,24(sp)
 400a800:	df000604 	addi	fp,sp,24
 400a804:	e13ffb15 	stw	r4,-20(fp)
 400a808:	e17ffa15 	stw	r5,-24(fp)
 400a80c:	e0bffa17 	ldw	r2,-24(fp)
 400a810:	e0bfff15 	stw	r2,-4(fp)
  NIOS2_READ_STATUS (context);
 400a814:	0005303a 	rdctl	r2,status
 400a818:	e0bffe15 	stw	r2,-8(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 400a81c:	e0fffe17 	ldw	r3,-8(fp)
 400a820:	00bfff84 	movi	r2,-2
 400a824:	1884703a 	and	r2,r3,r2
 400a828:	1001703a 	wrctl	status,r2
  return context;
 400a82c:	e0bffe17 	ldw	r2,-8(fp)
  status = alt_irq_disable_all ();
 400a830:	e0bffd15 	stw	r2,-12(fp)
  alt_irq_active &= ~(1 << id);
 400a834:	00c00044 	movi	r3,1
 400a838:	e0bfff17 	ldw	r2,-4(fp)
 400a83c:	1884983a 	sll	r2,r3,r2
 400a840:	0084303a 	nor	r2,zero,r2
 400a844:	1007883a 	mov	r3,r2
 400a848:	d0a6c217 	ldw	r2,-25848(gp)
 400a84c:	1884703a 	and	r2,r3,r2
 400a850:	d0a6c215 	stw	r2,-25848(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 400a854:	d0a6c217 	ldw	r2,-25848(gp)
 400a858:	100170fa 	wrctl	ienable,r2
 400a85c:	e0bffd17 	ldw	r2,-12(fp)
 400a860:	e0bffc15 	stw	r2,-16(fp)
  NIOS2_WRITE_STATUS (context);
 400a864:	e0bffc17 	ldw	r2,-16(fp)
 400a868:	1001703a 	wrctl	status,r2
}
 400a86c:	0001883a 	nop
  return 0;
 400a870:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
}
 400a874:	e037883a 	mov	sp,fp
 400a878:	df000017 	ldw	fp,0(sp)
 400a87c:	dec00104 	addi	sp,sp,4
 400a880:	f800283a 	ret

0400a884 <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
 400a884:	defffc04 	addi	sp,sp,-16
 400a888:	df000315 	stw	fp,12(sp)
 400a88c:	df000304 	addi	fp,sp,12
 400a890:	e13ffe15 	stw	r4,-8(fp)
 400a894:	e17ffd15 	stw	r5,-12(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
 400a898:	000530fa 	rdctl	r2,ienable
 400a89c:	e0bfff15 	stw	r2,-4(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
 400a8a0:	00c00044 	movi	r3,1
 400a8a4:	e0bffd17 	ldw	r2,-12(fp)
 400a8a8:	1884983a 	sll	r2,r3,r2
 400a8ac:	1007883a 	mov	r3,r2
 400a8b0:	e0bfff17 	ldw	r2,-4(fp)
 400a8b4:	1884703a 	and	r2,r3,r2
 400a8b8:	1004c03a 	cmpne	r2,r2,zero
 400a8bc:	10803fcc 	andi	r2,r2,255
}
 400a8c0:	e037883a 	mov	sp,fp
 400a8c4:	df000017 	ldw	fp,0(sp)
 400a8c8:	dec00104 	addi	sp,sp,4
 400a8cc:	f800283a 	ret

0400a8d0 <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
 400a8d0:	defff504 	addi	sp,sp,-44
 400a8d4:	dfc00a15 	stw	ra,40(sp)
 400a8d8:	df000915 	stw	fp,36(sp)
 400a8dc:	df000904 	addi	fp,sp,36
 400a8e0:	e13ffa15 	stw	r4,-24(fp)
 400a8e4:	e17ff915 	stw	r5,-28(fp)
 400a8e8:	e1bff815 	stw	r6,-32(fp)
 400a8ec:	e1fff715 	stw	r7,-36(fp)
  int rc = -EINVAL;  
 400a8f0:	00bffa84 	movi	r2,-22
 400a8f4:	e0bfff15 	stw	r2,-4(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
 400a8f8:	e0bff917 	ldw	r2,-28(fp)
 400a8fc:	e0bffe15 	stw	r2,-8(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
 400a900:	e0bffe17 	ldw	r2,-8(fp)
 400a904:	10800808 	cmpgei	r2,r2,32
 400a908:	1000251e 	bne	r2,zero,400a9a0 <alt_iic_isr_register+0xd0>
  NIOS2_READ_STATUS (context);
 400a90c:	0005303a 	rdctl	r2,status
 400a910:	e0bffc15 	stw	r2,-16(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 400a914:	e0fffc17 	ldw	r3,-16(fp)
 400a918:	00bfff84 	movi	r2,-2
 400a91c:	1884703a 	and	r2,r3,r2
 400a920:	1001703a 	wrctl	status,r2
  return context;
 400a924:	e0bffc17 	ldw	r2,-16(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
 400a928:	e0bffd15 	stw	r2,-12(fp)

    alt_irq[id].handler = isr;
 400a92c:	e0bffe17 	ldw	r2,-8(fp)
 400a930:	100890fa 	slli	r4,r2,3
 400a934:	e0fff817 	ldw	r3,-32(fp)
 400a938:	00812074 	movhi	r2,1153
 400a93c:	2085883a 	add	r2,r4,r2
 400a940:	10c0b215 	stw	r3,712(r2)
    alt_irq[id].context = isr_context;
 400a944:	e0bffe17 	ldw	r2,-8(fp)
 400a948:	100890fa 	slli	r4,r2,3
 400a94c:	e0fff717 	ldw	r3,-36(fp)
 400a950:	00812074 	movhi	r2,1153
 400a954:	2085883a 	add	r2,r4,r2
 400a958:	10c0b315 	stw	r3,716(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
 400a95c:	e0bff817 	ldw	r2,-32(fp)
 400a960:	10000526 	beq	r2,zero,400a978 <alt_iic_isr_register+0xa8>
 400a964:	e0bffe17 	ldw	r2,-8(fp)
 400a968:	100b883a 	mov	r5,r2
 400a96c:	e13ffa17 	ldw	r4,-24(fp)
 400a970:	400a7700 	call	400a770 <alt_ic_irq_enable>
 400a974:	00000406 	br	400a988 <alt_iic_isr_register+0xb8>
 400a978:	e0bffe17 	ldw	r2,-8(fp)
 400a97c:	100b883a 	mov	r5,r2
 400a980:	e13ffa17 	ldw	r4,-24(fp)
 400a984:	400a7f80 	call	400a7f8 <alt_ic_irq_disable>
 400a988:	e0bfff15 	stw	r2,-4(fp)
 400a98c:	e0bffd17 	ldw	r2,-12(fp)
 400a990:	e0bffb15 	stw	r2,-20(fp)
  NIOS2_WRITE_STATUS (context);
 400a994:	e0bffb17 	ldw	r2,-20(fp)
 400a998:	1001703a 	wrctl	status,r2
}
 400a99c:	0001883a 	nop

    alt_irq_enable_all(status);
  }

  return rc; 
 400a9a0:	e0bfff17 	ldw	r2,-4(fp)
}
 400a9a4:	e037883a 	mov	sp,fp
 400a9a8:	dfc00117 	ldw	ra,4(sp)
 400a9ac:	df000017 	ldw	fp,0(sp)
 400a9b0:	dec00204 	addi	sp,sp,8
 400a9b4:	f800283a 	ret

0400a9b8 <alt_get_errno>:
{
 400a9b8:	defffe04 	addi	sp,sp,-8
 400a9bc:	dfc00115 	stw	ra,4(sp)
 400a9c0:	df000015 	stw	fp,0(sp)
 400a9c4:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 400a9c8:	d0a00a17 	ldw	r2,-32728(gp)
 400a9cc:	10000326 	beq	r2,zero,400a9dc <alt_get_errno+0x24>
 400a9d0:	d0a00a17 	ldw	r2,-32728(gp)
 400a9d4:	103ee83a 	callr	r2
 400a9d8:	00000106 	br	400a9e0 <alt_get_errno+0x28>
 400a9dc:	d0a6c104 	addi	r2,gp,-25852
}
 400a9e0:	e037883a 	mov	sp,fp
 400a9e4:	dfc00117 	ldw	ra,4(sp)
 400a9e8:	df000017 	ldw	fp,0(sp)
 400a9ec:	dec00204 	addi	sp,sp,8
 400a9f0:	f800283a 	ret

0400a9f4 <isatty>:
 *
 * ALT_ISATTY is mapped onto the isatty() system call in alt_syscall.h
 */
 
int ALT_ISATTY (int file)
{
 400a9f4:	deffea04 	addi	sp,sp,-88
 400a9f8:	dfc01515 	stw	ra,84(sp)
 400a9fc:	df001415 	stw	fp,80(sp)
 400aa00:	df001404 	addi	fp,sp,80
 400aa04:	e13fec15 	stw	r4,-80(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 400aa08:	e0bfec17 	ldw	r2,-80(fp)
 400aa0c:	10000916 	blt	r2,zero,400aa34 <isatty+0x40>
 400aa10:	e0ffec17 	ldw	r3,-80(fp)
 400aa14:	1805883a 	mov	r2,r3
 400aa18:	1085883a 	add	r2,r2,r2
 400aa1c:	10c5883a 	add	r2,r2,r3
 400aa20:	100490ba 	slli	r2,r2,2
 400aa24:	00c10074 	movhi	r3,1025
 400aa28:	18f53404 	addi	r3,r3,-11056
 400aa2c:	10c5883a 	add	r2,r2,r3
 400aa30:	00000106 	br	400aa38 <isatty+0x44>
 400aa34:	0005883a 	mov	r2,zero
 400aa38:	e0bfff15 	stw	r2,-4(fp)
  
  if (fd)
 400aa3c:	e0bfff17 	ldw	r2,-4(fp)
 400aa40:	10000e26 	beq	r2,zero,400aa7c <isatty+0x88>
    /*
     * If a device driver does not provide an fstat() function, then it is 
     * treated as a terminal device by default.
     */

    if (!fd->dev->fstat)
 400aa44:	e0bfff17 	ldw	r2,-4(fp)
 400aa48:	10800017 	ldw	r2,0(r2)
 400aa4c:	10800817 	ldw	r2,32(r2)
 400aa50:	1000021e 	bne	r2,zero,400aa5c <isatty+0x68>
    {
      return 1;
 400aa54:	00800044 	movi	r2,1
 400aa58:	00000d06 	br	400aa90 <isatty+0x9c>
     * this is called so that the device can identify itself.
     */ 

    else
    {
      fstat (file, &stat);
 400aa5c:	e0bfed04 	addi	r2,fp,-76
 400aa60:	100b883a 	mov	r5,r2
 400aa64:	e13fec17 	ldw	r4,-80(fp)
 400aa68:	400a6640 	call	400a664 <fstat>
      return (stat.st_mode == _IFCHR) ? 1 : 0;
 400aa6c:	e0bfee17 	ldw	r2,-72(fp)
 400aa70:	10880020 	cmpeqi	r2,r2,8192
 400aa74:	10803fcc 	andi	r2,r2,255
 400aa78:	00000506 	br	400aa90 <isatty+0x9c>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
 400aa7c:	400a9b80 	call	400a9b8 <alt_get_errno>
 400aa80:	1007883a 	mov	r3,r2
 400aa84:	00801444 	movi	r2,81
 400aa88:	18800015 	stw	r2,0(r3)
    return 0;
 400aa8c:	0005883a 	mov	r2,zero
  }
}
 400aa90:	e037883a 	mov	sp,fp
 400aa94:	dfc00117 	ldw	ra,4(sp)
 400aa98:	df000017 	ldw	fp,0(sp)
 400aa9c:	dec00204 	addi	sp,sp,8
 400aaa0:	f800283a 	ret

0400aaa4 <alt_load_section>:
 */

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
 400aaa4:	defffc04 	addi	sp,sp,-16
 400aaa8:	df000315 	stw	fp,12(sp)
 400aaac:	df000304 	addi	fp,sp,12
 400aab0:	e13fff15 	stw	r4,-4(fp)
 400aab4:	e17ffe15 	stw	r5,-8(fp)
 400aab8:	e1bffd15 	stw	r6,-12(fp)
  if (to != from)
 400aabc:	e0fffe17 	ldw	r3,-8(fp)
 400aac0:	e0bfff17 	ldw	r2,-4(fp)
 400aac4:	18800c26 	beq	r3,r2,400aaf8 <alt_load_section+0x54>
  {
    while( to != end )
 400aac8:	00000806 	br	400aaec <alt_load_section+0x48>
    {
      *to++ = *from++;
 400aacc:	e0ffff17 	ldw	r3,-4(fp)
 400aad0:	18800104 	addi	r2,r3,4
 400aad4:	e0bfff15 	stw	r2,-4(fp)
 400aad8:	e0bffe17 	ldw	r2,-8(fp)
 400aadc:	11000104 	addi	r4,r2,4
 400aae0:	e13ffe15 	stw	r4,-8(fp)
 400aae4:	18c00017 	ldw	r3,0(r3)
 400aae8:	10c00015 	stw	r3,0(r2)
    while( to != end )
 400aaec:	e0fffe17 	ldw	r3,-8(fp)
 400aaf0:	e0bffd17 	ldw	r2,-12(fp)
 400aaf4:	18bff51e 	bne	r3,r2,400aacc <alt_load_section+0x28>
    }
  }
}
 400aaf8:	0001883a 	nop
 400aafc:	e037883a 	mov	sp,fp
 400ab00:	df000017 	ldw	fp,0(sp)
 400ab04:	dec00104 	addi	sp,sp,4
 400ab08:	f800283a 	ret

0400ab0c <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
 400ab0c:	defffe04 	addi	sp,sp,-8
 400ab10:	dfc00115 	stw	ra,4(sp)
 400ab14:	df000015 	stw	fp,0(sp)
 400ab18:	d839883a 	mov	fp,sp
  /* 
   * Copy the .rwdata section. 
   */

  alt_load_section (&__flash_rwdata_start, 
 400ab1c:	01810074 	movhi	r6,1025
 400ab20:	31b9bb04 	addi	r6,r6,-6420
 400ab24:	01410074 	movhi	r5,1025
 400ab28:	29731f04 	addi	r5,r5,-13188
 400ab2c:	01010074 	movhi	r4,1025
 400ab30:	2139bb04 	addi	r4,r4,-6420
 400ab34:	400aaa40 	call	400aaa4 <alt_load_section>

  /*
   * Copy the exception handler.
   */

  alt_load_section (&__flash_exceptions_start, 
 400ab38:	01810034 	movhi	r6,1024
 400ab3c:	3180d904 	addi	r6,r6,868
 400ab40:	01410034 	movhi	r5,1024
 400ab44:	29400804 	addi	r5,r5,32
 400ab48:	01010034 	movhi	r4,1024
 400ab4c:	21000804 	addi	r4,r4,32
 400ab50:	400aaa40 	call	400aaa4 <alt_load_section>

  /*
   * Copy the .rodata section.
   */

  alt_load_section (&__flash_rodata_start, 
 400ab54:	01810074 	movhi	r6,1025
 400ab58:	31b31f04 	addi	r6,r6,-13188
 400ab5c:	01410074 	movhi	r5,1025
 400ab60:	2972fa04 	addi	r5,r5,-13336
 400ab64:	01010074 	movhi	r4,1025
 400ab68:	2132fa04 	addi	r4,r4,-13336
 400ab6c:	400aaa40 	call	400aaa4 <alt_load_section>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
 400ab70:	400bed00 	call	400bed0 <alt_dcache_flush_all>
  alt_icache_flush_all();
 400ab74:	400c09c0 	call	400c09c <alt_icache_flush_all>
}
 400ab78:	0001883a 	nop
 400ab7c:	e037883a 	mov	sp,fp
 400ab80:	dfc00117 	ldw	ra,4(sp)
 400ab84:	df000017 	ldw	fp,0(sp)
 400ab88:	dec00204 	addi	sp,sp,8
 400ab8c:	f800283a 	ret

0400ab90 <alt_get_errno>:
{
 400ab90:	defffe04 	addi	sp,sp,-8
 400ab94:	dfc00115 	stw	ra,4(sp)
 400ab98:	df000015 	stw	fp,0(sp)
 400ab9c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 400aba0:	d0a00a17 	ldw	r2,-32728(gp)
 400aba4:	10000326 	beq	r2,zero,400abb4 <alt_get_errno+0x24>
 400aba8:	d0a00a17 	ldw	r2,-32728(gp)
 400abac:	103ee83a 	callr	r2
 400abb0:	00000106 	br	400abb8 <alt_get_errno+0x28>
 400abb4:	d0a6c104 	addi	r2,gp,-25852
}
 400abb8:	e037883a 	mov	sp,fp
 400abbc:	dfc00117 	ldw	ra,4(sp)
 400abc0:	df000017 	ldw	fp,0(sp)
 400abc4:	dec00204 	addi	sp,sp,8
 400abc8:	f800283a 	ret

0400abcc <lseek>:
 * ALT_LSEEK is mapped onto the lseek() system call in alt_syscall.h
 *
 */

off_t ALT_LSEEK (int file, off_t ptr, int dir)
{
 400abcc:	defff904 	addi	sp,sp,-28
 400abd0:	dfc00615 	stw	ra,24(sp)
 400abd4:	df000515 	stw	fp,20(sp)
 400abd8:	df000504 	addi	fp,sp,20
 400abdc:	e13ffd15 	stw	r4,-12(fp)
 400abe0:	e17ffc15 	stw	r5,-16(fp)
 400abe4:	e1bffb15 	stw	r6,-20(fp)
  alt_fd* fd;
  off_t   rc = 0; 
 400abe8:	e03fff15 	stw	zero,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 400abec:	e0bffd17 	ldw	r2,-12(fp)
 400abf0:	10000916 	blt	r2,zero,400ac18 <lseek+0x4c>
 400abf4:	e0fffd17 	ldw	r3,-12(fp)
 400abf8:	1805883a 	mov	r2,r3
 400abfc:	1085883a 	add	r2,r2,r2
 400ac00:	10c5883a 	add	r2,r2,r3
 400ac04:	100490ba 	slli	r2,r2,2
 400ac08:	00c10074 	movhi	r3,1025
 400ac0c:	18f53404 	addi	r3,r3,-11056
 400ac10:	10c5883a 	add	r2,r2,r3
 400ac14:	00000106 	br	400ac1c <lseek+0x50>
 400ac18:	0005883a 	mov	r2,zero
 400ac1c:	e0bffe15 	stw	r2,-8(fp)
  
  if (fd) 
 400ac20:	e0bffe17 	ldw	r2,-8(fp)
 400ac24:	10001026 	beq	r2,zero,400ac68 <lseek+0x9c>
    /*
     * If the device driver provides an implementation of the lseek() function,
     * then call that to process the request.
     */
 
    if (fd->dev->lseek)
 400ac28:	e0bffe17 	ldw	r2,-8(fp)
 400ac2c:	10800017 	ldw	r2,0(r2)
 400ac30:	10800717 	ldw	r2,28(r2)
 400ac34:	10000926 	beq	r2,zero,400ac5c <lseek+0x90>
    {
      rc = fd->dev->lseek(fd, ptr, dir);
 400ac38:	e0bffe17 	ldw	r2,-8(fp)
 400ac3c:	10800017 	ldw	r2,0(r2)
 400ac40:	10800717 	ldw	r2,28(r2)
 400ac44:	e1bffb17 	ldw	r6,-20(fp)
 400ac48:	e17ffc17 	ldw	r5,-16(fp)
 400ac4c:	e13ffe17 	ldw	r4,-8(fp)
 400ac50:	103ee83a 	callr	r2
 400ac54:	e0bfff15 	stw	r2,-4(fp)
 400ac58:	00000506 	br	400ac70 <lseek+0xa4>
     * Otherwise return an error.
     */

    else
    {
      rc = -ENOTSUP;
 400ac5c:	00bfde84 	movi	r2,-134
 400ac60:	e0bfff15 	stw	r2,-4(fp)
 400ac64:	00000206 	br	400ac70 <lseek+0xa4>
    }
  }
  else  
  {
    rc = -EBADFD;
 400ac68:	00bfebc4 	movi	r2,-81
 400ac6c:	e0bfff15 	stw	r2,-4(fp)
  }

  if (rc < 0)
 400ac70:	e0bfff17 	ldw	r2,-4(fp)
 400ac74:	1000070e 	bge	r2,zero,400ac94 <lseek+0xc8>
  {
    ALT_ERRNO = -rc;
 400ac78:	400ab900 	call	400ab90 <alt_get_errno>
 400ac7c:	1007883a 	mov	r3,r2
 400ac80:	e0bfff17 	ldw	r2,-4(fp)
 400ac84:	0085c83a 	sub	r2,zero,r2
 400ac88:	18800015 	stw	r2,0(r3)
    rc = -1;
 400ac8c:	00bfffc4 	movi	r2,-1
 400ac90:	e0bfff15 	stw	r2,-4(fp)
  }

  return rc;
 400ac94:	e0bfff17 	ldw	r2,-4(fp)
}
 400ac98:	e037883a 	mov	sp,fp
 400ac9c:	dfc00117 	ldw	ra,4(sp)
 400aca0:	df000017 	ldw	fp,0(sp)
 400aca4:	dec00204 	addi	sp,sp,8
 400aca8:	f800283a 	ret

0400acac <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
 400acac:	defffd04 	addi	sp,sp,-12
 400acb0:	dfc00215 	stw	ra,8(sp)
 400acb4:	df000115 	stw	fp,4(sp)
 400acb8:	df000104 	addi	fp,sp,4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
 400acbc:	0009883a 	mov	r4,zero
 400acc0:	400b1500 	call	400b150 <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
  ALT_OS_INIT();
 400acc4:	0001883a 	nop
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
 400acc8:	400b18c0 	call	400b18c <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
 400accc:	01810074 	movhi	r6,1025
 400acd0:	31b31904 	addi	r6,r6,-13212
 400acd4:	01410074 	movhi	r5,1025
 400acd8:	29731904 	addi	r5,r5,-13212
 400acdc:	01010074 	movhi	r4,1025
 400ace0:	21331904 	addi	r4,r4,-13212
 400ace4:	400c2040 	call	400c204 <alt_io_redirect>
  /* 
   * Call the C++ constructors 
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling C++ constructors.\r\n");
  _do_ctors ();
 400ace8:	400bfd40 	call	400bfd4 <_do_ctors>
   * redefined as _exit()). This is in the interest of reducing code footprint,
   * in that the atexit() overhead is removed when it's not needed.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling atexit.\r\n");
  atexit (_do_dtors);
 400acec:	01010074 	movhi	r4,1025
 400acf0:	21300e04 	addi	r4,r4,-16328
 400acf4:	400c93c0 	call	400c93c <atexit>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
 400acf8:	d0a6c317 	ldw	r2,-25844(gp)
 400acfc:	d0e6c417 	ldw	r3,-25840(gp)
 400ad00:	d126c517 	ldw	r4,-25836(gp)
 400ad04:	200d883a 	mov	r6,r4
 400ad08:	180b883a 	mov	r5,r3
 400ad0c:	1009883a 	mov	r4,r2
 400ad10:	4006f800 	call	4006f80 <main>
 400ad14:	e0bfff15 	stw	r2,-4(fp)
  close(STDOUT_FILENO);
 400ad18:	01000044 	movi	r4,1
 400ad1c:	400a5200 	call	400a520 <close>
  exit (result);
 400ad20:	e13fff17 	ldw	r4,-4(fp)
 400ad24:	400c9500 	call	400c950 <exit>

0400ad28 <__malloc_lock>:
 * configuration is single threaded, so there is nothing to do here. Note that 
 * this requires that malloc is never called by an interrupt service routine.
 */

void __malloc_lock ( struct _reent *_r )
{
 400ad28:	defffe04 	addi	sp,sp,-8
 400ad2c:	df000115 	stw	fp,4(sp)
 400ad30:	df000104 	addi	fp,sp,4
 400ad34:	e13fff15 	stw	r4,-4(fp)
}
 400ad38:	0001883a 	nop
 400ad3c:	e037883a 	mov	sp,fp
 400ad40:	df000017 	ldw	fp,0(sp)
 400ad44:	dec00104 	addi	sp,sp,4
 400ad48:	f800283a 	ret

0400ad4c <__malloc_unlock>:
/*
 *
 */

void __malloc_unlock ( struct _reent *_r )
{
 400ad4c:	defffe04 	addi	sp,sp,-8
 400ad50:	df000115 	stw	fp,4(sp)
 400ad54:	df000104 	addi	fp,sp,4
 400ad58:	e13fff15 	stw	r4,-4(fp)
}
 400ad5c:	0001883a 	nop
 400ad60:	e037883a 	mov	sp,fp
 400ad64:	df000017 	ldw	fp,0(sp)
 400ad68:	dec00104 	addi	sp,sp,4
 400ad6c:	f800283a 	ret

0400ad70 <alt_get_errno>:
{
 400ad70:	defffe04 	addi	sp,sp,-8
 400ad74:	dfc00115 	stw	ra,4(sp)
 400ad78:	df000015 	stw	fp,0(sp)
 400ad7c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 400ad80:	d0a00a17 	ldw	r2,-32728(gp)
 400ad84:	10000326 	beq	r2,zero,400ad94 <alt_get_errno+0x24>
 400ad88:	d0a00a17 	ldw	r2,-32728(gp)
 400ad8c:	103ee83a 	callr	r2
 400ad90:	00000106 	br	400ad98 <alt_get_errno+0x28>
 400ad94:	d0a6c104 	addi	r2,gp,-25852
}
 400ad98:	e037883a 	mov	sp,fp
 400ad9c:	dfc00117 	ldw	ra,4(sp)
 400ada0:	df000017 	ldw	fp,0(sp)
 400ada4:	dec00204 	addi	sp,sp,8
 400ada8:	f800283a 	ret

0400adac <read>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_READ (int file, void *ptr, size_t len)
{
 400adac:	defff904 	addi	sp,sp,-28
 400adb0:	dfc00615 	stw	ra,24(sp)
 400adb4:	df000515 	stw	fp,20(sp)
 400adb8:	df000504 	addi	fp,sp,20
 400adbc:	e13ffd15 	stw	r4,-12(fp)
 400adc0:	e17ffc15 	stw	r5,-16(fp)
 400adc4:	e1bffb15 	stw	r6,-20(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 400adc8:	e0bffd17 	ldw	r2,-12(fp)
 400adcc:	10000916 	blt	r2,zero,400adf4 <read+0x48>
 400add0:	e0fffd17 	ldw	r3,-12(fp)
 400add4:	1805883a 	mov	r2,r3
 400add8:	1085883a 	add	r2,r2,r2
 400addc:	10c5883a 	add	r2,r2,r3
 400ade0:	100490ba 	slli	r2,r2,2
 400ade4:	00c10074 	movhi	r3,1025
 400ade8:	18f53404 	addi	r3,r3,-11056
 400adec:	10c5883a 	add	r2,r2,r3
 400adf0:	00000106 	br	400adf8 <read+0x4c>
 400adf4:	0005883a 	mov	r2,zero
 400adf8:	e0bfff15 	stw	r2,-4(fp)
  
  if (fd)
 400adfc:	e0bfff17 	ldw	r2,-4(fp)
 400ae00:	10002226 	beq	r2,zero,400ae8c <read+0xe0>
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
 400ae04:	e0bfff17 	ldw	r2,-4(fp)
 400ae08:	10800217 	ldw	r2,8(r2)
 400ae0c:	108000cc 	andi	r2,r2,3
 400ae10:	10800060 	cmpeqi	r2,r2,1
 400ae14:	1000181e 	bne	r2,zero,400ae78 <read+0xcc>
        (fd->dev->read))
 400ae18:	e0bfff17 	ldw	r2,-4(fp)
 400ae1c:	10800017 	ldw	r2,0(r2)
 400ae20:	10800517 	ldw	r2,20(r2)
    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
 400ae24:	10001426 	beq	r2,zero,400ae78 <read+0xcc>
      {
        if ((rval = fd->dev->read(fd, ptr, len)) < 0)
 400ae28:	e0bfff17 	ldw	r2,-4(fp)
 400ae2c:	10800017 	ldw	r2,0(r2)
 400ae30:	10800517 	ldw	r2,20(r2)
 400ae34:	e0fffb17 	ldw	r3,-20(fp)
 400ae38:	180d883a 	mov	r6,r3
 400ae3c:	e17ffc17 	ldw	r5,-16(fp)
 400ae40:	e13fff17 	ldw	r4,-4(fp)
 400ae44:	103ee83a 	callr	r2
 400ae48:	e0bffe15 	stw	r2,-8(fp)
 400ae4c:	e0bffe17 	ldw	r2,-8(fp)
 400ae50:	1000070e 	bge	r2,zero,400ae70 <read+0xc4>
        {
          ALT_ERRNO = -rval;
 400ae54:	400ad700 	call	400ad70 <alt_get_errno>
 400ae58:	1007883a 	mov	r3,r2
 400ae5c:	e0bffe17 	ldw	r2,-8(fp)
 400ae60:	0085c83a 	sub	r2,zero,r2
 400ae64:	18800015 	stw	r2,0(r3)
          return -1;
 400ae68:	00bfffc4 	movi	r2,-1
 400ae6c:	00000c06 	br	400aea0 <read+0xf4>
        }
        return rval;
 400ae70:	e0bffe17 	ldw	r2,-8(fp)
 400ae74:	00000a06 	br	400aea0 <read+0xf4>
      }
      else
      {
        ALT_ERRNO = EACCES;
 400ae78:	400ad700 	call	400ad70 <alt_get_errno>
 400ae7c:	1007883a 	mov	r3,r2
 400ae80:	00800344 	movi	r2,13
 400ae84:	18800015 	stw	r2,0(r3)
 400ae88:	00000406 	br	400ae9c <read+0xf0>
      }
    }
  else
  {
    ALT_ERRNO = EBADFD;
 400ae8c:	400ad700 	call	400ad70 <alt_get_errno>
 400ae90:	1007883a 	mov	r3,r2
 400ae94:	00801444 	movi	r2,81
 400ae98:	18800015 	stw	r2,0(r3)
  }
  return -1;
 400ae9c:	00bfffc4 	movi	r2,-1
}
 400aea0:	e037883a 	mov	sp,fp
 400aea4:	dfc00117 	ldw	ra,4(sp)
 400aea8:	df000017 	ldw	fp,0(sp)
 400aeac:	dec00204 	addi	sp,sp,8
 400aeb0:	f800283a 	ret

0400aeb4 <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
 400aeb4:	defffe04 	addi	sp,sp,-8
 400aeb8:	df000115 	stw	fp,4(sp)
 400aebc:	df000104 	addi	fp,sp,4
 400aec0:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
 400aec4:	e0bfff17 	ldw	r2,-4(fp)
 400aec8:	108000d0 	cmplti	r2,r2,3
 400aecc:	1000101e 	bne	r2,zero,400af10 <alt_release_fd+0x5c>
  {
    alt_fd_list[fd].fd_flags = 0;
 400aed0:	e0ffff17 	ldw	r3,-4(fp)
 400aed4:	1805883a 	mov	r2,r3
 400aed8:	1085883a 	add	r2,r2,r2
 400aedc:	10c5883a 	add	r2,r2,r3
 400aee0:	100490ba 	slli	r2,r2,2
 400aee4:	00c10074 	movhi	r3,1025
 400aee8:	10c7883a 	add	r3,r2,r3
 400aeec:	18353615 	stw	zero,-11048(r3)
    alt_fd_list[fd].dev      = 0;
 400aef0:	e0ffff17 	ldw	r3,-4(fp)
 400aef4:	1805883a 	mov	r2,r3
 400aef8:	1085883a 	add	r2,r2,r2
 400aefc:	10c5883a 	add	r2,r2,r3
 400af00:	100490ba 	slli	r2,r2,2
 400af04:	00c10074 	movhi	r3,1025
 400af08:	10c7883a 	add	r3,r2,r3
 400af0c:	18353415 	stw	zero,-11056(r3)
  }
}
 400af10:	0001883a 	nop
 400af14:	e037883a 	mov	sp,fp
 400af18:	df000017 	ldw	fp,0(sp)
 400af1c:	dec00104 	addi	sp,sp,4
 400af20:	f800283a 	ret

0400af24 <sbrk>:
#endif
 
caddr_t ALT_SBRK (int incr) __attribute__ ((no_instrument_function ));

caddr_t ALT_SBRK (int incr)
{ 
 400af24:	defff904 	addi	sp,sp,-28
 400af28:	df000615 	stw	fp,24(sp)
 400af2c:	df000604 	addi	fp,sp,24
 400af30:	e13ffa15 	stw	r4,-24(fp)
  NIOS2_READ_STATUS (context);
 400af34:	0005303a 	rdctl	r2,status
 400af38:	e0bffd15 	stw	r2,-12(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 400af3c:	e0fffd17 	ldw	r3,-12(fp)
 400af40:	00bfff84 	movi	r2,-2
 400af44:	1884703a 	and	r2,r3,r2
 400af48:	1001703a 	wrctl	status,r2
  return context;
 400af4c:	e0bffd17 	ldw	r2,-12(fp)
  alt_irq_context context;
  char *prev_heap_end; 

  context = alt_irq_disable_all();
 400af50:	e0bfff15 	stw	r2,-4(fp)

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
 400af54:	d0a00c17 	ldw	r2,-32720(gp)
 400af58:	10c000c4 	addi	r3,r2,3
 400af5c:	00bfff04 	movi	r2,-4
 400af60:	1884703a 	and	r2,r3,r2
 400af64:	d0a00c15 	stw	r2,-32720(gp)
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
 400af68:	d0e00c17 	ldw	r3,-32720(gp)
 400af6c:	e0bffa17 	ldw	r2,-24(fp)
 400af70:	1887883a 	add	r3,r3,r2
 400af74:	00820034 	movhi	r2,2048
 400af78:	10800004 	addi	r2,r2,0
 400af7c:	10c0072e 	bgeu	r2,r3,400af9c <sbrk+0x78>
 400af80:	e0bfff17 	ldw	r2,-4(fp)
 400af84:	e0bffc15 	stw	r2,-16(fp)
  NIOS2_WRITE_STATUS (context);
 400af88:	e0bffc17 	ldw	r2,-16(fp)
 400af8c:	1001703a 	wrctl	status,r2
}
 400af90:	0001883a 	nop
    alt_irq_enable_all(context);
    return (caddr_t)-1;
 400af94:	00bfffc4 	movi	r2,-1
 400af98:	00000c06 	br	400afcc <sbrk+0xa8>
  }
#endif

  prev_heap_end = heap_end; 
 400af9c:	d0a00c17 	ldw	r2,-32720(gp)
 400afa0:	e0bffe15 	stw	r2,-8(fp)
  heap_end += incr; 
 400afa4:	d0e00c17 	ldw	r3,-32720(gp)
 400afa8:	e0bffa17 	ldw	r2,-24(fp)
 400afac:	1885883a 	add	r2,r3,r2
 400afb0:	d0a00c15 	stw	r2,-32720(gp)
 400afb4:	e0bfff17 	ldw	r2,-4(fp)
 400afb8:	e0bffb15 	stw	r2,-20(fp)
  NIOS2_WRITE_STATUS (context);
 400afbc:	e0bffb17 	ldw	r2,-20(fp)
 400afc0:	1001703a 	wrctl	status,r2
}
 400afc4:	0001883a 	nop

#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
 400afc8:	e0bffe17 	ldw	r2,-8(fp)
} 
 400afcc:	e037883a 	mov	sp,fp
 400afd0:	df000017 	ldw	fp,0(sp)
 400afd4:	dec00104 	addi	sp,sp,4
 400afd8:	f800283a 	ret

0400afdc <alt_get_errno>:
{
 400afdc:	defffe04 	addi	sp,sp,-8
 400afe0:	dfc00115 	stw	ra,4(sp)
 400afe4:	df000015 	stw	fp,0(sp)
 400afe8:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 400afec:	d0a00a17 	ldw	r2,-32728(gp)
 400aff0:	10000326 	beq	r2,zero,400b000 <alt_get_errno+0x24>
 400aff4:	d0a00a17 	ldw	r2,-32728(gp)
 400aff8:	103ee83a 	callr	r2
 400affc:	00000106 	br	400b004 <alt_get_errno+0x28>
 400b000:	d0a6c104 	addi	r2,gp,-25852
}
 400b004:	e037883a 	mov	sp,fp
 400b008:	dfc00117 	ldw	ra,4(sp)
 400b00c:	df000017 	ldw	fp,0(sp)
 400b010:	dec00204 	addi	sp,sp,8
 400b014:	f800283a 	ret

0400b018 <write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
 400b018:	defff904 	addi	sp,sp,-28
 400b01c:	dfc00615 	stw	ra,24(sp)
 400b020:	df000515 	stw	fp,20(sp)
 400b024:	df000504 	addi	fp,sp,20
 400b028:	e13ffd15 	stw	r4,-12(fp)
 400b02c:	e17ffc15 	stw	r5,-16(fp)
 400b030:	e1bffb15 	stw	r6,-20(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 400b034:	e0bffd17 	ldw	r2,-12(fp)
 400b038:	10000916 	blt	r2,zero,400b060 <write+0x48>
 400b03c:	e0fffd17 	ldw	r3,-12(fp)
 400b040:	1805883a 	mov	r2,r3
 400b044:	1085883a 	add	r2,r2,r2
 400b048:	10c5883a 	add	r2,r2,r3
 400b04c:	100490ba 	slli	r2,r2,2
 400b050:	00c10074 	movhi	r3,1025
 400b054:	18f53404 	addi	r3,r3,-11056
 400b058:	10c5883a 	add	r2,r2,r3
 400b05c:	00000106 	br	400b064 <write+0x4c>
 400b060:	0005883a 	mov	r2,zero
 400b064:	e0bfff15 	stw	r2,-4(fp)
  
  if (fd)
 400b068:	e0bfff17 	ldw	r2,-4(fp)
 400b06c:	10002126 	beq	r2,zero,400b0f4 <write+0xdc>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
 400b070:	e0bfff17 	ldw	r2,-4(fp)
 400b074:	10800217 	ldw	r2,8(r2)
 400b078:	108000cc 	andi	r2,r2,3
 400b07c:	10001826 	beq	r2,zero,400b0e0 <write+0xc8>
 400b080:	e0bfff17 	ldw	r2,-4(fp)
 400b084:	10800017 	ldw	r2,0(r2)
 400b088:	10800617 	ldw	r2,24(r2)
 400b08c:	10001426 	beq	r2,zero,400b0e0 <write+0xc8>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
 400b090:	e0bfff17 	ldw	r2,-4(fp)
 400b094:	10800017 	ldw	r2,0(r2)
 400b098:	10800617 	ldw	r2,24(r2)
 400b09c:	e0fffb17 	ldw	r3,-20(fp)
 400b0a0:	180d883a 	mov	r6,r3
 400b0a4:	e17ffc17 	ldw	r5,-16(fp)
 400b0a8:	e13fff17 	ldw	r4,-4(fp)
 400b0ac:	103ee83a 	callr	r2
 400b0b0:	e0bffe15 	stw	r2,-8(fp)
 400b0b4:	e0bffe17 	ldw	r2,-8(fp)
 400b0b8:	1000070e 	bge	r2,zero,400b0d8 <write+0xc0>
      {
        ALT_ERRNO = -rval;
 400b0bc:	400afdc0 	call	400afdc <alt_get_errno>
 400b0c0:	1007883a 	mov	r3,r2
 400b0c4:	e0bffe17 	ldw	r2,-8(fp)
 400b0c8:	0085c83a 	sub	r2,zero,r2
 400b0cc:	18800015 	stw	r2,0(r3)
        return -1;
 400b0d0:	00bfffc4 	movi	r2,-1
 400b0d4:	00000c06 	br	400b108 <write+0xf0>
      }
      return rval;
 400b0d8:	e0bffe17 	ldw	r2,-8(fp)
 400b0dc:	00000a06 	br	400b108 <write+0xf0>
    }
    else
    {
      ALT_ERRNO = EACCES;
 400b0e0:	400afdc0 	call	400afdc <alt_get_errno>
 400b0e4:	1007883a 	mov	r3,r2
 400b0e8:	00800344 	movi	r2,13
 400b0ec:	18800015 	stw	r2,0(r3)
 400b0f0:	00000406 	br	400b104 <write+0xec>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
 400b0f4:	400afdc0 	call	400afdc <alt_get_errno>
 400b0f8:	1007883a 	mov	r3,r2
 400b0fc:	00801444 	movi	r2,81
 400b100:	18800015 	stw	r2,0(r3)
  }
  return -1;
 400b104:	00bfffc4 	movi	r2,-1
}
 400b108:	e037883a 	mov	sp,fp
 400b10c:	dfc00117 	ldw	ra,4(sp)
 400b110:	df000017 	ldw	fp,0(sp)
 400b114:	dec00204 	addi	sp,sp,8
 400b118:	f800283a 	ret

0400b11c <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
 400b11c:	defffd04 	addi	sp,sp,-12
 400b120:	dfc00215 	stw	ra,8(sp)
 400b124:	df000115 	stw	fp,4(sp)
 400b128:	df000104 	addi	fp,sp,4
 400b12c:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
 400b130:	d1600704 	addi	r5,gp,-32740
 400b134:	e13fff17 	ldw	r4,-4(fp)
 400b138:	400bf2c0 	call	400bf2c <alt_dev_llist_insert>
}
 400b13c:	e037883a 	mov	sp,fp
 400b140:	dfc00117 	ldw	ra,4(sp)
 400b144:	df000017 	ldw	fp,0(sp)
 400b148:	dec00204 	addi	sp,sp,8
 400b14c:	f800283a 	ret

0400b150 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
 400b150:	defffd04 	addi	sp,sp,-12
 400b154:	dfc00215 	stw	ra,8(sp)
 400b158:	df000115 	stw	fp,4(sp)
 400b15c:	df000104 	addi	fp,sp,4
 400b160:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( CST455_MIDTERM, CST455_Midterm);
 400b164:	400c6c80 	call	400c6c8 <altera_nios2_gen2_irq_init>
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
 400b168:	00800044 	movi	r2,1
 400b16c:	1001703a 	wrctl	status,r2
}
 400b170:	0001883a 	nop
    alt_irq_cpu_enable_interrupts();
}
 400b174:	0001883a 	nop
 400b178:	e037883a 	mov	sp,fp
 400b17c:	dfc00117 	ldw	ra,4(sp)
 400b180:	df000017 	ldw	fp,0(sp)
 400b184:	dec00204 	addi	sp,sp,8
 400b188:	f800283a 	ret

0400b18c <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
 400b18c:	defffe04 	addi	sp,sp,-8
 400b190:	dfc00115 	stw	ra,4(sp)
 400b194:	df000015 	stw	fp,0(sp)
 400b198:	d839883a 	mov	fp,sp
    ALTERA_AVALON_TIMER_INIT ( SYS_CLK, sys_clk);
 400b19c:	01c0fa04 	movi	r7,1000
 400b1a0:	000d883a 	mov	r6,zero
 400b1a4:	000b883a 	mov	r5,zero
 400b1a8:	01020034 	movhi	r4,2048
 400b1ac:	21040004 	addi	r4,r4,4096
 400b1b0:	400bcec0 	call	400bcec <alt_avalon_timer_sc_init>
    ALTERA_AVALON_JTAG_UART_INIT ( DEBUG, DEBUG);
 400b1b4:	01800044 	movi	r6,1
 400b1b8:	000b883a 	mov	r5,zero
 400b1bc:	01010074 	movhi	r4,1025
 400b1c0:	21359e04 	addi	r4,r4,-10632
 400b1c4:	400b3500 	call	400b350 <altera_avalon_jtag_uart_init>
 400b1c8:	01010074 	movhi	r4,1025
 400b1cc:	21359404 	addi	r4,r4,-10672
 400b1d0:	400b11c0 	call	400b11c <alt_dev_reg>
}
 400b1d4:	0001883a 	nop
 400b1d8:	e037883a 	mov	sp,fp
 400b1dc:	dfc00117 	ldw	ra,4(sp)
 400b1e0:	df000017 	ldw	fp,0(sp)
 400b1e4:	dec00204 	addi	sp,sp,8
 400b1e8:	f800283a 	ret

0400b1ec <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
 400b1ec:	defffa04 	addi	sp,sp,-24
 400b1f0:	dfc00515 	stw	ra,20(sp)
 400b1f4:	df000415 	stw	fp,16(sp)
 400b1f8:	df000404 	addi	fp,sp,16
 400b1fc:	e13ffe15 	stw	r4,-8(fp)
 400b200:	e17ffd15 	stw	r5,-12(fp)
 400b204:	e1bffc15 	stw	r6,-16(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 400b208:	e0bffe17 	ldw	r2,-8(fp)
 400b20c:	10800017 	ldw	r2,0(r2)
 400b210:	e0bfff15 	stw	r2,-4(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
 400b214:	e0bfff17 	ldw	r2,-4(fp)
 400b218:	10c00a04 	addi	r3,r2,40
 400b21c:	e0bffe17 	ldw	r2,-8(fp)
 400b220:	10800217 	ldw	r2,8(r2)
 400b224:	100f883a 	mov	r7,r2
 400b228:	e1bffc17 	ldw	r6,-16(fp)
 400b22c:	e17ffd17 	ldw	r5,-12(fp)
 400b230:	1809883a 	mov	r4,r3
 400b234:	400b8280 	call	400b828 <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
 400b238:	e037883a 	mov	sp,fp
 400b23c:	dfc00117 	ldw	ra,4(sp)
 400b240:	df000017 	ldw	fp,0(sp)
 400b244:	dec00204 	addi	sp,sp,8
 400b248:	f800283a 	ret

0400b24c <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
 400b24c:	defffa04 	addi	sp,sp,-24
 400b250:	dfc00515 	stw	ra,20(sp)
 400b254:	df000415 	stw	fp,16(sp)
 400b258:	df000404 	addi	fp,sp,16
 400b25c:	e13ffe15 	stw	r4,-8(fp)
 400b260:	e17ffd15 	stw	r5,-12(fp)
 400b264:	e1bffc15 	stw	r6,-16(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 400b268:	e0bffe17 	ldw	r2,-8(fp)
 400b26c:	10800017 	ldw	r2,0(r2)
 400b270:	e0bfff15 	stw	r2,-4(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
 400b274:	e0bfff17 	ldw	r2,-4(fp)
 400b278:	10c00a04 	addi	r3,r2,40
 400b27c:	e0bffe17 	ldw	r2,-8(fp)
 400b280:	10800217 	ldw	r2,8(r2)
 400b284:	100f883a 	mov	r7,r2
 400b288:	e1bffc17 	ldw	r6,-16(fp)
 400b28c:	e17ffd17 	ldw	r5,-12(fp)
 400b290:	1809883a 	mov	r4,r3
 400b294:	400ba480 	call	400ba48 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
 400b298:	e037883a 	mov	sp,fp
 400b29c:	dfc00117 	ldw	ra,4(sp)
 400b2a0:	df000017 	ldw	fp,0(sp)
 400b2a4:	dec00204 	addi	sp,sp,8
 400b2a8:	f800283a 	ret

0400b2ac <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
 400b2ac:	defffc04 	addi	sp,sp,-16
 400b2b0:	dfc00315 	stw	ra,12(sp)
 400b2b4:	df000215 	stw	fp,8(sp)
 400b2b8:	df000204 	addi	fp,sp,8
 400b2bc:	e13ffe15 	stw	r4,-8(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 400b2c0:	e0bffe17 	ldw	r2,-8(fp)
 400b2c4:	10800017 	ldw	r2,0(r2)
 400b2c8:	e0bfff15 	stw	r2,-4(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
 400b2cc:	e0bfff17 	ldw	r2,-4(fp)
 400b2d0:	10c00a04 	addi	r3,r2,40
 400b2d4:	e0bffe17 	ldw	r2,-8(fp)
 400b2d8:	10800217 	ldw	r2,8(r2)
 400b2dc:	100b883a 	mov	r5,r2
 400b2e0:	1809883a 	mov	r4,r3
 400b2e4:	400b6cc0 	call	400b6cc <altera_avalon_jtag_uart_close>
}
 400b2e8:	e037883a 	mov	sp,fp
 400b2ec:	dfc00117 	ldw	ra,4(sp)
 400b2f0:	df000017 	ldw	fp,0(sp)
 400b2f4:	dec00204 	addi	sp,sp,8
 400b2f8:	f800283a 	ret

0400b2fc <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
 400b2fc:	defffa04 	addi	sp,sp,-24
 400b300:	dfc00515 	stw	ra,20(sp)
 400b304:	df000415 	stw	fp,16(sp)
 400b308:	df000404 	addi	fp,sp,16
 400b30c:	e13ffe15 	stw	r4,-8(fp)
 400b310:	e17ffd15 	stw	r5,-12(fp)
 400b314:	e1bffc15 	stw	r6,-16(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
 400b318:	e0bffe17 	ldw	r2,-8(fp)
 400b31c:	10800017 	ldw	r2,0(r2)
 400b320:	e0bfff15 	stw	r2,-4(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
 400b324:	e0bfff17 	ldw	r2,-4(fp)
 400b328:	10800a04 	addi	r2,r2,40
 400b32c:	e1bffc17 	ldw	r6,-16(fp)
 400b330:	e17ffd17 	ldw	r5,-12(fp)
 400b334:	1009883a 	mov	r4,r2
 400b338:	400b7340 	call	400b734 <altera_avalon_jtag_uart_ioctl>
}
 400b33c:	e037883a 	mov	sp,fp
 400b340:	dfc00117 	ldw	ra,4(sp)
 400b344:	df000017 	ldw	fp,0(sp)
 400b348:	dec00204 	addi	sp,sp,8
 400b34c:	f800283a 	ret

0400b350 <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
 400b350:	defffa04 	addi	sp,sp,-24
 400b354:	dfc00515 	stw	ra,20(sp)
 400b358:	df000415 	stw	fp,16(sp)
 400b35c:	df000404 	addi	fp,sp,16
 400b360:	e13fff15 	stw	r4,-4(fp)
 400b364:	e17ffe15 	stw	r5,-8(fp)
 400b368:	e1bffd15 	stw	r6,-12(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
  ALT_SEM_CREATE(&sp->read_lock, 1);
  ALT_SEM_CREATE(&sp->write_lock, 1);

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 400b36c:	e0bfff17 	ldw	r2,-4(fp)
 400b370:	00c00044 	movi	r3,1
 400b374:	10c00815 	stw	r3,32(r2)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
 400b378:	e0bfff17 	ldw	r2,-4(fp)
 400b37c:	10800017 	ldw	r2,0(r2)
 400b380:	10800104 	addi	r2,r2,4
 400b384:	1007883a 	mov	r3,r2
 400b388:	e0bfff17 	ldw	r2,-4(fp)
 400b38c:	10800817 	ldw	r2,32(r2)
 400b390:	18800035 	stwio	r2,0(r3)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
 400b394:	e0bffe17 	ldw	r2,-8(fp)
 400b398:	e0fffd17 	ldw	r3,-12(fp)
 400b39c:	d8000015 	stw	zero,0(sp)
 400b3a0:	e1ffff17 	ldw	r7,-4(fp)
 400b3a4:	01810074 	movhi	r6,1025
 400b3a8:	31ad0404 	addi	r6,r6,-19440
 400b3ac:	180b883a 	mov	r5,r3
 400b3b0:	1009883a 	mov	r4,r2
 400b3b4:	400a7200 	call	400a720 <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
 400b3b8:	e0bfff17 	ldw	r2,-4(fp)
 400b3bc:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
 400b3c0:	e0bfff17 	ldw	r2,-4(fp)
 400b3c4:	10800204 	addi	r2,r2,8
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 400b3c8:	d0e6c717 	ldw	r3,-25828(gp)
 400b3cc:	e1ffff17 	ldw	r7,-4(fp)
 400b3d0:	01810074 	movhi	r6,1025
 400b3d4:	31ad8904 	addi	r6,r6,-18908
 400b3d8:	180b883a 	mov	r5,r3
 400b3dc:	1009883a 	mov	r4,r2
 400b3e0:	400bd700 	call	400bd70 <alt_alarm_start>
 400b3e4:	1000040e 	bge	r2,zero,400b3f8 <altera_avalon_jtag_uart_init+0xa8>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
 400b3e8:	e0ffff17 	ldw	r3,-4(fp)
 400b3ec:	00a00034 	movhi	r2,32768
 400b3f0:	10bfffc4 	addi	r2,r2,-1
 400b3f4:	18800115 	stw	r2,4(r3)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
}
 400b3f8:	0001883a 	nop
 400b3fc:	e037883a 	mov	sp,fp
 400b400:	dfc00117 	ldw	ra,4(sp)
 400b404:	df000017 	ldw	fp,0(sp)
 400b408:	dec00204 	addi	sp,sp,8
 400b40c:	f800283a 	ret

0400b410 <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
 400b410:	defff704 	addi	sp,sp,-36
 400b414:	df000815 	stw	fp,32(sp)
 400b418:	df000804 	addi	fp,sp,32
 400b41c:	e13ff815 	stw	r4,-32(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
 400b420:	e0bff817 	ldw	r2,-32(fp)
 400b424:	e0bffc15 	stw	r2,-16(fp)
  unsigned int base = sp->base;
 400b428:	e0bffc17 	ldw	r2,-16(fp)
 400b42c:	10800017 	ldw	r2,0(r2)
 400b430:	e0bffb15 	stw	r2,-20(fp)
  unsigned int postflag=0;
 400b434:	e03fff15 	stw	zero,-4(fp)
  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 400b438:	e0bffb17 	ldw	r2,-20(fp)
 400b43c:	10800104 	addi	r2,r2,4
 400b440:	10800037 	ldwio	r2,0(r2)
 400b444:	e0bffa15 	stw	r2,-24(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
 400b448:	e0bffa17 	ldw	r2,-24(fp)
 400b44c:	1080c00c 	andi	r2,r2,768
 400b450:	10006e26 	beq	r2,zero,400b60c <altera_avalon_jtag_uart_irq+0x1fc>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
 400b454:	e0bffa17 	ldw	r2,-24(fp)
 400b458:	1080400c 	andi	r2,r2,256
 400b45c:	10003526 	beq	r2,zero,400b534 <altera_avalon_jtag_uart_irq+0x124>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
 400b460:	00800074 	movhi	r2,1
 400b464:	e0bffe15 	stw	r2,-8(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 400b468:	e0bffc17 	ldw	r2,-16(fp)
 400b46c:	10800a17 	ldw	r2,40(r2)
 400b470:	10800044 	addi	r2,r2,1
 400b474:	1081ffcc 	andi	r2,r2,2047
 400b478:	e0bff915 	stw	r2,-28(fp)
        if (next == sp->rx_out)
 400b47c:	e0bffc17 	ldw	r2,-16(fp)
 400b480:	10800b17 	ldw	r2,44(r2)
 400b484:	e0fff917 	ldw	r3,-28(fp)
 400b488:	18801526 	beq	r3,r2,400b4e0 <altera_avalon_jtag_uart_irq+0xd0>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
 400b48c:	e0bffb17 	ldw	r2,-20(fp)
 400b490:	10800037 	ldwio	r2,0(r2)
 400b494:	e0bffe15 	stw	r2,-8(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
 400b498:	e0bffe17 	ldw	r2,-8(fp)
 400b49c:	10a0000c 	andi	r2,r2,32768
 400b4a0:	10001126 	beq	r2,zero,400b4e8 <altera_avalon_jtag_uart_irq+0xd8>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
 400b4a4:	e0bffc17 	ldw	r2,-16(fp)
 400b4a8:	10800a17 	ldw	r2,40(r2)
 400b4ac:	e0fffe17 	ldw	r3,-8(fp)
 400b4b0:	1809883a 	mov	r4,r3
 400b4b4:	e0fffc17 	ldw	r3,-16(fp)
 400b4b8:	1885883a 	add	r2,r3,r2
 400b4bc:	11000e05 	stb	r4,56(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 400b4c0:	e0bffc17 	ldw	r2,-16(fp)
 400b4c4:	10800a17 	ldw	r2,40(r2)
 400b4c8:	10800044 	addi	r2,r2,1
 400b4cc:	10c1ffcc 	andi	r3,r2,2047
 400b4d0:	e0bffc17 	ldw	r2,-16(fp)
 400b4d4:	10c00a15 	stw	r3,40(r2)
 * HAL.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_no_error (void)
{
  return 0;
 400b4d8:	0001883a 	nop
      {
 400b4dc:	003fe206 	br	400b468 <altera_avalon_jtag_uart_irq+0x58>
          break;
 400b4e0:	0001883a 	nop
 400b4e4:	00000106 	br	400b4ec <altera_avalon_jtag_uart_irq+0xdc>
          break;
 400b4e8:	0001883a 	nop

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, ALT_FLAG_SET);
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
 400b4ec:	e0bffe17 	ldw	r2,-8(fp)
 400b4f0:	00ffffd4 	movui	r3,65535
 400b4f4:	18800f2e 	bgeu	r3,r2,400b534 <altera_avalon_jtag_uart_irq+0x124>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 400b4f8:	e0bffc17 	ldw	r2,-16(fp)
 400b4fc:	10c00817 	ldw	r3,32(r2)
 400b500:	00bfff84 	movi	r2,-2
 400b504:	1886703a 	and	r3,r3,r2
 400b508:	e0bffc17 	ldw	r2,-16(fp)
 400b50c:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
 400b510:	e0bffb17 	ldw	r2,-20(fp)
 400b514:	10800104 	addi	r2,r2,4
 400b518:	1007883a 	mov	r3,r2
 400b51c:	e0bffc17 	ldw	r2,-16(fp)
 400b520:	10800817 	ldw	r2,32(r2)
 400b524:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 400b528:	e0bffb17 	ldw	r2,-20(fp)
 400b52c:	10800104 	addi	r2,r2,4
 400b530:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
 400b534:	e0bffa17 	ldw	r2,-24(fp)
 400b538:	1080800c 	andi	r2,r2,512
 400b53c:	103fbe26 	beq	r2,zero,400b438 <altera_avalon_jtag_uart_irq+0x28>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
 400b540:	e0bffa17 	ldw	r2,-24(fp)
 400b544:	1004d43a 	srli	r2,r2,16
 400b548:	e0bffd15 	stw	r2,-12(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
 400b54c:	00001506 	br	400b5a4 <altera_avalon_jtag_uart_irq+0x194>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
 400b550:	e0bffb17 	ldw	r2,-20(fp)
 400b554:	e0fffc17 	ldw	r3,-16(fp)
 400b558:	18c00d17 	ldw	r3,52(r3)
 400b55c:	e13ffc17 	ldw	r4,-16(fp)
 400b560:	20c7883a 	add	r3,r4,r3
 400b564:	18c20e03 	ldbu	r3,2104(r3)
 400b568:	18c03fcc 	andi	r3,r3,255
 400b56c:	18c0201c 	xori	r3,r3,128
 400b570:	18ffe004 	addi	r3,r3,-128
 400b574:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 400b578:	e0bffc17 	ldw	r2,-16(fp)
 400b57c:	10800d17 	ldw	r2,52(r2)
 400b580:	10800044 	addi	r2,r2,1
 400b584:	10c1ffcc 	andi	r3,r2,2047
 400b588:	e0bffc17 	ldw	r2,-16(fp)
 400b58c:	10c00d15 	stw	r3,52(r2)
        
        /* indicate that the ALT_FLAG_POST routine must be called */
        postflag=1;
 400b590:	00800044 	movi	r2,1
 400b594:	e0bfff15 	stw	r2,-4(fp)

        space--;
 400b598:	e0bffd17 	ldw	r2,-12(fp)
 400b59c:	10bfffc4 	addi	r2,r2,-1
 400b5a0:	e0bffd15 	stw	r2,-12(fp)
      while (space > 0 && sp->tx_out != sp->tx_in)
 400b5a4:	e0bffd17 	ldw	r2,-12(fp)
 400b5a8:	10000526 	beq	r2,zero,400b5c0 <altera_avalon_jtag_uart_irq+0x1b0>
 400b5ac:	e0bffc17 	ldw	r2,-16(fp)
 400b5b0:	10c00d17 	ldw	r3,52(r2)
 400b5b4:	e0bffc17 	ldw	r2,-16(fp)
 400b5b8:	10800c17 	ldw	r2,48(r2)
 400b5bc:	18bfe41e 	bne	r3,r2,400b550 <altera_avalon_jtag_uart_irq+0x140>
      {
        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, ALT_FLAG_SET);
      }

      if (space > 0)
 400b5c0:	e0bffd17 	ldw	r2,-12(fp)
 400b5c4:	103f9c26 	beq	r2,zero,400b438 <altera_avalon_jtag_uart_irq+0x28>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 400b5c8:	e0bffc17 	ldw	r2,-16(fp)
 400b5cc:	10c00817 	ldw	r3,32(r2)
 400b5d0:	00bfff44 	movi	r2,-3
 400b5d4:	1886703a 	and	r3,r3,r2
 400b5d8:	e0bffc17 	ldw	r2,-16(fp)
 400b5dc:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 400b5e0:	e0bffc17 	ldw	r2,-16(fp)
 400b5e4:	10800017 	ldw	r2,0(r2)
 400b5e8:	10800104 	addi	r2,r2,4
 400b5ec:	1007883a 	mov	r3,r2
 400b5f0:	e0bffc17 	ldw	r2,-16(fp)
 400b5f4:	10800817 	ldw	r2,32(r2)
 400b5f8:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 400b5fc:	e0bffb17 	ldw	r2,-20(fp)
 400b600:	10800104 	addi	r2,r2,4
 400b604:	10800037 	ldwio	r2,0(r2)
  {
 400b608:	003f8b06 	br	400b438 <altera_avalon_jtag_uart_irq+0x28>
      break;
 400b60c:	0001883a 	nop
      }
    }
  }
}
 400b610:	0001883a 	nop
 400b614:	e037883a 	mov	sp,fp
 400b618:	df000017 	ldw	fp,0(sp)
 400b61c:	dec00104 	addi	sp,sp,4
 400b620:	f800283a 	ret

0400b624 <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
 400b624:	defffc04 	addi	sp,sp,-16
 400b628:	df000315 	stw	fp,12(sp)
 400b62c:	df000304 	addi	fp,sp,12
 400b630:	e13ffd15 	stw	r4,-12(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
 400b634:	e0bffd17 	ldw	r2,-12(fp)
 400b638:	e0bfff15 	stw	r2,-4(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
 400b63c:	e0bfff17 	ldw	r2,-4(fp)
 400b640:	10800017 	ldw	r2,0(r2)
 400b644:	10800104 	addi	r2,r2,4
 400b648:	10800037 	ldwio	r2,0(r2)
 400b64c:	e0bffe15 	stw	r2,-8(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
 400b650:	e0bffe17 	ldw	r2,-8(fp)
 400b654:	1081000c 	andi	r2,r2,1024
 400b658:	10000b26 	beq	r2,zero,400b688 <altera_avalon_jtag_uart_timeout+0x64>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
 400b65c:	e0bfff17 	ldw	r2,-4(fp)
 400b660:	10800017 	ldw	r2,0(r2)
 400b664:	10800104 	addi	r2,r2,4
 400b668:	1007883a 	mov	r3,r2
 400b66c:	e0bfff17 	ldw	r2,-4(fp)
 400b670:	10800817 	ldw	r2,32(r2)
 400b674:	10810014 	ori	r2,r2,1024
 400b678:	18800035 	stwio	r2,0(r3)
    sp->host_inactive = 0;
 400b67c:	e0bfff17 	ldw	r2,-4(fp)
 400b680:	10000915 	stw	zero,36(r2)
 400b684:	00000c06 	br	400b6b8 <altera_avalon_jtag_uart_timeout+0x94>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
 400b688:	e0bfff17 	ldw	r2,-4(fp)
 400b68c:	10c00917 	ldw	r3,36(r2)
 400b690:	00a00034 	movhi	r2,32768
 400b694:	10bfff04 	addi	r2,r2,-4
 400b698:	10c00736 	bltu	r2,r3,400b6b8 <altera_avalon_jtag_uart_timeout+0x94>
    sp->host_inactive++;
 400b69c:	e0bfff17 	ldw	r2,-4(fp)
 400b6a0:	10800917 	ldw	r2,36(r2)
 400b6a4:	10c00044 	addi	r3,r2,1
 400b6a8:	e0bfff17 	ldw	r2,-4(fp)
 400b6ac:	10c00915 	stw	r3,36(r2)
    
    if (sp->host_inactive >= sp->timeout) {
 400b6b0:	e0bfff17 	ldw	r2,-4(fp)
 400b6b4:	10800917 	ldw	r2,36(r2)
 400b6b8:	d0a6c717 	ldw	r2,-25828(gp)
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, ALT_FLAG_SET);
    }
  }

  return alt_ticks_per_second();
}
 400b6bc:	e037883a 	mov	sp,fp
 400b6c0:	df000017 	ldw	fp,0(sp)
 400b6c4:	dec00104 	addi	sp,sp,4
 400b6c8:	f800283a 	ret

0400b6cc <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
 400b6cc:	defffd04 	addi	sp,sp,-12
 400b6d0:	df000215 	stw	fp,8(sp)
 400b6d4:	df000204 	addi	fp,sp,8
 400b6d8:	e13fff15 	stw	r4,-4(fp)
 400b6dc:	e17ffe15 	stw	r5,-8(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 400b6e0:	00000506 	br	400b6f8 <altera_avalon_jtag_uart_close+0x2c>
    if (flags & O_NONBLOCK) {
 400b6e4:	e0bffe17 	ldw	r2,-8(fp)
 400b6e8:	1090000c 	andi	r2,r2,16384
 400b6ec:	10000226 	beq	r2,zero,400b6f8 <altera_avalon_jtag_uart_close+0x2c>
      return -EWOULDBLOCK; 
 400b6f0:	00bffd44 	movi	r2,-11
 400b6f4:	00000b06 	br	400b724 <altera_avalon_jtag_uart_close+0x58>
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 400b6f8:	e0bfff17 	ldw	r2,-4(fp)
 400b6fc:	10c00d17 	ldw	r3,52(r2)
 400b700:	e0bfff17 	ldw	r2,-4(fp)
 400b704:	10800c17 	ldw	r2,48(r2)
 400b708:	18800526 	beq	r3,r2,400b720 <altera_avalon_jtag_uart_close+0x54>
 400b70c:	e0bfff17 	ldw	r2,-4(fp)
 400b710:	10c00917 	ldw	r3,36(r2)
 400b714:	e0bfff17 	ldw	r2,-4(fp)
 400b718:	10800117 	ldw	r2,4(r2)
 400b71c:	18bff136 	bltu	r3,r2,400b6e4 <altera_avalon_jtag_uart_close+0x18>
    }
  }

  return 0;
 400b720:	0005883a 	mov	r2,zero
}
 400b724:	e037883a 	mov	sp,fp
 400b728:	df000017 	ldw	fp,0(sp)
 400b72c:	dec00104 	addi	sp,sp,4
 400b730:	f800283a 	ret

0400b734 <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
 400b734:	defffa04 	addi	sp,sp,-24
 400b738:	df000515 	stw	fp,20(sp)
 400b73c:	df000504 	addi	fp,sp,20
 400b740:	e13ffd15 	stw	r4,-12(fp)
 400b744:	e17ffc15 	stw	r5,-16(fp)
 400b748:	e1bffb15 	stw	r6,-20(fp)
  int rc = -ENOTTY;
 400b74c:	00bff9c4 	movi	r2,-25
 400b750:	e0bfff15 	stw	r2,-4(fp)

  switch (req)
 400b754:	e0bffc17 	ldw	r2,-16(fp)
 400b758:	109a8060 	cmpeqi	r2,r2,27137
 400b75c:	1000041e 	bne	r2,zero,400b770 <altera_avalon_jtag_uart_ioctl+0x3c>
 400b760:	e0bffc17 	ldw	r2,-16(fp)
 400b764:	109a80a0 	cmpeqi	r2,r2,27138
 400b768:	1000181e 	bne	r2,zero,400b7cc <altera_avalon_jtag_uart_ioctl+0x98>
      rc = 0;
    }
    break;

  default:
    break;
 400b76c:	00002906 	br	400b814 <altera_avalon_jtag_uart_ioctl+0xe0>
    if (sp->timeout != INT_MAX)
 400b770:	e0bffd17 	ldw	r2,-12(fp)
 400b774:	10c00117 	ldw	r3,4(r2)
 400b778:	00a00034 	movhi	r2,32768
 400b77c:	10bfffc4 	addi	r2,r2,-1
 400b780:	18802126 	beq	r3,r2,400b808 <altera_avalon_jtag_uart_ioctl+0xd4>
      int timeout = *((int *)arg);
 400b784:	e0bffb17 	ldw	r2,-20(fp)
 400b788:	10800017 	ldw	r2,0(r2)
 400b78c:	e0bffe15 	stw	r2,-8(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
 400b790:	e0bffe17 	ldw	r2,-8(fp)
 400b794:	10800090 	cmplti	r2,r2,2
 400b798:	1000061e 	bne	r2,zero,400b7b4 <altera_avalon_jtag_uart_ioctl+0x80>
 400b79c:	e0fffe17 	ldw	r3,-8(fp)
 400b7a0:	00a00034 	movhi	r2,32768
 400b7a4:	10bfffc4 	addi	r2,r2,-1
 400b7a8:	18800226 	beq	r3,r2,400b7b4 <altera_avalon_jtag_uart_ioctl+0x80>
 400b7ac:	e0bffe17 	ldw	r2,-8(fp)
 400b7b0:	00000206 	br	400b7bc <altera_avalon_jtag_uart_ioctl+0x88>
 400b7b4:	00a00034 	movhi	r2,32768
 400b7b8:	10bfff84 	addi	r2,r2,-2
 400b7bc:	e0fffd17 	ldw	r3,-12(fp)
 400b7c0:	18800115 	stw	r2,4(r3)
      rc = 0;
 400b7c4:	e03fff15 	stw	zero,-4(fp)
    break;
 400b7c8:	00000f06 	br	400b808 <altera_avalon_jtag_uart_ioctl+0xd4>
    if (sp->timeout != INT_MAX)
 400b7cc:	e0bffd17 	ldw	r2,-12(fp)
 400b7d0:	10c00117 	ldw	r3,4(r2)
 400b7d4:	00a00034 	movhi	r2,32768
 400b7d8:	10bfffc4 	addi	r2,r2,-1
 400b7dc:	18800c26 	beq	r3,r2,400b810 <altera_avalon_jtag_uart_ioctl+0xdc>
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
 400b7e0:	e0bffd17 	ldw	r2,-12(fp)
 400b7e4:	10c00917 	ldw	r3,36(r2)
 400b7e8:	e0bffd17 	ldw	r2,-12(fp)
 400b7ec:	10800117 	ldw	r2,4(r2)
 400b7f0:	1885803a 	cmpltu	r2,r3,r2
 400b7f4:	10c03fcc 	andi	r3,r2,255
 400b7f8:	e0bffb17 	ldw	r2,-20(fp)
 400b7fc:	10c00015 	stw	r3,0(r2)
      rc = 0;
 400b800:	e03fff15 	stw	zero,-4(fp)
    break;
 400b804:	00000206 	br	400b810 <altera_avalon_jtag_uart_ioctl+0xdc>
    break;
 400b808:	0001883a 	nop
 400b80c:	00000106 	br	400b814 <altera_avalon_jtag_uart_ioctl+0xe0>
    break;
 400b810:	0001883a 	nop
  }

  return rc;
 400b814:	e0bfff17 	ldw	r2,-4(fp)
}
 400b818:	e037883a 	mov	sp,fp
 400b81c:	df000017 	ldw	fp,0(sp)
 400b820:	dec00104 	addi	sp,sp,4
 400b824:	f800283a 	ret

0400b828 <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
 400b828:	defff304 	addi	sp,sp,-52
 400b82c:	dfc00c15 	stw	ra,48(sp)
 400b830:	df000b15 	stw	fp,44(sp)
 400b834:	df000b04 	addi	fp,sp,44
 400b838:	e13ff815 	stw	r4,-32(fp)
 400b83c:	e17ff715 	stw	r5,-36(fp)
 400b840:	e1bff615 	stw	r6,-40(fp)
 400b844:	e1fff515 	stw	r7,-44(fp)
  char * ptr = buffer;
 400b848:	e0bff717 	ldw	r2,-36(fp)
 400b84c:	e0bfff15 	stw	r2,-4(fp)
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
 400b850:	00004706 	br	400b970 <altera_avalon_jtag_uart_read+0x148>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
 400b854:	e0bff817 	ldw	r2,-32(fp)
 400b858:	10800a17 	ldw	r2,40(r2)
 400b85c:	e0bffd15 	stw	r2,-12(fp)
      out = sp->rx_out;
 400b860:	e0bff817 	ldw	r2,-32(fp)
 400b864:	10800b17 	ldw	r2,44(r2)
 400b868:	e0bffc15 	stw	r2,-16(fp)

      if (in >= out)
 400b86c:	e0fffd17 	ldw	r3,-12(fp)
 400b870:	e0bffc17 	ldw	r2,-16(fp)
 400b874:	18800536 	bltu	r3,r2,400b88c <altera_avalon_jtag_uart_read+0x64>
        n = in - out;
 400b878:	e0fffd17 	ldw	r3,-12(fp)
 400b87c:	e0bffc17 	ldw	r2,-16(fp)
 400b880:	1885c83a 	sub	r2,r3,r2
 400b884:	e0bffe15 	stw	r2,-8(fp)
 400b888:	00000406 	br	400b89c <altera_avalon_jtag_uart_read+0x74>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
 400b88c:	00c20004 	movi	r3,2048
 400b890:	e0bffc17 	ldw	r2,-16(fp)
 400b894:	1885c83a 	sub	r2,r3,r2
 400b898:	e0bffe15 	stw	r2,-8(fp)

      if (n == 0)
 400b89c:	e0bffe17 	ldw	r2,-8(fp)
 400b8a0:	10001e26 	beq	r2,zero,400b91c <altera_avalon_jtag_uart_read+0xf4>
        break; /* No more data available */

      if (n > space)
 400b8a4:	e0fff617 	ldw	r3,-40(fp)
 400b8a8:	e0bffe17 	ldw	r2,-8(fp)
 400b8ac:	1880022e 	bgeu	r3,r2,400b8b8 <altera_avalon_jtag_uart_read+0x90>
        n = space;
 400b8b0:	e0bff617 	ldw	r2,-40(fp)
 400b8b4:	e0bffe15 	stw	r2,-8(fp)

      memcpy(ptr, sp->rx_buf + out, n);
 400b8b8:	e0bff817 	ldw	r2,-32(fp)
 400b8bc:	10c00e04 	addi	r3,r2,56
 400b8c0:	e0bffc17 	ldw	r2,-16(fp)
 400b8c4:	1885883a 	add	r2,r3,r2
 400b8c8:	e1bffe17 	ldw	r6,-8(fp)
 400b8cc:	100b883a 	mov	r5,r2
 400b8d0:	e13fff17 	ldw	r4,-4(fp)
 400b8d4:	40078800 	call	4007880 <memcpy>
      ptr   += n;
 400b8d8:	e0ffff17 	ldw	r3,-4(fp)
 400b8dc:	e0bffe17 	ldw	r2,-8(fp)
 400b8e0:	1885883a 	add	r2,r3,r2
 400b8e4:	e0bfff15 	stw	r2,-4(fp)
      space -= n;
 400b8e8:	e0fff617 	ldw	r3,-40(fp)
 400b8ec:	e0bffe17 	ldw	r2,-8(fp)
 400b8f0:	1885c83a 	sub	r2,r3,r2
 400b8f4:	e0bff615 	stw	r2,-40(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 400b8f8:	e0fffc17 	ldw	r3,-16(fp)
 400b8fc:	e0bffe17 	ldw	r2,-8(fp)
 400b900:	1885883a 	add	r2,r3,r2
 400b904:	10c1ffcc 	andi	r3,r2,2047
 400b908:	e0bff817 	ldw	r2,-32(fp)
 400b90c:	10c00b15 	stw	r3,44(r2)
    }
    while (space > 0);
 400b910:	e0bff617 	ldw	r2,-40(fp)
 400b914:	00bfcf16 	blt	zero,r2,400b854 <altera_avalon_jtag_uart_read+0x2c>
 400b918:	00000106 	br	400b920 <altera_avalon_jtag_uart_read+0xf8>
        break; /* No more data available */
 400b91c:	0001883a 	nop

    /* If we read any data then return it */
    if (ptr != buffer)
 400b920:	e0ffff17 	ldw	r3,-4(fp)
 400b924:	e0bff717 	ldw	r2,-36(fp)
 400b928:	1880141e 	bne	r3,r2,400b97c <altera_avalon_jtag_uart_read+0x154>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
 400b92c:	e0bff517 	ldw	r2,-44(fp)
 400b930:	1090000c 	andi	r2,r2,16384
 400b934:	1000131e 	bne	r2,zero,400b984 <altera_avalon_jtag_uart_read+0x15c>
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
        ;
    }
#else
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
 400b938:	0001883a 	nop
 400b93c:	e0bff817 	ldw	r2,-32(fp)
 400b940:	10800a17 	ldw	r2,40(r2)
 400b944:	e0fffd17 	ldw	r3,-12(fp)
 400b948:	1880051e 	bne	r3,r2,400b960 <altera_avalon_jtag_uart_read+0x138>
 400b94c:	e0bff817 	ldw	r2,-32(fp)
 400b950:	10c00917 	ldw	r3,36(r2)
 400b954:	e0bff817 	ldw	r2,-32(fp)
 400b958:	10800117 	ldw	r2,4(r2)
 400b95c:	18bff736 	bltu	r3,r2,400b93c <altera_avalon_jtag_uart_read+0x114>
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
 400b960:	e0bff817 	ldw	r2,-32(fp)
 400b964:	10800a17 	ldw	r2,40(r2)
 400b968:	e0fffd17 	ldw	r3,-12(fp)
 400b96c:	18800726 	beq	r3,r2,400b98c <altera_avalon_jtag_uart_read+0x164>
  while (space > 0)
 400b970:	e0bff617 	ldw	r2,-40(fp)
 400b974:	00bfb716 	blt	zero,r2,400b854 <altera_avalon_jtag_uart_read+0x2c>
 400b978:	00000506 	br	400b990 <altera_avalon_jtag_uart_read+0x168>
      break;
 400b97c:	0001883a 	nop
 400b980:	00000306 	br	400b990 <altera_avalon_jtag_uart_read+0x168>
      break;
 400b984:	0001883a 	nop
 400b988:	00000106 	br	400b990 <altera_avalon_jtag_uart_read+0x168>
      break;
 400b98c:	0001883a 	nop
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);

  if (ptr != buffer)
 400b990:	e0ffff17 	ldw	r3,-4(fp)
 400b994:	e0bff717 	ldw	r2,-36(fp)
 400b998:	18801926 	beq	r3,r2,400ba00 <altera_avalon_jtag_uart_read+0x1d8>
  NIOS2_READ_STATUS (context);
 400b99c:	0005303a 	rdctl	r2,status
 400b9a0:	e0bff915 	stw	r2,-28(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 400b9a4:	e0fff917 	ldw	r3,-28(fp)
 400b9a8:	00bfff84 	movi	r2,-2
 400b9ac:	1884703a 	and	r2,r3,r2
 400b9b0:	1001703a 	wrctl	status,r2
  return context;
 400b9b4:	e0bff917 	ldw	r2,-28(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
 400b9b8:	e0bffb15 	stw	r2,-20(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 400b9bc:	e0bff817 	ldw	r2,-32(fp)
 400b9c0:	10800817 	ldw	r2,32(r2)
 400b9c4:	10c00054 	ori	r3,r2,1
 400b9c8:	e0bff817 	ldw	r2,-32(fp)
 400b9cc:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 400b9d0:	e0bff817 	ldw	r2,-32(fp)
 400b9d4:	10800017 	ldw	r2,0(r2)
 400b9d8:	10800104 	addi	r2,r2,4
 400b9dc:	1007883a 	mov	r3,r2
 400b9e0:	e0bff817 	ldw	r2,-32(fp)
 400b9e4:	10800817 	ldw	r2,32(r2)
 400b9e8:	18800035 	stwio	r2,0(r3)
 400b9ec:	e0bffb17 	ldw	r2,-20(fp)
 400b9f0:	e0bffa15 	stw	r2,-24(fp)
  NIOS2_WRITE_STATUS (context);
 400b9f4:	e0bffa17 	ldw	r2,-24(fp)
 400b9f8:	1001703a 	wrctl	status,r2
}
 400b9fc:	0001883a 	nop
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
 400ba00:	e0ffff17 	ldw	r3,-4(fp)
 400ba04:	e0bff717 	ldw	r2,-36(fp)
 400ba08:	18800426 	beq	r3,r2,400ba1c <altera_avalon_jtag_uart_read+0x1f4>
    return ptr - buffer;
 400ba0c:	e0ffff17 	ldw	r3,-4(fp)
 400ba10:	e0bff717 	ldw	r2,-36(fp)
 400ba14:	1885c83a 	sub	r2,r3,r2
 400ba18:	00000606 	br	400ba34 <altera_avalon_jtag_uart_read+0x20c>
  else if (flags & O_NONBLOCK)
 400ba1c:	e0bff517 	ldw	r2,-44(fp)
 400ba20:	1090000c 	andi	r2,r2,16384
 400ba24:	10000226 	beq	r2,zero,400ba30 <altera_avalon_jtag_uart_read+0x208>
    return -EWOULDBLOCK;
 400ba28:	00bffd44 	movi	r2,-11
 400ba2c:	00000106 	br	400ba34 <altera_avalon_jtag_uart_read+0x20c>
  else
    return -EIO;
 400ba30:	00bffec4 	movi	r2,-5
}
 400ba34:	e037883a 	mov	sp,fp
 400ba38:	dfc00117 	ldw	ra,4(sp)
 400ba3c:	df000017 	ldw	fp,0(sp)
 400ba40:	dec00204 	addi	sp,sp,8
 400ba44:	f800283a 	ret

0400ba48 <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
 400ba48:	defff304 	addi	sp,sp,-52
 400ba4c:	dfc00c15 	stw	ra,48(sp)
 400ba50:	df000b15 	stw	fp,44(sp)
 400ba54:	df000b04 	addi	fp,sp,44
 400ba58:	e13ff815 	stw	r4,-32(fp)
 400ba5c:	e17ff715 	stw	r5,-36(fp)
 400ba60:	e1bff615 	stw	r6,-40(fp)
 400ba64:	e1fff515 	stw	r7,-44(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
 400ba68:	e03fff15 	stw	zero,-4(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
 400ba6c:	e0bff717 	ldw	r2,-36(fp)
 400ba70:	e0bffd15 	stw	r2,-12(fp)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
 400ba74:	00003706 	br	400bb54 <altera_avalon_jtag_uart_write+0x10c>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
 400ba78:	e0bff817 	ldw	r2,-32(fp)
 400ba7c:	10800c17 	ldw	r2,48(r2)
 400ba80:	e0bffc15 	stw	r2,-16(fp)
      out = sp->tx_out;
 400ba84:	e0bff817 	ldw	r2,-32(fp)
 400ba88:	10800d17 	ldw	r2,52(r2)
 400ba8c:	e0bfff15 	stw	r2,-4(fp)

      if (in < out)
 400ba90:	e0fffc17 	ldw	r3,-16(fp)
 400ba94:	e0bfff17 	ldw	r2,-4(fp)
 400ba98:	1880062e 	bgeu	r3,r2,400bab4 <altera_avalon_jtag_uart_write+0x6c>
        n = out - 1 - in;
 400ba9c:	e0ffff17 	ldw	r3,-4(fp)
 400baa0:	e0bffc17 	ldw	r2,-16(fp)
 400baa4:	1885c83a 	sub	r2,r3,r2
 400baa8:	10bfffc4 	addi	r2,r2,-1
 400baac:	e0bffe15 	stw	r2,-8(fp)
 400bab0:	00000b06 	br	400bae0 <altera_avalon_jtag_uart_write+0x98>
      else if (out > 0)
 400bab4:	e0bfff17 	ldw	r2,-4(fp)
 400bab8:	10000526 	beq	r2,zero,400bad0 <altera_avalon_jtag_uart_write+0x88>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
 400babc:	00c20004 	movi	r3,2048
 400bac0:	e0bffc17 	ldw	r2,-16(fp)
 400bac4:	1885c83a 	sub	r2,r3,r2
 400bac8:	e0bffe15 	stw	r2,-8(fp)
 400bacc:	00000406 	br	400bae0 <altera_avalon_jtag_uart_write+0x98>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
 400bad0:	00c1ffc4 	movi	r3,2047
 400bad4:	e0bffc17 	ldw	r2,-16(fp)
 400bad8:	1885c83a 	sub	r2,r3,r2
 400badc:	e0bffe15 	stw	r2,-8(fp)

      if (n == 0)
 400bae0:	e0bffe17 	ldw	r2,-8(fp)
 400bae4:	10001e26 	beq	r2,zero,400bb60 <altera_avalon_jtag_uart_write+0x118>
        break;

      if (n > count)
 400bae8:	e0fff617 	ldw	r3,-40(fp)
 400baec:	e0bffe17 	ldw	r2,-8(fp)
 400baf0:	1880022e 	bgeu	r3,r2,400bafc <altera_avalon_jtag_uart_write+0xb4>
        n = count;
 400baf4:	e0bff617 	ldw	r2,-40(fp)
 400baf8:	e0bffe15 	stw	r2,-8(fp)

      memcpy(sp->tx_buf + in, ptr, n);
 400bafc:	e0bff817 	ldw	r2,-32(fp)
 400bb00:	10c20e04 	addi	r3,r2,2104
 400bb04:	e0bffc17 	ldw	r2,-16(fp)
 400bb08:	1885883a 	add	r2,r3,r2
 400bb0c:	e1bffe17 	ldw	r6,-8(fp)
 400bb10:	e17ff717 	ldw	r5,-36(fp)
 400bb14:	1009883a 	mov	r4,r2
 400bb18:	40078800 	call	4007880 <memcpy>
      ptr   += n;
 400bb1c:	e0fff717 	ldw	r3,-36(fp)
 400bb20:	e0bffe17 	ldw	r2,-8(fp)
 400bb24:	1885883a 	add	r2,r3,r2
 400bb28:	e0bff715 	stw	r2,-36(fp)
      count -= n;
 400bb2c:	e0fff617 	ldw	r3,-40(fp)
 400bb30:	e0bffe17 	ldw	r2,-8(fp)
 400bb34:	1885c83a 	sub	r2,r3,r2
 400bb38:	e0bff615 	stw	r2,-40(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 400bb3c:	e0fffc17 	ldw	r3,-16(fp)
 400bb40:	e0bffe17 	ldw	r2,-8(fp)
 400bb44:	1885883a 	add	r2,r3,r2
 400bb48:	10c1ffcc 	andi	r3,r2,2047
 400bb4c:	e0bff817 	ldw	r2,-32(fp)
 400bb50:	10c00c15 	stw	r3,48(r2)
    while (count > 0)
 400bb54:	e0bff617 	ldw	r2,-40(fp)
 400bb58:	00bfc716 	blt	zero,r2,400ba78 <altera_avalon_jtag_uart_write+0x30>
 400bb5c:	00000106 	br	400bb64 <altera_avalon_jtag_uart_write+0x11c>
        break;
 400bb60:	0001883a 	nop
  NIOS2_READ_STATUS (context);
 400bb64:	0005303a 	rdctl	r2,status
 400bb68:	e0bff915 	stw	r2,-28(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 400bb6c:	e0fff917 	ldw	r3,-28(fp)
 400bb70:	00bfff84 	movi	r2,-2
 400bb74:	1884703a 	and	r2,r3,r2
 400bb78:	1001703a 	wrctl	status,r2
  return context;
 400bb7c:	e0bff917 	ldw	r2,-28(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
 400bb80:	e0bffb15 	stw	r2,-20(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 400bb84:	e0bff817 	ldw	r2,-32(fp)
 400bb88:	10800817 	ldw	r2,32(r2)
 400bb8c:	10c00094 	ori	r3,r2,2
 400bb90:	e0bff817 	ldw	r2,-32(fp)
 400bb94:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 400bb98:	e0bff817 	ldw	r2,-32(fp)
 400bb9c:	10800017 	ldw	r2,0(r2)
 400bba0:	10800104 	addi	r2,r2,4
 400bba4:	1007883a 	mov	r3,r2
 400bba8:	e0bff817 	ldw	r2,-32(fp)
 400bbac:	10800817 	ldw	r2,32(r2)
 400bbb0:	18800035 	stwio	r2,0(r3)
 400bbb4:	e0bffb17 	ldw	r2,-20(fp)
 400bbb8:	e0bffa15 	stw	r2,-24(fp)
  NIOS2_WRITE_STATUS (context);
 400bbbc:	e0bffa17 	ldw	r2,-24(fp)
 400bbc0:	1001703a 	wrctl	status,r2
}
 400bbc4:	0001883a 	nop
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
 400bbc8:	e0bff617 	ldw	r2,-40(fp)
 400bbcc:	0080100e 	bge	zero,r2,400bc10 <altera_avalon_jtag_uart_write+0x1c8>
    {
      if (flags & O_NONBLOCK)
 400bbd0:	e0bff517 	ldw	r2,-44(fp)
 400bbd4:	1090000c 	andi	r2,r2,16384
 400bbd8:	1000101e 	bne	r2,zero,400bc1c <altera_avalon_jtag_uart_write+0x1d4>
      /*
       * No OS present: Always wait for data to be removed from buffer.  Once
       * the interrupt routine has removed some data then we will be able to
       * insert some more.
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
 400bbdc:	0001883a 	nop
 400bbe0:	e0bff817 	ldw	r2,-32(fp)
 400bbe4:	10800d17 	ldw	r2,52(r2)
 400bbe8:	e0ffff17 	ldw	r3,-4(fp)
 400bbec:	1880051e 	bne	r3,r2,400bc04 <altera_avalon_jtag_uart_write+0x1bc>
 400bbf0:	e0bff817 	ldw	r2,-32(fp)
 400bbf4:	10c00917 	ldw	r3,36(r2)
 400bbf8:	e0bff817 	ldw	r2,-32(fp)
 400bbfc:	10800117 	ldw	r2,4(r2)
 400bc00:	18bff736 	bltu	r3,r2,400bbe0 <altera_avalon_jtag_uart_write+0x198>
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
 400bc04:	e0bff817 	ldw	r2,-32(fp)
 400bc08:	10800917 	ldw	r2,36(r2)
 400bc0c:	1000051e 	bne	r2,zero,400bc24 <altera_avalon_jtag_uart_write+0x1dc>
         break;
    }
  }
  while (count > 0);
 400bc10:	e0bff617 	ldw	r2,-40(fp)
 400bc14:	00bfcf16 	blt	zero,r2,400bb54 <altera_avalon_jtag_uart_write+0x10c>
 400bc18:	00000306 	br	400bc28 <altera_avalon_jtag_uart_write+0x1e0>
        break;
 400bc1c:	0001883a 	nop
 400bc20:	00000106 	br	400bc28 <altera_avalon_jtag_uart_write+0x1e0>
         break;
 400bc24:	0001883a 	nop
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);

  if (ptr != start)
 400bc28:	e0fff717 	ldw	r3,-36(fp)
 400bc2c:	e0bffd17 	ldw	r2,-12(fp)
 400bc30:	18800426 	beq	r3,r2,400bc44 <altera_avalon_jtag_uart_write+0x1fc>
    return ptr - start;
 400bc34:	e0fff717 	ldw	r3,-36(fp)
 400bc38:	e0bffd17 	ldw	r2,-12(fp)
 400bc3c:	1885c83a 	sub	r2,r3,r2
 400bc40:	00000606 	br	400bc5c <altera_avalon_jtag_uart_write+0x214>
  else if (flags & O_NONBLOCK)
 400bc44:	e0bff517 	ldw	r2,-44(fp)
 400bc48:	1090000c 	andi	r2,r2,16384
 400bc4c:	10000226 	beq	r2,zero,400bc58 <altera_avalon_jtag_uart_write+0x210>
    return -EWOULDBLOCK;
 400bc50:	00bffd44 	movi	r2,-11
 400bc54:	00000106 	br	400bc5c <altera_avalon_jtag_uart_write+0x214>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
 400bc58:	00bffec4 	movi	r2,-5
}
 400bc5c:	e037883a 	mov	sp,fp
 400bc60:	dfc00117 	ldw	ra,4(sp)
 400bc64:	df000017 	ldw	fp,0(sp)
 400bc68:	dec00204 	addi	sp,sp,8
 400bc6c:	f800283a 	ret

0400bc70 <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
 400bc70:	defffa04 	addi	sp,sp,-24
 400bc74:	dfc00515 	stw	ra,20(sp)
 400bc78:	df000415 	stw	fp,16(sp)
 400bc7c:	df000404 	addi	fp,sp,16
 400bc80:	e13ffc15 	stw	r4,-16(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
 400bc84:	0007883a 	mov	r3,zero
 400bc88:	e0bffc17 	ldw	r2,-16(fp)
 400bc8c:	10c00035 	stwio	r3,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
 400bc90:	e0bffc17 	ldw	r2,-16(fp)
 400bc94:	10800104 	addi	r2,r2,4
 400bc98:	10800037 	ldwio	r2,0(r2)
  NIOS2_READ_STATUS (context);
 400bc9c:	0005303a 	rdctl	r2,status
 400bca0:	e0bffd15 	stw	r2,-12(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 400bca4:	e0fffd17 	ldw	r3,-12(fp)
 400bca8:	00bfff84 	movi	r2,-2
 400bcac:	1884703a 	and	r2,r3,r2
 400bcb0:	1001703a 	wrctl	status,r2
  return context;
 400bcb4:	e0bffd17 	ldw	r2,-12(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
 400bcb8:	e0bfff15 	stw	r2,-4(fp)
  alt_tick ();
 400bcbc:	400c59c0 	call	400c59c <alt_tick>
 400bcc0:	e0bfff17 	ldw	r2,-4(fp)
 400bcc4:	e0bffe15 	stw	r2,-8(fp)
  NIOS2_WRITE_STATUS (context);
 400bcc8:	e0bffe17 	ldw	r2,-8(fp)
 400bccc:	1001703a 	wrctl	status,r2
}
 400bcd0:	0001883a 	nop
  alt_irq_enable_all(cpu_sr);
}
 400bcd4:	0001883a 	nop
 400bcd8:	e037883a 	mov	sp,fp
 400bcdc:	dfc00117 	ldw	ra,4(sp)
 400bce0:	df000017 	ldw	fp,0(sp)
 400bce4:	dec00204 	addi	sp,sp,8
 400bce8:	f800283a 	ret

0400bcec <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
 400bcec:	defff804 	addi	sp,sp,-32
 400bcf0:	dfc00715 	stw	ra,28(sp)
 400bcf4:	df000615 	stw	fp,24(sp)
 400bcf8:	df000604 	addi	fp,sp,24
 400bcfc:	e13ffe15 	stw	r4,-8(fp)
 400bd00:	e17ffd15 	stw	r5,-12(fp)
 400bd04:	e1bffc15 	stw	r6,-16(fp)
 400bd08:	e1fffb15 	stw	r7,-20(fp)
 400bd0c:	e0bffb17 	ldw	r2,-20(fp)
 400bd10:	e0bfff15 	stw	r2,-4(fp)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
 400bd14:	d0a6c717 	ldw	r2,-25828(gp)
 400bd18:	1000031e 	bne	r2,zero,400bd28 <alt_avalon_timer_sc_init+0x3c>
  {
    _alt_tick_rate = nticks;
 400bd1c:	e0bfff17 	ldw	r2,-4(fp)
 400bd20:	d0a6c715 	stw	r2,-25828(gp)
    return 0;
 400bd24:	00000106 	br	400bd2c <alt_avalon_timer_sc_init+0x40>
  }
  else
  {
    return -1;
 400bd28:	0001883a 	nop
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
 400bd2c:	e0bffe17 	ldw	r2,-8(fp)
 400bd30:	10800104 	addi	r2,r2,4
 400bd34:	00c001c4 	movi	r3,7
 400bd38:	10c00035 	stwio	r3,0(r2)
            ALTERA_AVALON_TIMER_CONTROL_CONT_MSK |
            ALTERA_AVALON_TIMER_CONTROL_START_MSK);

  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
 400bd3c:	d8000015 	stw	zero,0(sp)
 400bd40:	e1fffe17 	ldw	r7,-8(fp)
 400bd44:	01810074 	movhi	r6,1025
 400bd48:	31af1c04 	addi	r6,r6,-17296
 400bd4c:	e17ffc17 	ldw	r5,-16(fp)
 400bd50:	e13ffd17 	ldw	r4,-12(fp)
 400bd54:	400a7200 	call	400a720 <alt_ic_isr_register>
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
#endif  
}
 400bd58:	0001883a 	nop
 400bd5c:	e037883a 	mov	sp,fp
 400bd60:	dfc00117 	ldw	ra,4(sp)
 400bd64:	df000017 	ldw	fp,0(sp)
 400bd68:	dec00204 	addi	sp,sp,8
 400bd6c:	f800283a 	ret

0400bd70 <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
 400bd70:	defff404 	addi	sp,sp,-48
 400bd74:	df000b15 	stw	fp,44(sp)
 400bd78:	df000b04 	addi	fp,sp,44
 400bd7c:	e13ff815 	stw	r4,-32(fp)
 400bd80:	e17ff715 	stw	r5,-36(fp)
 400bd84:	e1bff615 	stw	r6,-40(fp)
 400bd88:	e1fff515 	stw	r7,-44(fp)
  alt_irq_context irq_context;
  alt_u64 current_nticks = 0;
 400bd8c:	e03ffe15 	stw	zero,-8(fp)
 400bd90:	e03fff15 	stw	zero,-4(fp)
  return _alt_tick_rate;
 400bd94:	d0a6c717 	ldw	r2,-25828(gp)
  
  if (alt_ticks_per_second ())
 400bd98:	10004826 	beq	r2,zero,400bebc <alt_alarm_start+0x14c>
  {
    if (alarm)
 400bd9c:	e0bff817 	ldw	r2,-32(fp)
 400bda0:	10004426 	beq	r2,zero,400beb4 <alt_alarm_start+0x144>
    {
      alarm->callback = callback;
 400bda4:	e0bff817 	ldw	r2,-32(fp)
 400bda8:	e0fff617 	ldw	r3,-40(fp)
 400bdac:	10c00415 	stw	r3,16(r2)
      alarm->context  = context;
 400bdb0:	e0bff817 	ldw	r2,-32(fp)
 400bdb4:	e0fff517 	ldw	r3,-44(fp)
 400bdb8:	10c00515 	stw	r3,20(r2)
  NIOS2_READ_STATUS (context);
 400bdbc:	0005303a 	rdctl	r2,status
 400bdc0:	e0bff915 	stw	r2,-28(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 400bdc4:	e0fff917 	ldw	r3,-28(fp)
 400bdc8:	00bfff84 	movi	r2,-2
 400bdcc:	1884703a 	and	r2,r3,r2
 400bdd0:	1001703a 	wrctl	status,r2
  return context;
 400bdd4:	e0bff917 	ldw	r2,-28(fp)
 
      irq_context = alt_irq_disable_all ();
 400bdd8:	e0bffd15 	stw	r2,-12(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u64 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
 400bddc:	d0a6c817 	ldw	r2,-25824(gp)
 400bde0:	d0e6c917 	ldw	r3,-25820(gp)
      
      current_nticks = alt_nticks();
 400bde4:	e0bffe15 	stw	r2,-8(fp)
 400bde8:	e0ffff15 	stw	r3,-4(fp)
      
      alarm->time = (alt_u64)nticks + current_nticks + 1; 
 400bdec:	e0bff717 	ldw	r2,-36(fp)
 400bdf0:	1011883a 	mov	r8,r2
 400bdf4:	0013883a 	mov	r9,zero
 400bdf8:	e13ffe17 	ldw	r4,-8(fp)
 400bdfc:	e17fff17 	ldw	r5,-4(fp)
 400be00:	4105883a 	add	r2,r8,r4
 400be04:	120d803a 	cmpltu	r6,r2,r8
 400be08:	4947883a 	add	r3,r9,r5
 400be0c:	30c9883a 	add	r4,r6,r3
 400be10:	2007883a 	mov	r3,r4
 400be14:	1009883a 	mov	r4,r2
 400be18:	180b883a 	mov	r5,r3
 400be1c:	01800044 	movi	r6,1
 400be20:	000f883a 	mov	r7,zero
 400be24:	2185883a 	add	r2,r4,r6
 400be28:	1111803a 	cmpltu	r8,r2,r4
 400be2c:	29c7883a 	add	r3,r5,r7
 400be30:	40c9883a 	add	r4,r8,r3
 400be34:	2007883a 	mov	r3,r4
 400be38:	1009883a 	mov	r4,r2
 400be3c:	180b883a 	mov	r5,r3
 400be40:	e0bff817 	ldw	r2,-32(fp)
 400be44:	11000215 	stw	r4,8(r2)
 400be48:	11400315 	stw	r5,12(r2)
          
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
 400be4c:	e0bff817 	ldw	r2,-32(fp)
 400be50:	d0e00d04 	addi	r3,gp,-32716
 400be54:	e0fffb15 	stw	r3,-20(fp)
 400be58:	e0bffa15 	stw	r2,-24(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 400be5c:	e0bffa17 	ldw	r2,-24(fp)
 400be60:	e0fffb17 	ldw	r3,-20(fp)
 400be64:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
 400be68:	e0bffb17 	ldw	r2,-20(fp)
 400be6c:	10c00017 	ldw	r3,0(r2)
 400be70:	e0bffa17 	ldw	r2,-24(fp)
 400be74:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 400be78:	e0bffb17 	ldw	r2,-20(fp)
 400be7c:	10800017 	ldw	r2,0(r2)
 400be80:	e0fffa17 	ldw	r3,-24(fp)
 400be84:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
 400be88:	e0bffb17 	ldw	r2,-20(fp)
 400be8c:	e0fffa17 	ldw	r3,-24(fp)
 400be90:	10c00015 	stw	r3,0(r2)
}
 400be94:	0001883a 	nop
 400be98:	e0bffd17 	ldw	r2,-12(fp)
 400be9c:	e0bffc15 	stw	r2,-16(fp)
  NIOS2_WRITE_STATUS (context);
 400bea0:	e0bffc17 	ldw	r2,-16(fp)
 400bea4:	1001703a 	wrctl	status,r2
}
 400bea8:	0001883a 	nop
      alt_irq_enable_all (irq_context);

      return 0;
 400beac:	0005883a 	mov	r2,zero
 400beb0:	00000306 	br	400bec0 <alt_alarm_start+0x150>
    }
    else
    {
      return -EINVAL;
 400beb4:	00bffa84 	movi	r2,-22
 400beb8:	00000106 	br	400bec0 <alt_alarm_start+0x150>
    }
  }
  else
  {
    return -ENOTSUP;
 400bebc:	00bfde84 	movi	r2,-134
  }
}
 400bec0:	e037883a 	mov	sp,fp
 400bec4:	df000017 	ldw	fp,0(sp)
 400bec8:	dec00104 	addi	sp,sp,4
 400becc:	f800283a 	ret

0400bed0 <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
 400bed0:	deffff04 	addi	sp,sp,-4
 400bed4:	df000015 	stw	fp,0(sp)
 400bed8:	d839883a 	mov	fp,sp
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
 400bedc:	0001883a 	nop
 400bee0:	e037883a 	mov	sp,fp
 400bee4:	df000017 	ldw	fp,0(sp)
 400bee8:	dec00104 	addi	sp,sp,4
 400beec:	f800283a 	ret

0400bef0 <alt_get_errno>:
{
 400bef0:	defffe04 	addi	sp,sp,-8
 400bef4:	dfc00115 	stw	ra,4(sp)
 400bef8:	df000015 	stw	fp,0(sp)
 400befc:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 400bf00:	d0a00a17 	ldw	r2,-32728(gp)
 400bf04:	10000326 	beq	r2,zero,400bf14 <alt_get_errno+0x24>
 400bf08:	d0a00a17 	ldw	r2,-32728(gp)
 400bf0c:	103ee83a 	callr	r2
 400bf10:	00000106 	br	400bf18 <alt_get_errno+0x28>
 400bf14:	d0a6c104 	addi	r2,gp,-25852
}
 400bf18:	e037883a 	mov	sp,fp
 400bf1c:	dfc00117 	ldw	ra,4(sp)
 400bf20:	df000017 	ldw	fp,0(sp)
 400bf24:	dec00204 	addi	sp,sp,8
 400bf28:	f800283a 	ret

0400bf2c <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
 400bf2c:	defffa04 	addi	sp,sp,-24
 400bf30:	dfc00515 	stw	ra,20(sp)
 400bf34:	df000415 	stw	fp,16(sp)
 400bf38:	df000404 	addi	fp,sp,16
 400bf3c:	e13ffd15 	stw	r4,-12(fp)
 400bf40:	e17ffc15 	stw	r5,-16(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
 400bf44:	e0bffd17 	ldw	r2,-12(fp)
 400bf48:	10000326 	beq	r2,zero,400bf58 <alt_dev_llist_insert+0x2c>
 400bf4c:	e0bffd17 	ldw	r2,-12(fp)
 400bf50:	10800217 	ldw	r2,8(r2)
 400bf54:	1000061e 	bne	r2,zero,400bf70 <alt_dev_llist_insert+0x44>
  {
    ALT_ERRNO = EINVAL;
 400bf58:	400bef00 	call	400bef0 <alt_get_errno>
 400bf5c:	1007883a 	mov	r3,r2
 400bf60:	00800584 	movi	r2,22
 400bf64:	18800015 	stw	r2,0(r3)
    return -EINVAL;
 400bf68:	00bffa84 	movi	r2,-22
 400bf6c:	00001406 	br	400bfc0 <alt_dev_llist_insert+0x94>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
 400bf70:	e0bffd17 	ldw	r2,-12(fp)
 400bf74:	e0fffc17 	ldw	r3,-16(fp)
 400bf78:	e0ffff15 	stw	r3,-4(fp)
 400bf7c:	e0bffe15 	stw	r2,-8(fp)
  entry->previous = list;
 400bf80:	e0bffe17 	ldw	r2,-8(fp)
 400bf84:	e0ffff17 	ldw	r3,-4(fp)
 400bf88:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
 400bf8c:	e0bfff17 	ldw	r2,-4(fp)
 400bf90:	10c00017 	ldw	r3,0(r2)
 400bf94:	e0bffe17 	ldw	r2,-8(fp)
 400bf98:	10c00015 	stw	r3,0(r2)
  list->next->previous = entry;
 400bf9c:	e0bfff17 	ldw	r2,-4(fp)
 400bfa0:	10800017 	ldw	r2,0(r2)
 400bfa4:	e0fffe17 	ldw	r3,-8(fp)
 400bfa8:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
 400bfac:	e0bfff17 	ldw	r2,-4(fp)
 400bfb0:	e0fffe17 	ldw	r3,-8(fp)
 400bfb4:	10c00015 	stw	r3,0(r2)
}
 400bfb8:	0001883a 	nop

  return 0;  
 400bfbc:	0005883a 	mov	r2,zero
}
 400bfc0:	e037883a 	mov	sp,fp
 400bfc4:	dfc00117 	ldw	ra,4(sp)
 400bfc8:	df000017 	ldw	fp,0(sp)
 400bfcc:	dec00204 	addi	sp,sp,8
 400bfd0:	f800283a 	ret

0400bfd4 <_do_ctors>:
/*
 * Run the C++ static constructors.
 */

void _do_ctors(void)
{
 400bfd4:	defffd04 	addi	sp,sp,-12
 400bfd8:	dfc00215 	stw	ra,8(sp)
 400bfdc:	df000115 	stw	fp,4(sp)
 400bfe0:	df000104 	addi	fp,sp,4
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 400bfe4:	00810074 	movhi	r2,1025
 400bfe8:	10b2f904 	addi	r2,r2,-13340
 400bfec:	e0bfff15 	stw	r2,-4(fp)
 400bff0:	00000606 	br	400c00c <_do_ctors+0x38>
        (*ctor) (); 
 400bff4:	e0bfff17 	ldw	r2,-4(fp)
 400bff8:	10800017 	ldw	r2,0(r2)
 400bffc:	103ee83a 	callr	r2
  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 400c000:	e0bfff17 	ldw	r2,-4(fp)
 400c004:	10bfff04 	addi	r2,r2,-4
 400c008:	e0bfff15 	stw	r2,-4(fp)
 400c00c:	e0ffff17 	ldw	r3,-4(fp)
 400c010:	00810074 	movhi	r2,1025
 400c014:	10b2fa04 	addi	r2,r2,-13336
 400c018:	18bff62e 	bgeu	r3,r2,400bff4 <_do_ctors+0x20>
}
 400c01c:	0001883a 	nop
 400c020:	0001883a 	nop
 400c024:	e037883a 	mov	sp,fp
 400c028:	dfc00117 	ldw	ra,4(sp)
 400c02c:	df000017 	ldw	fp,0(sp)
 400c030:	dec00204 	addi	sp,sp,8
 400c034:	f800283a 	ret

0400c038 <_do_dtors>:
/*
 * Run the C++ static destructors.
 */

void _do_dtors(void)
{
 400c038:	defffd04 	addi	sp,sp,-12
 400c03c:	dfc00215 	stw	ra,8(sp)
 400c040:	df000115 	stw	fp,4(sp)
 400c044:	df000104 	addi	fp,sp,4
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
 400c048:	00810074 	movhi	r2,1025
 400c04c:	10b2f904 	addi	r2,r2,-13340
 400c050:	e0bfff15 	stw	r2,-4(fp)
 400c054:	00000606 	br	400c070 <_do_dtors+0x38>
        (*dtor) (); 
 400c058:	e0bfff17 	ldw	r2,-4(fp)
 400c05c:	10800017 	ldw	r2,0(r2)
 400c060:	103ee83a 	callr	r2
  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
 400c064:	e0bfff17 	ldw	r2,-4(fp)
 400c068:	10bfff04 	addi	r2,r2,-4
 400c06c:	e0bfff15 	stw	r2,-4(fp)
 400c070:	e0ffff17 	ldw	r3,-4(fp)
 400c074:	00810074 	movhi	r2,1025
 400c078:	10b2fa04 	addi	r2,r2,-13336
 400c07c:	18bff62e 	bgeu	r3,r2,400c058 <_do_dtors+0x20>
}
 400c080:	0001883a 	nop
 400c084:	0001883a 	nop
 400c088:	e037883a 	mov	sp,fp
 400c08c:	dfc00117 	ldw	ra,4(sp)
 400c090:	df000017 	ldw	fp,0(sp)
 400c094:	dec00204 	addi	sp,sp,8
 400c098:	f800283a 	ret

0400c09c <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
 400c09c:	deffff04 	addi	sp,sp,-4
 400c0a0:	df000015 	stw	fp,0(sp)
 400c0a4:	d839883a 	mov	fp,sp
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
#endif
}
 400c0a8:	0001883a 	nop
 400c0ac:	e037883a 	mov	sp,fp
 400c0b0:	df000017 	ldw	fp,0(sp)
 400c0b4:	dec00104 	addi	sp,sp,4
 400c0b8:	f800283a 	ret

0400c0bc <alt_exception_cause_generated_bad_addr>:
 * Return: 1: BADADDR (bad_addr argument to handler) is valid
 *         0: BADADDR is not valid
 */
int 
alt_exception_cause_generated_bad_addr(alt_exception_cause cause)
{
 400c0bc:	defffe04 	addi	sp,sp,-8
 400c0c0:	df000115 	stw	fp,4(sp)
 400c0c4:	df000104 	addi	fp,sp,4
 400c0c8:	e13fff15 	stw	r4,-4(fp)
  switch (cause) {
 400c0cc:	e0bfff17 	ldw	r2,-4(fp)
 400c0d0:	10bffe84 	addi	r2,r2,-6
 400c0d4:	10c00428 	cmpgeui	r3,r2,16
 400c0d8:	18c03fcc 	andi	r3,r3,255
 400c0dc:	18000f1e 	bne	r3,zero,400c11c <alt_exception_cause_generated_bad_addr+0x60>
 400c0e0:	00c00044 	movi	r3,1
 400c0e4:	1884983a 	sll	r2,r3,r2
 400c0e8:	10e2c8cc 	andi	r3,r2,35619
 400c0ec:	1806c03a 	cmpne	r3,r3,zero
 400c0f0:	18c03fcc 	andi	r3,r3,255
 400c0f4:	1800051e 	bne	r3,zero,400c10c <alt_exception_cause_generated_bad_addr+0x50>
 400c0f8:	1084100c 	andi	r2,r2,4160
 400c0fc:	1004c03a 	cmpne	r2,r2,zero
 400c100:	10803fcc 	andi	r2,r2,255
 400c104:	1000031e 	bne	r2,zero,400c114 <alt_exception_cause_generated_bad_addr+0x58>
 400c108:	00000406 	br	400c11c <alt_exception_cause_generated_bad_addr+0x60>
  case NIOS2_EXCEPTION_MISALIGNED_TARGET_PC:
  case NIOS2_EXCEPTION_TLB_READ_PERM_VIOLATION:
  case NIOS2_EXCEPTION_TLB_WRITE_PERM_VIOLATION:
  case NIOS2_EXCEPTION_MPU_DATA_REGION_VIOLATION:
  case NIOS2_EXCEPTION_ECC_DATA_ERR:
    return 1;
 400c10c:	00800044 	movi	r2,1
 400c110:	00000306 	br	400c120 <alt_exception_cause_generated_bad_addr+0x64>

  case NIOS2_EXCEPTION_TLB_MISS:
  case NIOS2_EXCEPTION_ECC_TLB_ERR:
    return 0;
 400c114:	0005883a 	mov	r2,zero
 400c118:	00000106 	br	400c120 <alt_exception_cause_generated_bad_addr+0x64>

  default:
    return 0;
 400c11c:	0005883a 	mov	r2,zero
  }
}
 400c120:	e037883a 	mov	sp,fp
 400c124:	df000017 	ldw	fp,0(sp)
 400c128:	dec00104 	addi	sp,sp,4
 400c12c:	f800283a 	ret

0400c130 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
 400c130:	defff904 	addi	sp,sp,-28
 400c134:	dfc00615 	stw	ra,24(sp)
 400c138:	df000515 	stw	fp,20(sp)
 400c13c:	df000504 	addi	fp,sp,20
 400c140:	e13ffe15 	stw	r4,-8(fp)
 400c144:	e17ffd15 	stw	r5,-12(fp)
 400c148:	e1bffc15 	stw	r6,-16(fp)
 400c14c:	e1fffb15 	stw	r7,-20(fp)
  int old;

  old = open (name, flags, mode);
 400c150:	e1bffb17 	ldw	r6,-20(fp)
 400c154:	e17ffc17 	ldw	r5,-16(fp)
 400c158:	e13ffd17 	ldw	r4,-12(fp)
 400c15c:	400c3980 	call	400c398 <open>
 400c160:	e0bfff15 	stw	r2,-4(fp)

  if (old >= 0)
 400c164:	e0bfff17 	ldw	r2,-4(fp)
 400c168:	10002016 	blt	r2,zero,400c1ec <alt_open_fd+0xbc>
  {
    fd->dev      = alt_fd_list[old].dev;
 400c16c:	e0ffff17 	ldw	r3,-4(fp)
 400c170:	1805883a 	mov	r2,r3
 400c174:	1085883a 	add	r2,r2,r2
 400c178:	10c5883a 	add	r2,r2,r3
 400c17c:	100490ba 	slli	r2,r2,2
 400c180:	00c10074 	movhi	r3,1025
 400c184:	10c7883a 	add	r3,r2,r3
 400c188:	18f53417 	ldw	r3,-11056(r3)
 400c18c:	e0bffe17 	ldw	r2,-8(fp)
 400c190:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
 400c194:	e0ffff17 	ldw	r3,-4(fp)
 400c198:	1805883a 	mov	r2,r3
 400c19c:	1085883a 	add	r2,r2,r2
 400c1a0:	10c5883a 	add	r2,r2,r3
 400c1a4:	100490ba 	slli	r2,r2,2
 400c1a8:	00c10074 	movhi	r3,1025
 400c1ac:	10c7883a 	add	r3,r2,r3
 400c1b0:	18f53517 	ldw	r3,-11052(r3)
 400c1b4:	e0bffe17 	ldw	r2,-8(fp)
 400c1b8:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
 400c1bc:	e0ffff17 	ldw	r3,-4(fp)
 400c1c0:	1805883a 	mov	r2,r3
 400c1c4:	1085883a 	add	r2,r2,r2
 400c1c8:	10c5883a 	add	r2,r2,r3
 400c1cc:	100490ba 	slli	r2,r2,2
 400c1d0:	00c10074 	movhi	r3,1025
 400c1d4:	10c7883a 	add	r3,r2,r3
 400c1d8:	18f53617 	ldw	r3,-11048(r3)
 400c1dc:	e0bffe17 	ldw	r2,-8(fp)
 400c1e0:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
 400c1e4:	e13fff17 	ldw	r4,-4(fp)
 400c1e8:	400aeb40 	call	400aeb4 <alt_release_fd>
  }
} 
 400c1ec:	0001883a 	nop
 400c1f0:	e037883a 	mov	sp,fp
 400c1f4:	dfc00117 	ldw	ra,4(sp)
 400c1f8:	df000017 	ldw	fp,0(sp)
 400c1fc:	dec00204 	addi	sp,sp,8
 400c200:	f800283a 	ret

0400c204 <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
 400c204:	defffb04 	addi	sp,sp,-20
 400c208:	dfc00415 	stw	ra,16(sp)
 400c20c:	df000315 	stw	fp,12(sp)
 400c210:	df000304 	addi	fp,sp,12
 400c214:	e13fff15 	stw	r4,-4(fp)
 400c218:	e17ffe15 	stw	r5,-8(fp)
 400c21c:	e1bffd15 	stw	r6,-12(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
 400c220:	01c07fc4 	movi	r7,511
 400c224:	01800044 	movi	r6,1
 400c228:	e17fff17 	ldw	r5,-4(fp)
 400c22c:	01010074 	movhi	r4,1025
 400c230:	21353704 	addi	r4,r4,-11044
 400c234:	400c1300 	call	400c130 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
 400c238:	01c07fc4 	movi	r7,511
 400c23c:	000d883a 	mov	r6,zero
 400c240:	e17ffe17 	ldw	r5,-8(fp)
 400c244:	01010074 	movhi	r4,1025
 400c248:	21353404 	addi	r4,r4,-11056
 400c24c:	400c1300 	call	400c130 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
 400c250:	01c07fc4 	movi	r7,511
 400c254:	01800044 	movi	r6,1
 400c258:	e17ffd17 	ldw	r5,-12(fp)
 400c25c:	01010074 	movhi	r4,1025
 400c260:	21353a04 	addi	r4,r4,-11032
 400c264:	400c1300 	call	400c130 <alt_open_fd>
}  
 400c268:	0001883a 	nop
 400c26c:	e037883a 	mov	sp,fp
 400c270:	dfc00117 	ldw	ra,4(sp)
 400c274:	df000017 	ldw	fp,0(sp)
 400c278:	dec00204 	addi	sp,sp,8
 400c27c:	f800283a 	ret

0400c280 <alt_get_errno>:
{
 400c280:	defffe04 	addi	sp,sp,-8
 400c284:	dfc00115 	stw	ra,4(sp)
 400c288:	df000015 	stw	fp,0(sp)
 400c28c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 400c290:	d0a00a17 	ldw	r2,-32728(gp)
 400c294:	10000326 	beq	r2,zero,400c2a4 <alt_get_errno+0x24>
 400c298:	d0a00a17 	ldw	r2,-32728(gp)
 400c29c:	103ee83a 	callr	r2
 400c2a0:	00000106 	br	400c2a8 <alt_get_errno+0x28>
 400c2a4:	d0a6c104 	addi	r2,gp,-25852
}
 400c2a8:	e037883a 	mov	sp,fp
 400c2ac:	dfc00117 	ldw	ra,4(sp)
 400c2b0:	df000017 	ldw	fp,0(sp)
 400c2b4:	dec00204 	addi	sp,sp,8
 400c2b8:	f800283a 	ret

0400c2bc <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
 400c2bc:	defffd04 	addi	sp,sp,-12
 400c2c0:	df000215 	stw	fp,8(sp)
 400c2c4:	df000204 	addi	fp,sp,8
 400c2c8:	e13ffe15 	stw	r4,-8(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
 400c2cc:	e0bffe17 	ldw	r2,-8(fp)
 400c2d0:	10800217 	ldw	r2,8(r2)
 400c2d4:	10d00034 	orhi	r3,r2,16384
 400c2d8:	e0bffe17 	ldw	r2,-8(fp)
 400c2dc:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
 400c2e0:	e03fff15 	stw	zero,-4(fp)
 400c2e4:	00002306 	br	400c374 <alt_file_locked+0xb8>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
 400c2e8:	e0ffff17 	ldw	r3,-4(fp)
 400c2ec:	1805883a 	mov	r2,r3
 400c2f0:	1085883a 	add	r2,r2,r2
 400c2f4:	10c5883a 	add	r2,r2,r3
 400c2f8:	100490ba 	slli	r2,r2,2
 400c2fc:	00c10074 	movhi	r3,1025
 400c300:	10c7883a 	add	r3,r2,r3
 400c304:	18f53417 	ldw	r3,-11056(r3)
 400c308:	e0bffe17 	ldw	r2,-8(fp)
 400c30c:	10800017 	ldw	r2,0(r2)
 400c310:	1880151e 	bne	r3,r2,400c368 <alt_file_locked+0xac>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
 400c314:	e0ffff17 	ldw	r3,-4(fp)
 400c318:	1805883a 	mov	r2,r3
 400c31c:	1085883a 	add	r2,r2,r2
 400c320:	10c5883a 	add	r2,r2,r3
 400c324:	100490ba 	slli	r2,r2,2
 400c328:	00c10074 	movhi	r3,1025
 400c32c:	10c7883a 	add	r3,r2,r3
 400c330:	18b53617 	ldw	r2,-11048(r3)
    if ((alt_fd_list[i].dev == fd->dev) &&
 400c334:	10000c0e 	bge	r2,zero,400c368 <alt_file_locked+0xac>
        (&alt_fd_list[i] != fd))
 400c338:	e0ffff17 	ldw	r3,-4(fp)
 400c33c:	1805883a 	mov	r2,r3
 400c340:	1085883a 	add	r2,r2,r2
 400c344:	10c5883a 	add	r2,r2,r3
 400c348:	100490ba 	slli	r2,r2,2
 400c34c:	00c10074 	movhi	r3,1025
 400c350:	18f53404 	addi	r3,r3,-11056
 400c354:	10c5883a 	add	r2,r2,r3
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
 400c358:	e0fffe17 	ldw	r3,-8(fp)
 400c35c:	18800226 	beq	r3,r2,400c368 <alt_file_locked+0xac>
    {
      return -EACCES;
 400c360:	00bffcc4 	movi	r2,-13
 400c364:	00000806 	br	400c388 <alt_file_locked+0xcc>
  for (i = 0; i <= alt_max_fd; i++)
 400c368:	e0bfff17 	ldw	r2,-4(fp)
 400c36c:	10800044 	addi	r2,r2,1
 400c370:	e0bfff15 	stw	r2,-4(fp)
 400c374:	d0a00917 	ldw	r2,-32732(gp)
 400c378:	1007883a 	mov	r3,r2
 400c37c:	e0bfff17 	ldw	r2,-4(fp)
 400c380:	18bfd92e 	bgeu	r3,r2,400c2e8 <alt_file_locked+0x2c>
    }
  }
  
  /* The device is not locked */
 
  return 0;
 400c384:	0005883a 	mov	r2,zero
}
 400c388:	e037883a 	mov	sp,fp
 400c38c:	df000017 	ldw	fp,0(sp)
 400c390:	dec00104 	addi	sp,sp,4
 400c394:	f800283a 	ret

0400c398 <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
 400c398:	defff604 	addi	sp,sp,-40
 400c39c:	dfc00915 	stw	ra,36(sp)
 400c3a0:	df000815 	stw	fp,32(sp)
 400c3a4:	df000804 	addi	fp,sp,32
 400c3a8:	e13ffa15 	stw	r4,-24(fp)
 400c3ac:	e17ff915 	stw	r5,-28(fp)
 400c3b0:	e1bff815 	stw	r6,-32(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
 400c3b4:	00bfffc4 	movi	r2,-1
 400c3b8:	e0bffe15 	stw	r2,-8(fp)
  int status = -ENODEV;
 400c3bc:	00bffb44 	movi	r2,-19
 400c3c0:	e0bffd15 	stw	r2,-12(fp)
  int isafs = 0;
 400c3c4:	e03ffc15 	stw	zero,-16(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
 400c3c8:	d1600704 	addi	r5,gp,-32740
 400c3cc:	e13ffa17 	ldw	r4,-24(fp)
 400c3d0:	400c6ec0 	call	400c6ec <alt_find_dev>
 400c3d4:	e0bfff15 	stw	r2,-4(fp)
 400c3d8:	e0bfff17 	ldw	r2,-4(fp)
 400c3dc:	1000051e 	bne	r2,zero,400c3f4 <open+0x5c>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
 400c3e0:	e13ffa17 	ldw	r4,-24(fp)
 400c3e4:	400c77c0 	call	400c77c <alt_find_file>
 400c3e8:	e0bfff15 	stw	r2,-4(fp)
    isafs = 1;
 400c3ec:	00800044 	movi	r2,1
 400c3f0:	e0bffc15 	stw	r2,-16(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
 400c3f4:	e0bfff17 	ldw	r2,-4(fp)
 400c3f8:	10002c26 	beq	r2,zero,400c4ac <open+0x114>
  {
    if ((index = alt_get_fd (dev)) < 0)
 400c3fc:	e13fff17 	ldw	r4,-4(fp)
 400c400:	400c8840 	call	400c884 <alt_get_fd>
 400c404:	e0bffe15 	stw	r2,-8(fp)
 400c408:	e0bffe17 	ldw	r2,-8(fp)
 400c40c:	1000030e 	bge	r2,zero,400c41c <open+0x84>
    {
      status = index;
 400c410:	e0bffe17 	ldw	r2,-8(fp)
 400c414:	e0bffd15 	stw	r2,-12(fp)
 400c418:	00002606 	br	400c4b4 <open+0x11c>
    }
    else
    {
      fd = &alt_fd_list[index];
 400c41c:	e0fffe17 	ldw	r3,-8(fp)
 400c420:	1805883a 	mov	r2,r3
 400c424:	1085883a 	add	r2,r2,r2
 400c428:	10c5883a 	add	r2,r2,r3
 400c42c:	100490ba 	slli	r2,r2,2
 400c430:	00c10074 	movhi	r3,1025
 400c434:	18f53404 	addi	r3,r3,-11056
 400c438:	10c5883a 	add	r2,r2,r3
 400c43c:	e0bffb15 	stw	r2,-20(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
 400c440:	e0fff917 	ldw	r3,-28(fp)
 400c444:	00900034 	movhi	r2,16384
 400c448:	10bfffc4 	addi	r2,r2,-1
 400c44c:	1886703a 	and	r3,r3,r2
 400c450:	e0bffb17 	ldw	r2,-20(fp)
 400c454:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
 400c458:	e0bffc17 	ldw	r2,-16(fp)
 400c45c:	1000051e 	bne	r2,zero,400c474 <open+0xdc>
 400c460:	e13ffb17 	ldw	r4,-20(fp)
 400c464:	400c2bc0 	call	400c2bc <alt_file_locked>
 400c468:	e0bffd15 	stw	r2,-12(fp)
 400c46c:	e0bffd17 	ldw	r2,-12(fp)
 400c470:	10001016 	blt	r2,zero,400c4b4 <open+0x11c>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
 400c474:	e0bfff17 	ldw	r2,-4(fp)
 400c478:	10800317 	ldw	r2,12(r2)
 400c47c:	10000826 	beq	r2,zero,400c4a0 <open+0x108>
 400c480:	e0bfff17 	ldw	r2,-4(fp)
 400c484:	10800317 	ldw	r2,12(r2)
 400c488:	e1fff817 	ldw	r7,-32(fp)
 400c48c:	e1bff917 	ldw	r6,-28(fp)
 400c490:	e17ffa17 	ldw	r5,-24(fp)
 400c494:	e13ffb17 	ldw	r4,-20(fp)
 400c498:	103ee83a 	callr	r2
 400c49c:	00000106 	br	400c4a4 <open+0x10c>
 400c4a0:	0005883a 	mov	r2,zero
 400c4a4:	e0bffd15 	stw	r2,-12(fp)
 400c4a8:	00000206 	br	400c4b4 <open+0x11c>
      }
    }
  }
  else
  {
    status = -ENODEV;
 400c4ac:	00bffb44 	movi	r2,-19
 400c4b0:	e0bffd15 	stw	r2,-12(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
 400c4b4:	e0bffd17 	ldw	r2,-12(fp)
 400c4b8:	1000090e 	bge	r2,zero,400c4e0 <open+0x148>
  {
    alt_release_fd (index);  
 400c4bc:	e13ffe17 	ldw	r4,-8(fp)
 400c4c0:	400aeb40 	call	400aeb4 <alt_release_fd>
    ALT_ERRNO = -status;
 400c4c4:	400c2800 	call	400c280 <alt_get_errno>
 400c4c8:	1007883a 	mov	r3,r2
 400c4cc:	e0bffd17 	ldw	r2,-12(fp)
 400c4d0:	0085c83a 	sub	r2,zero,r2
 400c4d4:	18800015 	stw	r2,0(r3)
    return -1;
 400c4d8:	00bfffc4 	movi	r2,-1
 400c4dc:	00000106 	br	400c4e4 <open+0x14c>
  }
  
  /* return the reference upon success */

  return index;
 400c4e0:	e0bffe17 	ldw	r2,-8(fp)
}
 400c4e4:	e037883a 	mov	sp,fp
 400c4e8:	dfc00117 	ldw	ra,4(sp)
 400c4ec:	df000017 	ldw	fp,0(sp)
 400c4f0:	dec00204 	addi	sp,sp,8
 400c4f4:	f800283a 	ret

0400c4f8 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
 400c4f8:	defffa04 	addi	sp,sp,-24
 400c4fc:	df000515 	stw	fp,20(sp)
 400c500:	df000504 	addi	fp,sp,20
 400c504:	e13ffb15 	stw	r4,-20(fp)
  NIOS2_READ_STATUS (context);
 400c508:	0005303a 	rdctl	r2,status
 400c50c:	e0bffc15 	stw	r2,-16(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 400c510:	e0fffc17 	ldw	r3,-16(fp)
 400c514:	00bfff84 	movi	r2,-2
 400c518:	1884703a 	and	r2,r3,r2
 400c51c:	1001703a 	wrctl	status,r2
  return context;
 400c520:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
 400c524:	e0bfff15 	stw	r2,-4(fp)
  alt_llist_remove (&alarm->llist);
 400c528:	e0bffb17 	ldw	r2,-20(fp)
 400c52c:	e0bffd15 	stw	r2,-12(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
 400c530:	e0bffd17 	ldw	r2,-12(fp)
 400c534:	10800017 	ldw	r2,0(r2)
 400c538:	e0fffd17 	ldw	r3,-12(fp)
 400c53c:	18c00117 	ldw	r3,4(r3)
 400c540:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
 400c544:	e0bffd17 	ldw	r2,-12(fp)
 400c548:	10800117 	ldw	r2,4(r2)
 400c54c:	e0fffd17 	ldw	r3,-12(fp)
 400c550:	18c00017 	ldw	r3,0(r3)
 400c554:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
 400c558:	e0bffd17 	ldw	r2,-12(fp)
 400c55c:	e0fffd17 	ldw	r3,-12(fp)
 400c560:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
 400c564:	e0bffd17 	ldw	r2,-12(fp)
 400c568:	e0fffd17 	ldw	r3,-12(fp)
 400c56c:	10c00015 	stw	r3,0(r2)
} 
 400c570:	0001883a 	nop
 400c574:	e0bfff17 	ldw	r2,-4(fp)
 400c578:	e0bffe15 	stw	r2,-8(fp)
  NIOS2_WRITE_STATUS (context);
 400c57c:	e0bffe17 	ldw	r2,-8(fp)
 400c580:	1001703a 	wrctl	status,r2
}
 400c584:	0001883a 	nop
  alt_irq_enable_all (irq_context);
}
 400c588:	0001883a 	nop
 400c58c:	e037883a 	mov	sp,fp
 400c590:	df000017 	ldw	fp,0(sp)
 400c594:	dec00104 	addi	sp,sp,4
 400c598:	f800283a 	ret

0400c59c <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
 400c59c:	defff904 	addi	sp,sp,-28
 400c5a0:	dfc00615 	stw	ra,24(sp)
 400c5a4:	df000515 	stw	fp,20(sp)
 400c5a8:	dc400415 	stw	r17,16(sp)
 400c5ac:	dc000315 	stw	r16,12(sp)
 400c5b0:	df000504 	addi	fp,sp,20
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
 400c5b4:	d0a00d17 	ldw	r2,-32716(gp)
 400c5b8:	e0bffd15 	stw	r2,-12(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
 400c5bc:	d126c817 	ldw	r4,-25824(gp)
 400c5c0:	d166c917 	ldw	r5,-25820(gp)
 400c5c4:	01800044 	movi	r6,1
 400c5c8:	000f883a 	mov	r7,zero
 400c5cc:	2185883a 	add	r2,r4,r6
 400c5d0:	1111803a 	cmpltu	r8,r2,r4
 400c5d4:	29c7883a 	add	r3,r5,r7
 400c5d8:	40c9883a 	add	r4,r8,r3
 400c5dc:	2007883a 	mov	r3,r4
 400c5e0:	1009883a 	mov	r4,r2
 400c5e4:	180b883a 	mov	r5,r3
 400c5e8:	d126c815 	stw	r4,-25824(gp)
 400c5ec:	d166c915 	stw	r5,-25820(gp)
 
  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 400c5f0:	00002906 	br	400c698 <alt_tick+0xfc>
  {
    next = (alt_alarm*) alarm->llist.next;
 400c5f4:	e0bffd17 	ldw	r2,-12(fp)
 400c5f8:	10800017 	ldw	r2,0(r2)
 400c5fc:	e0bffc15 	stw	r2,-16(fp)
    
    /* if the alarm period has expired, make the callback */    
    if (alarm->time <= _alt_nticks)
 400c600:	e13ffd17 	ldw	r4,-12(fp)
 400c604:	20800217 	ldw	r2,8(r4)
 400c608:	20c00317 	ldw	r3,12(r4)
 400c60c:	d126c817 	ldw	r4,-25824(gp)
 400c610:	d166c917 	ldw	r5,-25820(gp)
 400c614:	28c01e36 	bltu	r5,r3,400c690 <alt_tick+0xf4>
 400c618:	1940011e 	bne	r3,r5,400c620 <alt_tick+0x84>
 400c61c:	20801c36 	bltu	r4,r2,400c690 <alt_tick+0xf4>
    {
      next_callback = alarm->callback (alarm->context);
 400c620:	e0bffd17 	ldw	r2,-12(fp)
 400c624:	10800417 	ldw	r2,16(r2)
 400c628:	e0fffd17 	ldw	r3,-12(fp)
 400c62c:	18c00517 	ldw	r3,20(r3)
 400c630:	1809883a 	mov	r4,r3
 400c634:	103ee83a 	callr	r2
 400c638:	e0bffb15 	stw	r2,-20(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
 400c63c:	e0bffb17 	ldw	r2,-20(fp)
 400c640:	1000031e 	bne	r2,zero,400c650 <alt_tick+0xb4>
      {
        alt_alarm_stop (alarm);
 400c644:	e13ffd17 	ldw	r4,-12(fp)
 400c648:	400c4f80 	call	400c4f8 <alt_alarm_stop>
 400c64c:	00001006 	br	400c690 <alt_tick+0xf4>
      }
      else
      {
        alarm->time += next_callback;
 400c650:	e0bffd17 	ldw	r2,-12(fp)
 400c654:	11000217 	ldw	r4,8(r2)
 400c658:	11400317 	ldw	r5,12(r2)
 400c65c:	e0bffb17 	ldw	r2,-20(fp)
 400c660:	1021883a 	mov	r16,r2
 400c664:	0023883a 	mov	r17,zero
 400c668:	2405883a 	add	r2,r4,r16
 400c66c:	110d803a 	cmpltu	r6,r2,r4
 400c670:	2c47883a 	add	r3,r5,r17
 400c674:	30c9883a 	add	r4,r6,r3
 400c678:	2007883a 	mov	r3,r4
 400c67c:	1009883a 	mov	r4,r2
 400c680:	180b883a 	mov	r5,r3
 400c684:	e0bffd17 	ldw	r2,-12(fp)
 400c688:	11000215 	stw	r4,8(r2)
 400c68c:	11400315 	stw	r5,12(r2)
      }
    }
    alarm = next;
 400c690:	e0bffc17 	ldw	r2,-16(fp)
 400c694:	e0bffd15 	stw	r2,-12(fp)
  while (alarm != (alt_alarm*) &alt_alarm_list)
 400c698:	e0fffd17 	ldw	r3,-12(fp)
 400c69c:	d0a00d04 	addi	r2,gp,-32716
 400c6a0:	18bfd41e 	bne	r3,r2,400c5f4 <alt_tick+0x58>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
 400c6a4:	0001883a 	nop
}
 400c6a8:	0001883a 	nop
 400c6ac:	e6fffe04 	addi	sp,fp,-8
 400c6b0:	dfc00317 	ldw	ra,12(sp)
 400c6b4:	df000217 	ldw	fp,8(sp)
 400c6b8:	dc400117 	ldw	r17,4(sp)
 400c6bc:	dc000017 	ldw	r16,0(sp)
 400c6c0:	dec00404 	addi	sp,sp,16
 400c6c4:	f800283a 	ret

0400c6c8 <altera_nios2_gen2_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
 400c6c8:	deffff04 	addi	sp,sp,-4
 400c6cc:	df000015 	stw	fp,0(sp)
 400c6d0:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
 400c6d4:	000170fa 	wrctl	ienable,zero
}
 400c6d8:	0001883a 	nop
 400c6dc:	e037883a 	mov	sp,fp
 400c6e0:	df000017 	ldw	fp,0(sp)
 400c6e4:	dec00104 	addi	sp,sp,4
 400c6e8:	f800283a 	ret

0400c6ec <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
 400c6ec:	defffa04 	addi	sp,sp,-24
 400c6f0:	dfc00515 	stw	ra,20(sp)
 400c6f4:	df000415 	stw	fp,16(sp)
 400c6f8:	df000404 	addi	fp,sp,16
 400c6fc:	e13ffd15 	stw	r4,-12(fp)
 400c700:	e17ffc15 	stw	r5,-16(fp)
  alt_dev* next = (alt_dev*) llist->next;
 400c704:	e0bffc17 	ldw	r2,-16(fp)
 400c708:	10800017 	ldw	r2,0(r2)
 400c70c:	e0bfff15 	stw	r2,-4(fp)
  alt_32 len;

  len  = strlen(name) + 1;
 400c710:	e13ffd17 	ldw	r4,-12(fp)
 400c714:	4007ba00 	call	4007ba0 <strlen>
 400c718:	10800044 	addi	r2,r2,1
 400c71c:	e0bffe15 	stw	r2,-8(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
 400c720:	00000d06 	br	400c758 <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
 400c724:	e0bfff17 	ldw	r2,-4(fp)
 400c728:	10800217 	ldw	r2,8(r2)
 400c72c:	e0fffe17 	ldw	r3,-8(fp)
 400c730:	180d883a 	mov	r6,r3
 400c734:	e17ffd17 	ldw	r5,-12(fp)
 400c738:	1009883a 	mov	r4,r2
 400c73c:	400c9840 	call	400c984 <memcmp>
 400c740:	1000021e 	bne	r2,zero,400c74c <alt_find_dev+0x60>
    {
      /* match found */

      return next;
 400c744:	e0bfff17 	ldw	r2,-4(fp)
 400c748:	00000706 	br	400c768 <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
 400c74c:	e0bfff17 	ldw	r2,-4(fp)
 400c750:	10800017 	ldw	r2,0(r2)
 400c754:	e0bfff15 	stw	r2,-4(fp)
  while (next != (alt_dev*) llist)
 400c758:	e0ffff17 	ldw	r3,-4(fp)
 400c75c:	e0bffc17 	ldw	r2,-16(fp)
 400c760:	18bff01e 	bne	r3,r2,400c724 <alt_find_dev+0x38>
  }
  
  /* No match found */
  
  return NULL;
 400c764:	0005883a 	mov	r2,zero
}
 400c768:	e037883a 	mov	sp,fp
 400c76c:	dfc00117 	ldw	ra,4(sp)
 400c770:	df000017 	ldw	fp,0(sp)
 400c774:	dec00204 	addi	sp,sp,8
 400c778:	f800283a 	ret

0400c77c <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
 400c77c:	defffb04 	addi	sp,sp,-20
 400c780:	dfc00415 	stw	ra,16(sp)
 400c784:	df000315 	stw	fp,12(sp)
 400c788:	df000304 	addi	fp,sp,12
 400c78c:	e13ffd15 	stw	r4,-12(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
 400c790:	d0a00517 	ldw	r2,-32748(gp)
 400c794:	e0bfff15 	stw	r2,-4(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
 400c798:	00003106 	br	400c860 <alt_find_file+0xe4>
  {
    len = strlen(next->name);
 400c79c:	e0bfff17 	ldw	r2,-4(fp)
 400c7a0:	10800217 	ldw	r2,8(r2)
 400c7a4:	1009883a 	mov	r4,r2
 400c7a8:	4007ba00 	call	4007ba0 <strlen>
 400c7ac:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
 400c7b0:	e0bfff17 	ldw	r2,-4(fp)
 400c7b4:	10c00217 	ldw	r3,8(r2)
 400c7b8:	e0bffe17 	ldw	r2,-8(fp)
 400c7bc:	10bfffc4 	addi	r2,r2,-1
 400c7c0:	1885883a 	add	r2,r3,r2
 400c7c4:	10800003 	ldbu	r2,0(r2)
 400c7c8:	10803fcc 	andi	r2,r2,255
 400c7cc:	1080201c 	xori	r2,r2,128
 400c7d0:	10bfe004 	addi	r2,r2,-128
 400c7d4:	10800bd8 	cmpnei	r2,r2,47
 400c7d8:	1000031e 	bne	r2,zero,400c7e8 <alt_find_file+0x6c>
    {
      len -= 1;
 400c7dc:	e0bffe17 	ldw	r2,-8(fp)
 400c7e0:	10bfffc4 	addi	r2,r2,-1
 400c7e4:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
 400c7e8:	e0bffe17 	ldw	r2,-8(fp)
 400c7ec:	e0fffd17 	ldw	r3,-12(fp)
 400c7f0:	1885883a 	add	r2,r3,r2
 400c7f4:	10800003 	ldbu	r2,0(r2)
 400c7f8:	10803fcc 	andi	r2,r2,255
 400c7fc:	1080201c 	xori	r2,r2,128
 400c800:	10bfe004 	addi	r2,r2,-128
 400c804:	10800be0 	cmpeqi	r2,r2,47
 400c808:	1000081e 	bne	r2,zero,400c82c <alt_find_file+0xb0>
 400c80c:	e0bffe17 	ldw	r2,-8(fp)
 400c810:	e0fffd17 	ldw	r3,-12(fp)
 400c814:	1885883a 	add	r2,r3,r2
 400c818:	10800003 	ldbu	r2,0(r2)
 400c81c:	10803fcc 	andi	r2,r2,255
 400c820:	1080201c 	xori	r2,r2,128
 400c824:	10bfe004 	addi	r2,r2,-128
 400c828:	10000a1e 	bne	r2,zero,400c854 <alt_find_file+0xd8>
        !memcmp (next->name, name, len))
 400c82c:	e0bfff17 	ldw	r2,-4(fp)
 400c830:	10800217 	ldw	r2,8(r2)
 400c834:	e0fffe17 	ldw	r3,-8(fp)
 400c838:	180d883a 	mov	r6,r3
 400c83c:	e17ffd17 	ldw	r5,-12(fp)
 400c840:	1009883a 	mov	r4,r2
 400c844:	400c9840 	call	400c984 <memcmp>
    if (((name[len] == '/') || (name[len] == '\0')) && 
 400c848:	1000021e 	bne	r2,zero,400c854 <alt_find_file+0xd8>
    {
      /* match found */

      return next;
 400c84c:	e0bfff17 	ldw	r2,-4(fp)
 400c850:	00000706 	br	400c870 <alt_find_file+0xf4>
    }
    next = (alt_dev*) next->llist.next;
 400c854:	e0bfff17 	ldw	r2,-4(fp)
 400c858:	10800017 	ldw	r2,0(r2)
 400c85c:	e0bfff15 	stw	r2,-4(fp)
  while (next != (alt_dev*) &alt_fs_list)
 400c860:	e0ffff17 	ldw	r3,-4(fp)
 400c864:	d0a00504 	addi	r2,gp,-32748
 400c868:	18bfcc1e 	bne	r3,r2,400c79c <alt_find_file+0x20>
  }
  
  /* No match found */
  
  return NULL;     
 400c86c:	0005883a 	mov	r2,zero
}
 400c870:	e037883a 	mov	sp,fp
 400c874:	dfc00117 	ldw	ra,4(sp)
 400c878:	df000017 	ldw	fp,0(sp)
 400c87c:	dec00204 	addi	sp,sp,8
 400c880:	f800283a 	ret

0400c884 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
 400c884:	defffc04 	addi	sp,sp,-16
 400c888:	df000315 	stw	fp,12(sp)
 400c88c:	df000304 	addi	fp,sp,12
 400c890:	e13ffd15 	stw	r4,-12(fp)
  alt_32 i;
  int rc = -EMFILE;
 400c894:	00bffa04 	movi	r2,-24
 400c898:	e0bffe15 	stw	r2,-8(fp)
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
 400c89c:	e03fff15 	stw	zero,-4(fp)
 400c8a0:	00001d06 	br	400c918 <alt_get_fd+0x94>
  {
    if (!alt_fd_list[i].dev)
 400c8a4:	e0ffff17 	ldw	r3,-4(fp)
 400c8a8:	1805883a 	mov	r2,r3
 400c8ac:	1085883a 	add	r2,r2,r2
 400c8b0:	10c5883a 	add	r2,r2,r3
 400c8b4:	100490ba 	slli	r2,r2,2
 400c8b8:	00c10074 	movhi	r3,1025
 400c8bc:	10c7883a 	add	r3,r2,r3
 400c8c0:	18b53417 	ldw	r2,-11056(r3)
 400c8c4:	1000111e 	bne	r2,zero,400c90c <alt_get_fd+0x88>
    {
      alt_fd_list[i].dev = dev;
 400c8c8:	e0ffff17 	ldw	r3,-4(fp)
 400c8cc:	1805883a 	mov	r2,r3
 400c8d0:	1085883a 	add	r2,r2,r2
 400c8d4:	10c5883a 	add	r2,r2,r3
 400c8d8:	100490ba 	slli	r2,r2,2
 400c8dc:	e13ffd17 	ldw	r4,-12(fp)
 400c8e0:	00c10074 	movhi	r3,1025
 400c8e4:	10c7883a 	add	r3,r2,r3
 400c8e8:	19353415 	stw	r4,-11056(r3)
      if (i > alt_max_fd)
 400c8ec:	d0e00917 	ldw	r3,-32732(gp)
 400c8f0:	e0bfff17 	ldw	r2,-4(fp)
 400c8f4:	1880020e 	bge	r3,r2,400c900 <alt_get_fd+0x7c>
      {
        alt_max_fd = i;
 400c8f8:	e0bfff17 	ldw	r2,-4(fp)
 400c8fc:	d0a00915 	stw	r2,-32732(gp)
      }
      rc = i;
 400c900:	e0bfff17 	ldw	r2,-4(fp)
 400c904:	e0bffe15 	stw	r2,-8(fp)
      goto alt_get_fd_exit;
 400c908:	00000706 	br	400c928 <alt_get_fd+0xa4>
  for (i = 0; i < ALT_MAX_FD; i++)
 400c90c:	e0bfff17 	ldw	r2,-4(fp)
 400c910:	10800044 	addi	r2,r2,1
 400c914:	e0bfff15 	stw	r2,-4(fp)
 400c918:	e0bfff17 	ldw	r2,-4(fp)
 400c91c:	10800810 	cmplti	r2,r2,32
 400c920:	103fe01e 	bne	r2,zero,400c8a4 <alt_get_fd+0x20>
    }
  }

 alt_get_fd_exit:
 400c924:	0001883a 	nop
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);

  return rc;
 400c928:	e0bffe17 	ldw	r2,-8(fp)
}
 400c92c:	e037883a 	mov	sp,fp
 400c930:	df000017 	ldw	fp,0(sp)
 400c934:	dec00104 	addi	sp,sp,4
 400c938:	f800283a 	ret

0400c93c <atexit>:
 400c93c:	200b883a 	mov	r5,r4
 400c940:	000f883a 	mov	r7,zero
 400c944:	000d883a 	mov	r6,zero
 400c948:	0009883a 	mov	r4,zero
 400c94c:	400c9fc1 	jmpi	400c9fc <__register_exitproc>

0400c950 <exit>:
 400c950:	defffe04 	addi	sp,sp,-8
 400c954:	000b883a 	mov	r5,zero
 400c958:	dc000015 	stw	r16,0(sp)
 400c95c:	dfc00115 	stw	ra,4(sp)
 400c960:	2021883a 	mov	r16,r4
 400c964:	400ca8c0 	call	400ca8c <__call_exitprocs>
 400c968:	00810074 	movhi	r2,1025
 400c96c:	1139ad17 	ldw	r4,-6476(r2)
 400c970:	20800f17 	ldw	r2,60(r4)
 400c974:	10000126 	beq	r2,zero,400c97c <exit+0x2c>
 400c978:	103ee83a 	callr	r2
 400c97c:	8009883a 	mov	r4,r16
 400c980:	400cbac0 	call	400cbac <_exit>

0400c984 <memcmp>:
 400c984:	30800128 	cmpgeui	r2,r6,4
 400c988:	10000d26 	beq	r2,zero,400c9c0 <memcmp+0x3c>
 400c98c:	2144b03a 	or	r2,r4,r5
 400c990:	108000cc 	andi	r2,r2,3
 400c994:	10000726 	beq	r2,zero,400c9b4 <memcmp+0x30>
 400c998:	30bfffc4 	addi	r2,r6,-1
 400c99c:	00000a06 	br	400c9c8 <memcmp+0x44>
 400c9a0:	31bfff04 	addi	r6,r6,-4
 400c9a4:	30800128 	cmpgeui	r2,r6,4
 400c9a8:	21000104 	addi	r4,r4,4
 400c9ac:	29400104 	addi	r5,r5,4
 400c9b0:	10000326 	beq	r2,zero,400c9c0 <memcmp+0x3c>
 400c9b4:	20c00017 	ldw	r3,0(r4)
 400c9b8:	28800017 	ldw	r2,0(r5)
 400c9bc:	18bff826 	beq	r3,r2,400c9a0 <memcmp+0x1c>
 400c9c0:	30bfffc4 	addi	r2,r6,-1
 400c9c4:	30000b26 	beq	r6,zero,400c9f4 <memcmp+0x70>
 400c9c8:	11800044 	addi	r6,r2,1
 400c9cc:	218d883a 	add	r6,r4,r6
 400c9d0:	00000106 	br	400c9d8 <memcmp+0x54>
 400c9d4:	21800726 	beq	r4,r6,400c9f4 <memcmp+0x70>
 400c9d8:	20800003 	ldbu	r2,0(r4)
 400c9dc:	28c00003 	ldbu	r3,0(r5)
 400c9e0:	21000044 	addi	r4,r4,1
 400c9e4:	29400044 	addi	r5,r5,1
 400c9e8:	10fffa26 	beq	r2,r3,400c9d4 <memcmp+0x50>
 400c9ec:	10c5c83a 	sub	r2,r2,r3
 400c9f0:	f800283a 	ret
 400c9f4:	0005883a 	mov	r2,zero
 400c9f8:	f800283a 	ret

0400c9fc <__register_exitproc>:
 400c9fc:	00810074 	movhi	r2,1025
 400ca00:	10f9ad17 	ldw	r3,-6476(r2)
 400ca04:	18805217 	ldw	r2,328(r3)
 400ca08:	10001726 	beq	r2,zero,400ca68 <__register_exitproc+0x6c>
 400ca0c:	10c00117 	ldw	r3,4(r2)
 400ca10:	1a000808 	cmpgei	r8,r3,32
 400ca14:	40001b1e 	bne	r8,zero,400ca84 <__register_exitproc+0x88>
 400ca18:	20000b26 	beq	r4,zero,400ca48 <__register_exitproc+0x4c>
 400ca1c:	181090ba 	slli	r8,r3,2
 400ca20:	02400044 	movi	r9,1
 400ca24:	48d2983a 	sll	r9,r9,r3
 400ca28:	1211883a 	add	r8,r2,r8
 400ca2c:	41802215 	stw	r6,136(r8)
 400ca30:	11806217 	ldw	r6,392(r2)
 400ca34:	21000098 	cmpnei	r4,r4,2
 400ca38:	324cb03a 	or	r6,r6,r9
 400ca3c:	11806215 	stw	r6,392(r2)
 400ca40:	41c04215 	stw	r7,264(r8)
 400ca44:	20000b26 	beq	r4,zero,400ca74 <__register_exitproc+0x78>
 400ca48:	19000084 	addi	r4,r3,2
 400ca4c:	200890ba 	slli	r4,r4,2
 400ca50:	18c00044 	addi	r3,r3,1
 400ca54:	10c00115 	stw	r3,4(r2)
 400ca58:	1105883a 	add	r2,r2,r4
 400ca5c:	11400015 	stw	r5,0(r2)
 400ca60:	0005883a 	mov	r2,zero
 400ca64:	f800283a 	ret
 400ca68:	18805304 	addi	r2,r3,332
 400ca6c:	18805215 	stw	r2,328(r3)
 400ca70:	003fe606 	br	400ca0c <__register_exitproc+0x10>
 400ca74:	11006317 	ldw	r4,396(r2)
 400ca78:	2248b03a 	or	r4,r4,r9
 400ca7c:	11006315 	stw	r4,396(r2)
 400ca80:	003ff106 	br	400ca48 <__register_exitproc+0x4c>
 400ca84:	00bfffc4 	movi	r2,-1
 400ca88:	f800283a 	ret

0400ca8c <__call_exitprocs>:
 400ca8c:	defff704 	addi	sp,sp,-36
 400ca90:	00810074 	movhi	r2,1025
 400ca94:	dcc00315 	stw	r19,12(sp)
 400ca98:	14f9ad17 	ldw	r19,-6476(r2)
 400ca9c:	dc800215 	stw	r18,8(sp)
 400caa0:	dfc00815 	stw	ra,32(sp)
 400caa4:	9c805217 	ldw	r18,328(r19)
 400caa8:	ddc00715 	stw	r23,28(sp)
 400caac:	dd800615 	stw	r22,24(sp)
 400cab0:	dd400515 	stw	r21,20(sp)
 400cab4:	dd000415 	stw	r20,16(sp)
 400cab8:	dc400115 	stw	r17,4(sp)
 400cabc:	dc000015 	stw	r16,0(sp)
 400cac0:	90001026 	beq	r18,zero,400cb04 <__call_exitprocs+0x78>
 400cac4:	202b883a 	mov	r21,r4
 400cac8:	282d883a 	mov	r22,r5
 400cacc:	05000044 	movi	r20,1
 400cad0:	94000117 	ldw	r16,4(r18)
 400cad4:	847fffc4 	addi	r17,r16,-1
 400cad8:	88000a16 	blt	r17,zero,400cb04 <__call_exitprocs+0x78>
 400cadc:	84000044 	addi	r16,r16,1
 400cae0:	802090ba 	slli	r16,r16,2
 400cae4:	9421883a 	add	r16,r18,r16
 400cae8:	b0001126 	beq	r22,zero,400cb30 <__call_exitprocs+0xa4>
 400caec:	80804017 	ldw	r2,256(r16)
 400caf0:	15800f26 	beq	r2,r22,400cb30 <__call_exitprocs+0xa4>
 400caf4:	8c7fffc4 	addi	r17,r17,-1
 400caf8:	88bfffd8 	cmpnei	r2,r17,-1
 400cafc:	843fff04 	addi	r16,r16,-4
 400cb00:	103ff91e 	bne	r2,zero,400cae8 <__call_exitprocs+0x5c>
 400cb04:	dfc00817 	ldw	ra,32(sp)
 400cb08:	ddc00717 	ldw	r23,28(sp)
 400cb0c:	dd800617 	ldw	r22,24(sp)
 400cb10:	dd400517 	ldw	r21,20(sp)
 400cb14:	dd000417 	ldw	r20,16(sp)
 400cb18:	dcc00317 	ldw	r19,12(sp)
 400cb1c:	dc800217 	ldw	r18,8(sp)
 400cb20:	dc400117 	ldw	r17,4(sp)
 400cb24:	dc000017 	ldw	r16,0(sp)
 400cb28:	dec00904 	addi	sp,sp,36
 400cb2c:	f800283a 	ret
 400cb30:	90800117 	ldw	r2,4(r18)
 400cb34:	81800017 	ldw	r6,0(r16)
 400cb38:	10bfffc4 	addi	r2,r2,-1
 400cb3c:	14401726 	beq	r2,r17,400cb9c <__call_exitprocs+0x110>
 400cb40:	80000015 	stw	zero,0(r16)
 400cb44:	303feb26 	beq	r6,zero,400caf4 <__call_exitprocs+0x68>
 400cb48:	a446983a 	sll	r3,r20,r17
 400cb4c:	90806217 	ldw	r2,392(r18)
 400cb50:	95c00117 	ldw	r23,4(r18)
 400cb54:	1884703a 	and	r2,r3,r2
 400cb58:	1000081e 	bne	r2,zero,400cb7c <__call_exitprocs+0xf0>
 400cb5c:	303ee83a 	callr	r6
 400cb60:	90c00117 	ldw	r3,4(r18)
 400cb64:	98805217 	ldw	r2,328(r19)
 400cb68:	1dc0011e 	bne	r3,r23,400cb70 <__call_exitprocs+0xe4>
 400cb6c:	14bfe126 	beq	r2,r18,400caf4 <__call_exitprocs+0x68>
 400cb70:	103fe426 	beq	r2,zero,400cb04 <__call_exitprocs+0x78>
 400cb74:	1025883a 	mov	r18,r2
 400cb78:	003fd506 	br	400cad0 <__call_exitprocs+0x44>
 400cb7c:	90806317 	ldw	r2,396(r18)
 400cb80:	81002017 	ldw	r4,128(r16)
 400cb84:	1886703a 	and	r3,r3,r2
 400cb88:	1800061e 	bne	r3,zero,400cba4 <__call_exitprocs+0x118>
 400cb8c:	200b883a 	mov	r5,r4
 400cb90:	a809883a 	mov	r4,r21
 400cb94:	303ee83a 	callr	r6
 400cb98:	003ff106 	br	400cb60 <__call_exitprocs+0xd4>
 400cb9c:	94400115 	stw	r17,4(r18)
 400cba0:	003fe806 	br	400cb44 <__call_exitprocs+0xb8>
 400cba4:	303ee83a 	callr	r6
 400cba8:	003fed06 	br	400cb60 <__call_exitprocs+0xd4>

0400cbac <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
 400cbac:	defffd04 	addi	sp,sp,-12
 400cbb0:	df000215 	stw	fp,8(sp)
 400cbb4:	df000204 	addi	fp,sp,8
 400cbb8:	e13ffe15 	stw	r4,-8(fp)
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
  ALT_OS_STOP();
 400cbbc:	0001883a 	nop
 400cbc0:	e0bffe17 	ldw	r2,-8(fp)
 400cbc4:	e0bfff15 	stw	r2,-4(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  register int r2 asm ("r2") = exit_code;
 400cbc8:	e0bfff17 	ldw	r2,-4(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "r"(r2), "r"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
 400cbcc:	10000226 	beq	r2,zero,400cbd8 <_exit+0x2c>
    ALT_SIM_FAIL();
 400cbd0:	002af070 	cmpltui	zero,zero,43969
  } else {
    ALT_SIM_PASS();
  }
#endif /* DEBUG_STUB */
}
 400cbd4:	00000106 	br	400cbdc <_exit+0x30>
    ALT_SIM_PASS();
 400cbd8:	002af0b0 	cmpltui	zero,zero,43970
}
 400cbdc:	0001883a 	nop
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
 400cbe0:	0001883a 	nop
 400cbe4:	003ffe06 	br	400cbe0 <_exit+0x34>
