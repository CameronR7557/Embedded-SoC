
Lab04.elf:     file format elf32-littlenios2
Lab04.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x04000364

Program Header:
    LOAD off    0x00001000 vaddr 0x04000000 paddr 0x04000000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x04000020 paddr 0x04000020 align 2**12
         filesz 0x0000c94c memsz 0x0000c94c flags r-x
    LOAD off    0x0000d96c vaddr 0x0400c96c paddr 0x0400e3dc align 2**12
         filesz 0x00001a70 memsz 0x00001a70 flags rw-
    LOAD off    0x00000e4c vaddr 0x0400fe4c paddr 0x0400fe4c align 2**12
         filesz 0x00000000 memsz 0x00800268 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  04000000  04000000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000344  04000020  04000020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         0000c594  04000364  04000364  00001364  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00000074  0400c8f8  0400c8f8  0000d8f8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00001a70  0400c96c  0400e3dc  0000d96c  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          008002ee  0400fe4c  0400fe4c  0000fe4c  2**2
                  ALLOC, SMALL_DATA
  6 .SDRAM        00000000  048100b4  048100b4  0000f3dc  2**0
                  CONTENTS
  7 .comment      0000002d  00000000  00000000  0000f3dc  2**0
                  CONTENTS, READONLY
  8 .debug_aranges 00000b90  00000000  00000000  0000f410  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  9 .debug_info   0001c32b  00000000  00000000  0000ffa0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 10 .debug_abbrev 00007ede  00000000  00000000  0002c2cb  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 11 .debug_line   0000848a  00000000  00000000  000341a9  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_frame  00002ad8  00000000  00000000  0003c634  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_str    000034ba  00000000  00000000  0003f10c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_alt_sim_info 00000010  00000000  00000000  000425c8  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_ranges 00000098  00000000  00000000  000425d8  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_line_str 0000175e  00000000  00000000  00042670  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_loclists 000041c3  00000000  00000000  00043dce  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_rnglists 000005db  00000000  00000000  00047f91  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .thread_model 00000003  00000000  00000000  0004c376  2**0
                  CONTENTS, READONLY
 20 .cpu          00000005  00000000  00000000  0004c379  2**0
                  CONTENTS, READONLY
 21 .qsys         00000001  00000000  00000000  0004c37e  2**0
                  CONTENTS, READONLY
 22 .simulation_enabled 00000001  00000000  00000000  0004c37f  2**0
                  CONTENTS, READONLY
 23 .stderr_dev   00000005  00000000  00000000  0004c380  2**0
                  CONTENTS, READONLY
 24 .stdin_dev    00000005  00000000  00000000  0004c385  2**0
                  CONTENTS, READONLY
 25 .stdout_dev   00000005  00000000  00000000  0004c38a  2**0
                  CONTENTS, READONLY
 26 .sopc_system_name 00000005  00000000  00000000  0004c38f  2**0
                  CONTENTS, READONLY
 27 .quartus_project_dir 00000038  00000000  00000000  0004c394  2**0
                  CONTENTS, READONLY
 28 .jdi          0000422c  00000000  00000000  0004c3cc  2**0
                  CONTENTS, READONLY
 29 .sopcinfo     00040120  00000000  00000000  000505f8  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
04000000 l    d  .entry	00000000 .entry
04000020 l    d  .exceptions	00000000 .exceptions
04000364 l    d  .text	00000000 .text
0400c8f8 l    d  .rodata	00000000 .rodata
0400c96c l    d  .rwdata	00000000 .rwdata
0400fe4c l    d  .bss	00000000 .bss
048100b4 l    d  .SDRAM	00000000 .SDRAM
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_line_str	00000000 .debug_line_str
00000000 l    d  .debug_loclists	00000000 .debug_loclists
00000000 l    d  .debug_rnglists	00000000 .debug_rnglists
00000000 l    df *ABS*	00000000 crt0.o
0400039c l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 port_asm.o
04000020 l       .exceptions	00000000 save_context
0400009c l       .exceptions	00000000 save_sp_to_pxCurrentTCB
04000104 l       .exceptions	00000000 irq_test_user
0400016c l       .exceptions	00000000 restore_context
04000124 l       .exceptions	00000000 soft_exceptions
04000134 l       .exceptions	00000000 call_scheduler
04000148 l       .exceptions	00000000 exceptions_unknown_user
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_instruction_exception_entry.c
00000000 l    df *ABS*	00000000 croutine.c
00000000 l    df *ABS*	00000000 event_groups.c
04000a30 l     F .text	00000070 prvTestWaitCondition
00000000 l    df *ABS*	00000000 list.c
00000000 l    df *ABS*	00000000 port.c
04000d30 l     F .text	0000002c prvReadGp
04000e94 l     F .text	00000090 prvSetupTimerInterrupt
00000000 l    df *ABS*	00000000 heap_1.c
0400fec4 l     O .bss	00800000 ucHeap
0400fe4c l     O .bss	00000004 xNextFreeByte
0400fe50 l     O .bss	00000004 pucAlignedHeap.0
00000000 l    df *ABS*	00000000 queue.c
04001574 l     F .text	00000084 prvInitialiseNewQueue
040015f8 l     F .text	00000060 prvInitialiseMutex
04002430 l     F .text	0000018c prvCopyDataToQueue
040027e4 l     F .text	00000058 prvIsQueueFull
04002658 l     F .text	000000f4 prvUnlockQueue
040025bc l     F .text	0000009c prvCopyDataFromQueue
0400274c l     F .text	00000050 prvIsQueueEmpty
040023e0 l     F .text	00000050 prvGetDisinheritPriorityAfterTimeout
00000000 l    df *ABS*	00000000 stream_buffer.c
0400372c l     F .text	00000080 prvInitialiseNewStreamBuffer
040036b8 l     F .text	00000074 prvBytesInBuffer
04002e8c l     F .text	000000d0 prvWriteMessageToBuffer
040034f8 l     F .text	000000e0 prvWriteBytesToBuffer
04003234 l     F .text	000000e0 prvReadMessageFromBuffer
040035d8 l     F .text	000000e0 prvReadBytesFromBuffer
00000000 l    df *ABS*	00000000 tasks.c
0480fec4 l     O .bss	00000064 pxReadyTasksLists
0480ff28 l     O .bss	00000014 xDelayedTaskList1
0480ff3c l     O .bss	00000014 xDelayedTaskList2
0400fe58 l     O .bss	00000004 pxDelayedTaskList
0400fe5c l     O .bss	00000004 pxOverflowDelayedTaskList
0480ff50 l     O .bss	00000014 xPendingReadyList
0480ff64 l     O .bss	00000014 xTasksWaitingTermination
0400fe60 l     O .bss	00000004 uxDeletedTasksWaitingCleanUp
0480ff78 l     O .bss	00000014 xSuspendedTaskList
0400fe64 l     O .bss	00000004 uxCurrentNumberOfTasks
0400fe68 l     O .bss	00000004 xTickCount
0400fe6c l     O .bss	00000004 uxTopReadyPriority
0400fe70 l     O .bss	00000004 xSchedulerRunning
0400fe74 l     O .bss	00000004 xPendedTicks
0400fe78 l     O .bss	00000004 xYieldPending
0400fe7c l     O .bss	00000004 xNumOfOverflows
0400fe80 l     O .bss	00000004 uxTaskNumber
0400fe84 l     O .bss	00000004 xNextTaskUnblockTime
0400fe88 l     O .bss	00000004 xIdleTaskHandle
0400fe8c l     O .bss	00000004 uxSchedulerSuspended
040038a0 l     F .text	000001ac prvInitialiseNewTask
04003a4c l     F .text	000001b8 prvAddNewTaskToReadyList
040056f8 l     F .text	000000c0 prvInitialiseTaskLists
04005940 l     F .text	00000048 prvResetNextTaskUnblockTime
040058fc l     F .text	00000044 prvDeleteTCB
04006e34 l     F .text	00000144 prvAddCurrentTaskToDelayedList
04004274 l     F .text	0000006c prvTaskIsTaskSuspended
040056dc l     F .text	0000001c prvIdleTask
040057b8 l     F .text	00000080 prvCheckTasksWaitingTermination
04005838 l     F .text	00000064 prvTaskCheckFreeStackSpace
00000000 l    df *ABS*	00000000 timers.c
00000000 l    df *ABS*	00000000 main.c
00000000 l    df *ABS*	00000000 lib2-mul.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 findfp.c
04007794 l     F .text	00000008 __fp_lock
040077a8 l     F .text	00000008 __fp_unlock
040077b0 l     F .text	00000168 __sinit.part.0
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 impure.c
0400c96c l     O .rwdata	00000424 impure_data
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 closer.c
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 lseekr.c
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 readr.c
00000000 l    df *ABS*	00000000 fstatr.c
00000000 l    df *ABS*	00000000 isattyr.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 alt_close.c
0400a1f4 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_dev.c
0400a30c l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_fstat.c
0400a338 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_isatty.c
0400a6c8 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_load.c
0400a7b4 l     F .text	00000068 alt_load_section
00000000 l    df *ABS*	00000000 alt_lseek.c
0400a8a0 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
00000000 l    df *ABS*	00000000 alt_read.c
0400aa80 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
0400e3d0 l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_write.c
0400acec l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_sys_init.c
0400ae2c l     F .text	00000034 alt_dev_reg
0400d340 l     O .rwdata	00001060 DEBUG
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
0400b120 l     F .text	00000214 altera_avalon_jtag_uart_irq
0400b334 l     F .text	000000a8 altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
0400b980 l     F .text	0000007c alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
0400bc00 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_do_ctors.c
00000000 l    df *ABS*	00000000 alt_do_dtors.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
0400be40 l     F .text	000000d4 alt_open_fd
00000000 l    df *ABS*	00000000 alt_open.c
0400bf90 l     F .text	0000003c alt_get_errno
0400bfcc l     F .text	000000dc alt_file_locked
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 alt_exit.c
0400feb4 g     O .bss	00000004 alt_instruction_exception_handler
04009fe8 g     F .text	00000058 _isatty_r
0400a9bc g     F .text	0000007c alt_main
0400761c g     F .text	000000d0 _puts_r
0480ffb4 g     O .bss	00000100 alt_irq
04009c94 g     F .text	00000064 _lseek_r
0400015c g       .exceptions	00000000 restore_sp_from_pxCurrentTCB
04004f68 g     F .text	000000bc vTaskPlaceOnUnorderedEventList
04001164 g     F .text	0000002c xPortGetFreeHeapSize
04000788 g     F .text	0000003c xEventGroupGetBitsFromISR
0400e3dc g       *ABS*	00000000 __flash_rwdata_start
048100b4 g       *ABS*	00000000 __alt_heap_start
04003e44 g     F .text	00000058 uxTaskPriorityGet
0400fe90 g     O .bss	00000004 pushbutton_queue
04009208 g     F .text	0000005c __sseek
04007ad8 g     F .text	00000010 __sinit
04007004 g     F .text	00000060 taskReadPBs
04007918 g     F .text	00000078 __sfmoreglue
04002f5c g     F .text	00000160 xStreamBufferReceive
0400aa5c g     F .text	00000024 __malloc_unlock
04003cf8 g     F .text	000000f0 xTaskDelayUntil
040003f4 g     F .text	00000184 xEventGroupSync
040089b8 g     F .text	00000128 memmove
04006d88 g     F .text	000000ac ulTaskGenericNotifyValueClear
04005f74 g     F .text	00000054 vTaskEnterCritical
04007ac4 g     F .text	00000014 _cleanup
04001a04 g     F .text	00000108 xQueueGenericSendFromISR
04004a5c g     F .text	00000040 pcTaskGetName
04002ae4 g     F .text	000000a4 xStreamBufferSpacesAvailable
0400c3d8 g     F .text	00000024 altera_nios2_gen2_irq_init
040029c4 g     F .text	000000b4 xStreamBufferReset
04000000 g     F .entry	0000000c __reset
040016b4 g     F .text	00000090 xQueueGiveMutexRecursive
0400fe54 g     O .bss	00000004 pxCurrentTCB
04000020 g       *ABS*	00000000 __flash_exceptions_start
04009f88 g     F .text	00000060 _fstat_r
0400fea0 g     O .bss	00000004 errno
04009180 g     F .text	00000008 __seofread
04002d98 g     F .text	000000f4 xStreamBufferSendFromISR
0400feac g     O .bss	00000004 alt_argv
040163a0 g       *ABS*	00000000 _gp
04003ee8 g     F .text	00000268 vTaskPrioritySet
04005590 g     F .text	0000003c vTaskInternalSetTimeOutState
04000578 g     F .text	000001a8 xEventGroupWaitBits
04000f68 g     F .text	000000cc _alt_ic_isr_register
0400d1c0 g     O .rwdata	00000180 alt_fd_list
04000e3c g     F .text	00000038 xPortStartScheduler
040046a0 g     F .text	00000048 vTaskEndScheduler
0400c3fc g     F .text	00000090 alt_find_dev
040073dc g     F .text	00000100 memcpy
04004f18 g     F .text	00000050 vTaskPlaceOnEventList
040052f4 g     F .text	00000250 vTaskRemoveFromUnorderedEventList
0400779c g     F .text	0000000c _cleanup_r
0400bf14 g     F .text	0000007c alt_io_redirect
0400225c g     F .text	0000007c xQueuePeekFromISR
0400c8f8 g       *ABS*	00000000 __DTOR_END__
040076ec g     F .text	00000010 puts
0400bdcc g     F .text	00000074 alt_exception_cause_generated_bad_addr
0400111c g     F .text	00000024 vPortFree
04001da4 g     F .text	00000210 xQueueSemaphoreTake
0400b538 g     F .text	00000220 altera_avalon_jtag_uart_read
0400a134 g     F .text	00000064 .hidden __udivsi3
0400a704 g     F .text	000000b0 isatty
0400589c g     F .text	00000060 uxTaskGetStackHighWaterMark
04000b34 g     F .text	0000008c vListInsertEnd
0400fe9c g     O .bss	00000004 __malloc_top_pad
040060a8 g     F .text	00000104 ulTaskGenericNotifyTake
040003a0 g     F .text	00000054 xEventGroupCreate
04007b20 g     F .text	000004a8 __sfvwrite_r
040090d4 g     F .text	00000058 _sbrk_r
040009b8 g     F .text	0000003c vEventGroupSetBitsCallback
04004468 g     F .text	000001a4 xTaskResumeFromISR
04009f24 g     F .text	00000064 _read_r
04000b08 g     F .text	0000002c vListInitialiseItem
0400e3c4 g     O .rwdata	00000004 alt_max_fd
04000f24 g     F .text	00000044 vPortSysTickHandler
04009474 g     F .text	000000f8 _fclose_r
04001bfc g     F .text	000001a8 xQueueReceive
040097e4 g     F .text	00000084 fflush
0400fe98 g     O .bss	00000004 __malloc_max_sbrked_mem
04003e9c g     F .text	0000004c uxTaskPriorityGetFromISR
0400a8dc g     F .text	000000e0 lseek
0400e3a4 g     O .rwdata	00000004 _global_impure_ptr
040007c4 g     F .text	00000180 xEventGroupSetBits
04008ae0 g     F .text	000005f4 _realloc_r
048100b4 g       *ABS*	00000000 __bss_end
0400a5e0 g     F .text	000000e8 alt_iic_isr_register
0400c2ac g     F .text	0000012c alt_tick
04001034 g     F .text	000000e8 pvPortMalloc
04007af8 g     F .text	00000014 __fp_lock_all
0400a594 g     F .text	0000004c alt_ic_irq_enabled
040023a4 g     F .text	0000003c vQueueDelete
04000e74 g     F .text	00000020 vPortEndScheduler
04000aa0 g     F .text	00000068 vListInitialise
04003314 g     F .text	00000058 xStreamBufferIsEmpty
0400c208 g     F .text	000000a4 alt_alarm_stop
0400fea4 g     O .bss	00000004 alt_irq_active
0400023c g     F .exceptions	000000c8 alt_irq_handler
0400d198 g     O .rwdata	00000028 alt_dev_null
040049e8 g     F .text	00000028 xTaskGetTickCount
04001850 g     F .text	000001b4 xQueueGenericSend
04002bc8 g     F .text	000001d0 xStreamBufferSend
04003470 g     F .text	00000088 xStreamBufferReceiveCompletedFromISR
0400bbe0 g     F .text	00000020 alt_dcache_flush_all
04006a30 g     F .text	000002cc vTaskGenericNotifyGiveFromISR
040030bc g     F .text	00000098 xStreamBufferNextMessageLengthBytes
04005bb8 g     F .text	000001b8 xTaskPriorityDisinherit
0400e3dc g       *ABS*	00000000 __ram_rwdata_end
0400e3bc g     O .rwdata	00000008 alt_dev_list
0400ad28 g     F .text	00000104 write
04005024 g     F .text	000002d0 xTaskRemoveFromEventList
0400c96c g       *ABS*	00000000 __ram_rodata_end
0400a374 g     F .text	000000bc fstat
04000720 g     F .text	00000068 xEventGroupClearBits
04000000 g       *ABS*	00000000 __alt_mem_SDRAM
04001fb4 g     F .text	000001b0 xQueuePeek
0400a198 g     F .text	0000005c .hidden __umodsi3
048100b4 g       *ABS*	00000000 end
04003154 g     F .text	000000e0 xStreamBufferReceiveFromISR
04003c04 g     F .text	000000f4 vTaskDelete
0400b060 g     F .text	000000c0 altera_avalon_jtag_uart_init
04000304 g     F .exceptions	00000060 alt_instruction_exception_entry
04006070 g     F .text	00000038 pvTaskIncrementMutexHeldCount
0400c8f8 g       *ABS*	00000000 __CTOR_LIST__
08000000 g       *ABS*	00000000 __alt_stack_pointer
0400b9fc g     F .text	00000084 alt_avalon_timer_sc_init
0400b758 g     F .text	00000228 altera_avalon_jtag_uart_write
04007ae8 g     F .text	00000004 __sfp_lock_acquire
040088bc g     F .text	000000fc memchr
040055cc g     F .text	000000e8 xTaskCheckForTimeOut
0400998c g     F .text	00000308 _free_r
040059b0 g     F .text	00000208 xTaskPriorityInherit
0400c79c g     F .text	00000120 __call_exitprocs
040061ac g     F .text	00000164 xTaskGenericNotifyWait
04002960 g     F .text	00000064 vStreamBufferDelete
0400e3ac g     O .rwdata	00000004 __malloc_sbrk_base
04000364 g     F .text	0000003c _start
0400feb8 g     O .bss	00000004 _alt_tick_rate
040046e8 g     F .text	0000002c vTaskSuspendAll
0400336c g     F .text	0000007c xStreamBufferIsFull
04004a10 g     F .text	0000002c xTaskGetTickCountFromISR
0400febc g     O .bss	00000008 _alt_nticks
0400aabc g     F .text	00000108 read
0400ae9c g     F .text	00000060 alt_sys_init
04000c98 g     F .text	00000098 uxListRemove
0400c70c g     F .text	00000090 __register_exitproc
0400288c g     F .text	000000d4 xStreamBufferGenericCreate
0400b3dc g     F .text	00000068 altera_avalon_jtag_uart_close
040073b4 g     F .text	00000028 .hidden __mulsi3
0400c96c g       *ABS*	00000000 __ram_rwdata_start
0400c8f8 g       *ABS*	00000000 __ram_rodata_start
0480ff8c g     O .bss	00000028 __malloc_current_mallinfo
040042e0 g     F .text	00000188 vTaskResume
04004e28 g     F .text	000000f0 vTaskSwitchContext
0400aefc g     F .text	00000060 altera_avalon_jtag_uart_read_fd
0400c594 g     F .text	000000b8 alt_get_fd
0400941c g     F .text	00000058 _close_r
0400c694 g     F .text	00000078 memcmp
0400afbc g     F .text	00000050 altera_avalon_jtag_uart_close_fd
048100b4 g       *ABS*	00000000 __alt_stack_base
0400b00c g     F .text	00000054 altera_avalon_jtag_uart_ioctl_fd
040092d0 g     F .text	0000014c __swsetup_r
04004150 g     F .text	00000124 vTaskSuspend
04007990 g     F .text	00000134 __sfp
04004a9c g     F .text	00000050 xTaskCatchUpTicks
04004a3c g     F .text	00000020 uxTaskGetNumberOfTasks
0400cd90 g     O .rwdata	00000408 __malloc_av_
04007af4 g     F .text	00000004 __sinit_lock_release
0400912c g     F .text	00000054 __sread
0400c48c g     F .text	00000108 alt_find_file
0400bc3c g     F .text	000000a8 alt_dev_llist_insert
0400aa38 g     F .text	00000024 __malloc_lock
0400ac34 g     F .text	000000b8 sbrk
04001744 g     F .text	0000009c xQueueTakeMutexRecursive
04009784 g     F .text	00000060 _fflush_r
04000944 g     F .text	00000074 vEventGroupDelete
04006310 g     F .text	00000348 xTaskGenericNotify
0400fe4c g       *ABS*	00000000 __bss_start
040074dc g     F .text	00000140 memset
04006f78 g     F .text	0000008c main
0400feb0 g     O .bss	00000004 alt_envp
0400fe94 g     O .bss	00000004 __malloc_max_total_mem
0400af5c g     F .text	00000060 altera_avalon_jtag_uart_write_fd
04000bc0 g     F .text	000000d8 vListInsert
04009264 g     F .text	00000008 __sclose
08000000 g       *ABS*	00000000 __alt_heap_limit
0400956c g     F .text	00000010 fclose
04008108 g     F .text	000007b4 _malloc_r
0400e3c8 g     O .rwdata	00000004 alt_errno
04007fc8 g     F .text	00000098 _fwalk
04002164 g     F .text	000000f8 xQueueReceiveFromISR
04005988 g     F .text	00000028 xTaskGetCurrentTaskHandle
0400a040 g     F .text	00000080 .hidden __divsi3
040013d0 g     F .text	000001a4 xQueueGenericCreate
04009868 g     F .text	00000124 _malloc_trim_r
0400c8f8 g       *ABS*	00000000 __CTOR_END__
040017e0 g     F .text	00000070 xQueueCreateCountingSemaphore
0400c8f8 g       *ABS*	00000000 __flash_rodata_start
0400c8f8 g       *ABS*	00000000 __DTOR_LIST__
04002a78 g     F .text	0000006c xStreamBufferSetTriggerLevel
04006658 g     F .text	000003d8 xTaskGenericNotifyFromISR
0400ae60 g     F .text	0000003c alt_irq_init
0400abc4 g     F .text	00000070 alt_release_fd
04004714 g     F .text	000002d4 xTaskResumeAll
0400e3a0 g     O .rwdata	00000004 uxTopUsedPriority
04002318 g     F .text	00000054 uxQueueSpacesAvailable
0400460c g     F .text	00000094 vTaskStartScheduler
0400c64c g     F .text	00000014 atexit
0400926c g     F .text	00000064 _write_r
0400283c g     F .text	00000050 xQueueIsQueueFullFromISR
0400e3a8 g     O .rwdata	00000004 _impure_ptr
0400fea8 g     O .bss	00000004 alt_argc
0400957c g     F .text	00000208 __sflush_r
0400bd48 g     F .text	00000064 _do_dtors
04000020 g       .exceptions	00000000 alt_irq_entry
04007b0c g     F .text	00000014 __fp_unlock_all
040056b4 g     F .text	00000028 vTaskMissedYield
0400e3b4 g     O .rwdata	00000008 alt_fs_list
040022d8 g     F .text	00000040 uxQueueMessagesWaiting
04004aec g     F .text	0000033c xTaskIncrementTick
04000020 g       *ABS*	00000000 __ram_exceptions_start
04009e98 g     F .text	0000008c __swhatbuf_r
0400a430 g     F .text	00000050 alt_ic_isr_register
04001190 g     F .text	00000240 xQueueGenericReset
0400e3dc g       *ABS*	00000000 _edata
048100b4 g       *ABS*	00000000 _end
04000364 g       *ABS*	00000000 __ram_exceptions_end
0400b444 g     F .text	000000f4 altera_avalon_jtag_uart_ioctl
040037ac g     F .text	000000f4 xTaskCreate
04001140 g     F .text	00000024 vPortInitialiseBlocks
04006cfc g     F .text	0000008c xTaskGenericNotifyStateClear
0400a508 g     F .text	0000008c alt_ic_irq_disable
04009188 g     F .text	00000080 __swrite
0400e3b0 g     O .rwdata	00000004 __malloc_trim_threshold
0400c660 g     F .text	00000034 exit
04008060 g     F .text	000000a8 _fwalk_reent
04007064 g     F .text	00000350 taskLEDControl
0400a0c0 g     F .text	00000074 .hidden __modsi3
04003de8 g     F .text	0000005c vTaskDelay
08000000 g       *ABS*	00000000 __alt_data_end
04000020 g     F .exceptions	00000000 alt_exception
04007aec g     F .text	00000004 __sfp_lock_release
04005d70 g     F .text	00000204 vTaskPriorityDisinheritAfterTimeout
0400c8bc g     F .text	0000003c _exit
0400ba80 g     F .text	00000160 alt_alarm_start
04009cf8 g     F .text	000001a0 __smakebuf_r
04005fc8 g     F .text	00000064 vTaskExitCritical
040076fc g     F .text	00000098 strlen
04000d5c g     F .text	000000e0 pxPortInitialiseStack
0400c0a8 g     F .text	00000160 open
0400bdac g     F .text	00000020 alt_icache_flush_all
04005544 g     F .text	0000004c vTaskSetTimeOutState
0400e3cc g     O .rwdata	00000004 alt_priority_mask
0400a480 g     F .text	00000088 alt_ic_irq_enable
0400236c g     F .text	00000038 uxQueueMessagesWaitingFromISR
0400279c g     F .text	00000048 xQueueIsQueueEmptyFromISR
04002b88 g     F .text	00000040 xStreamBufferBytesAvailable
0400e3d4 g     O .rwdata	00000008 alt_alarm_list
0400bce4 g     F .text	00000064 _do_ctors
0400602c g     F .text	00000044 uxTaskResetEventItemValue
04001658 g     F .text	0000005c xQueueCreateMutex
0400a230 g     F .text	000000dc close
0400a81c g     F .text	00000084 alt_load
040009f4 g     F .text	0000003c vEventGroupClearBitsCallback
040033e8 g     F .text	00000088 xStreamBufferSendCompletedFromISR
04001b0c g     F .text	000000f0 xQueueGiveFromISR
04007af0 g     F .text	00000004 __sinit_lock_acquire



Disassembly of section .entry:

04000000 <__reset>:
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
 4000000:	00410034 	movhi	at,1024
    ori r1, r1, %lo(_start)
 4000004:	0840d914 	ori	at,at,868
    jmp r1
 4000008:	0800683a 	jmp	at
	...

Disassembly of section .exceptions:

04000020 <alt_exception>:
# Entry point for exceptions.
.section .exceptions.entry.user, "xa"

# Save the entire context of a task.
save_context:
	addi	sp,	sp, -116		# Create space on the stack.
 4000020:	deffe304 	addi	sp,sp,-116
	stw		ra, 0(sp)
 4000024:	dfc00015 	stw	ra,0(sp)
								# Leave a gap for muldiv 0
	stw		at, 8(sp)
 4000028:	d8400215 	stw	at,8(sp)
	stw		r2, 12(sp)
 400002c:	d8800315 	stw	r2,12(sp)
	stw		r3, 16(sp)
 4000030:	d8c00415 	stw	r3,16(sp)
	stw		r4, 20(sp)
 4000034:	d9000515 	stw	r4,20(sp)
	stw		r5, 24(sp)
 4000038:	d9400615 	stw	r5,24(sp)
	stw		r6, 28(sp)
 400003c:	d9800715 	stw	r6,28(sp)
	stw		r7, 32(sp)
 4000040:	d9c00815 	stw	r7,32(sp)
	stw		r8, 36(sp)
 4000044:	da000915 	stw	r8,36(sp)
	stw		r9, 40(sp)
 4000048:	da400a15 	stw	r9,40(sp)
	stw		r10, 44(sp)
 400004c:	da800b15 	stw	r10,44(sp)
	stw		r11, 48(sp)
 4000050:	dac00c15 	stw	r11,48(sp)
	stw		r12, 52(sp)
 4000054:	db000d15 	stw	r12,52(sp)
	stw		r13, 56(sp)
 4000058:	db400e15 	stw	r13,56(sp)
	stw		r14, 60(sp)
 400005c:	db800f15 	stw	r14,60(sp)
	stw		r15, 64(sp)
 4000060:	dbc01015 	stw	r15,64(sp)
	rdctl	r5, estatus 		# Save the eStatus
 4000064:	000b307a 	rdctl	r5,estatus
	stw		r5, 68(sp)
 4000068:	d9401115 	stw	r5,68(sp)
	addi	r15, ea, -4			# Instruction that caused exception
 400006c:	ebffff04 	addi	r15,ea,-4
	stw		r15, 72(sp)			# Save as EA
 4000070:	dbc01215 	stw	r15,72(sp)
	stw		r16, 76(sp)			# Save the remaining registers
 4000074:	dc001315 	stw	r16,76(sp)
	stw		r17, 80(sp)
 4000078:	dc401415 	stw	r17,80(sp)
	stw		r18, 84(sp)
 400007c:	dc801515 	stw	r18,84(sp)
	stw		r19, 88(sp)
 4000080:	dcc01615 	stw	r19,88(sp)
	stw		r20, 92(sp)
 4000084:	dd001715 	stw	r20,92(sp)
	stw		r21, 96(sp)
 4000088:	dd401815 	stw	r21,96(sp)
	stw		r22, 100(sp)
 400008c:	dd801915 	stw	r22,100(sp)
	stw		r23, 104(sp)
 4000090:	ddc01a15 	stw	r23,104(sp)
	stw		gp, 108(sp)
 4000094:	de801b15 	stw	gp,108(sp)
	stw		fp, 112(sp)
 4000098:	df001c15 	stw	fp,112(sp)

0400009c <save_sp_to_pxCurrentTCB>:
 400009c:	06010074 	movhi	et,1025

save_sp_to_pxCurrentTCB:
	movia	et, pxCurrentTCB	# Load the address of the pxCurrentTCB pointer
 40000a0:	c63f9504 	addi	et,et,-428
	ldw		et, (et)			# Load the value of the pxCurrentTCB pointer
 40000a4:	c6000017 	ldw	et,0(et)
	stw		sp, (et)			# Store the stack pointer into the top of the TCB
 40000a8:	c6c00015 	stw	sp,0(et)

	br		irq_test_user		# skip the section .exceptions.entry
 40000ac:	00001506 	br	4000104 <irq_test_user>

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
 40000b0:	deffed04 	addi	sp,sp,-76
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
 40000b4:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
 40000b8:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
 40000bc:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
 40000c0:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
 40000c4:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
 40000c8:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
 40000cc:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
 40000d0:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
 40000d4:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
 40000d8:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
 40000dc:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
 40000e0:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
 40000e4:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
 40000e8:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
 40000ec:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
 40000f0:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
 40000f4:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
 40000f8:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
 40000fc:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
 4000100:	dbc01215 	stw	r15,72(sp)

04000104 <irq_test_user>:
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
 4000104:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
 4000108:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
 400010c:	10000326 	beq	r2,zero,400011c <irq_test_user+0x18>
        beq   r4, zero, .Lnot_irq
 4000110:	20000226 	beq	r4,zero,400011c <irq_test_user+0x18>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
 4000114:	400023c0 	call	400023c <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
 4000118:	00001006 	br	400015c <restore_sp_from_pxCurrentTCB>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw ea, 72(sp) /* EA is PC+4 so will skip over instruction causing exception */
 400011c:	df401215 	stw	ea,72(sp)
.Lunknown_16bit:
        addi.n r4, r4, 2 /* Need PC+2 to skip over instruction causing exception */
        stw r4, 72(sp)

#else /* CDX is not Enabled and all instructions are 32bits */
        ldw r2, -4(ea) /* Instruction value that caused exception */
 4000120:	e8bfff17 	ldw	r2,-4(ea)

04000124 <soft_exceptions>:

	eret					# Return to address ea, loading eStatus into Status.

	.section .exceptions.soft, "xa"
soft_exceptions:
	movhi	r3, 0x003b				/* upper half of trap opcode */
 4000124:	00c00ef4 	movhi	r3,59
	ori		r3, r3, 0x683a			/* lower half of trap opcode */
 4000128:	18da0e94 	ori	r3,r3,26682
	beq		r2, r3, call_scheduler
 400012c:	10c00126 	beq	r2,r3,4000134 <call_scheduler>
	br		exceptions_unknown_user			# its something else
 4000130:	00000506 	br	4000148 <exceptions_unknown_user>

04000134 <call_scheduler>:

call_scheduler:
	stw		ea, 72(sp)						# EA is PC+4 so will skip over instruction causing exception
 4000134:	df401215 	stw	ea,72(sp)
 4000138:	03c10034 	movhi	r15,1024
	movia	r15, vTaskSwitchContext			# Pick the next context - use long call version in place of "call"
 400013c:	7bd38a04 	addi	r15,r15,20008
	callr	r15
 4000140:	783ee83a 	callr	r15
	br		restore_sp_from_pxCurrentTCB	# Switch in the task context and restore.
 4000144:	00000506 	br	400015c <restore_sp_from_pxCurrentTCB>

04000148 <exceptions_unknown_user>:
 4000148:	e93fff04 	addi	r4,ea,-4
 400014c:	40003040 	call	4000304 <alt_instruction_exception_entry>
 4000150:	1000021e 	bne	r2,zero,400015c <restore_sp_from_pxCurrentTCB>
 4000154:	ebffff04 	addi	r15,ea,-4
 4000158:	dbc01215 	stw	r15,72(sp)

0400015c <restore_sp_from_pxCurrentTCB>:
 400015c:	06010074 	movhi	et,1025
	movia	et, pxCurrentTCB		# Load the address of the pxCurrentTCB pointer
 4000160:	c63f9504 	addi	et,et,-428
	ldw		et, (et)				# Load the value of the pxCurrentTCB pointer
 4000164:	c6000017 	ldw	et,0(et)
	ldw		sp, (et)				# Load the stack pointer with the top value of the TCB
 4000168:	c6c00017 	ldw	sp,0(et)

0400016c <restore_context>:
	ldw		ra, 0(sp)		# Restore the registers.
 400016c:	dfc00017 	ldw	ra,0(sp)
	ldw		at, 8(sp)
 4000170:	d8400217 	ldw	at,8(sp)
	ldw		r2, 12(sp)
 4000174:	d8800317 	ldw	r2,12(sp)
	ldw		r3, 16(sp)
 4000178:	d8c00417 	ldw	r3,16(sp)
	ldw		r4, 20(sp)
 400017c:	d9000517 	ldw	r4,20(sp)
	ldw		r5, 24(sp)
 4000180:	d9400617 	ldw	r5,24(sp)
	ldw		r6, 28(sp)
 4000184:	d9800717 	ldw	r6,28(sp)
	ldw		r7, 32(sp)
 4000188:	d9c00817 	ldw	r7,32(sp)
	ldw		r8, 36(sp)
 400018c:	da000917 	ldw	r8,36(sp)
	ldw		r9, 40(sp)
 4000190:	da400a17 	ldw	r9,40(sp)
	ldw		r10, 44(sp)
 4000194:	da800b17 	ldw	r10,44(sp)
	ldw		r11, 48(sp)
 4000198:	dac00c17 	ldw	r11,48(sp)
	ldw		r12, 52(sp)
 400019c:	db000d17 	ldw	r12,52(sp)
	ldw		r13, 56(sp)
 40001a0:	db400e17 	ldw	r13,56(sp)
	ldw		r14, 60(sp)
 40001a4:	db800f17 	ldw	r14,60(sp)
	ldw		r15, 64(sp)
 40001a8:	dbc01017 	ldw	r15,64(sp)
	ldw		et, 68(sp)		# Load the eStatus
 40001ac:	de001117 	ldw	et,68(sp)
	wrctl	estatus, et 	# Write the eStatus
 40001b0:	c001707a 	wrctl	estatus,et
	ldw		ea, 72(sp)		# Load the Program Counter
 40001b4:	df401217 	ldw	ea,72(sp)
	ldw		r16, 76(sp)
 40001b8:	dc001317 	ldw	r16,76(sp)
	ldw		r17, 80(sp)
 40001bc:	dc401417 	ldw	r17,80(sp)
	ldw		r18, 84(sp)
 40001c0:	dc801517 	ldw	r18,84(sp)
	ldw		r19, 88(sp)
 40001c4:	dcc01617 	ldw	r19,88(sp)
	ldw		r20, 92(sp)
 40001c8:	dd001717 	ldw	r20,92(sp)
	ldw		r21, 96(sp)
 40001cc:	dd401817 	ldw	r21,96(sp)
	ldw		r22, 100(sp)
 40001d0:	dd801917 	ldw	r22,100(sp)
	ldw		r23, 104(sp)
 40001d4:	ddc01a17 	ldw	r23,104(sp)
	ldw		gp, 108(sp)
 40001d8:	de801b17 	ldw	gp,108(sp)
	ldw		fp, 112(sp)
 40001dc:	df001c17 	ldw	fp,112(sp)
	addi	sp,	sp, 116		# Release stack space
 40001e0:	dec01d04 	addi	sp,sp,116
	eret					# Return to address ea, loading eStatus into Status.
 40001e4:	ef80083a 	eret
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
 40001e8:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
 40001ec:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
 40001f0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
 40001f4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
 40001f8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
 40001fc:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
 4000200:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
 4000204:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
 4000208:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
 400020c:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
 4000210:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
 4000214:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
 4000218:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
 400021c:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
 4000220:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
 4000224:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
 4000228:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
 400022c:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
 4000230:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
 4000234:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
 4000238:	ef80083a 	eret

0400023c <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
 400023c:	defff904 	addi	sp,sp,-28
 4000240:	dfc00615 	stw	ra,24(sp)
 4000244:	df000515 	stw	fp,20(sp)
 4000248:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
 400024c:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
 4000250:	0005313a 	rdctl	r2,ipending
 4000254:	e0bffc15 	stw	r2,-16(fp)

  return active;
 4000258:	e0bffc17 	ldw	r2,-16(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
 400025c:	e0bfff15 	stw	r2,-4(fp)

  do
  {
    i = 0;
 4000260:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
 4000264:	00800044 	movi	r2,1
 4000268:	e0bffe15 	stw	r2,-8(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
 400026c:	e0ffff17 	ldw	r3,-4(fp)
 4000270:	e0bffe17 	ldw	r2,-8(fp)
 4000274:	1884703a 	and	r2,r3,r2
 4000278:	10001126 	beq	r2,zero,40002c0 <alt_irq_handler+0x84>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
 400027c:	e0bffd17 	ldw	r2,-12(fp)
 4000280:	100690fa 	slli	r3,r2,3
 4000284:	00812074 	movhi	r2,1153
 4000288:	1885883a 	add	r2,r3,r2
 400028c:	10ffed17 	ldw	r3,-76(r2)
 4000290:	e0bffd17 	ldw	r2,-12(fp)
 4000294:	100890fa 	slli	r4,r2,3
 4000298:	00812074 	movhi	r2,1153
 400029c:	2085883a 	add	r2,r4,r2
 40002a0:	10bfee17 	ldw	r2,-72(r2)
 40002a4:	1009883a 	mov	r4,r2
 40002a8:	183ee83a 	callr	r3
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
 40002ac:	0001883a 	nop
  NIOS2_READ_IPENDING (active);
 40002b0:	0005313a 	rdctl	r2,ipending
 40002b4:	e0bffb15 	stw	r2,-20(fp)
  return active;
 40002b8:	e0bffb17 	ldw	r2,-20(fp)
 40002bc:	00000706 	br	40002dc <alt_irq_handler+0xa0>
      }
      mask <<= 1;
 40002c0:	e0bffe17 	ldw	r2,-8(fp)
 40002c4:	1085883a 	add	r2,r2,r2
 40002c8:	e0bffe15 	stw	r2,-8(fp)
      i++;
 40002cc:	e0bffd17 	ldw	r2,-12(fp)
 40002d0:	10800044 	addi	r2,r2,1
 40002d4:	e0bffd15 	stw	r2,-12(fp)
      if (active & mask)
 40002d8:	003fe406 	br	400026c <alt_irq_handler+0x30>

    } while (1);

    active = alt_irq_pending ();
 40002dc:	e0bfff15 	stw	r2,-4(fp)
    
  } while (active);
 40002e0:	e0bfff17 	ldw	r2,-4(fp)
 40002e4:	103fde1e 	bne	r2,zero,4000260 <alt_irq_handler+0x24>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
 40002e8:	0001883a 	nop
}
 40002ec:	0001883a 	nop
 40002f0:	e037883a 	mov	sp,fp
 40002f4:	dfc00117 	ldw	ra,4(sp)
 40002f8:	df000017 	ldw	fp,0(sp)
 40002fc:	dec00204 	addi	sp,sp,8
 4000300:	f800283a 	ret

04000304 <alt_instruction_exception_entry>:
 * that handler if it has been registered. Absent a handler, it will
 * break break or hang as discussed below.
 */
int 
alt_instruction_exception_entry (alt_u32 exception_pc)
{
 4000304:	defffb04 	addi	sp,sp,-20
 4000308:	dfc00415 	stw	ra,16(sp)
 400030c:	df000315 	stw	fp,12(sp)
 4000310:	df000304 	addi	fp,sp,12
 4000314:	e13ffd15 	stw	r4,-12(fp)
  cause = ( (cause & NIOS2_EXCEPTION_REG_CAUSE_MASK) >>
              NIOS2_EXCEPTION_REG_CAUSE_OFST );

  NIOS2_READ_BADADDR(badaddr);
#else
  cause = NIOS2_EXCEPTION_CAUSE_NOT_PRESENT;
 4000318:	00bfffc4 	movi	r2,-1
 400031c:	e0bfff15 	stw	r2,-4(fp)
  badaddr = 0;
 4000320:	e03ffe15 	stw	zero,-8(fp)
#endif /* NIOS2_HAS_EXTRA_EXCEPTION_INFO */

  if(alt_instruction_exception_handler) {
 4000324:	d0a6c517 	ldw	r2,-25836(gp)
 4000328:	10000726 	beq	r2,zero,4000348 <alt_instruction_exception_entry+0x44>
     * Call handler. Its return value indicates whether the exception-causing
     * instruction should be re-issued. The code that called us,
     * alt_eceptions_entry.S, will look at this value and adjust the ea
     * register as necessary
     */
    return alt_instruction_exception_handler(cause, exception_pc, badaddr);
 400032c:	d0a6c517 	ldw	r2,-25836(gp)
 4000330:	e0ffff17 	ldw	r3,-4(fp)
 4000334:	e1bffe17 	ldw	r6,-8(fp)
 4000338:	e17ffd17 	ldw	r5,-12(fp)
 400033c:	1809883a 	mov	r4,r3
 4000340:	103ee83a 	callr	r2
 4000344:	00000206 	br	4000350 <alt_instruction_exception_entry+0x4c>
   *    (a peripheral which negates its interrupt output before its
   *    interrupt handler has been executed will cause spurious interrupts)
   */
  else {
#ifdef NIOS2_HAS_DEBUG_STUB
    NIOS2_BREAK();
 4000348:	003da03a 	break	0
      ;
#endif /* NIOS2_HAS_DEBUG_STUB */
  }

  /* We should not get here. Remove compiler warning. */
  return NIOS2_EXCEPTION_RETURN_REISSUE_INST;
 400034c:	0005883a 	mov	r2,zero
}
 4000350:	e037883a 	mov	sp,fp
 4000354:	dfc00117 	ldw	ra,4(sp)
 4000358:	df000017 	ldw	fp,0(sp)
 400035c:	dec00204 	addi	sp,sp,8
 4000360:	f800283a 	ret

Disassembly of section .text:

04000364 <_start>:

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
 4000364:	06c20034 	movhi	sp,2048
    ori sp, sp, %lo(__alt_stack_pointer)
 4000368:	dec00014 	ori	sp,sp,0
    movhi gp, %hi(_gp)
 400036c:	06810074 	movhi	gp,1025
    ori gp, gp, %lo(_gp)
 4000370:	d698e814 	ori	gp,gp,25504
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
 4000374:	00810034 	movhi	r2,1024
    ori r2, r2, %lo(__bss_start)
 4000378:	10bf9314 	ori	r2,r2,65100

    movhi r3, %hi(__bss_end)
 400037c:	00c12074 	movhi	r3,1153
    ori r3, r3, %lo(__bss_end)
 4000380:	18c02d14 	ori	r3,r3,180

    beq r2, r3, 1f
 4000384:	10c00326 	beq	r2,r3,4000394 <_start+0x30>

0:
    stw zero, (r2)
 4000388:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
 400038c:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
 4000390:	10fffd36 	bltu	r2,r3,4000388 <_start+0x24>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
 4000394:	400a81c0 	call	400a81c <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
 4000398:	400a9bc0 	call	400a9bc <alt_main>

0400039c <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
 400039c:	003fff06 	br	400039c <alt_after_alt_main>

040003a0 <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    EventGroupHandle_t xEventGroupCreate( void )
    {
 40003a0:	defffd04 	addi	sp,sp,-12
 40003a4:	dfc00215 	stw	ra,8(sp)
 40003a8:	df000115 	stw	fp,4(sp)
 40003ac:	df000104 	addi	fp,sp,4
         * TickType_t alignment requirements the cast is safe.  In other cases,
         * where the natural word size of the architecture is less than
         * sizeof( TickType_t ), the TickType_t variables will be accessed in two
         * or more reads operations, and the alignment requirements is only that
         * of each individual read. */
        pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
 40003b0:	01000604 	movi	r4,24
 40003b4:	40010340 	call	4001034 <pvPortMalloc>
 40003b8:	e0bfff15 	stw	r2,-4(fp)

        if( pxEventBits != NULL )
 40003bc:	e0bfff17 	ldw	r2,-4(fp)
 40003c0:	10000626 	beq	r2,zero,40003dc <xEventGroupCreate+0x3c>
        {
            pxEventBits->uxEventBits = 0;
 40003c4:	e0bfff17 	ldw	r2,-4(fp)
 40003c8:	10000015 	stw	zero,0(r2)
            vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
 40003cc:	e0bfff17 	ldw	r2,-4(fp)
 40003d0:	10800104 	addi	r2,r2,4
 40003d4:	1009883a 	mov	r4,r2
 40003d8:	4000aa00 	call	4000aa0 <vListInitialise>
        else
        {
            traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
        }

        return pxEventBits;
 40003dc:	e0bfff17 	ldw	r2,-4(fp)
    }
 40003e0:	e037883a 	mov	sp,fp
 40003e4:	dfc00117 	ldw	ra,4(sp)
 40003e8:	df000017 	ldw	fp,0(sp)
 40003ec:	dec00204 	addi	sp,sp,8
 40003f0:	f800283a 	ret

040003f4 <xEventGroupSync>:

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup,
                             const EventBits_t uxBitsToSet,
                             const EventBits_t uxBitsToWaitFor,
                             TickType_t xTicksToWait )
{
 40003f4:	defff504 	addi	sp,sp,-44
 40003f8:	dfc00a15 	stw	ra,40(sp)
 40003fc:	df000915 	stw	fp,36(sp)
 4000400:	df000904 	addi	fp,sp,36
 4000404:	e13ffa15 	stw	r4,-24(fp)
 4000408:	e17ff915 	stw	r5,-28(fp)
 400040c:	e1bff815 	stw	r6,-32(fp)
 4000410:	e1fff715 	stw	r7,-36(fp)
    EventBits_t uxOriginalBitValue, uxReturn;
    EventGroup_t * pxEventBits = xEventGroup;
 4000414:	e0bffa17 	ldw	r2,-24(fp)
 4000418:	e0bffe15 	stw	r2,-8(fp)
    BaseType_t xAlreadyYielded;
    BaseType_t xTimeoutOccurred = pdFALSE;
 400041c:	e03ffd15 	stw	zero,-12(fp)
    {
        configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    }
    #endif

    vTaskSuspendAll();
 4000420:	40046e80 	call	40046e8 <vTaskSuspendAll>
    {
        uxOriginalBitValue = pxEventBits->uxEventBits;
 4000424:	e0bffe17 	ldw	r2,-8(fp)
 4000428:	10800017 	ldw	r2,0(r2)
 400042c:	e0bffc15 	stw	r2,-16(fp)

        ( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
 4000430:	e17ff917 	ldw	r5,-28(fp)
 4000434:	e13ffa17 	ldw	r4,-24(fp)
 4000438:	40007c40 	call	40007c4 <xEventGroupSetBits>

        if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
 400043c:	e0fffc17 	ldw	r3,-16(fp)
 4000440:	e0bff917 	ldw	r2,-28(fp)
 4000444:	1886b03a 	or	r3,r3,r2
 4000448:	e0bff817 	ldw	r2,-32(fp)
 400044c:	1884703a 	and	r2,r3,r2
 4000450:	e0fff817 	ldw	r3,-32(fp)
 4000454:	18800d1e 	bne	r3,r2,400048c <xEventGroupSync+0x98>
        {
            /* All the rendezvous bits are now set - no need to block. */
            uxReturn = ( uxOriginalBitValue | uxBitsToSet );
 4000458:	e0fffc17 	ldw	r3,-16(fp)
 400045c:	e0bff917 	ldw	r2,-28(fp)
 4000460:	1884b03a 	or	r2,r3,r2
 4000464:	e0bfff15 	stw	r2,-4(fp)

            /* Rendezvous always clear the bits.  They will have been cleared
             * already unless this is the only task in the rendezvous. */
            pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
 4000468:	e0bffe17 	ldw	r2,-8(fp)
 400046c:	10c00017 	ldw	r3,0(r2)
 4000470:	e0bff817 	ldw	r2,-32(fp)
 4000474:	0084303a 	nor	r2,zero,r2
 4000478:	1886703a 	and	r3,r3,r2
 400047c:	e0bffe17 	ldw	r2,-8(fp)
 4000480:	10c00015 	stw	r3,0(r2)

            xTicksToWait = 0;
 4000484:	e03ff715 	stw	zero,-36(fp)
 4000488:	00001106 	br	40004d0 <xEventGroupSync+0xdc>
        }
        else
        {
            if( xTicksToWait != ( TickType_t ) 0 )
 400048c:	e0bff717 	ldw	r2,-36(fp)
 4000490:	10000a26 	beq	r2,zero,40004bc <xEventGroupSync+0xc8>
                traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

                /* Store the bits that the calling task is waiting for in the
                 * task's event list item so the kernel knows when a match is
                 * found.  Then enter the blocked state. */
                vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
 4000494:	e0bffe17 	ldw	r2,-8(fp)
 4000498:	10c00104 	addi	r3,r2,4
 400049c:	e0bff817 	ldw	r2,-32(fp)
 40004a0:	10814034 	orhi	r2,r2,1280
 40004a4:	e1bff717 	ldw	r6,-36(fp)
 40004a8:	100b883a 	mov	r5,r2
 40004ac:	1809883a 	mov	r4,r3
 40004b0:	4004f680 	call	4004f68 <vTaskPlaceOnUnorderedEventList>

                /* This assignment is obsolete as uxReturn will get set after
                 * the task unblocks, but some compilers mistakenly generate a
                 * warning about uxReturn being returned without being set if the
                 * assignment is omitted. */
                uxReturn = 0;
 40004b4:	e03fff15 	stw	zero,-4(fp)
 40004b8:	00000506 	br	40004d0 <xEventGroupSync+0xdc>
            }
            else
            {
                /* The rendezvous bits were not set, but no block time was
                 * specified - just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
 40004bc:	e0bffe17 	ldw	r2,-8(fp)
 40004c0:	10800017 	ldw	r2,0(r2)
 40004c4:	e0bfff15 	stw	r2,-4(fp)
                xTimeoutOccurred = pdTRUE;
 40004c8:	00800044 	movi	r2,1
 40004cc:	e0bffd15 	stw	r2,-12(fp)
            }
        }
    }
    xAlreadyYielded = xTaskResumeAll();
 40004d0:	40047140 	call	4004714 <xTaskResumeAll>
 40004d4:	e0bffb15 	stw	r2,-20(fp)

    if( xTicksToWait != ( TickType_t ) 0 )
 40004d8:	e0bff717 	ldw	r2,-36(fp)
 40004dc:	10002026 	beq	r2,zero,4000560 <xEventGroupSync+0x16c>
    {
        if( xAlreadyYielded == pdFALSE )
 40004e0:	e0bffb17 	ldw	r2,-20(fp)
 40004e4:	1000011e 	bne	r2,zero,40004ec <xEventGroupSync+0xf8>
        {
            portYIELD_WITHIN_API();
 40004e8:	003b683a 	trap	0

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
 40004ec:	400602c0 	call	400602c <uxTaskResetEventItemValue>
 40004f0:	e0bfff15 	stw	r2,-4(fp)

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
 40004f4:	e0bfff17 	ldw	r2,-4(fp)
 40004f8:	1080802c 	andhi	r2,r2,512
 40004fc:	1000131e 	bne	r2,zero,400054c <xEventGroupSync+0x158>
        {
            /* The task timed out, just return the current event bit value. */
            taskENTER_CRITICAL();
 4000500:	4005f740 	call	4005f74 <vTaskEnterCritical>
            {
                uxReturn = pxEventBits->uxEventBits;
 4000504:	e0bffe17 	ldw	r2,-8(fp)
 4000508:	10800017 	ldw	r2,0(r2)
 400050c:	e0bfff15 	stw	r2,-4(fp)

                /* Although the task got here because it timed out before the
                 * bits it was waiting for were set, it is possible that since it
                 * unblocked another task has set the bits.  If this is the case
                 * then it needs to clear the bits before exiting. */
                if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
 4000510:	e0ffff17 	ldw	r3,-4(fp)
 4000514:	e0bff817 	ldw	r2,-32(fp)
 4000518:	1884703a 	and	r2,r3,r2
 400051c:	e0fff817 	ldw	r3,-32(fp)
 4000520:	1880071e 	bne	r3,r2,4000540 <xEventGroupSync+0x14c>
                {
                    pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
 4000524:	e0bffe17 	ldw	r2,-8(fp)
 4000528:	10c00017 	ldw	r3,0(r2)
 400052c:	e0bff817 	ldw	r2,-32(fp)
 4000530:	0084303a 	nor	r2,zero,r2
 4000534:	1886703a 	and	r3,r3,r2
 4000538:	e0bffe17 	ldw	r2,-8(fp)
 400053c:	10c00015 	stw	r3,0(r2)
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            taskEXIT_CRITICAL();
 4000540:	4005fc80 	call	4005fc8 <vTaskExitCritical>

            xTimeoutOccurred = pdTRUE;
 4000544:	00800044 	movi	r2,1
 4000548:	e0bffd15 	stw	r2,-12(fp)
            /* The task unblocked because the bits were set. */
        }

        /* Control bits might be set as the task had blocked should not be
         * returned. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
 400054c:	e0ffff17 	ldw	r3,-4(fp)
 4000550:	00804034 	movhi	r2,256
 4000554:	10bfffc4 	addi	r2,r2,-1
 4000558:	1884703a 	and	r2,r3,r2
 400055c:	e0bfff15 	stw	r2,-4(fp)
    traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
 4000560:	e0bfff17 	ldw	r2,-4(fp)
}
 4000564:	e037883a 	mov	sp,fp
 4000568:	dfc00117 	ldw	ra,4(sp)
 400056c:	df000017 	ldw	fp,0(sp)
 4000570:	dec00204 	addi	sp,sp,8
 4000574:	f800283a 	ret

04000578 <xEventGroupWaitBits>:
EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup,
                                 const EventBits_t uxBitsToWaitFor,
                                 const BaseType_t xClearOnExit,
                                 const BaseType_t xWaitForAllBits,
                                 TickType_t xTicksToWait )
{
 4000578:	defff304 	addi	sp,sp,-52
 400057c:	dfc00c15 	stw	ra,48(sp)
 4000580:	df000b15 	stw	fp,44(sp)
 4000584:	df000b04 	addi	fp,sp,44
 4000588:	e13ff815 	stw	r4,-32(fp)
 400058c:	e17ff715 	stw	r5,-36(fp)
 4000590:	e1bff615 	stw	r6,-40(fp)
 4000594:	e1fff515 	stw	r7,-44(fp)
    EventGroup_t * pxEventBits = xEventGroup;
 4000598:	e0bff817 	ldw	r2,-32(fp)
 400059c:	e0bffd15 	stw	r2,-12(fp)
    EventBits_t uxReturn, uxControlBits = 0;
 40005a0:	e03ffe15 	stw	zero,-8(fp)
    BaseType_t xWaitConditionMet, xAlreadyYielded;
    BaseType_t xTimeoutOccurred = pdFALSE;
 40005a4:	e03ffc15 	stw	zero,-16(fp)
    {
        configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    }
    #endif

    vTaskSuspendAll();
 40005a8:	40046e80 	call	40046e8 <vTaskSuspendAll>
    {
        const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
 40005ac:	e0bffd17 	ldw	r2,-12(fp)
 40005b0:	10800017 	ldw	r2,0(r2)
 40005b4:	e0bffb15 	stw	r2,-20(fp)

        /* Check to see if the wait condition is already met or not. */
        xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
 40005b8:	e1bff517 	ldw	r6,-44(fp)
 40005bc:	e17ff717 	ldw	r5,-36(fp)
 40005c0:	e13ffb17 	ldw	r4,-20(fp)
 40005c4:	4000a300 	call	4000a30 <prvTestWaitCondition>
 40005c8:	e0bffa15 	stw	r2,-24(fp)

        if( xWaitConditionMet != pdFALSE )
 40005cc:	e0bffa17 	ldw	r2,-24(fp)
 40005d0:	10000d26 	beq	r2,zero,4000608 <xEventGroupWaitBits+0x90>
        {
            /* The wait condition has already been met so there is no need to
             * block. */
            uxReturn = uxCurrentEventBits;
 40005d4:	e0bffb17 	ldw	r2,-20(fp)
 40005d8:	e0bfff15 	stw	r2,-4(fp)
            xTicksToWait = ( TickType_t ) 0;
 40005dc:	e0000215 	stw	zero,8(fp)

            /* Clear the wait bits if requested to do so. */
            if( xClearOnExit != pdFALSE )
 40005e0:	e0bff617 	ldw	r2,-40(fp)
 40005e4:	10002226 	beq	r2,zero,4000670 <xEventGroupWaitBits+0xf8>
            {
                pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
 40005e8:	e0bffd17 	ldw	r2,-12(fp)
 40005ec:	10c00017 	ldw	r3,0(r2)
 40005f0:	e0bff717 	ldw	r2,-36(fp)
 40005f4:	0084303a 	nor	r2,zero,r2
 40005f8:	1886703a 	and	r3,r3,r2
 40005fc:	e0bffd17 	ldw	r2,-12(fp)
 4000600:	10c00015 	stw	r3,0(r2)
 4000604:	00001a06 	br	4000670 <xEventGroupWaitBits+0xf8>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else if( xTicksToWait == ( TickType_t ) 0 )
 4000608:	e0800217 	ldw	r2,8(fp)
 400060c:	1000051e 	bne	r2,zero,4000624 <xEventGroupWaitBits+0xac>
        {
            /* The wait condition has not been met, but no block time was
             * specified, so just return the current value. */
            uxReturn = uxCurrentEventBits;
 4000610:	e0bffb17 	ldw	r2,-20(fp)
 4000614:	e0bfff15 	stw	r2,-4(fp)
            xTimeoutOccurred = pdTRUE;
 4000618:	00800044 	movi	r2,1
 400061c:	e0bffc15 	stw	r2,-16(fp)
 4000620:	00001306 	br	4000670 <xEventGroupWaitBits+0xf8>
        {
            /* The task is going to block to wait for its required bits to be
             * set.  uxControlBits are used to remember the specified behaviour of
             * this call to xEventGroupWaitBits() - for use when the event bits
             * unblock the task. */
            if( xClearOnExit != pdFALSE )
 4000624:	e0bff617 	ldw	r2,-40(fp)
 4000628:	10000326 	beq	r2,zero,4000638 <xEventGroupWaitBits+0xc0>
            {
                uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
 400062c:	e0bffe17 	ldw	r2,-8(fp)
 4000630:	10804034 	orhi	r2,r2,256
 4000634:	e0bffe15 	stw	r2,-8(fp)
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            if( xWaitForAllBits != pdFALSE )
 4000638:	e0bff517 	ldw	r2,-44(fp)
 400063c:	10000326 	beq	r2,zero,400064c <xEventGroupWaitBits+0xd4>
            {
                uxControlBits |= eventWAIT_FOR_ALL_BITS;
 4000640:	e0bffe17 	ldw	r2,-8(fp)
 4000644:	10810034 	orhi	r2,r2,1024
 4000648:	e0bffe15 	stw	r2,-8(fp)
            }

            /* Store the bits that the calling task is waiting for in the
             * task's event list item so the kernel knows when a match is
             * found.  Then enter the blocked state. */
            vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
 400064c:	e0bffd17 	ldw	r2,-12(fp)
 4000650:	11000104 	addi	r4,r2,4
 4000654:	e0fff717 	ldw	r3,-36(fp)
 4000658:	e0bffe17 	ldw	r2,-8(fp)
 400065c:	1884b03a 	or	r2,r3,r2
 4000660:	e1800217 	ldw	r6,8(fp)
 4000664:	100b883a 	mov	r5,r2
 4000668:	4004f680 	call	4004f68 <vTaskPlaceOnUnorderedEventList>

            /* This is obsolete as it will get set after the task unblocks, but
             * some compilers mistakenly generate a warning about the variable
             * being returned without being set if it is not done. */
            uxReturn = 0;
 400066c:	e03fff15 	stw	zero,-4(fp)

            traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
        }
    }
    xAlreadyYielded = xTaskResumeAll();
 4000670:	40047140 	call	4004714 <xTaskResumeAll>
 4000674:	e0bff915 	stw	r2,-28(fp)

    if( xTicksToWait != ( TickType_t ) 0 )
 4000678:	e0800217 	ldw	r2,8(fp)
 400067c:	10002226 	beq	r2,zero,4000708 <xEventGroupWaitBits+0x190>
    {
        if( xAlreadyYielded == pdFALSE )
 4000680:	e0bff917 	ldw	r2,-28(fp)
 4000684:	1000011e 	bne	r2,zero,400068c <xEventGroupWaitBits+0x114>
        {
            portYIELD_WITHIN_API();
 4000688:	003b683a 	trap	0

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
 400068c:	400602c0 	call	400602c <uxTaskResetEventItemValue>
 4000690:	e0bfff15 	stw	r2,-4(fp)

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
 4000694:	e0bfff17 	ldw	r2,-4(fp)
 4000698:	1080802c 	andhi	r2,r2,512
 400069c:	1000151e 	bne	r2,zero,40006f4 <xEventGroupWaitBits+0x17c>
        {
            taskENTER_CRITICAL();
 40006a0:	4005f740 	call	4005f74 <vTaskEnterCritical>
            {
                /* The task timed out, just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
 40006a4:	e0bffd17 	ldw	r2,-12(fp)
 40006a8:	10800017 	ldw	r2,0(r2)
 40006ac:	e0bfff15 	stw	r2,-4(fp)

                /* It is possible that the event bits were updated between this
                 * task leaving the Blocked state and running again. */
                if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
 40006b0:	e1bff517 	ldw	r6,-44(fp)
 40006b4:	e17ff717 	ldw	r5,-36(fp)
 40006b8:	e13fff17 	ldw	r4,-4(fp)
 40006bc:	4000a300 	call	4000a30 <prvTestWaitCondition>
 40006c0:	10000926 	beq	r2,zero,40006e8 <xEventGroupWaitBits+0x170>
                {
                    if( xClearOnExit != pdFALSE )
 40006c4:	e0bff617 	ldw	r2,-40(fp)
 40006c8:	10000726 	beq	r2,zero,40006e8 <xEventGroupWaitBits+0x170>
                    {
                        pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
 40006cc:	e0bffd17 	ldw	r2,-12(fp)
 40006d0:	10c00017 	ldw	r3,0(r2)
 40006d4:	e0bff717 	ldw	r2,-36(fp)
 40006d8:	0084303a 	nor	r2,zero,r2
 40006dc:	1886703a 	and	r3,r3,r2
 40006e0:	e0bffd17 	ldw	r2,-12(fp)
 40006e4:	10c00015 	stw	r3,0(r2)
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                xTimeoutOccurred = pdTRUE;
 40006e8:	00800044 	movi	r2,1
 40006ec:	e0bffc15 	stw	r2,-16(fp)
            }
            taskEXIT_CRITICAL();
 40006f0:	4005fc80 	call	4005fc8 <vTaskExitCritical>
        {
            /* The task unblocked because the bits were set. */
        }

        /* The task blocked so control bits may have been set. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
 40006f4:	e0ffff17 	ldw	r3,-4(fp)
 40006f8:	00804034 	movhi	r2,256
 40006fc:	10bfffc4 	addi	r2,r2,-1
 4000700:	1884703a 	and	r2,r3,r2
 4000704:	e0bfff15 	stw	r2,-4(fp)
    traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
 4000708:	e0bfff17 	ldw	r2,-4(fp)
}
 400070c:	e037883a 	mov	sp,fp
 4000710:	dfc00117 	ldw	ra,4(sp)
 4000714:	df000017 	ldw	fp,0(sp)
 4000718:	dec00204 	addi	sp,sp,8
 400071c:	f800283a 	ret

04000720 <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup,
                                  const EventBits_t uxBitsToClear )
{
 4000720:	defffa04 	addi	sp,sp,-24
 4000724:	dfc00515 	stw	ra,20(sp)
 4000728:	df000415 	stw	fp,16(sp)
 400072c:	df000404 	addi	fp,sp,16
 4000730:	e13ffd15 	stw	r4,-12(fp)
 4000734:	e17ffc15 	stw	r5,-16(fp)
    EventGroup_t * pxEventBits = xEventGroup;
 4000738:	e0bffd17 	ldw	r2,-12(fp)
 400073c:	e0bfff15 	stw	r2,-4(fp)
    /* Check the user is not attempting to clear the bits used by the kernel
     * itself. */
    configASSERT( xEventGroup );
    configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

    taskENTER_CRITICAL();
 4000740:	4005f740 	call	4005f74 <vTaskEnterCritical>
    {
        traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

        /* The value returned is the event group value prior to the bits being
         * cleared. */
        uxReturn = pxEventBits->uxEventBits;
 4000744:	e0bfff17 	ldw	r2,-4(fp)
 4000748:	10800017 	ldw	r2,0(r2)
 400074c:	e0bffe15 	stw	r2,-8(fp)

        /* Clear the bits. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
 4000750:	e0bfff17 	ldw	r2,-4(fp)
 4000754:	10c00017 	ldw	r3,0(r2)
 4000758:	e0bffc17 	ldw	r2,-16(fp)
 400075c:	0084303a 	nor	r2,zero,r2
 4000760:	1886703a 	and	r3,r3,r2
 4000764:	e0bfff17 	ldw	r2,-4(fp)
 4000768:	10c00015 	stw	r3,0(r2)
    }
    taskEXIT_CRITICAL();
 400076c:	4005fc80 	call	4005fc8 <vTaskExitCritical>

    return uxReturn;
 4000770:	e0bffe17 	ldw	r2,-8(fp)
}
 4000774:	e037883a 	mov	sp,fp
 4000778:	dfc00117 	ldw	ra,4(sp)
 400077c:	df000017 	ldw	fp,0(sp)
 4000780:	dec00204 	addi	sp,sp,8
 4000784:	f800283a 	ret

04000788 <xEventGroupGetBitsFromISR>:

#endif /* if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) ) */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
 4000788:	defffb04 	addi	sp,sp,-20
 400078c:	df000415 	stw	fp,16(sp)
 4000790:	df000404 	addi	fp,sp,16
 4000794:	e13ffc15 	stw	r4,-16(fp)
    UBaseType_t uxSavedInterruptStatus;
    EventGroup_t const * const pxEventBits = xEventGroup;
 4000798:	e0bffc17 	ldw	r2,-16(fp)
 400079c:	e0bfff15 	stw	r2,-4(fp)
    EventBits_t uxReturn;

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 40007a0:	e03ffe15 	stw	zero,-8(fp)
    {
        uxReturn = pxEventBits->uxEventBits;
 40007a4:	e0bfff17 	ldw	r2,-4(fp)
 40007a8:	10800017 	ldw	r2,0(r2)
 40007ac:	e0bffd15 	stw	r2,-12(fp)
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return uxReturn;
 40007b0:	e0bffd17 	ldw	r2,-12(fp)
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
 40007b4:	e037883a 	mov	sp,fp
 40007b8:	df000017 	ldw	fp,0(sp)
 40007bc:	dec00104 	addi	sp,sp,4
 40007c0:	f800283a 	ret

040007c4 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup,
                                const EventBits_t uxBitsToSet )
{
 40007c4:	defff304 	addi	sp,sp,-52
 40007c8:	dfc00c15 	stw	ra,48(sp)
 40007cc:	df000b15 	stw	fp,44(sp)
 40007d0:	df000b04 	addi	fp,sp,44
 40007d4:	e13ff615 	stw	r4,-40(fp)
 40007d8:	e17ff515 	stw	r5,-44(fp)
    ListItem_t * pxListItem;
    ListItem_t * pxNext;
    ListItem_t const * pxListEnd;
    List_t const * pxList;
    EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
 40007dc:	e03ffe15 	stw	zero,-8(fp)
    EventGroup_t * pxEventBits = xEventGroup;
 40007e0:	e0bff617 	ldw	r2,-40(fp)
 40007e4:	e0bffc15 	stw	r2,-16(fp)
    BaseType_t xMatchFound = pdFALSE;
 40007e8:	e03ffd15 	stw	zero,-12(fp)
    /* Check the user is not attempting to set the bits used by the kernel
     * itself. */
    configASSERT( xEventGroup );
    configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

    pxList = &( pxEventBits->xTasksWaitingForBits );
 40007ec:	e0bffc17 	ldw	r2,-16(fp)
 40007f0:	10800104 	addi	r2,r2,4
 40007f4:	e0bffb15 	stw	r2,-20(fp)
    pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 40007f8:	e0bffb17 	ldw	r2,-20(fp)
 40007fc:	10800204 	addi	r2,r2,8
 4000800:	e0bffa15 	stw	r2,-24(fp)
    vTaskSuspendAll();
 4000804:	40046e80 	call	40046e8 <vTaskSuspendAll>
    {
        traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

        pxListItem = listGET_HEAD_ENTRY( pxList );
 4000808:	e0bffb17 	ldw	r2,-20(fp)
 400080c:	10800317 	ldw	r2,12(r2)
 4000810:	e0bfff15 	stw	r2,-4(fp)

        /* Set the bits. */
        pxEventBits->uxEventBits |= uxBitsToSet;
 4000814:	e0bffc17 	ldw	r2,-16(fp)
 4000818:	10c00017 	ldw	r3,0(r2)
 400081c:	e0bff517 	ldw	r2,-44(fp)
 4000820:	1886b03a 	or	r3,r3,r2
 4000824:	e0bffc17 	ldw	r2,-16(fp)
 4000828:	10c00015 	stw	r3,0(r2)

        /* See if the new bit value should unblock any tasks. */
        while( pxListItem != pxListEnd )
 400082c:	00003306 	br	40008fc <xEventGroupSetBits+0x138>
        {
            pxNext = listGET_NEXT( pxListItem );
 4000830:	e0bfff17 	ldw	r2,-4(fp)
 4000834:	10800117 	ldw	r2,4(r2)
 4000838:	e0bff915 	stw	r2,-28(fp)
            uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
 400083c:	e0bfff17 	ldw	r2,-4(fp)
 4000840:	10800017 	ldw	r2,0(r2)
 4000844:	e0bff815 	stw	r2,-32(fp)
            xMatchFound = pdFALSE;
 4000848:	e03ffd15 	stw	zero,-12(fp)

            /* Split the bits waited for from the control bits. */
            uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
 400084c:	e0bff817 	ldw	r2,-32(fp)
 4000850:	10bfc02c 	andhi	r2,r2,65280
 4000854:	e0bff715 	stw	r2,-36(fp)
            uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
 4000858:	e0fff817 	ldw	r3,-32(fp)
 400085c:	00804034 	movhi	r2,256
 4000860:	10bfffc4 	addi	r2,r2,-1
 4000864:	1884703a 	and	r2,r3,r2
 4000868:	e0bff815 	stw	r2,-32(fp)

            if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
 400086c:	e0bff717 	ldw	r2,-36(fp)
 4000870:	1081002c 	andhi	r2,r2,1024
 4000874:	1000081e 	bne	r2,zero,4000898 <xEventGroupSetBits+0xd4>
            {
                /* Just looking for single bit being set. */
                if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
 4000878:	e0bffc17 	ldw	r2,-16(fp)
 400087c:	10c00017 	ldw	r3,0(r2)
 4000880:	e0bff817 	ldw	r2,-32(fp)
 4000884:	1884703a 	and	r2,r3,r2
 4000888:	10000b26 	beq	r2,zero,40008b8 <xEventGroupSetBits+0xf4>
                {
                    xMatchFound = pdTRUE;
 400088c:	00800044 	movi	r2,1
 4000890:	e0bffd15 	stw	r2,-12(fp)
 4000894:	00000806 	br	40008b8 <xEventGroupSetBits+0xf4>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
 4000898:	e0bffc17 	ldw	r2,-16(fp)
 400089c:	10c00017 	ldw	r3,0(r2)
 40008a0:	e0bff817 	ldw	r2,-32(fp)
 40008a4:	1884703a 	and	r2,r3,r2
 40008a8:	e0fff817 	ldw	r3,-32(fp)
 40008ac:	1880021e 	bne	r3,r2,40008b8 <xEventGroupSetBits+0xf4>
            {
                /* All bits are set. */
                xMatchFound = pdTRUE;
 40008b0:	00800044 	movi	r2,1
 40008b4:	e0bffd15 	stw	r2,-12(fp)
            else
            {
                /* Need all bits to be set, but not all the bits were set. */
            }

            if( xMatchFound != pdFALSE )
 40008b8:	e0bffd17 	ldw	r2,-12(fp)
 40008bc:	10000d26 	beq	r2,zero,40008f4 <xEventGroupSetBits+0x130>
            {
                /* The bits match.  Should the bits be cleared on exit? */
                if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
 40008c0:	e0bff717 	ldw	r2,-36(fp)
 40008c4:	1080402c 	andhi	r2,r2,256
 40008c8:	10000426 	beq	r2,zero,40008dc <xEventGroupSetBits+0x118>
                {
                    uxBitsToClear |= uxBitsWaitedFor;
 40008cc:	e0fffe17 	ldw	r3,-8(fp)
 40008d0:	e0bff817 	ldw	r2,-32(fp)
 40008d4:	1884b03a 	or	r2,r3,r2
 40008d8:	e0bffe15 	stw	r2,-8(fp)
                /* Store the actual event flag value in the task's event list
                 * item before removing the task from the event list.  The
                 * eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
                 * that is was unblocked due to its required bits matching, rather
                 * than because it timed out. */
                vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
 40008dc:	e0bffc17 	ldw	r2,-16(fp)
 40008e0:	10800017 	ldw	r2,0(r2)
 40008e4:	10808034 	orhi	r2,r2,512
 40008e8:	100b883a 	mov	r5,r2
 40008ec:	e13fff17 	ldw	r4,-4(fp)
 40008f0:	40052f40 	call	40052f4 <vTaskRemoveFromUnorderedEventList>
            }

            /* Move onto the next list item.  Note pxListItem->pxNext is not
             * used here as the list item may have been removed from the event list
             * and inserted into the ready/pending reading list. */
            pxListItem = pxNext;
 40008f4:	e0bff917 	ldw	r2,-28(fp)
 40008f8:	e0bfff15 	stw	r2,-4(fp)
        while( pxListItem != pxListEnd )
 40008fc:	e0ffff17 	ldw	r3,-4(fp)
 4000900:	e0bffa17 	ldw	r2,-24(fp)
 4000904:	18bfca1e 	bne	r3,r2,4000830 <xEventGroupSetBits+0x6c>
        }

        /* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
         * bit was set in the control word. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
 4000908:	e0bffc17 	ldw	r2,-16(fp)
 400090c:	10c00017 	ldw	r3,0(r2)
 4000910:	e0bffe17 	ldw	r2,-8(fp)
 4000914:	0084303a 	nor	r2,zero,r2
 4000918:	1886703a 	and	r3,r3,r2
 400091c:	e0bffc17 	ldw	r2,-16(fp)
 4000920:	10c00015 	stw	r3,0(r2)
    }
    ( void ) xTaskResumeAll();
 4000924:	40047140 	call	4004714 <xTaskResumeAll>

    return pxEventBits->uxEventBits;
 4000928:	e0bffc17 	ldw	r2,-16(fp)
 400092c:	10800017 	ldw	r2,0(r2)
}
 4000930:	e037883a 	mov	sp,fp
 4000934:	dfc00117 	ldw	ra,4(sp)
 4000938:	df000017 	ldw	fp,0(sp)
 400093c:	dec00204 	addi	sp,sp,8
 4000940:	f800283a 	ret

04000944 <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
 4000944:	defffb04 	addi	sp,sp,-20
 4000948:	dfc00415 	stw	ra,16(sp)
 400094c:	df000315 	stw	fp,12(sp)
 4000950:	df000304 	addi	fp,sp,12
 4000954:	e13ffd15 	stw	r4,-12(fp)
    EventGroup_t * pxEventBits = xEventGroup;
 4000958:	e0bffd17 	ldw	r2,-12(fp)
 400095c:	e0bfff15 	stw	r2,-4(fp)
    const List_t * pxTasksWaitingForBits;

    configASSERT( pxEventBits );

    pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
 4000960:	e0bfff17 	ldw	r2,-4(fp)
 4000964:	10800104 	addi	r2,r2,4
 4000968:	e0bffe15 	stw	r2,-8(fp)

    vTaskSuspendAll();
 400096c:	40046e80 	call	40046e8 <vTaskSuspendAll>
    {
        traceEVENT_GROUP_DELETE( xEventGroup );

        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
 4000970:	00000506 	br	4000988 <vEventGroupDelete+0x44>
        {
            /* Unblock the task, returning 0 as the event list is being deleted
             * and cannot therefore have any bits set. */
            configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
            vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
 4000974:	e0bffe17 	ldw	r2,-8(fp)
 4000978:	10800317 	ldw	r2,12(r2)
 400097c:	01408034 	movhi	r5,512
 4000980:	1009883a 	mov	r4,r2
 4000984:	40052f40 	call	40052f4 <vTaskRemoveFromUnorderedEventList>
        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
 4000988:	e0bffe17 	ldw	r2,-8(fp)
 400098c:	10800017 	ldw	r2,0(r2)
 4000990:	103ff81e 	bne	r2,zero,4000974 <vEventGroupDelete+0x30>
        }
    }
    ( void ) xTaskResumeAll();
 4000994:	40047140 	call	4004714 <xTaskResumeAll>

    #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
    {
        /* The event group can only have been allocated dynamically - free
         * it again. */
        vPortFree( pxEventBits );
 4000998:	e13fff17 	ldw	r4,-4(fp)
 400099c:	400111c0 	call	400111c <vPortFree>
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
 40009a0:	0001883a 	nop
 40009a4:	e037883a 	mov	sp,fp
 40009a8:	dfc00117 	ldw	ra,4(sp)
 40009ac:	df000017 	ldw	fp,0(sp)
 40009b0:	dec00204 	addi	sp,sp,8
 40009b4:	f800283a 	ret

040009b8 <vEventGroupSetBitsCallback>:

/* For internal use only - execute a 'set bits' command that was pended from
 * an interrupt. */
void vEventGroupSetBitsCallback( void * pvEventGroup,
                                 const uint32_t ulBitsToSet )
{
 40009b8:	defffc04 	addi	sp,sp,-16
 40009bc:	dfc00315 	stw	ra,12(sp)
 40009c0:	df000215 	stw	fp,8(sp)
 40009c4:	df000204 	addi	fp,sp,8
 40009c8:	e13fff15 	stw	r4,-4(fp)
 40009cc:	e17ffe15 	stw	r5,-8(fp)
    ( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
 40009d0:	e17ffe17 	ldw	r5,-8(fp)
 40009d4:	e13fff17 	ldw	r4,-4(fp)
 40009d8:	40007c40 	call	40007c4 <xEventGroupSetBits>
}
 40009dc:	0001883a 	nop
 40009e0:	e037883a 	mov	sp,fp
 40009e4:	dfc00117 	ldw	ra,4(sp)
 40009e8:	df000017 	ldw	fp,0(sp)
 40009ec:	dec00204 	addi	sp,sp,8
 40009f0:	f800283a 	ret

040009f4 <vEventGroupClearBitsCallback>:

/* For internal use only - execute a 'clear bits' command that was pended from
 * an interrupt. */
void vEventGroupClearBitsCallback( void * pvEventGroup,
                                   const uint32_t ulBitsToClear )
{
 40009f4:	defffc04 	addi	sp,sp,-16
 40009f8:	dfc00315 	stw	ra,12(sp)
 40009fc:	df000215 	stw	fp,8(sp)
 4000a00:	df000204 	addi	fp,sp,8
 4000a04:	e13fff15 	stw	r4,-4(fp)
 4000a08:	e17ffe15 	stw	r5,-8(fp)
    ( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
 4000a0c:	e17ffe17 	ldw	r5,-8(fp)
 4000a10:	e13fff17 	ldw	r4,-4(fp)
 4000a14:	40007200 	call	4000720 <xEventGroupClearBits>
}
 4000a18:	0001883a 	nop
 4000a1c:	e037883a 	mov	sp,fp
 4000a20:	dfc00117 	ldw	ra,4(sp)
 4000a24:	df000017 	ldw	fp,0(sp)
 4000a28:	dec00204 	addi	sp,sp,8
 4000a2c:	f800283a 	ret

04000a30 <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits,
                                        const EventBits_t uxBitsToWaitFor,
                                        const BaseType_t xWaitForAllBits )
{
 4000a30:	defffb04 	addi	sp,sp,-20
 4000a34:	df000415 	stw	fp,16(sp)
 4000a38:	df000404 	addi	fp,sp,16
 4000a3c:	e13ffe15 	stw	r4,-8(fp)
 4000a40:	e17ffd15 	stw	r5,-12(fp)
 4000a44:	e1bffc15 	stw	r6,-16(fp)
    BaseType_t xWaitConditionMet = pdFALSE;
 4000a48:	e03fff15 	stw	zero,-4(fp)

    if( xWaitForAllBits == pdFALSE )
 4000a4c:	e0bffc17 	ldw	r2,-16(fp)
 4000a50:	1000071e 	bne	r2,zero,4000a70 <prvTestWaitCondition+0x40>
    {
        /* Task only has to wait for one bit within uxBitsToWaitFor to be
         * set.  Is one already set? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
 4000a54:	e0fffe17 	ldw	r3,-8(fp)
 4000a58:	e0bffd17 	ldw	r2,-12(fp)
 4000a5c:	1884703a 	and	r2,r3,r2
 4000a60:	10000a26 	beq	r2,zero,4000a8c <prvTestWaitCondition+0x5c>
        {
            xWaitConditionMet = pdTRUE;
 4000a64:	00800044 	movi	r2,1
 4000a68:	e0bfff15 	stw	r2,-4(fp)
 4000a6c:	00000706 	br	4000a8c <prvTestWaitCondition+0x5c>
    }
    else
    {
        /* Task has to wait for all the bits in uxBitsToWaitFor to be set.
         * Are they set already? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
 4000a70:	e0fffe17 	ldw	r3,-8(fp)
 4000a74:	e0bffd17 	ldw	r2,-12(fp)
 4000a78:	1884703a 	and	r2,r3,r2
 4000a7c:	e0fffd17 	ldw	r3,-12(fp)
 4000a80:	1880021e 	bne	r3,r2,4000a8c <prvTestWaitCondition+0x5c>
        {
            xWaitConditionMet = pdTRUE;
 4000a84:	00800044 	movi	r2,1
 4000a88:	e0bfff15 	stw	r2,-4(fp)
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    return xWaitConditionMet;
 4000a8c:	e0bfff17 	ldw	r2,-4(fp)
}
 4000a90:	e037883a 	mov	sp,fp
 4000a94:	df000017 	ldw	fp,0(sp)
 4000a98:	dec00104 	addi	sp,sp,4
 4000a9c:	f800283a 	ret

04000aa0 <vListInitialise>:
/*-----------------------------------------------------------
* PUBLIC LIST API documented in list.h
*----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
 4000aa0:	defffe04 	addi	sp,sp,-8
 4000aa4:	df000115 	stw	fp,4(sp)
 4000aa8:	df000104 	addi	fp,sp,4
 4000aac:	e13fff15 	stw	r4,-4(fp)
    /* The list structure contains a list item which is used to mark the
     * end of the list.  To initialise the list the list end is inserted
     * as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 4000ab0:	e0bfff17 	ldw	r2,-4(fp)
 4000ab4:	10c00204 	addi	r3,r2,8
 4000ab8:	e0bfff17 	ldw	r2,-4(fp)
 4000abc:	10c00115 	stw	r3,4(r2)

    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( &( pxList->xListEnd ) );

    /* The list end value is the highest possible value in the list to
     * ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
 4000ac0:	e0bfff17 	ldw	r2,-4(fp)
 4000ac4:	00ffffc4 	movi	r3,-1
 4000ac8:	10c00215 	stw	r3,8(r2)

    /* The list end next and previous pointers point to itself so we know
     * when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 4000acc:	e0bfff17 	ldw	r2,-4(fp)
 4000ad0:	10c00204 	addi	r3,r2,8
 4000ad4:	e0bfff17 	ldw	r2,-4(fp)
 4000ad8:	10c00315 	stw	r3,12(r2)
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 4000adc:	e0bfff17 	ldw	r2,-4(fp)
 4000ae0:	10c00204 	addi	r3,r2,8
 4000ae4:	e0bfff17 	ldw	r2,-4(fp)
 4000ae8:	10c00415 	stw	r3,16(r2)
        pxList->xListEnd.pxContainer = NULL;
        listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( &( pxList->xListEnd ) );
    }
    #endif

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 4000aec:	e0bfff17 	ldw	r2,-4(fp)
 4000af0:	10000015 	stw	zero,0(r2)

    /* Write known values into the list if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
    listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
 4000af4:	0001883a 	nop
 4000af8:	e037883a 	mov	sp,fp
 4000afc:	df000017 	ldw	fp,0(sp)
 4000b00:	dec00104 	addi	sp,sp,4
 4000b04:	f800283a 	ret

04000b08 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
 4000b08:	defffe04 	addi	sp,sp,-8
 4000b0c:	df000115 	stw	fp,4(sp)
 4000b10:	df000104 	addi	fp,sp,4
 4000b14:	e13fff15 	stw	r4,-4(fp)
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
 4000b18:	e0bfff17 	ldw	r2,-4(fp)
 4000b1c:	10000415 	stw	zero,16(r2)

    /* Write known values into the list item if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
 4000b20:	0001883a 	nop
 4000b24:	e037883a 	mov	sp,fp
 4000b28:	df000017 	ldw	fp,0(sp)
 4000b2c:	dec00104 	addi	sp,sp,4
 4000b30:	f800283a 	ret

04000b34 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList,
                     ListItem_t * const pxNewListItem )
{
 4000b34:	defffc04 	addi	sp,sp,-16
 4000b38:	df000315 	stw	fp,12(sp)
 4000b3c:	df000304 	addi	fp,sp,12
 4000b40:	e13ffe15 	stw	r4,-8(fp)
 4000b44:	e17ffd15 	stw	r5,-12(fp)
    ListItem_t * const pxIndex = pxList->pxIndex;
 4000b48:	e0bffe17 	ldw	r2,-8(fp)
 4000b4c:	10800117 	ldw	r2,4(r2)
 4000b50:	e0bfff15 	stw	r2,-4(fp)
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
     * makes the new list item the last item to be removed by a call to
     * listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
 4000b54:	e0bffd17 	ldw	r2,-12(fp)
 4000b58:	e0ffff17 	ldw	r3,-4(fp)
 4000b5c:	10c00115 	stw	r3,4(r2)
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 4000b60:	e0bfff17 	ldw	r2,-4(fp)
 4000b64:	10c00217 	ldw	r3,8(r2)
 4000b68:	e0bffd17 	ldw	r2,-12(fp)
 4000b6c:	10c00215 	stw	r3,8(r2)

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
 4000b70:	e0bfff17 	ldw	r2,-4(fp)
 4000b74:	10800217 	ldw	r2,8(r2)
 4000b78:	e0fffd17 	ldw	r3,-12(fp)
 4000b7c:	10c00115 	stw	r3,4(r2)
    pxIndex->pxPrevious = pxNewListItem;
 4000b80:	e0bfff17 	ldw	r2,-4(fp)
 4000b84:	e0fffd17 	ldw	r3,-12(fp)
 4000b88:	10c00215 	stw	r3,8(r2)

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
 4000b8c:	e0bffd17 	ldw	r2,-12(fp)
 4000b90:	e0fffe17 	ldw	r3,-8(fp)
 4000b94:	10c00415 	stw	r3,16(r2)

    ( pxList->uxNumberOfItems )++;
 4000b98:	e0bffe17 	ldw	r2,-8(fp)
 4000b9c:	10800017 	ldw	r2,0(r2)
 4000ba0:	10c00044 	addi	r3,r2,1
 4000ba4:	e0bffe17 	ldw	r2,-8(fp)
 4000ba8:	10c00015 	stw	r3,0(r2)
}
 4000bac:	0001883a 	nop
 4000bb0:	e037883a 	mov	sp,fp
 4000bb4:	df000017 	ldw	fp,0(sp)
 4000bb8:	dec00104 	addi	sp,sp,4
 4000bbc:	f800283a 	ret

04000bc0 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList,
                  ListItem_t * const pxNewListItem )
{
 4000bc0:	defffb04 	addi	sp,sp,-20
 4000bc4:	df000415 	stw	fp,16(sp)
 4000bc8:	df000404 	addi	fp,sp,16
 4000bcc:	e13ffd15 	stw	r4,-12(fp)
 4000bd0:	e17ffc15 	stw	r5,-16(fp)
    ListItem_t * pxIterator;
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 4000bd4:	e0bffc17 	ldw	r2,-16(fp)
 4000bd8:	10800017 	ldw	r2,0(r2)
 4000bdc:	e0bffe15 	stw	r2,-8(fp)
     * new list item should be placed after it.  This ensures that TCBs which are
     * stored in ready lists (all of which have the same xItemValue value) get a
     * share of the CPU.  However, if the xItemValue is the same as the back marker
     * the iteration loop below will not end.  Therefore the value is checked
     * first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
 4000be0:	e0bffe17 	ldw	r2,-8(fp)
 4000be4:	10bfffd8 	cmpnei	r2,r2,-1
 4000be8:	1000041e 	bne	r2,zero,4000bfc <vListInsert+0x3c>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
 4000bec:	e0bffd17 	ldw	r2,-12(fp)
 4000bf0:	10800417 	ldw	r2,16(r2)
 4000bf4:	e0bfff15 	stw	r2,-4(fp)
 4000bf8:	00000c06 	br	4000c2c <vListInsert+0x6c>
        *   5) If the FreeRTOS port supports interrupt nesting then ensure that
        *      the priority of the tick interrupt is at or below
        *      configMAX_SYSCALL_INTERRUPT_PRIORITY.
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
 4000bfc:	e0bffd17 	ldw	r2,-12(fp)
 4000c00:	10800204 	addi	r2,r2,8
 4000c04:	e0bfff15 	stw	r2,-4(fp)
 4000c08:	00000306 	br	4000c18 <vListInsert+0x58>
 4000c0c:	e0bfff17 	ldw	r2,-4(fp)
 4000c10:	10800117 	ldw	r2,4(r2)
 4000c14:	e0bfff15 	stw	r2,-4(fp)
 4000c18:	e0bfff17 	ldw	r2,-4(fp)
 4000c1c:	10800117 	ldw	r2,4(r2)
 4000c20:	10800017 	ldw	r2,0(r2)
 4000c24:	e0fffe17 	ldw	r3,-8(fp)
 4000c28:	18bff82e 	bgeu	r3,r2,4000c0c <vListInsert+0x4c>
            /* There is nothing to do here, just iterating to the wanted
             * insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
 4000c2c:	e0bfff17 	ldw	r2,-4(fp)
 4000c30:	10c00117 	ldw	r3,4(r2)
 4000c34:	e0bffc17 	ldw	r2,-16(fp)
 4000c38:	10c00115 	stw	r3,4(r2)
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 4000c3c:	e0bffc17 	ldw	r2,-16(fp)
 4000c40:	10800117 	ldw	r2,4(r2)
 4000c44:	e0fffc17 	ldw	r3,-16(fp)
 4000c48:	10c00215 	stw	r3,8(r2)
    pxNewListItem->pxPrevious = pxIterator;
 4000c4c:	e0bffc17 	ldw	r2,-16(fp)
 4000c50:	e0ffff17 	ldw	r3,-4(fp)
 4000c54:	10c00215 	stw	r3,8(r2)
    pxIterator->pxNext = pxNewListItem;
 4000c58:	e0bfff17 	ldw	r2,-4(fp)
 4000c5c:	e0fffc17 	ldw	r3,-16(fp)
 4000c60:	10c00115 	stw	r3,4(r2)

    /* Remember which list the item is in.  This allows fast removal of the
     * item later. */
    pxNewListItem->pxContainer = pxList;
 4000c64:	e0bffc17 	ldw	r2,-16(fp)
 4000c68:	e0fffd17 	ldw	r3,-12(fp)
 4000c6c:	10c00415 	stw	r3,16(r2)

    ( pxList->uxNumberOfItems )++;
 4000c70:	e0bffd17 	ldw	r2,-12(fp)
 4000c74:	10800017 	ldw	r2,0(r2)
 4000c78:	10c00044 	addi	r3,r2,1
 4000c7c:	e0bffd17 	ldw	r2,-12(fp)
 4000c80:	10c00015 	stw	r3,0(r2)
}
 4000c84:	0001883a 	nop
 4000c88:	e037883a 	mov	sp,fp
 4000c8c:	df000017 	ldw	fp,0(sp)
 4000c90:	dec00104 	addi	sp,sp,4
 4000c94:	f800283a 	ret

04000c98 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
 4000c98:	defffd04 	addi	sp,sp,-12
 4000c9c:	df000215 	stw	fp,8(sp)
 4000ca0:	df000204 	addi	fp,sp,8
 4000ca4:	e13ffe15 	stw	r4,-8(fp)
/* The list item knows which list it is in.  Obtain the list from the list
 * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
 4000ca8:	e0bffe17 	ldw	r2,-8(fp)
 4000cac:	10800417 	ldw	r2,16(r2)
 4000cb0:	e0bfff15 	stw	r2,-4(fp)

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 4000cb4:	e0bffe17 	ldw	r2,-8(fp)
 4000cb8:	10800117 	ldw	r2,4(r2)
 4000cbc:	e0fffe17 	ldw	r3,-8(fp)
 4000cc0:	18c00217 	ldw	r3,8(r3)
 4000cc4:	10c00215 	stw	r3,8(r2)
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 4000cc8:	e0bffe17 	ldw	r2,-8(fp)
 4000ccc:	10800217 	ldw	r2,8(r2)
 4000cd0:	e0fffe17 	ldw	r3,-8(fp)
 4000cd4:	18c00117 	ldw	r3,4(r3)
 4000cd8:	10c00115 	stw	r3,4(r2)

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
 4000cdc:	e0bfff17 	ldw	r2,-4(fp)
 4000ce0:	10800117 	ldw	r2,4(r2)
 4000ce4:	e0fffe17 	ldw	r3,-8(fp)
 4000ce8:	1880041e 	bne	r3,r2,4000cfc <uxListRemove+0x64>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
 4000cec:	e0bffe17 	ldw	r2,-8(fp)
 4000cf0:	10c00217 	ldw	r3,8(r2)
 4000cf4:	e0bfff17 	ldw	r2,-4(fp)
 4000cf8:	10c00115 	stw	r3,4(r2)
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
 4000cfc:	e0bffe17 	ldw	r2,-8(fp)
 4000d00:	10000415 	stw	zero,16(r2)
    ( pxList->uxNumberOfItems )--;
 4000d04:	e0bfff17 	ldw	r2,-4(fp)
 4000d08:	10800017 	ldw	r2,0(r2)
 4000d0c:	10ffffc4 	addi	r3,r2,-1
 4000d10:	e0bfff17 	ldw	r2,-4(fp)
 4000d14:	10c00015 	stw	r3,0(r2)

    return pxList->uxNumberOfItems;
 4000d18:	e0bfff17 	ldw	r2,-4(fp)
 4000d1c:	10800017 	ldw	r2,0(r2)
}
 4000d20:	e037883a 	mov	sp,fp
 4000d24:	df000017 	ldw	fp,0(sp)
 4000d28:	dec00104 	addi	sp,sp,4
 4000d2c:	f800283a 	ret

04000d30 <prvReadGp>:
void vPortSysTickHandler( void * context);

/*-----------------------------------------------------------*/

static void prvReadGp( uint32_t *ulValue )
{
 4000d30:	defffe04 	addi	sp,sp,-8
 4000d34:	df000115 	stw	fp,4(sp)
 4000d38:	df000104 	addi	fp,sp,4
 4000d3c:	e13fff15 	stw	r4,-4(fp)
	asm( "stw gp, (%0)" :: "r"(ulValue) );
 4000d40:	e0bfff17 	ldw	r2,-4(fp)
 4000d44:	16800015 	stw	gp,0(r2)
}
 4000d48:	0001883a 	nop
 4000d4c:	e037883a 	mov	sp,fp
 4000d50:	df000017 	ldw	fp,0(sp)
 4000d54:	dec00104 	addi	sp,sp,4
 4000d58:	f800283a 	ret

04000d5c <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{    
 4000d5c:	defff904 	addi	sp,sp,-28
 4000d60:	dfc00615 	stw	ra,24(sp)
 4000d64:	df000515 	stw	fp,20(sp)
 4000d68:	df000504 	addi	fp,sp,20
 4000d6c:	e13ffd15 	stw	r4,-12(fp)
 4000d70:	e17ffc15 	stw	r5,-16(fp)
 4000d74:	e1bffb15 	stw	r6,-20(fp)
StackType_t *pxFramePointer = pxTopOfStack - 1;
 4000d78:	e0bffd17 	ldw	r2,-12(fp)
 4000d7c:	10bfff04 	addi	r2,r2,-4
 4000d80:	e0bfff15 	stw	r2,-4(fp)
StackType_t xGlobalPointer;

    prvReadGp( &xGlobalPointer ); 
 4000d84:	e0bffe04 	addi	r2,fp,-8
 4000d88:	1009883a 	mov	r4,r2
 4000d8c:	4000d300 	call	4000d30 <prvReadGp>

    /* End of stack marker. */
    *pxTopOfStack = 0xdeadbeef;
 4000d90:	e0fffd17 	ldw	r3,-12(fp)
 4000d94:	00b7abb4 	movhi	r2,57006
 4000d98:	10afbbc4 	addi	r2,r2,-16657
 4000d9c:	18800015 	stw	r2,0(r3)
    pxTopOfStack--;
 4000da0:	e0bffd17 	ldw	r2,-12(fp)
 4000da4:	10bfff04 	addi	r2,r2,-4
 4000da8:	e0bffd15 	stw	r2,-12(fp)
    
    *pxTopOfStack = ( StackType_t ) pxFramePointer; 
 4000dac:	e0ffff17 	ldw	r3,-4(fp)
 4000db0:	e0bffd17 	ldw	r2,-12(fp)
 4000db4:	10c00015 	stw	r3,0(r2)
    pxTopOfStack--;
 4000db8:	e0bffd17 	ldw	r2,-12(fp)
 4000dbc:	10bfff04 	addi	r2,r2,-4
 4000dc0:	e0bffd15 	stw	r2,-12(fp)
    
    *pxTopOfStack = xGlobalPointer; 
 4000dc4:	e0fffe17 	ldw	r3,-8(fp)
 4000dc8:	e0bffd17 	ldw	r2,-12(fp)
 4000dcc:	10c00015 	stw	r3,0(r2)
    
    /* Space for R23 to R16. */
    pxTopOfStack -= 9;
 4000dd0:	e0bffd17 	ldw	r2,-12(fp)
 4000dd4:	10bff704 	addi	r2,r2,-36
 4000dd8:	e0bffd15 	stw	r2,-12(fp)

    *pxTopOfStack = ( StackType_t ) pxCode; 
 4000ddc:	e0fffc17 	ldw	r3,-16(fp)
 4000de0:	e0bffd17 	ldw	r2,-12(fp)
 4000de4:	10c00015 	stw	r3,0(r2)
    pxTopOfStack--;
 4000de8:	e0bffd17 	ldw	r2,-12(fp)
 4000dec:	10bfff04 	addi	r2,r2,-4
 4000df0:	e0bffd15 	stw	r2,-12(fp)

    *pxTopOfStack = portINITIAL_ESTATUS; 
 4000df4:	e0bffd17 	ldw	r2,-12(fp)
 4000df8:	00c00044 	movi	r3,1
 4000dfc:	10c00015 	stw	r3,0(r2)

    /* Space for R15 to R5. */    
    pxTopOfStack -= 12;
 4000e00:	e0bffd17 	ldw	r2,-12(fp)
 4000e04:	10bff404 	addi	r2,r2,-48
 4000e08:	e0bffd15 	stw	r2,-12(fp)
    
    *pxTopOfStack = ( StackType_t ) pvParameters; 
 4000e0c:	e0fffb17 	ldw	r3,-20(fp)
 4000e10:	e0bffd17 	ldw	r2,-12(fp)
 4000e14:	10c00015 	stw	r3,0(r2)

    /* Space for R3 to R1, muldiv and RA. */
    pxTopOfStack -= 5;
 4000e18:	e0bffd17 	ldw	r2,-12(fp)
 4000e1c:	10bffb04 	addi	r2,r2,-20
 4000e20:	e0bffd15 	stw	r2,-12(fp)
    
    return pxTopOfStack;
 4000e24:	e0bffd17 	ldw	r2,-12(fp)
}
 4000e28:	e037883a 	mov	sp,fp
 4000e2c:	dfc00117 	ldw	ra,4(sp)
 4000e30:	df000017 	ldw	fp,0(sp)
 4000e34:	dec00204 	addi	sp,sp,8
 4000e38:	f800283a 	ret

04000e3c <xPortStartScheduler>:

/* 
 * See header file for description. 
 */
BaseType_t xPortStartScheduler( void )
{
 4000e3c:	defffe04 	addi	sp,sp,-8
 4000e40:	dfc00115 	stw	ra,4(sp)
 4000e44:	df000015 	stw	fp,0(sp)
 4000e48:	d839883a 	mov	fp,sp
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();
 4000e4c:	4000e940 	call	4000e94 <prvSetupTimerInterrupt>
 4000e50:	00810034 	movhi	r2,1024
	
	/* Start the first task. */
    asm volatile (  " movia r2, restore_sp_from_pxCurrentTCB        \n"
 4000e54:	10805704 	addi	r2,r2,348
 4000e58:	1000683a 	jmp	r2
                    " jmp r2                                          " );

	/* Should not get here! */
	return 0;
 4000e5c:	0005883a 	mov	r2,zero
}
 4000e60:	e037883a 	mov	sp,fp
 4000e64:	dfc00117 	ldw	ra,4(sp)
 4000e68:	df000017 	ldw	fp,0(sp)
 4000e6c:	dec00204 	addi	sp,sp,8
 4000e70:	f800283a 	ret

04000e74 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
 4000e74:	deffff04 	addi	sp,sp,-4
 4000e78:	df000015 	stw	fp,0(sp)
 4000e7c:	d839883a 	mov	fp,sp
	/* It is unlikely that the NIOS2 port will require this function as there
	is nothing to return to.  */
}
 4000e80:	0001883a 	nop
 4000e84:	e037883a 	mov	sp,fp
 4000e88:	df000017 	ldw	fp,0(sp)
 4000e8c:	dec00104 	addi	sp,sp,4
 4000e90:	f800283a 	ret

04000e94 <prvSetupTimerInterrupt>:
/*
 * Setup the systick timer to generate the tick interrupts at the required
 * frequency.
 */
void prvSetupTimerInterrupt( void )
{
 4000e94:	defffd04 	addi	sp,sp,-12
 4000e98:	dfc00215 	stw	ra,8(sp)
 4000e9c:	df000115 	stw	fp,4(sp)
 4000ea0:	df000104 	addi	fp,sp,4
	/* Try to register the interrupt handler. */
	if ( -EINVAL == _alt_ic_isr_register( SYS_CLK_IRQ_INTERRUPT_CONTROLLER_ID, SYS_CLK_IRQ, vPortSysTickHandler, 0x0, 0x0 ) )
 4000ea4:	d8000015 	stw	zero,0(sp)
 4000ea8:	000f883a 	mov	r7,zero
 4000eac:	01810034 	movhi	r6,1024
 4000eb0:	3183c904 	addi	r6,r6,3876
 4000eb4:	000b883a 	mov	r5,zero
 4000eb8:	0009883a 	mov	r4,zero
 4000ebc:	4000f680 	call	4000f68 <_alt_ic_isr_register>
 4000ec0:	10bffa98 	cmpnei	r2,r2,-22
 4000ec4:	1000021e 	bne	r2,zero,4000ed0 <prvSetupTimerInterrupt+0x3c>
	{ 
		/* Failed to install the Interrupt Handler. */
		asm( "break" );
 4000ec8:	003da03a 	break	0
 4000ecc:	00000c06 	br	4000f00 <prvSetupTimerInterrupt+0x6c>
	}
	else
	{
		/* Configure SysTick to interrupt at the requested rate. */
		IOWR_ALTERA_AVALON_TIMER_CONTROL( SYS_CLK_BASE, ALTERA_AVALON_TIMER_CONTROL_STOP_MSK );
 4000ed0:	00c00204 	movi	r3,8
 4000ed4:	00820034 	movhi	r2,2048
 4000ed8:	10c40935 	stwio	r3,4132(r2)
		IOWR_ALTERA_AVALON_TIMER_PERIODL( SYS_CLK_BASE, ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) & 0xFFFF );
 4000edc:	00f0d414 	movui	r3,50000
 4000ee0:	00820034 	movhi	r2,2048
 4000ee4:	10c40a35 	stwio	r3,4136(r2)
		IOWR_ALTERA_AVALON_TIMER_PERIODH( SYS_CLK_BASE, ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) >> 16 );
 4000ee8:	0007883a 	mov	r3,zero
 4000eec:	00820034 	movhi	r2,2048
 4000ef0:	10c40b35 	stwio	r3,4140(r2)
		IOWR_ALTERA_AVALON_TIMER_CONTROL( SYS_CLK_BASE, ALTERA_AVALON_TIMER_CONTROL_CONT_MSK | ALTERA_AVALON_TIMER_CONTROL_START_MSK | ALTERA_AVALON_TIMER_CONTROL_ITO_MSK );	
 4000ef4:	00c001c4 	movi	r3,7
 4000ef8:	00820034 	movhi	r2,2048
 4000efc:	10c40935 	stwio	r3,4132(r2)
	} 

	/* Clear any already pending interrupts generated by the Timer. */
	IOWR_ALTERA_AVALON_TIMER_STATUS( SYS_CLK_BASE, ~ALTERA_AVALON_TIMER_STATUS_TO_MSK );
 4000f00:	00ffff84 	movi	r3,-2
 4000f04:	00820034 	movhi	r2,2048
 4000f08:	10c40835 	stwio	r3,4128(r2)
}
 4000f0c:	0001883a 	nop
 4000f10:	e037883a 	mov	sp,fp
 4000f14:	dfc00117 	ldw	ra,4(sp)
 4000f18:	df000017 	ldw	fp,0(sp)
 4000f1c:	dec00204 	addi	sp,sp,8
 4000f20:	f800283a 	ret

04000f24 <vPortSysTickHandler>:
/*-----------------------------------------------------------*/

void vPortSysTickHandler( void * context)
{
 4000f24:	defffd04 	addi	sp,sp,-12
 4000f28:	dfc00215 	stw	ra,8(sp)
 4000f2c:	df000115 	stw	fp,4(sp)
 4000f30:	df000104 	addi	fp,sp,4
 4000f34:	e13fff15 	stw	r4,-4(fp)
	/* Increment the kernel tick. */
	if( xTaskIncrementTick() != pdFALSE )
 4000f38:	4004aec0 	call	4004aec <xTaskIncrementTick>
 4000f3c:	10000126 	beq	r2,zero,4000f44 <vPortSysTickHandler+0x20>
	{
        vTaskSwitchContext();
 4000f40:	4004e280 	call	4004e28 <vTaskSwitchContext>
	}
		
	/* Clear the interrupt. */
	IOWR_ALTERA_AVALON_TIMER_STATUS( SYS_CLK_BASE, ~ALTERA_AVALON_TIMER_STATUS_TO_MSK );
 4000f44:	00ffff84 	movi	r3,-2
 4000f48:	00820034 	movhi	r2,2048
 4000f4c:	10c40835 	stwio	r3,4128(r2)
}
 4000f50:	0001883a 	nop
 4000f54:	e037883a 	mov	sp,fp
 4000f58:	dfc00117 	ldw	ra,4(sp)
 4000f5c:	df000017 	ldw	fp,0(sp)
 4000f60:	dec00204 	addi	sp,sp,8
 4000f64:	f800283a 	ret

04000f68 <_alt_ic_isr_register>:
 * kernel has its scheduler started so that contexts are saved and switched 
 * correctly.
 */
int _alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr,
  void *isr_context, void *flags)
{
 4000f68:	defff604 	addi	sp,sp,-40
 4000f6c:	dfc00915 	stw	ra,36(sp)
 4000f70:	df000815 	stw	fp,32(sp)
 4000f74:	df000804 	addi	fp,sp,32
 4000f78:	e13ffb15 	stw	r4,-20(fp)
 4000f7c:	e17ffa15 	stw	r5,-24(fp)
 4000f80:	e1bff915 	stw	r6,-28(fp)
 4000f84:	e1fff815 	stw	r7,-32(fp)
	int rc = -EINVAL;  
 4000f88:	00bffa84 	movi	r2,-22
 4000f8c:	e0bfff15 	stw	r2,-4(fp)
	alt_irq_context status;
	int id = irq;             /* IRQ interpreted as the interrupt ID. */
 4000f90:	e0bffa17 	ldw	r2,-24(fp)
 4000f94:	e0bffe15 	stw	r2,-8(fp)

	if (id < ALT_NIRQ)
 4000f98:	e0bffe17 	ldw	r2,-8(fp)
 4000f9c:	10800808 	cmpgei	r2,r2,32
 4000fa0:	10001e1e 	bne	r2,zero,400101c <_alt_ic_isr_register+0xb4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 4000fa4:	0005303a 	rdctl	r2,status
 4000fa8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 4000fac:	e0fffc17 	ldw	r3,-16(fp)
 4000fb0:	00bfff84 	movi	r2,-2
 4000fb4:	1884703a 	and	r2,r3,r2
 4000fb8:	1001703a 	wrctl	status,r2
  
  return context;
 4000fbc:	e0bffc17 	ldw	r2,-16(fp)
		 * interrupts are disabled while the handler tables are updated to ensure
		 * that an interrupt doesn't occur while the tables are in an inconsistant
		 * state.
		 */
	
		status = alt_irq_disable_all ();
 4000fc0:	e0bffd15 	stw	r2,-12(fp)
	
		alt_irq[id].handler = isr;
 4000fc4:	e0bffe17 	ldw	r2,-8(fp)
 4000fc8:	100890fa 	slli	r4,r2,3
 4000fcc:	e0fff917 	ldw	r3,-28(fp)
 4000fd0:	00812074 	movhi	r2,1153
 4000fd4:	2085883a 	add	r2,r4,r2
 4000fd8:	10ffed15 	stw	r3,-76(r2)
		alt_irq[id].context = isr_context;
 4000fdc:	e0bffe17 	ldw	r2,-8(fp)
 4000fe0:	100890fa 	slli	r4,r2,3
 4000fe4:	e0fff817 	ldw	r3,-32(fp)
 4000fe8:	00812074 	movhi	r2,1153
 4000fec:	2085883a 	add	r2,r4,r2
 4000ff0:	10ffee15 	stw	r3,-72(r2)
	
		rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
 4000ff4:	e0bff917 	ldw	r2,-28(fp)
 4000ff8:	10000426 	beq	r2,zero,400100c <_alt_ic_isr_register+0xa4>
 4000ffc:	e17ffe17 	ldw	r5,-8(fp)
 4001000:	e13ffb17 	ldw	r4,-20(fp)
 4001004:	400a4800 	call	400a480 <alt_ic_irq_enable>
 4001008:	00000306 	br	4001018 <_alt_ic_isr_register+0xb0>
 400100c:	e17ffe17 	ldw	r5,-8(fp)
 4001010:	e13ffb17 	ldw	r4,-20(fp)
 4001014:	400a5080 	call	400a508 <alt_ic_irq_disable>
 4001018:	e0bfff15 	stw	r2,-4(fp)
	
		/* alt_irq_enable_all(status); This line is removed to prevent the interrupt from being immediately enabled. */
	}
    
	return rc; 
 400101c:	e0bfff17 	ldw	r2,-4(fp)
}
 4001020:	e037883a 	mov	sp,fp
 4001024:	dfc00117 	ldw	ra,4(sp)
 4001028:	df000017 	ldw	fp,0(sp)
 400102c:	dec00204 	addi	sp,sp,8
 4001030:	f800283a 	ret

04001034 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void * pvPortMalloc( size_t xWantedSize )
{
 4001034:	defffc04 	addi	sp,sp,-16
 4001038:	dfc00315 	stw	ra,12(sp)
 400103c:	df000215 	stw	fp,8(sp)
 4001040:	df000204 	addi	fp,sp,8
 4001044:	e13ffe15 	stw	r4,-8(fp)
    void * pvReturn = NULL;
 4001048:	e03fff15 	stw	zero,-4(fp)
    static uint8_t * pucAlignedHeap = NULL;

    /* Ensure that blocks are always aligned. */
    #if ( portBYTE_ALIGNMENT != 1 )
    {
        if( xWantedSize & portBYTE_ALIGNMENT_MASK )
 400104c:	e0bffe17 	ldw	r2,-8(fp)
 4001050:	108000cc 	andi	r2,r2,3
 4001054:	10000d26 	beq	r2,zero,400108c <pvPortMalloc+0x58>
        {
            /* Byte alignment required. Check for overflow. */
            if( ( xWantedSize + ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ) > xWantedSize )
 4001058:	e0fffe17 	ldw	r3,-8(fp)
 400105c:	00bfff04 	movi	r2,-4
 4001060:	1884703a 	and	r2,r3,r2
 4001064:	10800104 	addi	r2,r2,4
 4001068:	e0fffe17 	ldw	r3,-8(fp)
 400106c:	1880062e 	bgeu	r3,r2,4001088 <pvPortMalloc+0x54>
            {
                xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 4001070:	e0fffe17 	ldw	r3,-8(fp)
 4001074:	00bfff04 	movi	r2,-4
 4001078:	1884703a 	and	r2,r3,r2
 400107c:	10800104 	addi	r2,r2,4
 4001080:	e0bffe15 	stw	r2,-8(fp)
 4001084:	00000106 	br	400108c <pvPortMalloc+0x58>
            }
            else
            {
                xWantedSize = 0;
 4001088:	e03ffe15 	stw	zero,-8(fp)
            }
        }
    }
    #endif /* if ( portBYTE_ALIGNMENT != 1 ) */

    vTaskSuspendAll();
 400108c:	40046e80 	call	40046e8 <vTaskSuspendAll>
    {
        if( pucAlignedHeap == NULL )
 4001090:	d0a6ac17 	ldw	r2,-25936(gp)
 4001094:	1000051e 	bne	r2,zero,40010ac <pvPortMalloc+0x78>
        {
            /* Ensure the heap starts on a correctly aligned boundary. */
            pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) & ucHeap[ portBYTE_ALIGNMENT - 1 ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
 4001098:	00810074 	movhi	r2,1025
 400109c:	10bfb1c4 	addi	r2,r2,-313
 40010a0:	00ffff04 	movi	r3,-4
 40010a4:	10c4703a 	and	r2,r2,r3
 40010a8:	d0a6ac15 	stw	r2,-25936(gp)
        }

        /* Check there is enough room left for the allocation and. */
        if( ( xWantedSize > 0 ) &&                                /* valid size */
 40010ac:	e0bffe17 	ldw	r2,-8(fp)
 40010b0:	10001326 	beq	r2,zero,4001100 <pvPortMalloc+0xcc>
            ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
 40010b4:	d0e6ab17 	ldw	r3,-25940(gp)
 40010b8:	e0bffe17 	ldw	r2,-8(fp)
 40010bc:	1887883a 	add	r3,r3,r2
        if( ( xWantedSize > 0 ) &&                                /* valid size */
 40010c0:	00802034 	movhi	r2,128
 40010c4:	10bffec4 	addi	r2,r2,-5
 40010c8:	10c00d36 	bltu	r2,r3,4001100 <pvPortMalloc+0xcc>
            ( ( xNextFreeByte + xWantedSize ) > xNextFreeByte ) ) /* Check for overflow. */
 40010cc:	d0e6ab17 	ldw	r3,-25940(gp)
 40010d0:	e0bffe17 	ldw	r2,-8(fp)
 40010d4:	1885883a 	add	r2,r3,r2
 40010d8:	d0e6ab17 	ldw	r3,-25940(gp)
            ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
 40010dc:	1880082e 	bgeu	r3,r2,4001100 <pvPortMalloc+0xcc>
        {
            /* Return the next free byte then increment the index past this
             * block. */
            pvReturn = pucAlignedHeap + xNextFreeByte;
 40010e0:	d0e6ac17 	ldw	r3,-25936(gp)
 40010e4:	d0a6ab17 	ldw	r2,-25940(gp)
 40010e8:	1885883a 	add	r2,r3,r2
 40010ec:	e0bfff15 	stw	r2,-4(fp)
            xNextFreeByte += xWantedSize;
 40010f0:	d0e6ab17 	ldw	r3,-25940(gp)
 40010f4:	e0bffe17 	ldw	r2,-8(fp)
 40010f8:	1885883a 	add	r2,r3,r2
 40010fc:	d0a6ab15 	stw	r2,-25940(gp)
        }

        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();
 4001100:	40047140 	call	4004714 <xTaskResumeAll>
            vApplicationMallocFailedHook();
        }
    }
    #endif

    return pvReturn;
 4001104:	e0bfff17 	ldw	r2,-4(fp)
}
 4001108:	e037883a 	mov	sp,fp
 400110c:	dfc00117 	ldw	ra,4(sp)
 4001110:	df000017 	ldw	fp,0(sp)
 4001114:	dec00204 	addi	sp,sp,8
 4001118:	f800283a 	ret

0400111c <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void * pv )
{
 400111c:	defffe04 	addi	sp,sp,-8
 4001120:	df000115 	stw	fp,4(sp)
 4001124:	df000104 	addi	fp,sp,4
 4001128:	e13fff15 	stw	r4,-4(fp)
     * https://www.FreeRTOS.org for more information. */
    ( void ) pv;

    /* Force an assert as it is invalid to call this function. */
    configASSERT( pv == NULL );
}
 400112c:	0001883a 	nop
 4001130:	e037883a 	mov	sp,fp
 4001134:	df000017 	ldw	fp,0(sp)
 4001138:	dec00104 	addi	sp,sp,4
 400113c:	f800283a 	ret

04001140 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
 4001140:	deffff04 	addi	sp,sp,-4
 4001144:	df000015 	stw	fp,0(sp)
 4001148:	d839883a 	mov	fp,sp
    /* Only required when static memory is not cleared. */
    xNextFreeByte = ( size_t ) 0;
 400114c:	d026ab15 	stw	zero,-25940(gp)
}
 4001150:	0001883a 	nop
 4001154:	e037883a 	mov	sp,fp
 4001158:	df000017 	ldw	fp,0(sp)
 400115c:	dec00104 	addi	sp,sp,4
 4001160:	f800283a 	ret

04001164 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
 4001164:	deffff04 	addi	sp,sp,-4
 4001168:	df000015 	stw	fp,0(sp)
 400116c:	d839883a 	mov	fp,sp
    return( configADJUSTED_HEAP_SIZE - xNextFreeByte );
 4001170:	d0e6ab17 	ldw	r3,-25940(gp)
 4001174:	00802034 	movhi	r2,128
 4001178:	10bfff04 	addi	r2,r2,-4
 400117c:	10c5c83a 	sub	r2,r2,r3
}
 4001180:	e037883a 	mov	sp,fp
 4001184:	df000017 	ldw	fp,0(sp)
 4001188:	dec00104 	addi	sp,sp,4
 400118c:	f800283a 	ret

04001190 <xQueueGenericReset>:
    }
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue,
                               BaseType_t xNewQueue )
{
 4001190:	defff404 	addi	sp,sp,-48
 4001194:	dfc00b15 	stw	ra,44(sp)
 4001198:	df000a15 	stw	fp,40(sp)
 400119c:	dd400915 	stw	r21,36(sp)
 40011a0:	dd000815 	stw	r20,32(sp)
 40011a4:	dcc00715 	stw	r19,28(sp)
 40011a8:	dc800615 	stw	r18,24(sp)
 40011ac:	dc400515 	stw	r17,20(sp)
 40011b0:	dc000415 	stw	r16,16(sp)
 40011b4:	df000a04 	addi	fp,sp,40
 40011b8:	e13ff715 	stw	r4,-36(fp)
 40011bc:	e17ff615 	stw	r5,-40(fp)
    BaseType_t xReturn = pdPASS;
 40011c0:	00800044 	movi	r2,1
 40011c4:	e0bff915 	stw	r2,-28(fp)
    Queue_t * const pxQueue = xQueue;
 40011c8:	e0bff717 	ldw	r2,-36(fp)
 40011cc:	e0bff815 	stw	r2,-32(fp)

    configASSERT( pxQueue );

    if( ( pxQueue != NULL ) &&
 40011d0:	e0bff817 	ldw	r2,-32(fp)
 40011d4:	10007126 	beq	r2,zero,400139c <xQueueGenericReset+0x20c>
        ( pxQueue->uxLength >= 1U ) &&
 40011d8:	e0bff817 	ldw	r2,-32(fp)
 40011dc:	10800f17 	ldw	r2,60(r2)
    if( ( pxQueue != NULL ) &&
 40011e0:	10006e26 	beq	r2,zero,400139c <xQueueGenericReset+0x20c>
        /* Check for multiplication overflow. */
        ( ( SIZE_MAX / pxQueue->uxLength ) >= pxQueue->uxItemSize ) )
 40011e4:	e0bff817 	ldw	r2,-32(fp)
 40011e8:	14001017 	ldw	r16,64(r2)
 40011ec:	e0bff817 	ldw	r2,-32(fp)
 40011f0:	14400f17 	ldw	r17,60(r2)
 40011f4:	0025883a 	mov	r18,zero
 40011f8:	8008d43a 	srli	r4,r16,16
 40011fc:	8804d43a 	srli	r2,r17,16
 4001200:	20ffffcc 	andi	r3,r4,65535
 4001204:	18000b1e 	bne	r3,zero,4001234 <xQueueGenericReset+0xa4>
 4001208:	10ffffcc 	andi	r3,r2,65535
 400120c:	1800061e 	bne	r3,zero,4001228 <xQueueGenericReset+0x98>
 4001210:	80bfffcc 	andi	r2,r16,65535
 4001214:	88ffffcc 	andi	r3,r17,65535
 4001218:	180b883a 	mov	r5,r3
 400121c:	1009883a 	mov	r4,r2
 4001220:	40073b40 	call	40073b4 <__mulsi3>
 4001224:	00001f06 	br	40012a4 <xQueueGenericReset+0x114>
 4001228:	1029883a 	mov	r20,r2
 400122c:	802b883a 	mov	r21,r16
 4001230:	00000406 	br	4001244 <xQueueGenericReset+0xb4>
 4001234:	10bfffcc 	andi	r2,r2,65535
 4001238:	1000131e 	bne	r2,zero,4001288 <xQueueGenericReset+0xf8>
 400123c:	2029883a 	mov	r20,r4
 4001240:	882b883a 	mov	r21,r17
 4001244:	80bfffcc 	andi	r2,r16,65535
 4001248:	88ffffcc 	andi	r3,r17,65535
 400124c:	180b883a 	mov	r5,r3
 4001250:	1009883a 	mov	r4,r2
 4001254:	40073b40 	call	40073b4 <__mulsi3>
 4001258:	1027883a 	mov	r19,r2
 400125c:	a8bfffcc 	andi	r2,r21,65535
 4001260:	a0ffffcc 	andi	r3,r20,65535
 4001264:	180b883a 	mov	r5,r3
 4001268:	1009883a 	mov	r4,r2
 400126c:	40073b40 	call	40073b4 <__mulsi3>
 4001270:	9806d43a 	srli	r3,r19,16
 4001274:	10c5883a 	add	r2,r2,r3
 4001278:	1005d43a 	srai	r2,r2,16
 400127c:	10bfffcc 	andi	r2,r2,65535
 4001280:	1000041e 	bne	r2,zero,4001294 <xQueueGenericReset+0x104>
 4001284:	00000706 	br	40012a4 <xQueueGenericReset+0x114>
 4001288:	880b883a 	mov	r5,r17
 400128c:	8009883a 	mov	r4,r16
 4001290:	40073b40 	call	40073b4 <__mulsi3>
 4001294:	880b883a 	mov	r5,r17
 4001298:	8009883a 	mov	r4,r16
 400129c:	40073b40 	call	40073b4 <__mulsi3>
 40012a0:	04800044 	movi	r18,1
 40012a4:	9005883a 	mov	r2,r18
        ( pxQueue->uxLength >= 1U ) &&
 40012a8:	10003c1e 	bne	r2,zero,400139c <xQueueGenericReset+0x20c>
    {
        taskENTER_CRITICAL();
 40012ac:	4005f740 	call	4005f74 <vTaskEnterCritical>
        {
            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 40012b0:	e0bff817 	ldw	r2,-32(fp)
 40012b4:	14000017 	ldw	r16,0(r2)
 40012b8:	e0bff817 	ldw	r2,-32(fp)
 40012bc:	10c00f17 	ldw	r3,60(r2)
 40012c0:	e0bff817 	ldw	r2,-32(fp)
 40012c4:	10801017 	ldw	r2,64(r2)
 40012c8:	100b883a 	mov	r5,r2
 40012cc:	1809883a 	mov	r4,r3
 40012d0:	40073b40 	call	40073b4 <__mulsi3>
 40012d4:	8087883a 	add	r3,r16,r2
 40012d8:	e0bff817 	ldw	r2,-32(fp)
 40012dc:	10c00215 	stw	r3,8(r2)
            pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 40012e0:	e0bff817 	ldw	r2,-32(fp)
 40012e4:	10000e15 	stw	zero,56(r2)
            pxQueue->pcWriteTo = pxQueue->pcHead;
 40012e8:	e0bff817 	ldw	r2,-32(fp)
 40012ec:	10c00017 	ldw	r3,0(r2)
 40012f0:	e0bff817 	ldw	r2,-32(fp)
 40012f4:	10c00115 	stw	r3,4(r2)
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 40012f8:	e0bff817 	ldw	r2,-32(fp)
 40012fc:	14000017 	ldw	r16,0(r2)
 4001300:	e0bff817 	ldw	r2,-32(fp)
 4001304:	10800f17 	ldw	r2,60(r2)
 4001308:	10ffffc4 	addi	r3,r2,-1
 400130c:	e0bff817 	ldw	r2,-32(fp)
 4001310:	10801017 	ldw	r2,64(r2)
 4001314:	100b883a 	mov	r5,r2
 4001318:	1809883a 	mov	r4,r3
 400131c:	40073b40 	call	40073b4 <__mulsi3>
 4001320:	8087883a 	add	r3,r16,r2
 4001324:	e0bff817 	ldw	r2,-32(fp)
 4001328:	10c00315 	stw	r3,12(r2)
            pxQueue->cRxLock = queueUNLOCKED;
 400132c:	e0bff817 	ldw	r2,-32(fp)
 4001330:	00ffffc4 	movi	r3,-1
 4001334:	10c01105 	stb	r3,68(r2)
            pxQueue->cTxLock = queueUNLOCKED;
 4001338:	e0bff817 	ldw	r2,-32(fp)
 400133c:	00ffffc4 	movi	r3,-1
 4001340:	10c01145 	stb	r3,69(r2)

            if( xNewQueue == pdFALSE )
 4001344:	e0bff617 	ldw	r2,-40(fp)
 4001348:	10000a1e 	bne	r2,zero,4001374 <xQueueGenericReset+0x1e4>
                /* If there are tasks blocked waiting to read from the queue, then
                 * the tasks will remain blocked as after this function exits the queue
                 * will still be empty.  If there are tasks blocked waiting to write to
                 * the queue, then one should be unblocked as after this function exits
                 * it will be possible to write to it. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 400134c:	e0bff817 	ldw	r2,-32(fp)
 4001350:	10800417 	ldw	r2,16(r2)
 4001354:	10000f26 	beq	r2,zero,4001394 <xQueueGenericReset+0x204>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 4001358:	e0bff817 	ldw	r2,-32(fp)
 400135c:	10800404 	addi	r2,r2,16
 4001360:	1009883a 	mov	r4,r2
 4001364:	40050240 	call	4005024 <xTaskRemoveFromEventList>
 4001368:	10000a26 	beq	r2,zero,4001394 <xQueueGenericReset+0x204>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
 400136c:	003b683a 	trap	0
 4001370:	00000806 	br	4001394 <xQueueGenericReset+0x204>
                }
            }
            else
            {
                /* Ensure the event queues start in the correct state. */
                vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 4001374:	e0bff817 	ldw	r2,-32(fp)
 4001378:	10800404 	addi	r2,r2,16
 400137c:	1009883a 	mov	r4,r2
 4001380:	4000aa00 	call	4000aa0 <vListInitialise>
                vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 4001384:	e0bff817 	ldw	r2,-32(fp)
 4001388:	10800904 	addi	r2,r2,36
 400138c:	1009883a 	mov	r4,r2
 4001390:	4000aa00 	call	4000aa0 <vListInitialise>
            }
        }
        taskEXIT_CRITICAL();
 4001394:	4005fc80 	call	4005fc8 <vTaskExitCritical>
 4001398:	00000106 	br	40013a0 <xQueueGenericReset+0x210>
    }
    else
    {
        xReturn = pdFAIL;
 400139c:	e03ff915 	stw	zero,-28(fp)

    configASSERT( xReturn != pdFAIL );

    /* A value is returned for calling semantic consistency with previous
     * versions. */
    return xReturn;
 40013a0:	e0bff917 	ldw	r2,-28(fp)
}
 40013a4:	e6fffa04 	addi	sp,fp,-24
 40013a8:	dfc00717 	ldw	ra,28(sp)
 40013ac:	df000617 	ldw	fp,24(sp)
 40013b0:	dd400517 	ldw	r21,20(sp)
 40013b4:	dd000417 	ldw	r20,16(sp)
 40013b8:	dcc00317 	ldw	r19,12(sp)
 40013bc:	dc800217 	ldw	r18,8(sp)
 40013c0:	dc400117 	ldw	r17,4(sp)
 40013c4:	dc000017 	ldw	r16,0(sp)
 40013c8:	dec00804 	addi	sp,sp,32
 40013cc:	f800283a 	ret

040013d0 <xQueueGenericCreate>:
#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,
                                       const UBaseType_t uxItemSize,
                                       const uint8_t ucQueueType )
    {
 40013d0:	defff304 	addi	sp,sp,-52
 40013d4:	dfc00c15 	stw	ra,48(sp)
 40013d8:	df000b15 	stw	fp,44(sp)
 40013dc:	dcc00a15 	stw	r19,40(sp)
 40013e0:	dc800915 	stw	r18,36(sp)
 40013e4:	dc400815 	stw	r17,32(sp)
 40013e8:	dc000715 	stw	r16,28(sp)
 40013ec:	df000b04 	addi	fp,sp,44
 40013f0:	e13ff815 	stw	r4,-32(fp)
 40013f4:	e17ff715 	stw	r5,-36(fp)
 40013f8:	3005883a 	mov	r2,r6
 40013fc:	e0bff605 	stb	r2,-40(fp)
        Queue_t * pxNewQueue = NULL;
 4001400:	e03ffb15 	stw	zero,-20(fp)
        size_t xQueueSizeInBytes;
        uint8_t * pucQueueStorage;

        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
 4001404:	e0bff817 	ldw	r2,-32(fp)
 4001408:	10005026 	beq	r2,zero,400154c <xQueueGenericCreate+0x17c>
            /* Check for multiplication overflow. */
            ( ( SIZE_MAX / uxQueueLength ) >= uxItemSize ) &&
 400140c:	0021883a 	mov	r16,zero
 4001410:	e0bff717 	ldw	r2,-36(fp)
 4001414:	100cd43a 	srli	r6,r2,16
 4001418:	e0fff717 	ldw	r3,-36(fp)
 400141c:	e0bff817 	ldw	r2,-32(fp)
 4001420:	1008d43a 	srli	r4,r2,16
 4001424:	e0bff817 	ldw	r2,-32(fp)
 4001428:	317fffcc 	andi	r5,r6,65535
 400142c:	28000b1e 	bne	r5,zero,400145c <xQueueGenericCreate+0x8c>
 4001430:	217fffcc 	andi	r5,r4,65535
 4001434:	2800061e 	bne	r5,zero,4001450 <xQueueGenericCreate+0x80>
 4001438:	18ffffcc 	andi	r3,r3,65535
 400143c:	10bfffcc 	andi	r2,r2,65535
 4001440:	100b883a 	mov	r5,r2
 4001444:	1809883a 	mov	r4,r3
 4001448:	40073b40 	call	40073b4 <__mulsi3>
 400144c:	00001f06 	br	40014cc <xQueueGenericCreate+0xfc>
 4001450:	2025883a 	mov	r18,r4
 4001454:	1827883a 	mov	r19,r3
 4001458:	00000406 	br	400146c <xQueueGenericCreate+0x9c>
 400145c:	213fffcc 	andi	r4,r4,65535
 4001460:	2000131e 	bne	r4,zero,40014b0 <xQueueGenericCreate+0xe0>
 4001464:	3025883a 	mov	r18,r6
 4001468:	1027883a 	mov	r19,r2
 400146c:	18ffffcc 	andi	r3,r3,65535
 4001470:	10bfffcc 	andi	r2,r2,65535
 4001474:	100b883a 	mov	r5,r2
 4001478:	1809883a 	mov	r4,r3
 400147c:	40073b40 	call	40073b4 <__mulsi3>
 4001480:	1023883a 	mov	r17,r2
 4001484:	98bfffcc 	andi	r2,r19,65535
 4001488:	90ffffcc 	andi	r3,r18,65535
 400148c:	180b883a 	mov	r5,r3
 4001490:	1009883a 	mov	r4,r2
 4001494:	40073b40 	call	40073b4 <__mulsi3>
 4001498:	8806d43a 	srli	r3,r17,16
 400149c:	10c5883a 	add	r2,r2,r3
 40014a0:	1005d43a 	srai	r2,r2,16
 40014a4:	10bfffcc 	andi	r2,r2,65535
 40014a8:	1000041e 	bne	r2,zero,40014bc <xQueueGenericCreate+0xec>
 40014ac:	00000706 	br	40014cc <xQueueGenericCreate+0xfc>
 40014b0:	e17ff817 	ldw	r5,-32(fp)
 40014b4:	e13ff717 	ldw	r4,-36(fp)
 40014b8:	40073b40 	call	40073b4 <__mulsi3>
 40014bc:	e17ff817 	ldw	r5,-32(fp)
 40014c0:	e13ff717 	ldw	r4,-36(fp)
 40014c4:	40073b40 	call	40073b4 <__mulsi3>
 40014c8:	04000044 	movi	r16,1
 40014cc:	8005883a 	mov	r2,r16
        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
 40014d0:	10001e1e 	bne	r2,zero,400154c <xQueueGenericCreate+0x17c>
            /* Check for addition overflow. */
            ( ( SIZE_MAX - sizeof( Queue_t ) ) >= ( uxQueueLength * uxItemSize ) ) )
 40014d4:	e17ff717 	ldw	r5,-36(fp)
 40014d8:	e13ff817 	ldw	r4,-32(fp)
 40014dc:	40073b40 	call	40073b4 <__mulsi3>
 40014e0:	1007883a 	mov	r3,r2
            ( ( SIZE_MAX / uxQueueLength ) >= uxItemSize ) &&
 40014e4:	00bfedc4 	movi	r2,-73
 40014e8:	10c01836 	bltu	r2,r3,400154c <xQueueGenericCreate+0x17c>
        {
            /* Allocate enough space to hold the maximum number of items that
             * can be in the queue at any time.  It is valid for uxItemSize to be
             * zero in the case the queue is used as a semaphore. */
            xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 40014ec:	e17ff717 	ldw	r5,-36(fp)
 40014f0:	e13ff817 	ldw	r4,-32(fp)
 40014f4:	40073b40 	call	40073b4 <__mulsi3>
 40014f8:	e0bffa15 	stw	r2,-24(fp)
             * alignment requirements of the Queue_t structure - which in this case
             * is an int8_t *.  Therefore, whenever the stack alignment requirements
             * are greater than or equal to the pointer to char requirements the cast
             * is safe.  In other cases alignment requirements are not strict (one or
             * two bytes). */
            pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
 40014fc:	e0bffa17 	ldw	r2,-24(fp)
 4001500:	10801204 	addi	r2,r2,72
 4001504:	1009883a 	mov	r4,r2
 4001508:	40010340 	call	4001034 <pvPortMalloc>
 400150c:	e0bffb15 	stw	r2,-20(fp)

            if( pxNewQueue != NULL )
 4001510:	e0bffb17 	ldw	r2,-20(fp)
 4001514:	10000d26 	beq	r2,zero,400154c <xQueueGenericCreate+0x17c>
            {
                /* Jump past the queue structure to find the location of the queue
                 * storage area. */
                pucQueueStorage = ( uint8_t * ) pxNewQueue;
 4001518:	e0bffb17 	ldw	r2,-20(fp)
 400151c:	e0bff915 	stw	r2,-28(fp)
                pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 4001520:	e0bff917 	ldw	r2,-28(fp)
 4001524:	10801204 	addi	r2,r2,72
 4001528:	e0bff915 	stw	r2,-28(fp)
                     * deleted. */
                    pxNewQueue->ucStaticallyAllocated = pdFALSE;
                }
                #endif /* configSUPPORT_STATIC_ALLOCATION */

                prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
 400152c:	e0fff603 	ldbu	r3,-40(fp)
 4001530:	e0bffb17 	ldw	r2,-20(fp)
 4001534:	d8800015 	stw	r2,0(sp)
 4001538:	180f883a 	mov	r7,r3
 400153c:	e1bff917 	ldw	r6,-28(fp)
 4001540:	e17ff717 	ldw	r5,-36(fp)
 4001544:	e13ff817 	ldw	r4,-32(fp)
 4001548:	40015740 	call	4001574 <prvInitialiseNewQueue>
        {
            configASSERT( pxNewQueue );
            mtCOVERAGE_TEST_MARKER();
        }

        return pxNewQueue;
 400154c:	e0bffb17 	ldw	r2,-20(fp)
    }
 4001550:	e6fffc04 	addi	sp,fp,-16
 4001554:	dfc00517 	ldw	ra,20(sp)
 4001558:	df000417 	ldw	fp,16(sp)
 400155c:	dcc00317 	ldw	r19,12(sp)
 4001560:	dc800217 	ldw	r18,8(sp)
 4001564:	dc400117 	ldw	r17,4(sp)
 4001568:	dc000017 	ldw	r16,0(sp)
 400156c:	dec00604 	addi	sp,sp,24
 4001570:	f800283a 	ret

04001574 <prvInitialiseNewQueue>:
static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength,
                                   const UBaseType_t uxItemSize,
                                   uint8_t * pucQueueStorage,
                                   const uint8_t ucQueueType,
                                   Queue_t * pxNewQueue )
{
 4001574:	defffa04 	addi	sp,sp,-24
 4001578:	dfc00515 	stw	ra,20(sp)
 400157c:	df000415 	stw	fp,16(sp)
 4001580:	df000404 	addi	fp,sp,16
 4001584:	e13fff15 	stw	r4,-4(fp)
 4001588:	e17ffe15 	stw	r5,-8(fp)
 400158c:	e1bffd15 	stw	r6,-12(fp)
 4001590:	3805883a 	mov	r2,r7
 4001594:	e0bffc05 	stb	r2,-16(fp)
    /* Remove compiler warnings about unused parameters should
     * configUSE_TRACE_FACILITY not be set to 1. */
    ( void ) ucQueueType;

    if( uxItemSize == ( UBaseType_t ) 0 )
 4001598:	e0bffe17 	ldw	r2,-8(fp)
 400159c:	1000041e 	bne	r2,zero,40015b0 <prvInitialiseNewQueue+0x3c>
    {
        /* No RAM was allocated for the queue storage area, but PC head cannot
         * be set to NULL because NULL is used as a key to say the queue is used as
         * a mutex.  Therefore just set pcHead to point to the queue as a benign
         * value that is known to be within the memory map. */
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 40015a0:	e0800217 	ldw	r2,8(fp)
 40015a4:	e0c00217 	ldw	r3,8(fp)
 40015a8:	10c00015 	stw	r3,0(r2)
 40015ac:	00000306 	br	40015bc <prvInitialiseNewQueue+0x48>
    }
    else
    {
        /* Set the head to the start of the queue storage area. */
        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 40015b0:	e0800217 	ldw	r2,8(fp)
 40015b4:	e0fffd17 	ldw	r3,-12(fp)
 40015b8:	10c00015 	stw	r3,0(r2)
    }

    /* Initialise the queue members as described where the queue type is
     * defined. */
    pxNewQueue->uxLength = uxQueueLength;
 40015bc:	e0800217 	ldw	r2,8(fp)
 40015c0:	e0ffff17 	ldw	r3,-4(fp)
 40015c4:	10c00f15 	stw	r3,60(r2)
    pxNewQueue->uxItemSize = uxItemSize;
 40015c8:	e0800217 	ldw	r2,8(fp)
 40015cc:	e0fffe17 	ldw	r3,-8(fp)
 40015d0:	10c01015 	stw	r3,64(r2)
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 40015d4:	01400044 	movi	r5,1
 40015d8:	e1000217 	ldw	r4,8(fp)
 40015dc:	40011900 	call	4001190 <xQueueGenericReset>
        pxNewQueue->pxQueueSetContainer = NULL;
    }
    #endif /* configUSE_QUEUE_SETS */

    traceQUEUE_CREATE( pxNewQueue );
}
 40015e0:	0001883a 	nop
 40015e4:	e037883a 	mov	sp,fp
 40015e8:	dfc00117 	ldw	ra,4(sp)
 40015ec:	df000017 	ldw	fp,0(sp)
 40015f0:	dec00204 	addi	sp,sp,8
 40015f4:	f800283a 	ret

040015f8 <prvInitialiseMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    static void prvInitialiseMutex( Queue_t * pxNewQueue )
    {
 40015f8:	defffd04 	addi	sp,sp,-12
 40015fc:	dfc00215 	stw	ra,8(sp)
 4001600:	df000115 	stw	fp,4(sp)
 4001604:	df000104 	addi	fp,sp,4
 4001608:	e13fff15 	stw	r4,-4(fp)
        if( pxNewQueue != NULL )
 400160c:	e0bfff17 	ldw	r2,-4(fp)
 4001610:	10000b26 	beq	r2,zero,4001640 <prvInitialiseMutex+0x48>
        {
            /* The queue create function will set all the queue structure members
            * correctly for a generic queue, but this function is creating a
            * mutex.  Overwrite those members that need to be set differently -
            * in particular the information required for priority inheritance. */
            pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
 4001614:	e0bfff17 	ldw	r2,-4(fp)
 4001618:	10000215 	stw	zero,8(r2)
            pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 400161c:	e0bfff17 	ldw	r2,-4(fp)
 4001620:	10000015 	stw	zero,0(r2)

            /* In case this is a recursive mutex. */
            pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
 4001624:	e0bfff17 	ldw	r2,-4(fp)
 4001628:	10000315 	stw	zero,12(r2)

            traceCREATE_MUTEX( pxNewQueue );

            /* Start with the semaphore in the expected state. */
            ( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 400162c:	000f883a 	mov	r7,zero
 4001630:	000d883a 	mov	r6,zero
 4001634:	000b883a 	mov	r5,zero
 4001638:	e13fff17 	ldw	r4,-4(fp)
 400163c:	40018500 	call	4001850 <xQueueGenericSend>
        }
        else
        {
            traceCREATE_MUTEX_FAILED();
        }
    }
 4001640:	0001883a 	nop
 4001644:	e037883a 	mov	sp,fp
 4001648:	dfc00117 	ldw	ra,4(sp)
 400164c:	df000017 	ldw	fp,0(sp)
 4001650:	dec00204 	addi	sp,sp,8
 4001654:	f800283a 	ret

04001658 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

    QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
    {
 4001658:	defffa04 	addi	sp,sp,-24
 400165c:	dfc00515 	stw	ra,20(sp)
 4001660:	df000415 	stw	fp,16(sp)
 4001664:	df000404 	addi	fp,sp,16
 4001668:	2005883a 	mov	r2,r4
 400166c:	e0bffc05 	stb	r2,-16(fp)
        QueueHandle_t xNewQueue;
        const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
 4001670:	00800044 	movi	r2,1
 4001674:	e0bfff15 	stw	r2,-4(fp)
 4001678:	e03ffe15 	stw	zero,-8(fp)

        xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
 400167c:	e0bffc03 	ldbu	r2,-16(fp)
 4001680:	100d883a 	mov	r6,r2
 4001684:	e17ffe17 	ldw	r5,-8(fp)
 4001688:	e13fff17 	ldw	r4,-4(fp)
 400168c:	40013d00 	call	40013d0 <xQueueGenericCreate>
 4001690:	e0bffd15 	stw	r2,-12(fp)
        prvInitialiseMutex( ( Queue_t * ) xNewQueue );
 4001694:	e13ffd17 	ldw	r4,-12(fp)
 4001698:	40015f80 	call	40015f8 <prvInitialiseMutex>

        return xNewQueue;
 400169c:	e0bffd17 	ldw	r2,-12(fp)
    }
 40016a0:	e037883a 	mov	sp,fp
 40016a4:	dfc00117 	ldw	ra,4(sp)
 40016a8:	df000017 	ldw	fp,0(sp)
 40016ac:	dec00204 	addi	sp,sp,8
 40016b0:	f800283a 	ret

040016b4 <xQueueGiveMutexRecursive>:
/*-----------------------------------------------------------*/

#if ( configUSE_RECURSIVE_MUTEXES == 1 )

    BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
    {
 40016b4:	defffa04 	addi	sp,sp,-24
 40016b8:	dfc00515 	stw	ra,20(sp)
 40016bc:	df000415 	stw	fp,16(sp)
 40016c0:	dc000315 	stw	r16,12(sp)
 40016c4:	df000404 	addi	fp,sp,16
 40016c8:	e13ffc15 	stw	r4,-16(fp)
        BaseType_t xReturn;
        Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 40016cc:	e0bffc17 	ldw	r2,-16(fp)
 40016d0:	e0bffd15 	stw	r2,-12(fp)
         * change outside of this task.  If this task does not hold the mutex then
         * pxMutexHolder can never coincidentally equal the tasks handle, and as
         * this is the only condition we are interested in it does not matter if
         * pxMutexHolder is accessed simultaneously by another task.  Therefore no
         * mutual exclusion is required to test the pxMutexHolder variable. */
        if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
 40016d4:	e0bffd17 	ldw	r2,-12(fp)
 40016d8:	14000217 	ldw	r16,8(r2)
 40016dc:	40059880 	call	4005988 <xTaskGetCurrentTaskHandle>
 40016e0:	8080101e 	bne	r16,r2,4001724 <xQueueGiveMutexRecursive+0x70>
            /* uxRecursiveCallCount cannot be zero if xMutexHolder is equal to
             * the task handle, therefore no underflow check is required.  Also,
             * uxRecursiveCallCount is only modified by the mutex holder, and as
             * there can only be one, no mutual exclusion is required to modify the
             * uxRecursiveCallCount member. */
            ( pxMutex->u.xSemaphore.uxRecursiveCallCount )--;
 40016e4:	e0bffd17 	ldw	r2,-12(fp)
 40016e8:	10800317 	ldw	r2,12(r2)
 40016ec:	10ffffc4 	addi	r3,r2,-1
 40016f0:	e0bffd17 	ldw	r2,-12(fp)
 40016f4:	10c00315 	stw	r3,12(r2)

            /* Has the recursive call count unwound to 0? */
            if( pxMutex->u.xSemaphore.uxRecursiveCallCount == ( UBaseType_t ) 0 )
 40016f8:	e0bffd17 	ldw	r2,-12(fp)
 40016fc:	10800317 	ldw	r2,12(r2)
 4001700:	1000051e 	bne	r2,zero,4001718 <xQueueGiveMutexRecursive+0x64>
            {
                /* Return the mutex.  This will automatically unblock any other
                 * task that might be waiting to access the mutex. */
                ( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
 4001704:	000f883a 	mov	r7,zero
 4001708:	000d883a 	mov	r6,zero
 400170c:	000b883a 	mov	r5,zero
 4001710:	e13ffd17 	ldw	r4,-12(fp)
 4001714:	40018500 	call	4001850 <xQueueGenericSend>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            xReturn = pdPASS;
 4001718:	00800044 	movi	r2,1
 400171c:	e0bffe15 	stw	r2,-8(fp)
 4001720:	00000106 	br	4001728 <xQueueGiveMutexRecursive+0x74>
        }
        else
        {
            /* The mutex cannot be given because the calling task is not the
             * holder. */
            xReturn = pdFAIL;
 4001724:	e03ffe15 	stw	zero,-8(fp)

            traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
        }

        return xReturn;
 4001728:	e0bffe17 	ldw	r2,-8(fp)
    }
 400172c:	e6ffff04 	addi	sp,fp,-4
 4001730:	dfc00217 	ldw	ra,8(sp)
 4001734:	df000117 	ldw	fp,4(sp)
 4001738:	dc000017 	ldw	r16,0(sp)
 400173c:	dec00304 	addi	sp,sp,12
 4001740:	f800283a 	ret

04001744 <xQueueTakeMutexRecursive>:

#if ( configUSE_RECURSIVE_MUTEXES == 1 )

    BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex,
                                         TickType_t xTicksToWait )
    {
 4001744:	defff904 	addi	sp,sp,-28
 4001748:	dfc00615 	stw	ra,24(sp)
 400174c:	df000515 	stw	fp,20(sp)
 4001750:	dc000415 	stw	r16,16(sp)
 4001754:	df000504 	addi	fp,sp,20
 4001758:	e13ffc15 	stw	r4,-16(fp)
 400175c:	e17ffb15 	stw	r5,-20(fp)
        BaseType_t xReturn;
        Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 4001760:	e0bffc17 	ldw	r2,-16(fp)
 4001764:	e0bffd15 	stw	r2,-12(fp)
        /* Comments regarding mutual exclusion as per those within
         * xQueueGiveMutexRecursive(). */

        traceTAKE_MUTEX_RECURSIVE( pxMutex );

        if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
 4001768:	e0bffd17 	ldw	r2,-12(fp)
 400176c:	14000217 	ldw	r16,8(r2)
 4001770:	40059880 	call	4005988 <xTaskGetCurrentTaskHandle>
 4001774:	8080081e 	bne	r16,r2,4001798 <xQueueTakeMutexRecursive+0x54>
        {
            ( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
 4001778:	e0bffd17 	ldw	r2,-12(fp)
 400177c:	10800317 	ldw	r2,12(r2)
 4001780:	10c00044 	addi	r3,r2,1
 4001784:	e0bffd17 	ldw	r2,-12(fp)
 4001788:	10c00315 	stw	r3,12(r2)
            xReturn = pdPASS;
 400178c:	00800044 	movi	r2,1
 4001790:	e0bffe15 	stw	r2,-8(fp)
 4001794:	00000b06 	br	40017c4 <xQueueTakeMutexRecursive+0x80>
        }
        else
        {
            xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );
 4001798:	e17ffb17 	ldw	r5,-20(fp)
 400179c:	e13ffd17 	ldw	r4,-12(fp)
 40017a0:	4001da40 	call	4001da4 <xQueueSemaphoreTake>
 40017a4:	e0bffe15 	stw	r2,-8(fp)

            /* pdPASS will only be returned if the mutex was successfully
             * obtained.  The calling task may have entered the Blocked state
             * before reaching here. */
            if( xReturn != pdFAIL )
 40017a8:	e0bffe17 	ldw	r2,-8(fp)
 40017ac:	10000526 	beq	r2,zero,40017c4 <xQueueTakeMutexRecursive+0x80>
            {
                ( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
 40017b0:	e0bffd17 	ldw	r2,-12(fp)
 40017b4:	10800317 	ldw	r2,12(r2)
 40017b8:	10c00044 	addi	r3,r2,1
 40017bc:	e0bffd17 	ldw	r2,-12(fp)
 40017c0:	10c00315 	stw	r3,12(r2)
            {
                traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
            }
        }

        return xReturn;
 40017c4:	e0bffe17 	ldw	r2,-8(fp)
    }
 40017c8:	e6ffff04 	addi	sp,fp,-4
 40017cc:	dfc00217 	ldw	ra,8(sp)
 40017d0:	df000117 	ldw	fp,4(sp)
 40017d4:	dc000017 	ldw	r16,0(sp)
 40017d8:	dec00304 	addi	sp,sp,12
 40017dc:	f800283a 	ret

040017e0 <xQueueCreateCountingSemaphore>:

#if ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

    QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount,
                                                 const UBaseType_t uxInitialCount )
    {
 40017e0:	defffb04 	addi	sp,sp,-20
 40017e4:	dfc00415 	stw	ra,16(sp)
 40017e8:	df000315 	stw	fp,12(sp)
 40017ec:	df000304 	addi	fp,sp,12
 40017f0:	e13ffe15 	stw	r4,-8(fp)
 40017f4:	e17ffd15 	stw	r5,-12(fp)
        QueueHandle_t xHandle = NULL;
 40017f8:	e03fff15 	stw	zero,-4(fp)

        if( ( uxMaxCount != 0 ) &&
 40017fc:	e0bffe17 	ldw	r2,-8(fp)
 4001800:	10000d26 	beq	r2,zero,4001838 <xQueueCreateCountingSemaphore+0x58>
 4001804:	e0bffd17 	ldw	r2,-12(fp)
 4001808:	e0fffe17 	ldw	r3,-8(fp)
 400180c:	18800a36 	bltu	r3,r2,4001838 <xQueueCreateCountingSemaphore+0x58>
            ( uxInitialCount <= uxMaxCount ) )
        {
            xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
 4001810:	01800084 	movi	r6,2
 4001814:	000b883a 	mov	r5,zero
 4001818:	e13ffe17 	ldw	r4,-8(fp)
 400181c:	40013d00 	call	40013d0 <xQueueGenericCreate>
 4001820:	e0bfff15 	stw	r2,-4(fp)

            if( xHandle != NULL )
 4001824:	e0bfff17 	ldw	r2,-4(fp)
 4001828:	10000326 	beq	r2,zero,4001838 <xQueueCreateCountingSemaphore+0x58>
            {
                ( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 400182c:	e0bfff17 	ldw	r2,-4(fp)
 4001830:	e0fffd17 	ldw	r3,-12(fp)
 4001834:	10c00e15 	stw	r3,56(r2)
        {
            configASSERT( xHandle );
            mtCOVERAGE_TEST_MARKER();
        }

        return xHandle;
 4001838:	e0bfff17 	ldw	r2,-4(fp)
    }
 400183c:	e037883a 	mov	sp,fp
 4001840:	dfc00117 	ldw	ra,4(sp)
 4001844:	df000017 	ldw	fp,0(sp)
 4001848:	dec00204 	addi	sp,sp,8
 400184c:	f800283a 	ret

04001850 <xQueueGenericSend>:

BaseType_t xQueueGenericSend( QueueHandle_t xQueue,
                              const void * const pvItemToQueue,
                              TickType_t xTicksToWait,
                              const BaseType_t xCopyPosition )
{
 4001850:	defff504 	addi	sp,sp,-44
 4001854:	dfc00a15 	stw	ra,40(sp)
 4001858:	df000915 	stw	fp,36(sp)
 400185c:	df000904 	addi	fp,sp,36
 4001860:	e13ffa15 	stw	r4,-24(fp)
 4001864:	e17ff915 	stw	r5,-28(fp)
 4001868:	e1bff815 	stw	r6,-32(fp)
 400186c:	e1fff715 	stw	r7,-36(fp)
    BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 4001870:	e03fff15 	stw	zero,-4(fp)
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
 4001874:	e0bffa17 	ldw	r2,-24(fp)
 4001878:	e0bffe15 	stw	r2,-8(fp)
    /*lint -save -e904 This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
 400187c:	4005f740 	call	4005f74 <vTaskEnterCritical>
        {
            /* Is there room on the queue now?  The running task must be the
             * highest priority task wanting to access the queue.  If the head item
             * in the queue is to be overwritten then it does not matter if the
             * queue is full. */
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 4001880:	e0bffe17 	ldw	r2,-8(fp)
 4001884:	10c00e17 	ldw	r3,56(r2)
 4001888:	e0bffe17 	ldw	r2,-8(fp)
 400188c:	10800f17 	ldw	r2,60(r2)
 4001890:	18800336 	bltu	r3,r2,40018a0 <xQueueGenericSend+0x50>
 4001894:	e0bff717 	ldw	r2,-36(fp)
 4001898:	10800098 	cmpnei	r2,r2,2
 400189c:	1000151e 	bne	r2,zero,40018f4 <xQueueGenericSend+0xa4>
                        }
                    }
                }
                #else /* configUSE_QUEUE_SETS */
                {
                    xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 40018a0:	e1bff717 	ldw	r6,-36(fp)
 40018a4:	e17ff917 	ldw	r5,-28(fp)
 40018a8:	e13ffe17 	ldw	r4,-8(fp)
 40018ac:	40024300 	call	4002430 <prvCopyDataToQueue>
 40018b0:	e0bffd15 	stw	r2,-12(fp)

                    /* If there was a task waiting for data to arrive on the
                     * queue then unblock it now. */
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 40018b4:	e0bffe17 	ldw	r2,-8(fp)
 40018b8:	10800917 	ldw	r2,36(r2)
 40018bc:	10000726 	beq	r2,zero,40018dc <xQueueGenericSend+0x8c>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 40018c0:	e0bffe17 	ldw	r2,-8(fp)
 40018c4:	10800904 	addi	r2,r2,36
 40018c8:	1009883a 	mov	r4,r2
 40018cc:	40050240 	call	4005024 <xTaskRemoveFromEventList>
 40018d0:	10000526 	beq	r2,zero,40018e8 <xQueueGenericSend+0x98>
                        {
                            /* The unblocked task has a priority higher than
                             * our own so yield immediately.  Yes it is ok to do
                             * this from within the critical section - the kernel
                             * takes care of that. */
                            queueYIELD_IF_USING_PREEMPTION();
 40018d4:	003b683a 	trap	0
 40018d8:	00000306 	br	40018e8 <xQueueGenericSend+0x98>
                        else
                        {
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                    else if( xYieldRequired != pdFALSE )
 40018dc:	e0bffd17 	ldw	r2,-12(fp)
 40018e0:	10000126 	beq	r2,zero,40018e8 <xQueueGenericSend+0x98>
                    {
                        /* This path is a special case that will only get
                         * executed if the task was holding multiple mutexes and
                         * the mutexes were given back in an order that is
                         * different to that in which they were taken. */
                        queueYIELD_IF_USING_PREEMPTION();
 40018e4:	003b683a 	trap	0
                        mtCOVERAGE_TEST_MARKER();
                    }
                }
                #endif /* configUSE_QUEUE_SETS */

                taskEXIT_CRITICAL();
 40018e8:	4005fc80 	call	4005fc8 <vTaskExitCritical>
                return pdPASS;
 40018ec:	00800044 	movi	r2,1
 40018f0:	00003f06 	br	40019f0 <xQueueGenericSend+0x1a0>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
 40018f4:	e0bff817 	ldw	r2,-32(fp)
 40018f8:	1000031e 	bne	r2,zero,4001908 <xQueueGenericSend+0xb8>
                {
                    /* The queue was full and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
 40018fc:	4005fc80 	call	4005fc8 <vTaskExitCritical>

                    /* Return to the original privilege level before exiting
                     * the function. */
                    traceQUEUE_SEND_FAILED( pxQueue );
                    return errQUEUE_FULL;
 4001900:	0005883a 	mov	r2,zero
 4001904:	00003a06 	br	40019f0 <xQueueGenericSend+0x1a0>
                }
                else if( xEntryTimeSet == pdFALSE )
 4001908:	e0bfff17 	ldw	r2,-4(fp)
 400190c:	1000051e 	bne	r2,zero,4001924 <xQueueGenericSend+0xd4>
                {
                    /* The queue was full and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
 4001910:	e0bffb04 	addi	r2,fp,-20
 4001914:	1009883a 	mov	r4,r2
 4001918:	40055900 	call	4005590 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
 400191c:	00800044 	movi	r2,1
 4001920:	e0bfff15 	stw	r2,-4(fp)
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
 4001924:	4005fc80 	call	4005fc8 <vTaskExitCritical>

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
 4001928:	40046e80 	call	40046e8 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
 400192c:	4005f740 	call	4005f74 <vTaskEnterCritical>
 4001930:	e0bffe17 	ldw	r2,-8(fp)
 4001934:	10801103 	ldbu	r2,68(r2)
 4001938:	10803fcc 	andi	r2,r2,255
 400193c:	1080201c 	xori	r2,r2,128
 4001940:	10bfe004 	addi	r2,r2,-128
 4001944:	10bfffd8 	cmpnei	r2,r2,-1
 4001948:	1000021e 	bne	r2,zero,4001954 <xQueueGenericSend+0x104>
 400194c:	e0bffe17 	ldw	r2,-8(fp)
 4001950:	10001105 	stb	zero,68(r2)
 4001954:	e0bffe17 	ldw	r2,-8(fp)
 4001958:	10801143 	ldbu	r2,69(r2)
 400195c:	10803fcc 	andi	r2,r2,255
 4001960:	1080201c 	xori	r2,r2,128
 4001964:	10bfe004 	addi	r2,r2,-128
 4001968:	10bfffd8 	cmpnei	r2,r2,-1
 400196c:	1000021e 	bne	r2,zero,4001978 <xQueueGenericSend+0x128>
 4001970:	e0bffe17 	ldw	r2,-8(fp)
 4001974:	10001145 	stb	zero,69(r2)
 4001978:	4005fc80 	call	4005fc8 <vTaskExitCritical>

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 400197c:	e0fff804 	addi	r3,fp,-32
 4001980:	e0bffb04 	addi	r2,fp,-20
 4001984:	180b883a 	mov	r5,r3
 4001988:	1009883a 	mov	r4,r2
 400198c:	40055cc0 	call	40055cc <xTaskCheckForTimeOut>
 4001990:	1000131e 	bne	r2,zero,40019e0 <xQueueGenericSend+0x190>
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
 4001994:	e13ffe17 	ldw	r4,-8(fp)
 4001998:	40027e40 	call	40027e4 <prvIsQueueFull>
 400199c:	10000c26 	beq	r2,zero,40019d0 <xQueueGenericSend+0x180>
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 40019a0:	e0bffe17 	ldw	r2,-8(fp)
 40019a4:	10800404 	addi	r2,r2,16
 40019a8:	e0fff817 	ldw	r3,-32(fp)
 40019ac:	180b883a 	mov	r5,r3
 40019b0:	1009883a 	mov	r4,r2
 40019b4:	4004f180 	call	4004f18 <vTaskPlaceOnEventList>
                /* Unlocking the queue means queue events can effect the
                 * event list. It is possible that interrupts occurring now
                 * remove this task from the event list again - but as the
                 * scheduler is suspended the task will go onto the pending
                 * ready list instead of the actual ready list. */
                prvUnlockQueue( pxQueue );
 40019b8:	e13ffe17 	ldw	r4,-8(fp)
 40019bc:	40026580 	call	4002658 <prvUnlockQueue>
                /* Resuming the scheduler will move tasks from the pending
                 * ready list into the ready list - so it is feasible that this
                 * task is already in the ready list before it yields - in which
                 * case the yield will not cause a context switch unless there
                 * is also a higher priority task in the pending ready list. */
                if( xTaskResumeAll() == pdFALSE )
 40019c0:	40047140 	call	4004714 <xTaskResumeAll>
 40019c4:	103fad1e 	bne	r2,zero,400187c <xQueueGenericSend+0x2c>
                {
                    portYIELD_WITHIN_API();
 40019c8:	003b683a 	trap	0
 40019cc:	003fab06 	br	400187c <xQueueGenericSend+0x2c>
                }
            }
            else
            {
                /* Try again. */
                prvUnlockQueue( pxQueue );
 40019d0:	e13ffe17 	ldw	r4,-8(fp)
 40019d4:	40026580 	call	4002658 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
 40019d8:	40047140 	call	4004714 <xTaskResumeAll>
 40019dc:	003fa706 	br	400187c <xQueueGenericSend+0x2c>
            }
        }
        else
        {
            /* The timeout has expired. */
            prvUnlockQueue( pxQueue );
 40019e0:	e13ffe17 	ldw	r4,-8(fp)
 40019e4:	40026580 	call	4002658 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
 40019e8:	40047140 	call	4004714 <xTaskResumeAll>

            traceQUEUE_SEND_FAILED( pxQueue );
            return errQUEUE_FULL;
 40019ec:	0005883a 	mov	r2,zero
        }
    } /*lint -restore */
}
 40019f0:	e037883a 	mov	sp,fp
 40019f4:	dfc00117 	ldw	ra,4(sp)
 40019f8:	df000017 	ldw	fp,0(sp)
 40019fc:	dec00204 	addi	sp,sp,8
 4001a00:	f800283a 	ret

04001a04 <xQueueGenericSendFromISR>:

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue,
                                     const void * const pvItemToQueue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const BaseType_t xCopyPosition )
{
 4001a04:	defff404 	addi	sp,sp,-48
 4001a08:	dfc00b15 	stw	ra,44(sp)
 4001a0c:	df000a15 	stw	fp,40(sp)
 4001a10:	df000a04 	addi	fp,sp,40
 4001a14:	e13ff915 	stw	r4,-28(fp)
 4001a18:	e17ff815 	stw	r5,-32(fp)
 4001a1c:	e1bff715 	stw	r6,-36(fp)
 4001a20:	e1fff615 	stw	r7,-40(fp)
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
 4001a24:	e0bff917 	ldw	r2,-28(fp)
 4001a28:	e0bffe15 	stw	r2,-8(fp)
    /* Similar to xQueueGenericSend, except without blocking if there is no room
     * in the queue.  Also don't directly wake a task that was blocked on a queue
     * read, instead return a flag to say whether a context switch is required or
     * not (i.e. has a task with a higher priority than us been woken by this
     * post). */
    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 4001a2c:	e03ffd15 	stw	zero,-12(fp)
    {
        if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 4001a30:	e0bffe17 	ldw	r2,-8(fp)
 4001a34:	10c00e17 	ldw	r3,56(r2)
 4001a38:	e0bffe17 	ldw	r2,-8(fp)
 4001a3c:	10800f17 	ldw	r2,60(r2)
 4001a40:	18800336 	bltu	r3,r2,4001a50 <xQueueGenericSendFromISR+0x4c>
 4001a44:	e0bff617 	ldw	r2,-40(fp)
 4001a48:	10800098 	cmpnei	r2,r2,2
 4001a4c:	1000281e 	bne	r2,zero,4001af0 <xQueueGenericSendFromISR+0xec>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
 4001a50:	e0bffe17 	ldw	r2,-8(fp)
 4001a54:	10801143 	ldbu	r2,69(r2)
 4001a58:	e0bffcc5 	stb	r2,-13(fp)
            const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
 4001a5c:	e0bffe17 	ldw	r2,-8(fp)
 4001a60:	10800e17 	ldw	r2,56(r2)
 4001a64:	e0bffb15 	stw	r2,-20(fp)
            /* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
             *  semaphore or mutex.  That means prvCopyDataToQueue() cannot result
             *  in a task disinheriting a priority and prvCopyDataToQueue() can be
             *  called here even though the disinherit function does not check if
             *  the scheduler is suspended before accessing the ready lists. */
            ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 4001a68:	e1bff617 	ldw	r6,-40(fp)
 4001a6c:	e17ff817 	ldw	r5,-32(fp)
 4001a70:	e13ffe17 	ldw	r4,-8(fp)
 4001a74:	40024300 	call	4002430 <prvCopyDataToQueue>

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
 4001a78:	e0bffcc7 	ldb	r2,-13(fp)
 4001a7c:	10bfffd8 	cmpnei	r2,r2,-1
 4001a80:	10000e1e 	bne	r2,zero,4001abc <xQueueGenericSendFromISR+0xb8>
                        }
                    }
                }
                #else /* configUSE_QUEUE_SETS */
                {
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 4001a84:	e0bffe17 	ldw	r2,-8(fp)
 4001a88:	10800917 	ldw	r2,36(r2)
 4001a8c:	10001526 	beq	r2,zero,4001ae4 <xQueueGenericSendFromISR+0xe0>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 4001a90:	e0bffe17 	ldw	r2,-8(fp)
 4001a94:	10800904 	addi	r2,r2,36
 4001a98:	1009883a 	mov	r4,r2
 4001a9c:	40050240 	call	4005024 <xTaskRemoveFromEventList>
 4001aa0:	10001026 	beq	r2,zero,4001ae4 <xQueueGenericSendFromISR+0xe0>
                        {
                            /* The task waiting has a higher priority so record that a
                             * context switch is required. */
                            if( pxHigherPriorityTaskWoken != NULL )
 4001aa4:	e0bff717 	ldw	r2,-36(fp)
 4001aa8:	10000e26 	beq	r2,zero,4001ae4 <xQueueGenericSendFromISR+0xe0>
                            {
                                *pxHigherPriorityTaskWoken = pdTRUE;
 4001aac:	e0bff717 	ldw	r2,-36(fp)
 4001ab0:	00c00044 	movi	r3,1
 4001ab4:	10c00015 	stw	r3,0(r2)
 4001ab8:	00000a06 	br	4001ae4 <xQueueGenericSendFromISR+0xe0>
            }
            else
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                prvIncrementQueueTxLock( pxQueue, cTxLock );
 4001abc:	4004a3c0 	call	4004a3c <uxTaskGetNumberOfTasks>
 4001ac0:	e0bffa15 	stw	r2,-24(fp)
 4001ac4:	e0fffcc7 	ldb	r3,-13(fp)
 4001ac8:	e0bffa17 	ldw	r2,-24(fp)
 4001acc:	1880052e 	bgeu	r3,r2,4001ae4 <xQueueGenericSendFromISR+0xe0>
 4001ad0:	e0bffcc3 	ldbu	r2,-13(fp)
 4001ad4:	10800044 	addi	r2,r2,1
 4001ad8:	1007883a 	mov	r3,r2
 4001adc:	e0bffe17 	ldw	r2,-8(fp)
 4001ae0:	10c01145 	stb	r3,69(r2)
            }

            xReturn = pdPASS;
 4001ae4:	00800044 	movi	r2,1
 4001ae8:	e0bfff15 	stw	r2,-4(fp)
        {
 4001aec:	00000106 	br	4001af4 <xQueueGenericSendFromISR+0xf0>
        }
        else
        {
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
            xReturn = errQUEUE_FULL;
 4001af0:	e03fff15 	stw	zero,-4(fp)
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
 4001af4:	e0bfff17 	ldw	r2,-4(fp)
}
 4001af8:	e037883a 	mov	sp,fp
 4001afc:	dfc00117 	ldw	ra,4(sp)
 4001b00:	df000017 	ldw	fp,0(sp)
 4001b04:	dec00204 	addi	sp,sp,8
 4001b08:	f800283a 	ret

04001b0c <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue,
                              BaseType_t * const pxHigherPriorityTaskWoken )
{
 4001b0c:	defff604 	addi	sp,sp,-40
 4001b10:	dfc00915 	stw	ra,36(sp)
 4001b14:	df000815 	stw	fp,32(sp)
 4001b18:	df000804 	addi	fp,sp,32
 4001b1c:	e13ff915 	stw	r4,-28(fp)
 4001b20:	e17ff815 	stw	r5,-32(fp)
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
 4001b24:	e0bff917 	ldw	r2,-28(fp)
 4001b28:	e0bffe15 	stw	r2,-8(fp)
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 4001b2c:	e03ffd15 	stw	zero,-12(fp)
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 4001b30:	e0bffe17 	ldw	r2,-8(fp)
 4001b34:	10800e17 	ldw	r2,56(r2)
 4001b38:	e0bffc15 	stw	r2,-16(fp)

        /* When the queue is used to implement a semaphore no data is ever
         * moved through the queue but it is still valid to see if the queue 'has
         * space'. */
        if( uxMessagesWaiting < pxQueue->uxLength )
 4001b3c:	e0bffe17 	ldw	r2,-8(fp)
 4001b40:	10800f17 	ldw	r2,60(r2)
 4001b44:	e0fffc17 	ldw	r3,-16(fp)
 4001b48:	1880252e 	bgeu	r3,r2,4001be0 <xQueueGiveFromISR+0xd4>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
 4001b4c:	e0bffe17 	ldw	r2,-8(fp)
 4001b50:	10801143 	ldbu	r2,69(r2)
 4001b54:	e0bffbc5 	stb	r2,-17(fp)
             * holder - and if there is a mutex holder then the mutex cannot be
             * given from an ISR.  As this is the ISR version of the function it
             * can be assumed there is no mutex holder and no need to determine if
             * priority disinheritance is needed.  Simply increase the count of
             * messages (semaphores) available. */
            pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 4001b58:	e0bffc17 	ldw	r2,-16(fp)
 4001b5c:	10c00044 	addi	r3,r2,1
 4001b60:	e0bffe17 	ldw	r2,-8(fp)
 4001b64:	10c00e15 	stw	r3,56(r2)

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
 4001b68:	e0bffbc7 	ldb	r2,-17(fp)
 4001b6c:	10bfffd8 	cmpnei	r2,r2,-1
 4001b70:	10000e1e 	bne	r2,zero,4001bac <xQueueGiveFromISR+0xa0>
                        }
                    }
                }
                #else /* configUSE_QUEUE_SETS */
                {
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 4001b74:	e0bffe17 	ldw	r2,-8(fp)
 4001b78:	10800917 	ldw	r2,36(r2)
 4001b7c:	10001526 	beq	r2,zero,4001bd4 <xQueueGiveFromISR+0xc8>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 4001b80:	e0bffe17 	ldw	r2,-8(fp)
 4001b84:	10800904 	addi	r2,r2,36
 4001b88:	1009883a 	mov	r4,r2
 4001b8c:	40050240 	call	4005024 <xTaskRemoveFromEventList>
 4001b90:	10001026 	beq	r2,zero,4001bd4 <xQueueGiveFromISR+0xc8>
                        {
                            /* The task waiting has a higher priority so record that a
                             * context switch is required. */
                            if( pxHigherPriorityTaskWoken != NULL )
 4001b94:	e0bff817 	ldw	r2,-32(fp)
 4001b98:	10000e26 	beq	r2,zero,4001bd4 <xQueueGiveFromISR+0xc8>
                            {
                                *pxHigherPriorityTaskWoken = pdTRUE;
 4001b9c:	e0bff817 	ldw	r2,-32(fp)
 4001ba0:	00c00044 	movi	r3,1
 4001ba4:	10c00015 	stw	r3,0(r2)
 4001ba8:	00000a06 	br	4001bd4 <xQueueGiveFromISR+0xc8>
            }
            else
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                prvIncrementQueueTxLock( pxQueue, cTxLock );
 4001bac:	4004a3c0 	call	4004a3c <uxTaskGetNumberOfTasks>
 4001bb0:	e0bffa15 	stw	r2,-24(fp)
 4001bb4:	e0fffbc7 	ldb	r3,-17(fp)
 4001bb8:	e0bffa17 	ldw	r2,-24(fp)
 4001bbc:	1880052e 	bgeu	r3,r2,4001bd4 <xQueueGiveFromISR+0xc8>
 4001bc0:	e0bffbc3 	ldbu	r2,-17(fp)
 4001bc4:	10800044 	addi	r2,r2,1
 4001bc8:	1007883a 	mov	r3,r2
 4001bcc:	e0bffe17 	ldw	r2,-8(fp)
 4001bd0:	10c01145 	stb	r3,69(r2)
            }

            xReturn = pdPASS;
 4001bd4:	00800044 	movi	r2,1
 4001bd8:	e0bfff15 	stw	r2,-4(fp)
 4001bdc:	00000106 	br	4001be4 <xQueueGiveFromISR+0xd8>
        }
        else
        {
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
            xReturn = errQUEUE_FULL;
 4001be0:	e03fff15 	stw	zero,-4(fp)
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
 4001be4:	e0bfff17 	ldw	r2,-4(fp)
}
 4001be8:	e037883a 	mov	sp,fp
 4001bec:	dfc00117 	ldw	ra,4(sp)
 4001bf0:	df000017 	ldw	fp,0(sp)
 4001bf4:	dec00204 	addi	sp,sp,8
 4001bf8:	f800283a 	ret

04001bfc <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue,
                          void * const pvBuffer,
                          TickType_t xTicksToWait )
{
 4001bfc:	defff604 	addi	sp,sp,-40
 4001c00:	dfc00915 	stw	ra,36(sp)
 4001c04:	df000815 	stw	fp,32(sp)
 4001c08:	df000804 	addi	fp,sp,32
 4001c0c:	e13ffa15 	stw	r4,-24(fp)
 4001c10:	e17ff915 	stw	r5,-28(fp)
 4001c14:	e1bff815 	stw	r6,-32(fp)
    BaseType_t xEntryTimeSet = pdFALSE;
 4001c18:	e03fff15 	stw	zero,-4(fp)
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
 4001c1c:	e0bffa17 	ldw	r2,-24(fp)
 4001c20:	e0bffe15 	stw	r2,-8(fp)
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
 4001c24:	4005f740 	call	4005f74 <vTaskEnterCritical>
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 4001c28:	e0bffe17 	ldw	r2,-8(fp)
 4001c2c:	10800e17 	ldw	r2,56(r2)
 4001c30:	e0bffd15 	stw	r2,-12(fp)

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 4001c34:	e0bffd17 	ldw	r2,-12(fp)
 4001c38:	10001326 	beq	r2,zero,4001c88 <xQueueReceive+0x8c>
            {
                /* Data available, remove one item. */
                prvCopyDataFromQueue( pxQueue, pvBuffer );
 4001c3c:	e17ff917 	ldw	r5,-28(fp)
 4001c40:	e13ffe17 	ldw	r4,-8(fp)
 4001c44:	40025bc0 	call	40025bc <prvCopyDataFromQueue>
                traceQUEUE_RECEIVE( pxQueue );
                pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 4001c48:	e0bffd17 	ldw	r2,-12(fp)
 4001c4c:	10ffffc4 	addi	r3,r2,-1
 4001c50:	e0bffe17 	ldw	r2,-8(fp)
 4001c54:	10c00e15 	stw	r3,56(r2)

                /* There is now space in the queue, were any tasks waiting to
                 * post to the queue?  If so, unblock the highest priority waiting
                 * task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 4001c58:	e0bffe17 	ldw	r2,-8(fp)
 4001c5c:	10800417 	ldw	r2,16(r2)
 4001c60:	10000626 	beq	r2,zero,4001c7c <xQueueReceive+0x80>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 4001c64:	e0bffe17 	ldw	r2,-8(fp)
 4001c68:	10800404 	addi	r2,r2,16
 4001c6c:	1009883a 	mov	r4,r2
 4001c70:	40050240 	call	4005024 <xTaskRemoveFromEventList>
 4001c74:	10000126 	beq	r2,zero,4001c7c <xQueueReceive+0x80>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
 4001c78:	003b683a 	trap	0
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
 4001c7c:	4005fc80 	call	4005fc8 <vTaskExitCritical>
                return pdPASS;
 4001c80:	00800044 	movi	r2,1
 4001c84:	00004206 	br	4001d90 <xQueueReceive+0x194>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
 4001c88:	e0bff817 	ldw	r2,-32(fp)
 4001c8c:	1000031e 	bne	r2,zero,4001c9c <xQueueReceive+0xa0>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
 4001c90:	4005fc80 	call	4005fc8 <vTaskExitCritical>
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
 4001c94:	0005883a 	mov	r2,zero
 4001c98:	00003d06 	br	4001d90 <xQueueReceive+0x194>
                }
                else if( xEntryTimeSet == pdFALSE )
 4001c9c:	e0bfff17 	ldw	r2,-4(fp)
 4001ca0:	1000051e 	bne	r2,zero,4001cb8 <xQueueReceive+0xbc>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
 4001ca4:	e0bffb04 	addi	r2,fp,-20
 4001ca8:	1009883a 	mov	r4,r2
 4001cac:	40055900 	call	4005590 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
 4001cb0:	00800044 	movi	r2,1
 4001cb4:	e0bfff15 	stw	r2,-4(fp)
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
 4001cb8:	4005fc80 	call	4005fc8 <vTaskExitCritical>

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
 4001cbc:	40046e80 	call	40046e8 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
 4001cc0:	4005f740 	call	4005f74 <vTaskEnterCritical>
 4001cc4:	e0bffe17 	ldw	r2,-8(fp)
 4001cc8:	10801103 	ldbu	r2,68(r2)
 4001ccc:	10803fcc 	andi	r2,r2,255
 4001cd0:	1080201c 	xori	r2,r2,128
 4001cd4:	10bfe004 	addi	r2,r2,-128
 4001cd8:	10bfffd8 	cmpnei	r2,r2,-1
 4001cdc:	1000021e 	bne	r2,zero,4001ce8 <xQueueReceive+0xec>
 4001ce0:	e0bffe17 	ldw	r2,-8(fp)
 4001ce4:	10001105 	stb	zero,68(r2)
 4001ce8:	e0bffe17 	ldw	r2,-8(fp)
 4001cec:	10801143 	ldbu	r2,69(r2)
 4001cf0:	10803fcc 	andi	r2,r2,255
 4001cf4:	1080201c 	xori	r2,r2,128
 4001cf8:	10bfe004 	addi	r2,r2,-128
 4001cfc:	10bfffd8 	cmpnei	r2,r2,-1
 4001d00:	1000021e 	bne	r2,zero,4001d0c <xQueueReceive+0x110>
 4001d04:	e0bffe17 	ldw	r2,-8(fp)
 4001d08:	10001145 	stb	zero,69(r2)
 4001d0c:	4005fc80 	call	4005fc8 <vTaskExitCritical>

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 4001d10:	e0fff804 	addi	r3,fp,-32
 4001d14:	e0bffb04 	addi	r2,fp,-20
 4001d18:	180b883a 	mov	r5,r3
 4001d1c:	1009883a 	mov	r4,r2
 4001d20:	40055cc0 	call	40055cc <xTaskCheckForTimeOut>
 4001d24:	1000131e 	bne	r2,zero,4001d74 <xQueueReceive+0x178>
        {
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 4001d28:	e13ffe17 	ldw	r4,-8(fp)
 4001d2c:	400274c0 	call	400274c <prvIsQueueEmpty>
 4001d30:	10000c26 	beq	r2,zero,4001d64 <xQueueReceive+0x168>
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 4001d34:	e0bffe17 	ldw	r2,-8(fp)
 4001d38:	10800904 	addi	r2,r2,36
 4001d3c:	e0fff817 	ldw	r3,-32(fp)
 4001d40:	180b883a 	mov	r5,r3
 4001d44:	1009883a 	mov	r4,r2
 4001d48:	4004f180 	call	4004f18 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
 4001d4c:	e13ffe17 	ldw	r4,-8(fp)
 4001d50:	40026580 	call	4002658 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
 4001d54:	40047140 	call	4004714 <xTaskResumeAll>
 4001d58:	103fb21e 	bne	r2,zero,4001c24 <xQueueReceive+0x28>
                {
                    portYIELD_WITHIN_API();
 4001d5c:	003b683a 	trap	0
 4001d60:	003fb006 	br	4001c24 <xQueueReceive+0x28>
            }
            else
            {
                /* The queue contains data again.  Loop back to try and read the
                 * data. */
                prvUnlockQueue( pxQueue );
 4001d64:	e13ffe17 	ldw	r4,-8(fp)
 4001d68:	40026580 	call	4002658 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
 4001d6c:	40047140 	call	4004714 <xTaskResumeAll>
 4001d70:	003fac06 	br	4001c24 <xQueueReceive+0x28>
        }
        else
        {
            /* Timed out.  If there is no data in the queue exit, otherwise loop
             * back and attempt to read the data. */
            prvUnlockQueue( pxQueue );
 4001d74:	e13ffe17 	ldw	r4,-8(fp)
 4001d78:	40026580 	call	4002658 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
 4001d7c:	40047140 	call	4004714 <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 4001d80:	e13ffe17 	ldw	r4,-8(fp)
 4001d84:	400274c0 	call	400274c <prvIsQueueEmpty>
 4001d88:	103fa626 	beq	r2,zero,4001c24 <xQueueReceive+0x28>
            {
                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
 4001d8c:	0005883a 	mov	r2,zero
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
}
 4001d90:	e037883a 	mov	sp,fp
 4001d94:	dfc00117 	ldw	ra,4(sp)
 4001d98:	df000017 	ldw	fp,0(sp)
 4001d9c:	dec00204 	addi	sp,sp,8
 4001da0:	f800283a 	ret

04001da4 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue,
                                TickType_t xTicksToWait )
{
 4001da4:	defff504 	addi	sp,sp,-44
 4001da8:	dfc00a15 	stw	ra,40(sp)
 4001dac:	df000915 	stw	fp,36(sp)
 4001db0:	df000904 	addi	fp,sp,36
 4001db4:	e13ff815 	stw	r4,-32(fp)
 4001db8:	e17ff715 	stw	r5,-36(fp)
    BaseType_t xEntryTimeSet = pdFALSE;
 4001dbc:	e03fff15 	stw	zero,-4(fp)
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
 4001dc0:	e0bff817 	ldw	r2,-32(fp)
 4001dc4:	e0bffd15 	stw	r2,-12(fp)

    #if ( configUSE_MUTEXES == 1 )
        BaseType_t xInheritanceOccurred = pdFALSE;
 4001dc8:	e03ffe15 	stw	zero,-8(fp)
    /*lint -save -e904 This function relaxes the coding standard somewhat to allow return
     * statements within the function itself.  This is done in the interest
     * of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
 4001dcc:	4005f740 	call	4005f74 <vTaskEnterCritical>
        {
            /* Semaphores are queues with an item size of 0, and where the
             * number of messages in the queue is the semaphore's count value. */
            const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
 4001dd0:	e0bffd17 	ldw	r2,-12(fp)
 4001dd4:	10800e17 	ldw	r2,56(r2)
 4001dd8:	e0bffc15 	stw	r2,-16(fp)

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxSemaphoreCount > ( UBaseType_t ) 0 )
 4001ddc:	e0bffc17 	ldw	r2,-16(fp)
 4001de0:	10001726 	beq	r2,zero,4001e40 <xQueueSemaphoreTake+0x9c>
            {
                traceQUEUE_RECEIVE( pxQueue );

                /* Semaphores are queues with a data size of zero and where the
                 * messages waiting is the semaphore's count.  Reduce the count. */
                pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
 4001de4:	e0bffc17 	ldw	r2,-16(fp)
 4001de8:	10ffffc4 	addi	r3,r2,-1
 4001dec:	e0bffd17 	ldw	r2,-12(fp)
 4001df0:	10c00e15 	stw	r3,56(r2)

                #if ( configUSE_MUTEXES == 1 )
                {
                    if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 4001df4:	e0bffd17 	ldw	r2,-12(fp)
 4001df8:	10800017 	ldw	r2,0(r2)
 4001dfc:	1000041e 	bne	r2,zero,4001e10 <xQueueSemaphoreTake+0x6c>
                    {
                        /* Record the information required to implement
                         * priority inheritance should it become necessary. */
                        pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
 4001e00:	40060700 	call	4006070 <pvTaskIncrementMutexHeldCount>
 4001e04:	1007883a 	mov	r3,r2
 4001e08:	e0bffd17 	ldw	r2,-12(fp)
 4001e0c:	10c00215 	stw	r3,8(r2)
                }
                #endif /* configUSE_MUTEXES */

                /* Check to see if other tasks are blocked waiting to give the
                 * semaphore, and if so, unblock the highest priority such task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 4001e10:	e0bffd17 	ldw	r2,-12(fp)
 4001e14:	10800417 	ldw	r2,16(r2)
 4001e18:	10000626 	beq	r2,zero,4001e34 <xQueueSemaphoreTake+0x90>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 4001e1c:	e0bffd17 	ldw	r2,-12(fp)
 4001e20:	10800404 	addi	r2,r2,16
 4001e24:	1009883a 	mov	r4,r2
 4001e28:	40050240 	call	4005024 <xTaskRemoveFromEventList>
 4001e2c:	10000126 	beq	r2,zero,4001e34 <xQueueSemaphoreTake+0x90>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
 4001e30:	003b683a 	trap	0
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
 4001e34:	4005fc80 	call	4005fc8 <vTaskExitCritical>
                return pdPASS;
 4001e38:	00800044 	movi	r2,1
 4001e3c:	00005806 	br	4001fa0 <xQueueSemaphoreTake+0x1fc>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
 4001e40:	e0bff717 	ldw	r2,-36(fp)
 4001e44:	1000031e 	bne	r2,zero,4001e54 <xQueueSemaphoreTake+0xb0>
                {
                    /* The semaphore count was 0 and no block time is specified
                     * (or the block time has expired) so exit now. */
                    taskEXIT_CRITICAL();
 4001e48:	4005fc80 	call	4005fc8 <vTaskExitCritical>
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
 4001e4c:	0005883a 	mov	r2,zero
 4001e50:	00005306 	br	4001fa0 <xQueueSemaphoreTake+0x1fc>
                }
                else if( xEntryTimeSet == pdFALSE )
 4001e54:	e0bfff17 	ldw	r2,-4(fp)
 4001e58:	1000051e 	bne	r2,zero,4001e70 <xQueueSemaphoreTake+0xcc>
                {
                    /* The semaphore count was 0 and a block time was specified
                     * so configure the timeout structure ready to block. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
 4001e5c:	e0bff904 	addi	r2,fp,-28
 4001e60:	1009883a 	mov	r4,r2
 4001e64:	40055900 	call	4005590 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
 4001e68:	00800044 	movi	r2,1
 4001e6c:	e0bfff15 	stw	r2,-4(fp)
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
 4001e70:	4005fc80 	call	4005fc8 <vTaskExitCritical>

        /* Interrupts and other tasks can give to and take from the semaphore
         * now the critical section has been exited. */

        vTaskSuspendAll();
 4001e74:	40046e80 	call	40046e8 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
 4001e78:	4005f740 	call	4005f74 <vTaskEnterCritical>
 4001e7c:	e0bffd17 	ldw	r2,-12(fp)
 4001e80:	10801103 	ldbu	r2,68(r2)
 4001e84:	10803fcc 	andi	r2,r2,255
 4001e88:	1080201c 	xori	r2,r2,128
 4001e8c:	10bfe004 	addi	r2,r2,-128
 4001e90:	10bfffd8 	cmpnei	r2,r2,-1
 4001e94:	1000021e 	bne	r2,zero,4001ea0 <xQueueSemaphoreTake+0xfc>
 4001e98:	e0bffd17 	ldw	r2,-12(fp)
 4001e9c:	10001105 	stb	zero,68(r2)
 4001ea0:	e0bffd17 	ldw	r2,-12(fp)
 4001ea4:	10801143 	ldbu	r2,69(r2)
 4001ea8:	10803fcc 	andi	r2,r2,255
 4001eac:	1080201c 	xori	r2,r2,128
 4001eb0:	10bfe004 	addi	r2,r2,-128
 4001eb4:	10bfffd8 	cmpnei	r2,r2,-1
 4001eb8:	1000021e 	bne	r2,zero,4001ec4 <xQueueSemaphoreTake+0x120>
 4001ebc:	e0bffd17 	ldw	r2,-12(fp)
 4001ec0:	10001145 	stb	zero,69(r2)
 4001ec4:	4005fc80 	call	4005fc8 <vTaskExitCritical>

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 4001ec8:	e0fff704 	addi	r3,fp,-36
 4001ecc:	e0bff904 	addi	r2,fp,-28
 4001ed0:	180b883a 	mov	r5,r3
 4001ed4:	1009883a 	mov	r4,r2
 4001ed8:	40055cc0 	call	40055cc <xTaskCheckForTimeOut>
 4001edc:	10001d1e 	bne	r2,zero,4001f54 <xQueueSemaphoreTake+0x1b0>
        {
            /* A block time is specified and not expired.  If the semaphore
             * count is 0 then enter the Blocked state to wait for a semaphore to
             * become available.  As semaphores are implemented with queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 4001ee0:	e13ffd17 	ldw	r4,-12(fp)
 4001ee4:	400274c0 	call	400274c <prvIsQueueEmpty>
 4001ee8:	10001626 	beq	r2,zero,4001f44 <xQueueSemaphoreTake+0x1a0>
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

                #if ( configUSE_MUTEXES == 1 )
                {
                    if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 4001eec:	e0bffd17 	ldw	r2,-12(fp)
 4001ef0:	10800017 	ldw	r2,0(r2)
 4001ef4:	1000071e 	bne	r2,zero,4001f14 <xQueueSemaphoreTake+0x170>
                    {
                        taskENTER_CRITICAL();
 4001ef8:	4005f740 	call	4005f74 <vTaskEnterCritical>
                        {
                            xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
 4001efc:	e0bffd17 	ldw	r2,-12(fp)
 4001f00:	10800217 	ldw	r2,8(r2)
 4001f04:	1009883a 	mov	r4,r2
 4001f08:	40059b00 	call	40059b0 <xTaskPriorityInherit>
 4001f0c:	e0bffe15 	stw	r2,-8(fp)
                        }
                        taskEXIT_CRITICAL();
 4001f10:	4005fc80 	call	4005fc8 <vTaskExitCritical>
                        mtCOVERAGE_TEST_MARKER();
                    }
                }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 4001f14:	e0bffd17 	ldw	r2,-12(fp)
 4001f18:	10800904 	addi	r2,r2,36
 4001f1c:	e0fff717 	ldw	r3,-36(fp)
 4001f20:	180b883a 	mov	r5,r3
 4001f24:	1009883a 	mov	r4,r2
 4001f28:	4004f180 	call	4004f18 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
 4001f2c:	e13ffd17 	ldw	r4,-12(fp)
 4001f30:	40026580 	call	4002658 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
 4001f34:	40047140 	call	4004714 <xTaskResumeAll>
 4001f38:	103fa41e 	bne	r2,zero,4001dcc <xQueueSemaphoreTake+0x28>
                {
                    portYIELD_WITHIN_API();
 4001f3c:	003b683a 	trap	0
 4001f40:	003fa206 	br	4001dcc <xQueueSemaphoreTake+0x28>
            }
            else
            {
                /* There was no timeout and the semaphore count was not 0, so
                 * attempt to take the semaphore again. */
                prvUnlockQueue( pxQueue );
 4001f44:	e13ffd17 	ldw	r4,-12(fp)
 4001f48:	40026580 	call	4002658 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
 4001f4c:	40047140 	call	4004714 <xTaskResumeAll>
 4001f50:	003f9e06 	br	4001dcc <xQueueSemaphoreTake+0x28>
            }
        }
        else
        {
            /* Timed out. */
            prvUnlockQueue( pxQueue );
 4001f54:	e13ffd17 	ldw	r4,-12(fp)
 4001f58:	40026580 	call	4002658 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
 4001f5c:	40047140 	call	4004714 <xTaskResumeAll>

            /* If the semaphore count is 0 exit now as the timeout has
             * expired.  Otherwise return to attempt to take the semaphore that is
             * known to be available.  As semaphores are implemented by queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 4001f60:	e13ffd17 	ldw	r4,-12(fp)
 4001f64:	400274c0 	call	400274c <prvIsQueueEmpty>
 4001f68:	103f9826 	beq	r2,zero,4001dcc <xQueueSemaphoreTake+0x28>
                #if ( configUSE_MUTEXES == 1 )
                {
                    /* xInheritanceOccurred could only have be set if
                     * pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
                     * test the mutex type again to check it is actually a mutex. */
                    if( xInheritanceOccurred != pdFALSE )
 4001f6c:	e0bffe17 	ldw	r2,-8(fp)
 4001f70:	10000a26 	beq	r2,zero,4001f9c <xQueueSemaphoreTake+0x1f8>
                    {
                        taskENTER_CRITICAL();
 4001f74:	4005f740 	call	4005f74 <vTaskEnterCritical>
                            /* This task blocking on the mutex caused another
                             * task to inherit this task's priority.  Now this task
                             * has timed out the priority should be disinherited
                             * again, but only as low as the next highest priority
                             * task that is waiting for the same mutex. */
                            uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
 4001f78:	e13ffd17 	ldw	r4,-12(fp)
 4001f7c:	40023e00 	call	40023e0 <prvGetDisinheritPriorityAfterTimeout>
 4001f80:	e0bffb15 	stw	r2,-20(fp)
                            vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
 4001f84:	e0bffd17 	ldw	r2,-12(fp)
 4001f88:	10800217 	ldw	r2,8(r2)
 4001f8c:	e17ffb17 	ldw	r5,-20(fp)
 4001f90:	1009883a 	mov	r4,r2
 4001f94:	4005d700 	call	4005d70 <vTaskPriorityDisinheritAfterTimeout>
                        }
                        taskEXIT_CRITICAL();
 4001f98:	4005fc80 	call	4005fc8 <vTaskExitCritical>
                    }
                }
                #endif /* configUSE_MUTEXES */

                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
 4001f9c:	0005883a 	mov	r2,zero
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
}
 4001fa0:	e037883a 	mov	sp,fp
 4001fa4:	dfc00117 	ldw	ra,4(sp)
 4001fa8:	df000017 	ldw	fp,0(sp)
 4001fac:	dec00204 	addi	sp,sp,8
 4001fb0:	f800283a 	ret

04001fb4 <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue,
                       void * const pvBuffer,
                       TickType_t xTicksToWait )
{
 4001fb4:	defff504 	addi	sp,sp,-44
 4001fb8:	dfc00a15 	stw	ra,40(sp)
 4001fbc:	df000915 	stw	fp,36(sp)
 4001fc0:	df000904 	addi	fp,sp,36
 4001fc4:	e13ff915 	stw	r4,-28(fp)
 4001fc8:	e17ff815 	stw	r5,-32(fp)
 4001fcc:	e1bff715 	stw	r6,-36(fp)
    BaseType_t xEntryTimeSet = pdFALSE;
 4001fd0:	e03fff15 	stw	zero,-4(fp)
    TimeOut_t xTimeOut;
    int8_t * pcOriginalReadPosition;
    Queue_t * const pxQueue = xQueue;
 4001fd4:	e0bff917 	ldw	r2,-28(fp)
 4001fd8:	e0bffe15 	stw	r2,-8(fp)
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
 4001fdc:	4005f740 	call	4005f74 <vTaskEnterCritical>
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 4001fe0:	e0bffe17 	ldw	r2,-8(fp)
 4001fe4:	10800e17 	ldw	r2,56(r2)
 4001fe8:	e0bffd15 	stw	r2,-12(fp)

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 4001fec:	e0bffd17 	ldw	r2,-12(fp)
 4001ff0:	10001526 	beq	r2,zero,4002048 <xQueuePeek+0x94>
            {
                /* Remember the read position so it can be reset after the data
                 * is read from the queue as this function is only peeking the
                 * data, not removing it. */
                pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
 4001ff4:	e0bffe17 	ldw	r2,-8(fp)
 4001ff8:	10800317 	ldw	r2,12(r2)
 4001ffc:	e0bffc15 	stw	r2,-16(fp)

                prvCopyDataFromQueue( pxQueue, pvBuffer );
 4002000:	e17ff817 	ldw	r5,-32(fp)
 4002004:	e13ffe17 	ldw	r4,-8(fp)
 4002008:	40025bc0 	call	40025bc <prvCopyDataFromQueue>
                traceQUEUE_PEEK( pxQueue );

                /* The data is not being removed, so reset the read pointer. */
                pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
 400200c:	e0bffe17 	ldw	r2,-8(fp)
 4002010:	e0fffc17 	ldw	r3,-16(fp)
 4002014:	10c00315 	stw	r3,12(r2)

                /* The data is being left in the queue, so see if there are
                 * any other tasks waiting for the data. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 4002018:	e0bffe17 	ldw	r2,-8(fp)
 400201c:	10800917 	ldw	r2,36(r2)
 4002020:	10000626 	beq	r2,zero,400203c <xQueuePeek+0x88>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 4002024:	e0bffe17 	ldw	r2,-8(fp)
 4002028:	10800904 	addi	r2,r2,36
 400202c:	1009883a 	mov	r4,r2
 4002030:	40050240 	call	4005024 <xTaskRemoveFromEventList>
 4002034:	10000126 	beq	r2,zero,400203c <xQueuePeek+0x88>
                    {
                        /* The task waiting has a higher priority than this task. */
                        queueYIELD_IF_USING_PREEMPTION();
 4002038:	003b683a 	trap	0
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
 400203c:	4005fc80 	call	4005fc8 <vTaskExitCritical>
                return pdPASS;
 4002040:	00800044 	movi	r2,1
 4002044:	00004206 	br	4002150 <xQueuePeek+0x19c>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
 4002048:	e0bff717 	ldw	r2,-36(fp)
 400204c:	1000031e 	bne	r2,zero,400205c <xQueuePeek+0xa8>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
 4002050:	4005fc80 	call	4005fc8 <vTaskExitCritical>
                    traceQUEUE_PEEK_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
 4002054:	0005883a 	mov	r2,zero
 4002058:	00003d06 	br	4002150 <xQueuePeek+0x19c>
                }
                else if( xEntryTimeSet == pdFALSE )
 400205c:	e0bfff17 	ldw	r2,-4(fp)
 4002060:	1000051e 	bne	r2,zero,4002078 <xQueuePeek+0xc4>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure ready to enter the blocked
                     * state. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
 4002064:	e0bffa04 	addi	r2,fp,-24
 4002068:	1009883a 	mov	r4,r2
 400206c:	40055900 	call	4005590 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
 4002070:	00800044 	movi	r2,1
 4002074:	e0bfff15 	stw	r2,-4(fp)
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
 4002078:	4005fc80 	call	4005fc8 <vTaskExitCritical>

        /* Interrupts and other tasks can send to and receive from the queue
         * now that the critical section has been exited. */

        vTaskSuspendAll();
 400207c:	40046e80 	call	40046e8 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
 4002080:	4005f740 	call	4005f74 <vTaskEnterCritical>
 4002084:	e0bffe17 	ldw	r2,-8(fp)
 4002088:	10801103 	ldbu	r2,68(r2)
 400208c:	10803fcc 	andi	r2,r2,255
 4002090:	1080201c 	xori	r2,r2,128
 4002094:	10bfe004 	addi	r2,r2,-128
 4002098:	10bfffd8 	cmpnei	r2,r2,-1
 400209c:	1000021e 	bne	r2,zero,40020a8 <xQueuePeek+0xf4>
 40020a0:	e0bffe17 	ldw	r2,-8(fp)
 40020a4:	10001105 	stb	zero,68(r2)
 40020a8:	e0bffe17 	ldw	r2,-8(fp)
 40020ac:	10801143 	ldbu	r2,69(r2)
 40020b0:	10803fcc 	andi	r2,r2,255
 40020b4:	1080201c 	xori	r2,r2,128
 40020b8:	10bfe004 	addi	r2,r2,-128
 40020bc:	10bfffd8 	cmpnei	r2,r2,-1
 40020c0:	1000021e 	bne	r2,zero,40020cc <xQueuePeek+0x118>
 40020c4:	e0bffe17 	ldw	r2,-8(fp)
 40020c8:	10001145 	stb	zero,69(r2)
 40020cc:	4005fc80 	call	4005fc8 <vTaskExitCritical>

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 40020d0:	e0fff704 	addi	r3,fp,-36
 40020d4:	e0bffa04 	addi	r2,fp,-24
 40020d8:	180b883a 	mov	r5,r3
 40020dc:	1009883a 	mov	r4,r2
 40020e0:	40055cc0 	call	40055cc <xTaskCheckForTimeOut>
 40020e4:	1000131e 	bne	r2,zero,4002134 <xQueuePeek+0x180>
        {
            /* Timeout has not expired yet, check to see if there is data in the
            * queue now, and if not enter the Blocked state to wait for data. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 40020e8:	e13ffe17 	ldw	r4,-8(fp)
 40020ec:	400274c0 	call	400274c <prvIsQueueEmpty>
 40020f0:	10000c26 	beq	r2,zero,4002124 <xQueuePeek+0x170>
            {
                traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 40020f4:	e0bffe17 	ldw	r2,-8(fp)
 40020f8:	10800904 	addi	r2,r2,36
 40020fc:	e0fff717 	ldw	r3,-36(fp)
 4002100:	180b883a 	mov	r5,r3
 4002104:	1009883a 	mov	r4,r2
 4002108:	4004f180 	call	4004f18 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
 400210c:	e13ffe17 	ldw	r4,-8(fp)
 4002110:	40026580 	call	4002658 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
 4002114:	40047140 	call	4004714 <xTaskResumeAll>
 4002118:	103fb01e 	bne	r2,zero,4001fdc <xQueuePeek+0x28>
                {
                    portYIELD_WITHIN_API();
 400211c:	003b683a 	trap	0
 4002120:	003fae06 	br	4001fdc <xQueuePeek+0x28>
            }
            else
            {
                /* There is data in the queue now, so don't enter the blocked
                 * state, instead return to try and obtain the data. */
                prvUnlockQueue( pxQueue );
 4002124:	e13ffe17 	ldw	r4,-8(fp)
 4002128:	40026580 	call	4002658 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
 400212c:	40047140 	call	4004714 <xTaskResumeAll>
 4002130:	003faa06 	br	4001fdc <xQueuePeek+0x28>
        }
        else
        {
            /* The timeout has expired.  If there is still no data in the queue
             * exit, otherwise go back and try to read the data again. */
            prvUnlockQueue( pxQueue );
 4002134:	e13ffe17 	ldw	r4,-8(fp)
 4002138:	40026580 	call	4002658 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
 400213c:	40047140 	call	4004714 <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 4002140:	e13ffe17 	ldw	r4,-8(fp)
 4002144:	400274c0 	call	400274c <prvIsQueueEmpty>
 4002148:	103fa426 	beq	r2,zero,4001fdc <xQueuePeek+0x28>
            {
                traceQUEUE_PEEK_FAILED( pxQueue );
                return errQUEUE_EMPTY;
 400214c:	0005883a 	mov	r2,zero
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
}
 4002150:	e037883a 	mov	sp,fp
 4002154:	dfc00117 	ldw	ra,4(sp)
 4002158:	df000017 	ldw	fp,0(sp)
 400215c:	dec00204 	addi	sp,sp,8
 4002160:	f800283a 	ret

04002164 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue,
                                 void * const pvBuffer,
                                 BaseType_t * const pxHigherPriorityTaskWoken )
{
 4002164:	defff504 	addi	sp,sp,-44
 4002168:	dfc00a15 	stw	ra,40(sp)
 400216c:	df000915 	stw	fp,36(sp)
 4002170:	df000904 	addi	fp,sp,36
 4002174:	e13ff915 	stw	r4,-28(fp)
 4002178:	e17ff815 	stw	r5,-32(fp)
 400217c:	e1bff715 	stw	r6,-36(fp)
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
 4002180:	e0bff917 	ldw	r2,-28(fp)
 4002184:	e0bffe15 	stw	r2,-8(fp)
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 4002188:	e03ffd15 	stw	zero,-12(fp)
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 400218c:	e0bffe17 	ldw	r2,-8(fp)
 4002190:	10800e17 	ldw	r2,56(r2)
 4002194:	e0bffc15 	stw	r2,-16(fp)

        /* Cannot block in an ISR, so check there is data available. */
        if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 4002198:	e0bffc17 	ldw	r2,-16(fp)
 400219c:	10002826 	beq	r2,zero,4002240 <xQueueReceiveFromISR+0xdc>
        {
            const int8_t cRxLock = pxQueue->cRxLock;
 40021a0:	e0bffe17 	ldw	r2,-8(fp)
 40021a4:	10801103 	ldbu	r2,68(r2)
 40021a8:	e0bffbc5 	stb	r2,-17(fp)

            traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

            prvCopyDataFromQueue( pxQueue, pvBuffer );
 40021ac:	e17ff817 	ldw	r5,-32(fp)
 40021b0:	e13ffe17 	ldw	r4,-8(fp)
 40021b4:	40025bc0 	call	40025bc <prvCopyDataFromQueue>
            pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 40021b8:	e0bffc17 	ldw	r2,-16(fp)
 40021bc:	10ffffc4 	addi	r3,r2,-1
 40021c0:	e0bffe17 	ldw	r2,-8(fp)
 40021c4:	10c00e15 	stw	r3,56(r2)

            /* If the queue is locked the event list will not be modified.
             * Instead update the lock count so the task that unlocks the queue
             * will know that an ISR has removed data while the queue was
             * locked. */
            if( cRxLock == queueUNLOCKED )
 40021c8:	e0bffbc7 	ldb	r2,-17(fp)
 40021cc:	10bfffd8 	cmpnei	r2,r2,-1
 40021d0:	10000e1e 	bne	r2,zero,400220c <xQueueReceiveFromISR+0xa8>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 40021d4:	e0bffe17 	ldw	r2,-8(fp)
 40021d8:	10800417 	ldw	r2,16(r2)
 40021dc:	10001526 	beq	r2,zero,4002234 <xQueueReceiveFromISR+0xd0>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 40021e0:	e0bffe17 	ldw	r2,-8(fp)
 40021e4:	10800404 	addi	r2,r2,16
 40021e8:	1009883a 	mov	r4,r2
 40021ec:	40050240 	call	4005024 <xTaskRemoveFromEventList>
 40021f0:	10001026 	beq	r2,zero,4002234 <xQueueReceiveFromISR+0xd0>
                    {
                        /* The task waiting has a higher priority than us so
                         * force a context switch. */
                        if( pxHigherPriorityTaskWoken != NULL )
 40021f4:	e0bff717 	ldw	r2,-36(fp)
 40021f8:	10000e26 	beq	r2,zero,4002234 <xQueueReceiveFromISR+0xd0>
                        {
                            *pxHigherPriorityTaskWoken = pdTRUE;
 40021fc:	e0bff717 	ldw	r2,-36(fp)
 4002200:	00c00044 	movi	r3,1
 4002204:	10c00015 	stw	r3,0(r2)
 4002208:	00000a06 	br	4002234 <xQueueReceiveFromISR+0xd0>
            }
            else
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was removed while it was locked. */
                prvIncrementQueueRxLock( pxQueue, cRxLock );
 400220c:	4004a3c0 	call	4004a3c <uxTaskGetNumberOfTasks>
 4002210:	e0bffa15 	stw	r2,-24(fp)
 4002214:	e0fffbc7 	ldb	r3,-17(fp)
 4002218:	e0bffa17 	ldw	r2,-24(fp)
 400221c:	1880052e 	bgeu	r3,r2,4002234 <xQueueReceiveFromISR+0xd0>
 4002220:	e0bffbc3 	ldbu	r2,-17(fp)
 4002224:	10800044 	addi	r2,r2,1
 4002228:	1007883a 	mov	r3,r2
 400222c:	e0bffe17 	ldw	r2,-8(fp)
 4002230:	10c01105 	stb	r3,68(r2)
            }

            xReturn = pdPASS;
 4002234:	00800044 	movi	r2,1
 4002238:	e0bfff15 	stw	r2,-4(fp)
 400223c:	00000106 	br	4002244 <xQueueReceiveFromISR+0xe0>
        }
        else
        {
            xReturn = pdFAIL;
 4002240:	e03fff15 	stw	zero,-4(fp)
            traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
 4002244:	e0bfff17 	ldw	r2,-4(fp)
}
 4002248:	e037883a 	mov	sp,fp
 400224c:	dfc00117 	ldw	ra,4(sp)
 4002250:	df000017 	ldw	fp,0(sp)
 4002254:	dec00204 	addi	sp,sp,8
 4002258:	f800283a 	ret

0400225c <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,
                              void * const pvBuffer )
{
 400225c:	defff804 	addi	sp,sp,-32
 4002260:	dfc00715 	stw	ra,28(sp)
 4002264:	df000615 	stw	fp,24(sp)
 4002268:	df000604 	addi	fp,sp,24
 400226c:	e13ffb15 	stw	r4,-20(fp)
 4002270:	e17ffa15 	stw	r5,-24(fp)
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    int8_t * pcOriginalReadPosition;
    Queue_t * const pxQueue = xQueue;
 4002274:	e0bffb17 	ldw	r2,-20(fp)
 4002278:	e0bffe15 	stw	r2,-8(fp)
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 400227c:	e03ffd15 	stw	zero,-12(fp)
    {
        /* Cannot block in an ISR, so check there is data available. */
        if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 4002280:	e0bffe17 	ldw	r2,-8(fp)
 4002284:	10800e17 	ldw	r2,56(r2)
 4002288:	10000c26 	beq	r2,zero,40022bc <xQueuePeekFromISR+0x60>
        {
            traceQUEUE_PEEK_FROM_ISR( pxQueue );

            /* Remember the read position so it can be reset as nothing is
             * actually being removed from the queue. */
            pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
 400228c:	e0bffe17 	ldw	r2,-8(fp)
 4002290:	10800317 	ldw	r2,12(r2)
 4002294:	e0bffc15 	stw	r2,-16(fp)
            prvCopyDataFromQueue( pxQueue, pvBuffer );
 4002298:	e17ffa17 	ldw	r5,-24(fp)
 400229c:	e13ffe17 	ldw	r4,-8(fp)
 40022a0:	40025bc0 	call	40025bc <prvCopyDataFromQueue>
            pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
 40022a4:	e0bffe17 	ldw	r2,-8(fp)
 40022a8:	e0fffc17 	ldw	r3,-16(fp)
 40022ac:	10c00315 	stw	r3,12(r2)

            xReturn = pdPASS;
 40022b0:	00800044 	movi	r2,1
 40022b4:	e0bfff15 	stw	r2,-4(fp)
 40022b8:	00000106 	br	40022c0 <xQueuePeekFromISR+0x64>
        }
        else
        {
            xReturn = pdFAIL;
 40022bc:	e03fff15 	stw	zero,-4(fp)
            traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
 40022c0:	e0bfff17 	ldw	r2,-4(fp)
}
 40022c4:	e037883a 	mov	sp,fp
 40022c8:	dfc00117 	ldw	ra,4(sp)
 40022cc:	df000017 	ldw	fp,0(sp)
 40022d0:	dec00204 	addi	sp,sp,8
 40022d4:	f800283a 	ret

040022d8 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
 40022d8:	defffc04 	addi	sp,sp,-16
 40022dc:	dfc00315 	stw	ra,12(sp)
 40022e0:	df000215 	stw	fp,8(sp)
 40022e4:	df000204 	addi	fp,sp,8
 40022e8:	e13ffe15 	stw	r4,-8(fp)
    UBaseType_t uxReturn;

    configASSERT( xQueue );

    taskENTER_CRITICAL();
 40022ec:	4005f740 	call	4005f74 <vTaskEnterCritical>
    {
        uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
 40022f0:	e0bffe17 	ldw	r2,-8(fp)
 40022f4:	10800e17 	ldw	r2,56(r2)
 40022f8:	e0bfff15 	stw	r2,-4(fp)
    }
    taskEXIT_CRITICAL();
 40022fc:	4005fc80 	call	4005fc8 <vTaskExitCritical>

    return uxReturn;
 4002300:	e0bfff17 	ldw	r2,-4(fp)
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 4002304:	e037883a 	mov	sp,fp
 4002308:	dfc00117 	ldw	ra,4(sp)
 400230c:	df000017 	ldw	fp,0(sp)
 4002310:	dec00204 	addi	sp,sp,8
 4002314:	f800283a 	ret

04002318 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
 4002318:	defffb04 	addi	sp,sp,-20
 400231c:	dfc00415 	stw	ra,16(sp)
 4002320:	df000315 	stw	fp,12(sp)
 4002324:	df000304 	addi	fp,sp,12
 4002328:	e13ffd15 	stw	r4,-12(fp)
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;
 400232c:	e0bffd17 	ldw	r2,-12(fp)
 4002330:	e0bfff15 	stw	r2,-4(fp)

    configASSERT( pxQueue );

    taskENTER_CRITICAL();
 4002334:	4005f740 	call	4005f74 <vTaskEnterCritical>
    {
        uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
 4002338:	e0bfff17 	ldw	r2,-4(fp)
 400233c:	10c00f17 	ldw	r3,60(r2)
 4002340:	e0bfff17 	ldw	r2,-4(fp)
 4002344:	10800e17 	ldw	r2,56(r2)
 4002348:	1885c83a 	sub	r2,r3,r2
 400234c:	e0bffe15 	stw	r2,-8(fp)
    }
    taskEXIT_CRITICAL();
 4002350:	4005fc80 	call	4005fc8 <vTaskExitCritical>

    return uxReturn;
 4002354:	e0bffe17 	ldw	r2,-8(fp)
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 4002358:	e037883a 	mov	sp,fp
 400235c:	dfc00117 	ldw	ra,4(sp)
 4002360:	df000017 	ldw	fp,0(sp)
 4002364:	dec00204 	addi	sp,sp,8
 4002368:	f800283a 	ret

0400236c <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
 400236c:	defffc04 	addi	sp,sp,-16
 4002370:	df000315 	stw	fp,12(sp)
 4002374:	df000304 	addi	fp,sp,12
 4002378:	e13ffd15 	stw	r4,-12(fp)
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;
 400237c:	e0bffd17 	ldw	r2,-12(fp)
 4002380:	e0bfff15 	stw	r2,-4(fp)

    configASSERT( pxQueue );
    uxReturn = pxQueue->uxMessagesWaiting;
 4002384:	e0bfff17 	ldw	r2,-4(fp)
 4002388:	10800e17 	ldw	r2,56(r2)
 400238c:	e0bffe15 	stw	r2,-8(fp)

    return uxReturn;
 4002390:	e0bffe17 	ldw	r2,-8(fp)
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 4002394:	e037883a 	mov	sp,fp
 4002398:	df000017 	ldw	fp,0(sp)
 400239c:	dec00104 	addi	sp,sp,4
 40023a0:	f800283a 	ret

040023a4 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
 40023a4:	defffc04 	addi	sp,sp,-16
 40023a8:	dfc00315 	stw	ra,12(sp)
 40023ac:	df000215 	stw	fp,8(sp)
 40023b0:	df000204 	addi	fp,sp,8
 40023b4:	e13ffe15 	stw	r4,-8(fp)
    Queue_t * const pxQueue = xQueue;
 40023b8:	e0bffe17 	ldw	r2,-8(fp)
 40023bc:	e0bfff15 	stw	r2,-4(fp)

    #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
    {
        /* The queue can only have been allocated dynamically - free it
         * again. */
        vPortFree( pxQueue );
 40023c0:	e13fff17 	ldw	r4,-4(fp)
 40023c4:	400111c0 	call	400111c <vPortFree>
        /* The queue must have been statically allocated, so is not going to be
         * deleted.  Avoid compiler warnings about the unused parameter. */
        ( void ) pxQueue;
    }
    #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
 40023c8:	0001883a 	nop
 40023cc:	e037883a 	mov	sp,fp
 40023d0:	dfc00117 	ldw	ra,4(sp)
 40023d4:	df000017 	ldw	fp,0(sp)
 40023d8:	dec00204 	addi	sp,sp,8
 40023dc:	f800283a 	ret

040023e0 <prvGetDisinheritPriorityAfterTimeout>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
    {
 40023e0:	defffd04 	addi	sp,sp,-12
 40023e4:	df000215 	stw	fp,8(sp)
 40023e8:	df000204 	addi	fp,sp,8
 40023ec:	e13ffe15 	stw	r4,-8(fp)
         * priority, but the waiting task times out, then the holder should
         * disinherit the priority - but only down to the highest priority of any
         * other tasks that are waiting for the same mutex.  For this purpose,
         * return the priority of the highest priority task that is waiting for the
         * mutex. */
        if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
 40023f0:	e0bffe17 	ldw	r2,-8(fp)
 40023f4:	10800917 	ldw	r2,36(r2)
 40023f8:	10000726 	beq	r2,zero,4002418 <prvGetDisinheritPriorityAfterTimeout+0x38>
        {
            uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
 40023fc:	e0bffe17 	ldw	r2,-8(fp)
 4002400:	10800c17 	ldw	r2,48(r2)
 4002404:	10800017 	ldw	r2,0(r2)
 4002408:	00c00144 	movi	r3,5
 400240c:	1885c83a 	sub	r2,r3,r2
 4002410:	e0bfff15 	stw	r2,-4(fp)
 4002414:	00000106 	br	400241c <prvGetDisinheritPriorityAfterTimeout+0x3c>
        }
        else
        {
            uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
 4002418:	e03fff15 	stw	zero,-4(fp)
        }

        return uxHighestPriorityOfWaitingTasks;
 400241c:	e0bfff17 	ldw	r2,-4(fp)
    }
 4002420:	e037883a 	mov	sp,fp
 4002424:	df000017 	ldw	fp,0(sp)
 4002428:	dec00104 	addi	sp,sp,4
 400242c:	f800283a 	ret

04002430 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
                                      const void * pvItemToQueue,
                                      const BaseType_t xPosition )
{
 4002430:	defff904 	addi	sp,sp,-28
 4002434:	dfc00615 	stw	ra,24(sp)
 4002438:	df000515 	stw	fp,20(sp)
 400243c:	df000504 	addi	fp,sp,20
 4002440:	e13ffd15 	stw	r4,-12(fp)
 4002444:	e17ffc15 	stw	r5,-16(fp)
 4002448:	e1bffb15 	stw	r6,-20(fp)
    BaseType_t xReturn = pdFALSE;
 400244c:	e03fff15 	stw	zero,-4(fp)
    UBaseType_t uxMessagesWaiting;

    /* This function is called from a critical section. */

    uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 4002450:	e0bffd17 	ldw	r2,-12(fp)
 4002454:	10800e17 	ldw	r2,56(r2)
 4002458:	e0bffe15 	stw	r2,-8(fp)

    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 400245c:	e0bffd17 	ldw	r2,-12(fp)
 4002460:	10801017 	ldw	r2,64(r2)
 4002464:	10000b1e 	bne	r2,zero,4002494 <prvCopyDataToQueue+0x64>
    {
        #if ( configUSE_MUTEXES == 1 )
        {
            if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 4002468:	e0bffd17 	ldw	r2,-12(fp)
 400246c:	10800017 	ldw	r2,0(r2)
 4002470:	1000481e 	bne	r2,zero,4002594 <prvCopyDataToQueue+0x164>
            {
                /* The mutex is no longer being held. */
                xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
 4002474:	e0bffd17 	ldw	r2,-12(fp)
 4002478:	10800217 	ldw	r2,8(r2)
 400247c:	1009883a 	mov	r4,r2
 4002480:	4005bb80 	call	4005bb8 <xTaskPriorityDisinherit>
 4002484:	e0bfff15 	stw	r2,-4(fp)
                pxQueue->u.xSemaphore.xMutexHolder = NULL;
 4002488:	e0bffd17 	ldw	r2,-12(fp)
 400248c:	10000215 	stw	zero,8(r2)
 4002490:	00004006 	br	4002594 <prvCopyDataToQueue+0x164>
                mtCOVERAGE_TEST_MARKER();
            }
        }
        #endif /* configUSE_MUTEXES */
    }
    else if( xPosition == queueSEND_TO_BACK )
 4002494:	e0bffb17 	ldw	r2,-20(fp)
 4002498:	1000191e 	bne	r2,zero,4002500 <prvCopyDataToQueue+0xd0>
    {
        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 400249c:	e0bffd17 	ldw	r2,-12(fp)
 40024a0:	10c00117 	ldw	r3,4(r2)
 40024a4:	e0bffd17 	ldw	r2,-12(fp)
 40024a8:	10801017 	ldw	r2,64(r2)
 40024ac:	100d883a 	mov	r6,r2
 40024b0:	e17ffc17 	ldw	r5,-16(fp)
 40024b4:	1809883a 	mov	r4,r3
 40024b8:	40073dc0 	call	40073dc <memcpy>
        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 40024bc:	e0bffd17 	ldw	r2,-12(fp)
 40024c0:	10c00117 	ldw	r3,4(r2)
 40024c4:	e0bffd17 	ldw	r2,-12(fp)
 40024c8:	10801017 	ldw	r2,64(r2)
 40024cc:	1887883a 	add	r3,r3,r2
 40024d0:	e0bffd17 	ldw	r2,-12(fp)
 40024d4:	10c00115 	stw	r3,4(r2)

        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 40024d8:	e0bffd17 	ldw	r2,-12(fp)
 40024dc:	10c00117 	ldw	r3,4(r2)
 40024e0:	e0bffd17 	ldw	r2,-12(fp)
 40024e4:	10800217 	ldw	r2,8(r2)
 40024e8:	18802a36 	bltu	r3,r2,4002594 <prvCopyDataToQueue+0x164>
        {
            pxQueue->pcWriteTo = pxQueue->pcHead;
 40024ec:	e0bffd17 	ldw	r2,-12(fp)
 40024f0:	10c00017 	ldw	r3,0(r2)
 40024f4:	e0bffd17 	ldw	r2,-12(fp)
 40024f8:	10c00115 	stw	r3,4(r2)
 40024fc:	00002506 	br	4002594 <prvCopyDataToQueue+0x164>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
 4002500:	e0bffd17 	ldw	r2,-12(fp)
 4002504:	10c00317 	ldw	r3,12(r2)
 4002508:	e0bffd17 	ldw	r2,-12(fp)
 400250c:	10801017 	ldw	r2,64(r2)
 4002510:	100d883a 	mov	r6,r2
 4002514:	e17ffc17 	ldw	r5,-16(fp)
 4002518:	1809883a 	mov	r4,r3
 400251c:	40073dc0 	call	40073dc <memcpy>
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
 4002520:	e0bffd17 	ldw	r2,-12(fp)
 4002524:	10c00317 	ldw	r3,12(r2)
 4002528:	e0bffd17 	ldw	r2,-12(fp)
 400252c:	10801017 	ldw	r2,64(r2)
 4002530:	0085c83a 	sub	r2,zero,r2
 4002534:	1887883a 	add	r3,r3,r2
 4002538:	e0bffd17 	ldw	r2,-12(fp)
 400253c:	10c00315 	stw	r3,12(r2)

        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 4002540:	e0bffd17 	ldw	r2,-12(fp)
 4002544:	10c00317 	ldw	r3,12(r2)
 4002548:	e0bffd17 	ldw	r2,-12(fp)
 400254c:	10800017 	ldw	r2,0(r2)
 4002550:	1880082e 	bgeu	r3,r2,4002574 <prvCopyDataToQueue+0x144>
        {
            pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
 4002554:	e0bffd17 	ldw	r2,-12(fp)
 4002558:	10c00217 	ldw	r3,8(r2)
 400255c:	e0bffd17 	ldw	r2,-12(fp)
 4002560:	10801017 	ldw	r2,64(r2)
 4002564:	0085c83a 	sub	r2,zero,r2
 4002568:	1887883a 	add	r3,r3,r2
 400256c:	e0bffd17 	ldw	r2,-12(fp)
 4002570:	10c00315 	stw	r3,12(r2)
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( xPosition == queueOVERWRITE )
 4002574:	e0bffb17 	ldw	r2,-20(fp)
 4002578:	10800098 	cmpnei	r2,r2,2
 400257c:	1000051e 	bne	r2,zero,4002594 <prvCopyDataToQueue+0x164>
        {
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 4002580:	e0bffe17 	ldw	r2,-8(fp)
 4002584:	10000326 	beq	r2,zero,4002594 <prvCopyDataToQueue+0x164>
            {
                /* An item is not being added but overwritten, so subtract
                 * one from the recorded number of items in the queue so when
                 * one is added again below the number of recorded items remains
                 * correct. */
                --uxMessagesWaiting;
 4002588:	e0bffe17 	ldw	r2,-8(fp)
 400258c:	10bfffc4 	addi	r2,r2,-1
 4002590:	e0bffe15 	stw	r2,-8(fp)
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 4002594:	e0bffe17 	ldw	r2,-8(fp)
 4002598:	10c00044 	addi	r3,r2,1
 400259c:	e0bffd17 	ldw	r2,-12(fp)
 40025a0:	10c00e15 	stw	r3,56(r2)

    return xReturn;
 40025a4:	e0bfff17 	ldw	r2,-4(fp)
}
 40025a8:	e037883a 	mov	sp,fp
 40025ac:	dfc00117 	ldw	ra,4(sp)
 40025b0:	df000017 	ldw	fp,0(sp)
 40025b4:	dec00204 	addi	sp,sp,8
 40025b8:	f800283a 	ret

040025bc <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue,
                                  void * const pvBuffer )
{
 40025bc:	defffc04 	addi	sp,sp,-16
 40025c0:	dfc00315 	stw	ra,12(sp)
 40025c4:	df000215 	stw	fp,8(sp)
 40025c8:	df000204 	addi	fp,sp,8
 40025cc:	e13fff15 	stw	r4,-4(fp)
 40025d0:	e17ffe15 	stw	r5,-8(fp)
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 40025d4:	e0bfff17 	ldw	r2,-4(fp)
 40025d8:	10801017 	ldw	r2,64(r2)
 40025dc:	10001826 	beq	r2,zero,4002640 <prvCopyDataFromQueue+0x84>
    {
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 40025e0:	e0bfff17 	ldw	r2,-4(fp)
 40025e4:	10c00317 	ldw	r3,12(r2)
 40025e8:	e0bfff17 	ldw	r2,-4(fp)
 40025ec:	10801017 	ldw	r2,64(r2)
 40025f0:	1887883a 	add	r3,r3,r2
 40025f4:	e0bfff17 	ldw	r2,-4(fp)
 40025f8:	10c00315 	stw	r3,12(r2)

        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 40025fc:	e0bfff17 	ldw	r2,-4(fp)
 4002600:	10c00317 	ldw	r3,12(r2)
 4002604:	e0bfff17 	ldw	r2,-4(fp)
 4002608:	10800217 	ldw	r2,8(r2)
 400260c:	18800436 	bltu	r3,r2,4002620 <prvCopyDataFromQueue+0x64>
        {
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
 4002610:	e0bfff17 	ldw	r2,-4(fp)
 4002614:	10c00017 	ldw	r3,0(r2)
 4002618:	e0bfff17 	ldw	r2,-4(fp)
 400261c:	10c00315 	stw	r3,12(r2)
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 4002620:	e0bfff17 	ldw	r2,-4(fp)
 4002624:	10c00317 	ldw	r3,12(r2)
 4002628:	e0bfff17 	ldw	r2,-4(fp)
 400262c:	10801017 	ldw	r2,64(r2)
 4002630:	100d883a 	mov	r6,r2
 4002634:	180b883a 	mov	r5,r3
 4002638:	e13ffe17 	ldw	r4,-8(fp)
 400263c:	40073dc0 	call	40073dc <memcpy>
    }
}
 4002640:	0001883a 	nop
 4002644:	e037883a 	mov	sp,fp
 4002648:	dfc00117 	ldw	ra,4(sp)
 400264c:	df000017 	ldw	fp,0(sp)
 4002650:	dec00204 	addi	sp,sp,8
 4002654:	f800283a 	ret

04002658 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
 4002658:	defffc04 	addi	sp,sp,-16
 400265c:	dfc00315 	stw	ra,12(sp)
 4002660:	df000215 	stw	fp,8(sp)
 4002664:	df000204 	addi	fp,sp,8
 4002668:	e13ffe15 	stw	r4,-8(fp)

    /* The lock counts contains the number of extra data items placed or
     * removed from the queue while the queue was locked.  When a queue is
     * locked items can be added or removed, but the event lists cannot be
     * updated. */
    taskENTER_CRITICAL();
 400266c:	4005f740 	call	4005f74 <vTaskEnterCritical>
    {
        int8_t cTxLock = pxQueue->cTxLock;
 4002670:	e0bffe17 	ldw	r2,-8(fp)
 4002674:	10801143 	ldbu	r2,69(r2)
 4002678:	e0bfffc5 	stb	r2,-1(fp)

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
 400267c:	00000c06 	br	40026b0 <prvUnlockQueue+0x58>
            }
            #else /* configUSE_QUEUE_SETS */
            {
                /* Tasks that are removed from the event list will get added to
                 * the pending ready list as the scheduler is still suspended. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 4002680:	e0bffe17 	ldw	r2,-8(fp)
 4002684:	10800917 	ldw	r2,36(r2)
 4002688:	10000c26 	beq	r2,zero,40026bc <prvUnlockQueue+0x64>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 400268c:	e0bffe17 	ldw	r2,-8(fp)
 4002690:	10800904 	addi	r2,r2,36
 4002694:	1009883a 	mov	r4,r2
 4002698:	40050240 	call	4005024 <xTaskRemoveFromEventList>
 400269c:	10000126 	beq	r2,zero,40026a4 <prvUnlockQueue+0x4c>
                    {
                        /* The task waiting has a higher priority so record that
                         * a context switch is required. */
                        vTaskMissedYield();
 40026a0:	40056b40 	call	40056b4 <vTaskMissedYield>
                    break;
                }
            }
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
 40026a4:	e0bfffc3 	ldbu	r2,-1(fp)
 40026a8:	10bfffc4 	addi	r2,r2,-1
 40026ac:	e0bfffc5 	stb	r2,-1(fp)
        while( cTxLock > queueLOCKED_UNMODIFIED )
 40026b0:	e0bfffc7 	ldb	r2,-1(fp)
 40026b4:	00bff216 	blt	zero,r2,4002680 <prvUnlockQueue+0x28>
 40026b8:	00000106 	br	40026c0 <prvUnlockQueue+0x68>
                    break;
 40026bc:	0001883a 	nop
        }

        pxQueue->cTxLock = queueUNLOCKED;
 40026c0:	e0bffe17 	ldw	r2,-8(fp)
 40026c4:	00ffffc4 	movi	r3,-1
 40026c8:	10c01145 	stb	r3,69(r2)
    }
    taskEXIT_CRITICAL();
 40026cc:	4005fc80 	call	4005fc8 <vTaskExitCritical>

    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
 40026d0:	4005f740 	call	4005f74 <vTaskEnterCritical>
    {
        int8_t cRxLock = pxQueue->cRxLock;
 40026d4:	e0bffe17 	ldw	r2,-8(fp)
 40026d8:	10801103 	ldbu	r2,68(r2)
 40026dc:	e0bfff85 	stb	r2,-2(fp)

        while( cRxLock > queueLOCKED_UNMODIFIED )
 40026e0:	00000c06 	br	4002714 <prvUnlockQueue+0xbc>
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 40026e4:	e0bffe17 	ldw	r2,-8(fp)
 40026e8:	10800417 	ldw	r2,16(r2)
 40026ec:	10000c26 	beq	r2,zero,4002720 <prvUnlockQueue+0xc8>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 40026f0:	e0bffe17 	ldw	r2,-8(fp)
 40026f4:	10800404 	addi	r2,r2,16
 40026f8:	1009883a 	mov	r4,r2
 40026fc:	40050240 	call	4005024 <xTaskRemoveFromEventList>
 4002700:	10000126 	beq	r2,zero,4002708 <prvUnlockQueue+0xb0>
                {
                    vTaskMissedYield();
 4002704:	40056b40 	call	40056b4 <vTaskMissedYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                --cRxLock;
 4002708:	e0bfff83 	ldbu	r2,-2(fp)
 400270c:	10bfffc4 	addi	r2,r2,-1
 4002710:	e0bfff85 	stb	r2,-2(fp)
        while( cRxLock > queueLOCKED_UNMODIFIED )
 4002714:	e0bfff87 	ldb	r2,-2(fp)
 4002718:	00bff216 	blt	zero,r2,40026e4 <prvUnlockQueue+0x8c>
 400271c:	00000106 	br	4002724 <prvUnlockQueue+0xcc>
            }
            else
            {
                break;
 4002720:	0001883a 	nop
            }
        }

        pxQueue->cRxLock = queueUNLOCKED;
 4002724:	e0bffe17 	ldw	r2,-8(fp)
 4002728:	00ffffc4 	movi	r3,-1
 400272c:	10c01105 	stb	r3,68(r2)
    }
    taskEXIT_CRITICAL();
 4002730:	4005fc80 	call	4005fc8 <vTaskExitCritical>
}
 4002734:	0001883a 	nop
 4002738:	e037883a 	mov	sp,fp
 400273c:	dfc00117 	ldw	ra,4(sp)
 4002740:	df000017 	ldw	fp,0(sp)
 4002744:	dec00204 	addi	sp,sp,8
 4002748:	f800283a 	ret

0400274c <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
 400274c:	defffc04 	addi	sp,sp,-16
 4002750:	dfc00315 	stw	ra,12(sp)
 4002754:	df000215 	stw	fp,8(sp)
 4002758:	df000204 	addi	fp,sp,8
 400275c:	e13ffe15 	stw	r4,-8(fp)
    BaseType_t xReturn;

    taskENTER_CRITICAL();
 4002760:	4005f740 	call	4005f74 <vTaskEnterCritical>
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
 4002764:	e0bffe17 	ldw	r2,-8(fp)
 4002768:	10800e17 	ldw	r2,56(r2)
 400276c:	1000031e 	bne	r2,zero,400277c <prvIsQueueEmpty+0x30>
        {
            xReturn = pdTRUE;
 4002770:	00800044 	movi	r2,1
 4002774:	e0bfff15 	stw	r2,-4(fp)
 4002778:	00000106 	br	4002780 <prvIsQueueEmpty+0x34>
        }
        else
        {
            xReturn = pdFALSE;
 400277c:	e03fff15 	stw	zero,-4(fp)
        }
    }
    taskEXIT_CRITICAL();
 4002780:	4005fc80 	call	4005fc8 <vTaskExitCritical>

    return xReturn;
 4002784:	e0bfff17 	ldw	r2,-4(fp)
}
 4002788:	e037883a 	mov	sp,fp
 400278c:	dfc00117 	ldw	ra,4(sp)
 4002790:	df000017 	ldw	fp,0(sp)
 4002794:	dec00204 	addi	sp,sp,8
 4002798:	f800283a 	ret

0400279c <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
 400279c:	defffc04 	addi	sp,sp,-16
 40027a0:	df000315 	stw	fp,12(sp)
 40027a4:	df000304 	addi	fp,sp,12
 40027a8:	e13ffd15 	stw	r4,-12(fp)
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;
 40027ac:	e0bffd17 	ldw	r2,-12(fp)
 40027b0:	e0bffe15 	stw	r2,-8(fp)

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
 40027b4:	e0bffe17 	ldw	r2,-8(fp)
 40027b8:	10800e17 	ldw	r2,56(r2)
 40027bc:	1000031e 	bne	r2,zero,40027cc <xQueueIsQueueEmptyFromISR+0x30>
    {
        xReturn = pdTRUE;
 40027c0:	00800044 	movi	r2,1
 40027c4:	e0bfff15 	stw	r2,-4(fp)
 40027c8:	00000106 	br	40027d0 <xQueueIsQueueEmptyFromISR+0x34>
    }
    else
    {
        xReturn = pdFALSE;
 40027cc:	e03fff15 	stw	zero,-4(fp)
    }

    return xReturn;
 40027d0:	e0bfff17 	ldw	r2,-4(fp)
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 40027d4:	e037883a 	mov	sp,fp
 40027d8:	df000017 	ldw	fp,0(sp)
 40027dc:	dec00104 	addi	sp,sp,4
 40027e0:	f800283a 	ret

040027e4 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )
{
 40027e4:	defffc04 	addi	sp,sp,-16
 40027e8:	dfc00315 	stw	ra,12(sp)
 40027ec:	df000215 	stw	fp,8(sp)
 40027f0:	df000204 	addi	fp,sp,8
 40027f4:	e13ffe15 	stw	r4,-8(fp)
    BaseType_t xReturn;

    taskENTER_CRITICAL();
 40027f8:	4005f740 	call	4005f74 <vTaskEnterCritical>
    {
        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 40027fc:	e0bffe17 	ldw	r2,-8(fp)
 4002800:	10c00e17 	ldw	r3,56(r2)
 4002804:	e0bffe17 	ldw	r2,-8(fp)
 4002808:	10800f17 	ldw	r2,60(r2)
 400280c:	1880031e 	bne	r3,r2,400281c <prvIsQueueFull+0x38>
        {
            xReturn = pdTRUE;
 4002810:	00800044 	movi	r2,1
 4002814:	e0bfff15 	stw	r2,-4(fp)
 4002818:	00000106 	br	4002820 <prvIsQueueFull+0x3c>
        }
        else
        {
            xReturn = pdFALSE;
 400281c:	e03fff15 	stw	zero,-4(fp)
        }
    }
    taskEXIT_CRITICAL();
 4002820:	4005fc80 	call	4005fc8 <vTaskExitCritical>

    return xReturn;
 4002824:	e0bfff17 	ldw	r2,-4(fp)
}
 4002828:	e037883a 	mov	sp,fp
 400282c:	dfc00117 	ldw	ra,4(sp)
 4002830:	df000017 	ldw	fp,0(sp)
 4002834:	dec00204 	addi	sp,sp,8
 4002838:	f800283a 	ret

0400283c <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
 400283c:	defffc04 	addi	sp,sp,-16
 4002840:	df000315 	stw	fp,12(sp)
 4002844:	df000304 	addi	fp,sp,12
 4002848:	e13ffd15 	stw	r4,-12(fp)
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;
 400284c:	e0bffd17 	ldw	r2,-12(fp)
 4002850:	e0bffe15 	stw	r2,-8(fp)

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 4002854:	e0bffe17 	ldw	r2,-8(fp)
 4002858:	10c00e17 	ldw	r3,56(r2)
 400285c:	e0bffe17 	ldw	r2,-8(fp)
 4002860:	10800f17 	ldw	r2,60(r2)
 4002864:	1880031e 	bne	r3,r2,4002874 <xQueueIsQueueFullFromISR+0x38>
    {
        xReturn = pdTRUE;
 4002868:	00800044 	movi	r2,1
 400286c:	e0bfff15 	stw	r2,-4(fp)
 4002870:	00000106 	br	4002878 <xQueueIsQueueFullFromISR+0x3c>
    }
    else
    {
        xReturn = pdFALSE;
 4002874:	e03fff15 	stw	zero,-4(fp)
    }

    return xReturn;
 4002878:	e0bfff17 	ldw	r2,-4(fp)
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 400287c:	e037883a 	mov	sp,fp
 4002880:	df000017 	ldw	fp,0(sp)
 4002884:	dec00104 	addi	sp,sp,4
 4002888:	f800283a 	ret

0400288c <xStreamBufferGenericCreate>:
    StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes,
                                                     size_t xTriggerLevelBytes,
                                                     BaseType_t xIsMessageBuffer,
                                                     StreamBufferCallbackFunction_t pxSendCompletedCallback,
                                                     StreamBufferCallbackFunction_t pxReceiveCompletedCallback )
    {
 400288c:	defff504 	addi	sp,sp,-44
 4002890:	dfc00a15 	stw	ra,40(sp)
 4002894:	df000915 	stw	fp,36(sp)
 4002898:	df000904 	addi	fp,sp,36
 400289c:	e13ffd15 	stw	r4,-12(fp)
 40028a0:	e17ffc15 	stw	r5,-16(fp)
 40028a4:	e1bffb15 	stw	r6,-20(fp)
 40028a8:	e1fffa15 	stw	r7,-24(fp)

        /* In case the stream buffer is going to be used as a message buffer
         * (that is, it will hold discrete messages with a little meta data that
         * says how big the next message is) check the buffer will be large enough
         * to hold at least one message. */
        if( xIsMessageBuffer == pdTRUE )
 40028ac:	e0bffb17 	ldw	r2,-20(fp)
 40028b0:	10800058 	cmpnei	r2,r2,1
 40028b4:	1000031e 	bne	r2,zero,40028c4 <xStreamBufferGenericCreate+0x38>
        {
            /* Is a message buffer but not statically allocated. */
            ucFlags = sbFLAGS_IS_MESSAGE_BUFFER;
 40028b8:	00800044 	movi	r2,1
 40028bc:	e0bffec5 	stb	r2,-5(fp)
 40028c0:	00000106 	br	40028c8 <xStreamBufferGenericCreate+0x3c>
            configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );
        }
        else
        {
            /* Not a message buffer and not statically allocated. */
            ucFlags = 0;
 40028c4:	e03ffec5 	stb	zero,-5(fp)

        configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );

        /* A trigger level of 0 would cause a waiting task to unblock even when
         * the buffer was empty. */
        if( xTriggerLevelBytes == ( size_t ) 0 )
 40028c8:	e0bffc17 	ldw	r2,-16(fp)
 40028cc:	1000021e 	bne	r2,zero,40028d8 <xStreamBufferGenericCreate+0x4c>
        {
            xTriggerLevelBytes = ( size_t ) 1;
 40028d0:	00800044 	movi	r2,1
 40028d4:	e0bffc15 	stw	r2,-16(fp)
         * and the buffer follows immediately after.  The requested size is
         * incremented so the free space is returned as the user would expect -
         * this is a quirk of the implementation that means otherwise the free
         * space would be reported as one byte smaller than would be logically
         * expected. */
        if( xBufferSizeBytes < ( xBufferSizeBytes + 1 + sizeof( StreamBuffer_t ) ) )
 40028d8:	e0bffd17 	ldw	r2,-12(fp)
 40028dc:	00fff784 	movi	r3,-34
 40028e0:	18800936 	bltu	r3,r2,4002908 <xStreamBufferGenericCreate+0x7c>
        {
            xBufferSizeBytes++;
 40028e4:	e0bffd17 	ldw	r2,-12(fp)
 40028e8:	10800044 	addi	r2,r2,1
 40028ec:	e0bffd15 	stw	r2,-12(fp)
            pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */
 40028f0:	e0bffd17 	ldw	r2,-12(fp)
 40028f4:	10800804 	addi	r2,r2,32
 40028f8:	1009883a 	mov	r4,r2
 40028fc:	40010340 	call	4001034 <pvPortMalloc>
 4002900:	e0bfff15 	stw	r2,-4(fp)
 4002904:	00000106 	br	400290c <xStreamBufferGenericCreate+0x80>
        }
        else
        {
            pucAllocatedMemory = NULL;
 4002908:	e03fff15 	stw	zero,-4(fp)
        }

        if( pucAllocatedMemory != NULL )
 400290c:	e0bfff17 	ldw	r2,-4(fp)
 4002910:	10000d26 	beq	r2,zero,4002948 <xStreamBufferGenericCreate+0xbc>
        {
            prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory,       /* Structure at the start of the allocated memory. */ /*lint !e9087 Safe cast as allocated memory is aligned. */ /*lint !e826 Area is not too small and alignment is guaranteed provided malloc() behaves as expected and returns aligned buffer. */
 4002914:	e0bfff17 	ldw	r2,-4(fp)
 4002918:	11000804 	addi	r4,r2,32
 400291c:	e0bffec3 	ldbu	r2,-5(fp)
 4002920:	e0c00217 	ldw	r3,8(fp)
 4002924:	d8c00215 	stw	r3,8(sp)
 4002928:	e0fffa17 	ldw	r3,-24(fp)
 400292c:	d8c00115 	stw	r3,4(sp)
 4002930:	d8800015 	stw	r2,0(sp)
 4002934:	e1fffc17 	ldw	r7,-16(fp)
 4002938:	e1bffd17 	ldw	r6,-12(fp)
 400293c:	200b883a 	mov	r5,r4
 4002940:	e13fff17 	ldw	r4,-4(fp)
 4002944:	400372c0 	call	400372c <prvInitialiseNewStreamBuffer>
        else
        {
            traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );
        }

        return ( StreamBufferHandle_t ) pucAllocatedMemory; /*lint !e9087 !e826 Safe cast as allocated memory is aligned. */
 4002948:	e0bfff17 	ldw	r2,-4(fp)
    }
 400294c:	e037883a 	mov	sp,fp
 4002950:	dfc00117 	ldw	ra,4(sp)
 4002954:	df000017 	ldw	fp,0(sp)
 4002958:	dec00204 	addi	sp,sp,8
 400295c:	f800283a 	ret

04002960 <vStreamBufferDelete>:
    }
#endif /* ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
/*-----------------------------------------------------------*/

void vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer )
{
 4002960:	defffc04 	addi	sp,sp,-16
 4002964:	dfc00315 	stw	ra,12(sp)
 4002968:	df000215 	stw	fp,8(sp)
 400296c:	df000204 	addi	fp,sp,8
 4002970:	e13ffe15 	stw	r4,-8(fp)
    StreamBuffer_t * pxStreamBuffer = xStreamBuffer;
 4002974:	e0bffe17 	ldw	r2,-8(fp)
 4002978:	e0bfff15 	stw	r2,-4(fp)

    configASSERT( pxStreamBuffer );

    traceSTREAM_BUFFER_DELETE( xStreamBuffer );

    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) pdFALSE )
 400297c:	e0bfff17 	ldw	r2,-4(fp)
 4002980:	10800703 	ldbu	r2,28(r2)
 4002984:	10803fcc 	andi	r2,r2,255
 4002988:	1080008c 	andi	r2,r2,2
 400298c:	1000031e 	bne	r2,zero,400299c <vStreamBufferDelete+0x3c>
    {
        #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
        {
            /* Both the structure and the buffer were allocated using a single call
            * to pvPortMalloc(), hence only one call to vPortFree() is required. */
            vPortFree( ( void * ) pxStreamBuffer ); /*lint !e9087 Standard free() semantics require void *, plus pxStreamBuffer was allocated by pvPortMalloc(). */
 4002990:	e13fff17 	ldw	r4,-4(fp)
 4002994:	400111c0 	call	400111c <vPortFree>
    {
        /* The structure and buffer were not allocated dynamically and cannot be
         * freed - just scrub the structure so future use will assert. */
        ( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
    }
}
 4002998:	00000406 	br	40029ac <vStreamBufferDelete+0x4c>
        ( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
 400299c:	01800804 	movi	r6,32
 40029a0:	000b883a 	mov	r5,zero
 40029a4:	e13fff17 	ldw	r4,-4(fp)
 40029a8:	40074dc0 	call	40074dc <memset>
}
 40029ac:	0001883a 	nop
 40029b0:	e037883a 	mov	sp,fp
 40029b4:	dfc00117 	ldw	ra,4(sp)
 40029b8:	df000017 	ldw	fp,0(sp)
 40029bc:	dec00204 	addi	sp,sp,8
 40029c0:	f800283a 	ret

040029c4 <xStreamBufferReset>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer )
{
 40029c4:	defff604 	addi	sp,sp,-40
 40029c8:	dfc00915 	stw	ra,36(sp)
 40029cc:	df000815 	stw	fp,32(sp)
 40029d0:	df000804 	addi	fp,sp,32
 40029d4:	e13ffb15 	stw	r4,-20(fp)
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 40029d8:	e0bffb17 	ldw	r2,-20(fp)
 40029dc:	e0bffe15 	stw	r2,-8(fp)
    BaseType_t xReturn = pdFAIL;
 40029e0:	e03fff15 	stw	zero,-4(fp)
    StreamBufferCallbackFunction_t pxSendCallback = NULL, pxReceiveCallback = NULL;
 40029e4:	e03ffd15 	stw	zero,-12(fp)
 40029e8:	e03ffc15 	stw	zero,-16(fp)
        uxStreamBufferNumber = pxStreamBuffer->uxStreamBufferNumber;
    }
    #endif

    /* Can only reset a message buffer if there are no tasks blocked on it. */
    taskENTER_CRITICAL();
 40029ec:	4005f740 	call	4005f74 <vTaskEnterCritical>
    {
        if( ( pxStreamBuffer->xTaskWaitingToReceive == NULL ) && ( pxStreamBuffer->xTaskWaitingToSend == NULL ) )
 40029f0:	e0bffe17 	ldw	r2,-8(fp)
 40029f4:	10800417 	ldw	r2,16(r2)
 40029f8:	1000181e 	bne	r2,zero,4002a5c <xStreamBufferReset+0x98>
 40029fc:	e0bffe17 	ldw	r2,-8(fp)
 4002a00:	10800517 	ldw	r2,20(r2)
 4002a04:	1000151e 	bne	r2,zero,4002a5c <xStreamBufferReset+0x98>
                pxSendCallback = pxStreamBuffer->pxSendCompletedCallback;
                pxReceiveCallback = pxStreamBuffer->pxReceiveCompletedCallback;
            }
            #endif

            prvInitialiseNewStreamBuffer( pxStreamBuffer,
 4002a08:	e0bffe17 	ldw	r2,-8(fp)
 4002a0c:	11000617 	ldw	r4,24(r2)
 4002a10:	e0bffe17 	ldw	r2,-8(fp)
 4002a14:	11400217 	ldw	r5,8(r2)
 4002a18:	e0bffe17 	ldw	r2,-8(fp)
 4002a1c:	11800317 	ldw	r6,12(r2)
                                          pxStreamBuffer->pucBuffer,
                                          pxStreamBuffer->xLength,
                                          pxStreamBuffer->xTriggerLevelBytes,
                                          pxStreamBuffer->ucFlags,
 4002a20:	e0bffe17 	ldw	r2,-8(fp)
 4002a24:	10800703 	ldbu	r2,28(r2)
            prvInitialiseNewStreamBuffer( pxStreamBuffer,
 4002a28:	10803fcc 	andi	r2,r2,255
 4002a2c:	e0fffc17 	ldw	r3,-16(fp)
 4002a30:	d8c00215 	stw	r3,8(sp)
 4002a34:	e0fffd17 	ldw	r3,-12(fp)
 4002a38:	d8c00115 	stw	r3,4(sp)
 4002a3c:	d8800015 	stw	r2,0(sp)
 4002a40:	300f883a 	mov	r7,r6
 4002a44:	280d883a 	mov	r6,r5
 4002a48:	200b883a 	mov	r5,r4
 4002a4c:	e13ffe17 	ldw	r4,-8(fp)
 4002a50:	400372c0 	call	400372c <prvInitialiseNewStreamBuffer>
            }
            #endif

            traceSTREAM_BUFFER_RESET( xStreamBuffer );

            xReturn = pdPASS;
 4002a54:	00800044 	movi	r2,1
 4002a58:	e0bfff15 	stw	r2,-4(fp)
        }
    }
    taskEXIT_CRITICAL();
 4002a5c:	4005fc80 	call	4005fc8 <vTaskExitCritical>

    return xReturn;
 4002a60:	e0bfff17 	ldw	r2,-4(fp)
}
 4002a64:	e037883a 	mov	sp,fp
 4002a68:	dfc00117 	ldw	ra,4(sp)
 4002a6c:	df000017 	ldw	fp,0(sp)
 4002a70:	dec00204 	addi	sp,sp,8
 4002a74:	f800283a 	ret

04002a78 <xStreamBufferSetTriggerLevel>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer,
                                         size_t xTriggerLevel )
{
 4002a78:	defffb04 	addi	sp,sp,-20
 4002a7c:	df000415 	stw	fp,16(sp)
 4002a80:	df000404 	addi	fp,sp,16
 4002a84:	e13ffd15 	stw	r4,-12(fp)
 4002a88:	e17ffc15 	stw	r5,-16(fp)
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 4002a8c:	e0bffd17 	ldw	r2,-12(fp)
 4002a90:	e0bffe15 	stw	r2,-8(fp)
    BaseType_t xReturn;

    configASSERT( pxStreamBuffer );

    /* It is not valid for the trigger level to be 0. */
    if( xTriggerLevel == ( size_t ) 0 )
 4002a94:	e0bffc17 	ldw	r2,-16(fp)
 4002a98:	1000021e 	bne	r2,zero,4002aa4 <xStreamBufferSetTriggerLevel+0x2c>
    {
        xTriggerLevel = ( size_t ) 1;
 4002a9c:	00800044 	movi	r2,1
 4002aa0:	e0bffc15 	stw	r2,-16(fp)
    }

    /* The trigger level is the number of bytes that must be in the stream
     * buffer before a task that is waiting for data is unblocked. */
    if( xTriggerLevel < pxStreamBuffer->xLength )
 4002aa4:	e0bffe17 	ldw	r2,-8(fp)
 4002aa8:	10800217 	ldw	r2,8(r2)
 4002aac:	e0fffc17 	ldw	r3,-16(fp)
 4002ab0:	1880062e 	bgeu	r3,r2,4002acc <xStreamBufferSetTriggerLevel+0x54>
    {
        pxStreamBuffer->xTriggerLevelBytes = xTriggerLevel;
 4002ab4:	e0bffe17 	ldw	r2,-8(fp)
 4002ab8:	e0fffc17 	ldw	r3,-16(fp)
 4002abc:	10c00315 	stw	r3,12(r2)
        xReturn = pdPASS;
 4002ac0:	00800044 	movi	r2,1
 4002ac4:	e0bfff15 	stw	r2,-4(fp)
 4002ac8:	00000106 	br	4002ad0 <xStreamBufferSetTriggerLevel+0x58>
    }
    else
    {
        xReturn = pdFALSE;
 4002acc:	e03fff15 	stw	zero,-4(fp)
    }

    return xReturn;
 4002ad0:	e0bfff17 	ldw	r2,-4(fp)
}
 4002ad4:	e037883a 	mov	sp,fp
 4002ad8:	df000017 	ldw	fp,0(sp)
 4002adc:	dec00104 	addi	sp,sp,4
 4002ae0:	f800283a 	ret

04002ae4 <xStreamBufferSpacesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer )
{
 4002ae4:	defffb04 	addi	sp,sp,-20
 4002ae8:	df000415 	stw	fp,16(sp)
 4002aec:	df000404 	addi	fp,sp,16
 4002af0:	e13ffc15 	stw	r4,-16(fp)
    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 4002af4:	e0bffc17 	ldw	r2,-16(fp)
 4002af8:	e0bffe15 	stw	r2,-8(fp)
    /* The code below reads xTail and then xHead.  This is safe if the stream
     * buffer is updated once between the two reads - but not if the stream buffer
     * is updated more than once between the two reads - hence the loop. */
    do
    {
        xOriginalTail = pxStreamBuffer->xTail;
 4002afc:	e0bffe17 	ldw	r2,-8(fp)
 4002b00:	10800017 	ldw	r2,0(r2)
 4002b04:	e0bffd15 	stw	r2,-12(fp)
        xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
 4002b08:	e0bffe17 	ldw	r2,-8(fp)
 4002b0c:	10c00217 	ldw	r3,8(r2)
 4002b10:	e0bffe17 	ldw	r2,-8(fp)
 4002b14:	10800017 	ldw	r2,0(r2)
 4002b18:	1885883a 	add	r2,r3,r2
 4002b1c:	e0bfff15 	stw	r2,-4(fp)
        xSpace -= pxStreamBuffer->xHead;
 4002b20:	e0bffe17 	ldw	r2,-8(fp)
 4002b24:	10800117 	ldw	r2,4(r2)
 4002b28:	e0ffff17 	ldw	r3,-4(fp)
 4002b2c:	1885c83a 	sub	r2,r3,r2
 4002b30:	e0bfff15 	stw	r2,-4(fp)
    } while( xOriginalTail != pxStreamBuffer->xTail );
 4002b34:	e0bffe17 	ldw	r2,-8(fp)
 4002b38:	10800017 	ldw	r2,0(r2)
 4002b3c:	e0fffd17 	ldw	r3,-12(fp)
 4002b40:	18bfee1e 	bne	r3,r2,4002afc <xStreamBufferSpacesAvailable+0x18>

    xSpace -= ( size_t ) 1;
 4002b44:	e0bfff17 	ldw	r2,-4(fp)
 4002b48:	10bfffc4 	addi	r2,r2,-1
 4002b4c:	e0bfff15 	stw	r2,-4(fp)

    if( xSpace >= pxStreamBuffer->xLength )
 4002b50:	e0bffe17 	ldw	r2,-8(fp)
 4002b54:	10800217 	ldw	r2,8(r2)
 4002b58:	e0ffff17 	ldw	r3,-4(fp)
 4002b5c:	18800536 	bltu	r3,r2,4002b74 <xStreamBufferSpacesAvailable+0x90>
    {
        xSpace -= pxStreamBuffer->xLength;
 4002b60:	e0bffe17 	ldw	r2,-8(fp)
 4002b64:	10800217 	ldw	r2,8(r2)
 4002b68:	e0ffff17 	ldw	r3,-4(fp)
 4002b6c:	1885c83a 	sub	r2,r3,r2
 4002b70:	e0bfff15 	stw	r2,-4(fp)
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xSpace;
 4002b74:	e0bfff17 	ldw	r2,-4(fp)
}
 4002b78:	e037883a 	mov	sp,fp
 4002b7c:	df000017 	ldw	fp,0(sp)
 4002b80:	dec00104 	addi	sp,sp,4
 4002b84:	f800283a 	ret

04002b88 <xStreamBufferBytesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer )
{
 4002b88:	defffb04 	addi	sp,sp,-20
 4002b8c:	dfc00415 	stw	ra,16(sp)
 4002b90:	df000315 	stw	fp,12(sp)
 4002b94:	df000304 	addi	fp,sp,12
 4002b98:	e13ffd15 	stw	r4,-12(fp)
    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 4002b9c:	e0bffd17 	ldw	r2,-12(fp)
 4002ba0:	e0bfff15 	stw	r2,-4(fp)
    size_t xReturn;

    configASSERT( pxStreamBuffer );

    xReturn = prvBytesInBuffer( pxStreamBuffer );
 4002ba4:	e13fff17 	ldw	r4,-4(fp)
 4002ba8:	40036b80 	call	40036b8 <prvBytesInBuffer>
 4002bac:	e0bffe15 	stw	r2,-8(fp)
    return xReturn;
 4002bb0:	e0bffe17 	ldw	r2,-8(fp)
}
 4002bb4:	e037883a 	mov	sp,fp
 4002bb8:	dfc00117 	ldw	ra,4(sp)
 4002bbc:	df000017 	ldw	fp,0(sp)
 4002bc0:	dec00204 	addi	sp,sp,8
 4002bc4:	f800283a 	ret

04002bc8 <xStreamBufferSend>:

size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,
                          const void * pvTxData,
                          size_t xDataLengthBytes,
                          TickType_t xTicksToWait )
{
 4002bc8:	defff204 	addi	sp,sp,-56
 4002bcc:	dfc00d15 	stw	ra,52(sp)
 4002bd0:	df000c15 	stw	fp,48(sp)
 4002bd4:	df000c04 	addi	fp,sp,48
 4002bd8:	e13ff815 	stw	r4,-32(fp)
 4002bdc:	e17ff715 	stw	r5,-36(fp)
 4002be0:	e1bff615 	stw	r6,-40(fp)
 4002be4:	e1fff515 	stw	r7,-44(fp)
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 4002be8:	e0bff817 	ldw	r2,-32(fp)
 4002bec:	e0bffd15 	stw	r2,-12(fp)
    size_t xReturn, xSpace = 0;
 4002bf0:	e03fff15 	stw	zero,-4(fp)
    size_t xRequiredSpace = xDataLengthBytes;
 4002bf4:	e0bff617 	ldw	r2,-40(fp)
 4002bf8:	e0bffe15 	stw	r2,-8(fp)
    TimeOut_t xTimeOut;
    size_t xMaxReportedSpace = 0;
 4002bfc:	e03ffc15 	stw	zero,-16(fp)
    configASSERT( pvTxData );
    configASSERT( pxStreamBuffer );

    /* The maximum amount of space a stream buffer will ever report is its length
     * minus 1. */
    xMaxReportedSpace = pxStreamBuffer->xLength - ( size_t ) 1;
 4002c00:	e0bffd17 	ldw	r2,-12(fp)
 4002c04:	10800217 	ldw	r2,8(r2)
 4002c08:	10bfffc4 	addi	r2,r2,-1
 4002c0c:	e0bffc15 	stw	r2,-16(fp)

    /* This send function is used to write to both message buffers and stream
     * buffers.  If this is a message buffer then the space needed must be
     * increased by the amount of bytes needed to store the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 4002c10:	e0bffd17 	ldw	r2,-12(fp)
 4002c14:	10800703 	ldbu	r2,28(r2)
 4002c18:	10803fcc 	andi	r2,r2,255
 4002c1c:	1080004c 	andi	r2,r2,1
 4002c20:	10000826 	beq	r2,zero,4002c44 <xStreamBufferSend+0x7c>
    {
        xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
 4002c24:	e0bffe17 	ldw	r2,-8(fp)
 4002c28:	10800104 	addi	r2,r2,4
 4002c2c:	e0bffe15 	stw	r2,-8(fp)
        /* Overflow? */
        configASSERT( xRequiredSpace > xDataLengthBytes );

        /* If this is a message buffer then it must be possible to write the
         * whole message. */
        if( xRequiredSpace > xMaxReportedSpace )
 4002c30:	e0bffe17 	ldw	r2,-8(fp)
 4002c34:	e0fffc17 	ldw	r3,-16(fp)
 4002c38:	1880072e 	bgeu	r3,r2,4002c58 <xStreamBufferSend+0x90>
        {
            /* The message would not fit even if the entire buffer was empty,
             * so don't wait for space. */
            xTicksToWait = ( TickType_t ) 0;
 4002c3c:	e03ff515 	stw	zero,-44(fp)
 4002c40:	00000506 	br	4002c58 <xStreamBufferSend+0x90>
    else
    {
        /* If this is a stream buffer then it is acceptable to write only part
         * of the message to the buffer.  Cap the length to the total length of
         * the buffer. */
        if( xRequiredSpace > xMaxReportedSpace )
 4002c44:	e0bffe17 	ldw	r2,-8(fp)
 4002c48:	e0fffc17 	ldw	r3,-16(fp)
 4002c4c:	1880022e 	bgeu	r3,r2,4002c58 <xStreamBufferSend+0x90>
        {
            xRequiredSpace = xMaxReportedSpace;
 4002c50:	e0bffc17 	ldw	r2,-16(fp)
 4002c54:	e0bffe15 	stw	r2,-8(fp)
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    if( xTicksToWait != ( TickType_t ) 0 )
 4002c58:	e0bff517 	ldw	r2,-44(fp)
 4002c5c:	10002426 	beq	r2,zero,4002cf0 <xStreamBufferSend+0x128>
    {
        vTaskSetTimeOutState( &xTimeOut );
 4002c60:	e0bff904 	addi	r2,fp,-28
 4002c64:	1009883a 	mov	r4,r2
 4002c68:	40055440 	call	4005544 <vTaskSetTimeOutState>

        do
        {
            /* Wait until the required number of bytes are free in the message
             * buffer. */
            taskENTER_CRITICAL();
 4002c6c:	4005f740 	call	4005f74 <vTaskEnterCritical>
            {
                xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
 4002c70:	e13ffd17 	ldw	r4,-12(fp)
 4002c74:	4002ae40 	call	4002ae4 <xStreamBufferSpacesAvailable>
 4002c78:	e0bfff15 	stw	r2,-4(fp)

                if( xSpace < xRequiredSpace )
 4002c7c:	e0ffff17 	ldw	r3,-4(fp)
 4002c80:	e0bffe17 	ldw	r2,-8(fp)
 4002c84:	1880082e 	bgeu	r3,r2,4002ca8 <xStreamBufferSend+0xe0>
                {
                    /* Clear notification state as going to wait for space. */
                    ( void ) xTaskNotifyStateClear( NULL );
 4002c88:	000b883a 	mov	r5,zero
 4002c8c:	0009883a 	mov	r4,zero
 4002c90:	4006cfc0 	call	4006cfc <xTaskGenericNotifyStateClear>

                    /* Should only be one writer. */
                    configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
                    pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
 4002c94:	40059880 	call	4005988 <xTaskGetCurrentTaskHandle>
 4002c98:	1007883a 	mov	r3,r2
 4002c9c:	e0bffd17 	ldw	r2,-12(fp)
 4002ca0:	10c00515 	stw	r3,20(r2)
 4002ca4:	00000206 	br	4002cb0 <xStreamBufferSend+0xe8>
                }
                else
                {
                    taskEXIT_CRITICAL();
 4002ca8:	4005fc80 	call	4005fc8 <vTaskExitCritical>
                    break;
 4002cac:	00001006 	br	4002cf0 <xStreamBufferSend+0x128>
                }
            }
            taskEXIT_CRITICAL();
 4002cb0:	4005fc80 	call	4005fc8 <vTaskExitCritical>

            traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer );
            ( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
 4002cb4:	e0bff517 	ldw	r2,-44(fp)
 4002cb8:	d8800015 	stw	r2,0(sp)
 4002cbc:	000f883a 	mov	r7,zero
 4002cc0:	000d883a 	mov	r6,zero
 4002cc4:	000b883a 	mov	r5,zero
 4002cc8:	0009883a 	mov	r4,zero
 4002ccc:	40061ac0 	call	40061ac <xTaskGenericNotifyWait>
            pxStreamBuffer->xTaskWaitingToSend = NULL;
 4002cd0:	e0bffd17 	ldw	r2,-12(fp)
 4002cd4:	10000515 	stw	zero,20(r2)
        } while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );
 4002cd8:	e0fff504 	addi	r3,fp,-44
 4002cdc:	e0bff904 	addi	r2,fp,-28
 4002ce0:	180b883a 	mov	r5,r3
 4002ce4:	1009883a 	mov	r4,r2
 4002ce8:	40055cc0 	call	40055cc <xTaskCheckForTimeOut>
 4002cec:	103fdf26 	beq	r2,zero,4002c6c <xStreamBufferSend+0xa4>
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    if( xSpace == ( size_t ) 0 )
 4002cf0:	e0bfff17 	ldw	r2,-4(fp)
 4002cf4:	1000031e 	bne	r2,zero,4002d04 <xStreamBufferSend+0x13c>
    {
        xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
 4002cf8:	e13ffd17 	ldw	r4,-12(fp)
 4002cfc:	4002ae40 	call	4002ae4 <xStreamBufferSpacesAvailable>
 4002d00:	e0bfff15 	stw	r2,-4(fp)
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
 4002d04:	e0bffe17 	ldw	r2,-8(fp)
 4002d08:	d8800015 	stw	r2,0(sp)
 4002d0c:	e1ffff17 	ldw	r7,-4(fp)
 4002d10:	e1bff617 	ldw	r6,-40(fp)
 4002d14:	e17ff717 	ldw	r5,-36(fp)
 4002d18:	e13ffd17 	ldw	r4,-12(fp)
 4002d1c:	4002e8c0 	call	4002e8c <prvWriteMessageToBuffer>
 4002d20:	e0bffb15 	stw	r2,-20(fp)

    if( xReturn > ( size_t ) 0 )
 4002d24:	e0bffb17 	ldw	r2,-20(fp)
 4002d28:	10001526 	beq	r2,zero,4002d80 <xStreamBufferSend+0x1b8>
    {
        traceSTREAM_BUFFER_SEND( xStreamBuffer, xReturn );

        /* Was a task waiting for the data? */
        if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
 4002d2c:	e13ffd17 	ldw	r4,-12(fp)
 4002d30:	40036b80 	call	40036b8 <prvBytesInBuffer>
 4002d34:	1007883a 	mov	r3,r2
 4002d38:	e0bffd17 	ldw	r2,-12(fp)
 4002d3c:	10800317 	ldw	r2,12(r2)
 4002d40:	18800f36 	bltu	r3,r2,4002d80 <xStreamBufferSend+0x1b8>
        {
            prvSEND_COMPLETED( pxStreamBuffer );
 4002d44:	40046e80 	call	40046e8 <vTaskSuspendAll>
 4002d48:	e0bffd17 	ldw	r2,-12(fp)
 4002d4c:	10800417 	ldw	r2,16(r2)
 4002d50:	10000a26 	beq	r2,zero,4002d7c <xStreamBufferSend+0x1b4>
 4002d54:	e0bffd17 	ldw	r2,-12(fp)
 4002d58:	10800417 	ldw	r2,16(r2)
 4002d5c:	d8000015 	stw	zero,0(sp)
 4002d60:	000f883a 	mov	r7,zero
 4002d64:	000d883a 	mov	r6,zero
 4002d68:	000b883a 	mov	r5,zero
 4002d6c:	1009883a 	mov	r4,r2
 4002d70:	40063100 	call	4006310 <xTaskGenericNotify>
 4002d74:	e0bffd17 	ldw	r2,-12(fp)
 4002d78:	10000415 	stw	zero,16(r2)
 4002d7c:	40047140 	call	4004714 <xTaskResumeAll>
    {
        mtCOVERAGE_TEST_MARKER();
        traceSTREAM_BUFFER_SEND_FAILED( xStreamBuffer );
    }

    return xReturn;
 4002d80:	e0bffb17 	ldw	r2,-20(fp)
}
 4002d84:	e037883a 	mov	sp,fp
 4002d88:	dfc00117 	ldw	ra,4(sp)
 4002d8c:	df000017 	ldw	fp,0(sp)
 4002d90:	dec00204 	addi	sp,sp,8
 4002d94:	f800283a 	ret

04002d98 <xStreamBufferSendFromISR>:

size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,
                                 const void * pvTxData,
                                 size_t xDataLengthBytes,
                                 BaseType_t * const pxHigherPriorityTaskWoken )
{
 4002d98:	defff304 	addi	sp,sp,-52
 4002d9c:	dfc00c15 	stw	ra,48(sp)
 4002da0:	df000b15 	stw	fp,44(sp)
 4002da4:	df000b04 	addi	fp,sp,44
 4002da8:	e13ffa15 	stw	r4,-24(fp)
 4002dac:	e17ff915 	stw	r5,-28(fp)
 4002db0:	e1bff815 	stw	r6,-32(fp)
 4002db4:	e1fff715 	stw	r7,-36(fp)
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 4002db8:	e0bffa17 	ldw	r2,-24(fp)
 4002dbc:	e0bffe15 	stw	r2,-8(fp)
    size_t xReturn, xSpace;
    size_t xRequiredSpace = xDataLengthBytes;
 4002dc0:	e0bff817 	ldw	r2,-32(fp)
 4002dc4:	e0bfff15 	stw	r2,-4(fp)

    /* This send function is used to write to both message buffers and stream
     * buffers.  If this is a message buffer then the space needed must be
     * increased by the amount of bytes needed to store the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 4002dc8:	e0bffe17 	ldw	r2,-8(fp)
 4002dcc:	10800703 	ldbu	r2,28(r2)
 4002dd0:	10803fcc 	andi	r2,r2,255
 4002dd4:	1080004c 	andi	r2,r2,1
 4002dd8:	10000326 	beq	r2,zero,4002de8 <xStreamBufferSendFromISR+0x50>
    {
        xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
 4002ddc:	e0bfff17 	ldw	r2,-4(fp)
 4002de0:	10800104 	addi	r2,r2,4
 4002de4:	e0bfff15 	stw	r2,-4(fp)
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
 4002de8:	e13ffe17 	ldw	r4,-8(fp)
 4002dec:	4002ae40 	call	4002ae4 <xStreamBufferSpacesAvailable>
 4002df0:	e0bffd15 	stw	r2,-12(fp)
    xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
 4002df4:	e0bfff17 	ldw	r2,-4(fp)
 4002df8:	d8800015 	stw	r2,0(sp)
 4002dfc:	e1fffd17 	ldw	r7,-12(fp)
 4002e00:	e1bff817 	ldw	r6,-32(fp)
 4002e04:	e17ff917 	ldw	r5,-28(fp)
 4002e08:	e13ffe17 	ldw	r4,-8(fp)
 4002e0c:	4002e8c0 	call	4002e8c <prvWriteMessageToBuffer>
 4002e10:	e0bffc15 	stw	r2,-16(fp)

    if( xReturn > ( size_t ) 0 )
 4002e14:	e0bffc17 	ldw	r2,-16(fp)
 4002e18:	10001626 	beq	r2,zero,4002e74 <xStreamBufferSendFromISR+0xdc>
    {
        /* Was a task waiting for the data? */
        if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
 4002e1c:	e13ffe17 	ldw	r4,-8(fp)
 4002e20:	40036b80 	call	40036b8 <prvBytesInBuffer>
 4002e24:	1007883a 	mov	r3,r2
 4002e28:	e0bffe17 	ldw	r2,-8(fp)
 4002e2c:	10800317 	ldw	r2,12(r2)
 4002e30:	18801036 	bltu	r3,r2,4002e74 <xStreamBufferSendFromISR+0xdc>
        {
            prvSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
 4002e34:	e03ffb15 	stw	zero,-20(fp)
 4002e38:	e0bffe17 	ldw	r2,-8(fp)
 4002e3c:	10800417 	ldw	r2,16(r2)
 4002e40:	10000c26 	beq	r2,zero,4002e74 <xStreamBufferSendFromISR+0xdc>
 4002e44:	e0bffe17 	ldw	r2,-8(fp)
 4002e48:	10c00417 	ldw	r3,16(r2)
 4002e4c:	e0bff717 	ldw	r2,-36(fp)
 4002e50:	d8800115 	stw	r2,4(sp)
 4002e54:	d8000015 	stw	zero,0(sp)
 4002e58:	000f883a 	mov	r7,zero
 4002e5c:	000d883a 	mov	r6,zero
 4002e60:	000b883a 	mov	r5,zero
 4002e64:	1809883a 	mov	r4,r3
 4002e68:	40066580 	call	4006658 <xTaskGenericNotifyFromISR>
 4002e6c:	e0bffe17 	ldw	r2,-8(fp)
 4002e70:	10000415 	stw	zero,16(r2)
        mtCOVERAGE_TEST_MARKER();
    }

    traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xReturn );

    return xReturn;
 4002e74:	e0bffc17 	ldw	r2,-16(fp)
}
 4002e78:	e037883a 	mov	sp,fp
 4002e7c:	dfc00117 	ldw	ra,4(sp)
 4002e80:	df000017 	ldw	fp,0(sp)
 4002e84:	dec00204 	addi	sp,sp,8
 4002e88:	f800283a 	ret

04002e8c <prvWriteMessageToBuffer>:
static size_t prvWriteMessageToBuffer( StreamBuffer_t * const pxStreamBuffer,
                                       const void * pvTxData,
                                       size_t xDataLengthBytes,
                                       size_t xSpace,
                                       size_t xRequiredSpace )
{
 4002e8c:	defff804 	addi	sp,sp,-32
 4002e90:	dfc00715 	stw	ra,28(sp)
 4002e94:	df000615 	stw	fp,24(sp)
 4002e98:	df000604 	addi	fp,sp,24
 4002e9c:	e13ffd15 	stw	r4,-12(fp)
 4002ea0:	e17ffc15 	stw	r5,-16(fp)
 4002ea4:	e1bffb15 	stw	r6,-20(fp)
 4002ea8:	e1fffa15 	stw	r7,-24(fp)
    size_t xNextHead = pxStreamBuffer->xHead;
 4002eac:	e0bffd17 	ldw	r2,-12(fp)
 4002eb0:	10800117 	ldw	r2,4(r2)
 4002eb4:	e0bfff15 	stw	r2,-4(fp)
    configMESSAGE_BUFFER_LENGTH_TYPE xMessageLength;

    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 4002eb8:	e0bffd17 	ldw	r2,-12(fp)
 4002ebc:	10800703 	ldbu	r2,28(r2)
 4002ec0:	10803fcc 	andi	r2,r2,255
 4002ec4:	1080004c 	andi	r2,r2,1
 4002ec8:	10000f26 	beq	r2,zero,4002f08 <prvWriteMessageToBuffer+0x7c>
    {
        /* This is a message buffer, as opposed to a stream buffer. */

        /* Convert xDataLengthBytes to the message length type. */
        xMessageLength = ( configMESSAGE_BUFFER_LENGTH_TYPE ) xDataLengthBytes;
 4002ecc:	e0bffb17 	ldw	r2,-20(fp)
 4002ed0:	e0bffe15 	stw	r2,-8(fp)

        /* Ensure the data length given fits within configMESSAGE_BUFFER_LENGTH_TYPE. */
        configASSERT( ( size_t ) xMessageLength == xDataLengthBytes );

        if( xSpace >= xRequiredSpace )
 4002ed4:	e0fffa17 	ldw	r3,-24(fp)
 4002ed8:	e0800217 	ldw	r2,8(fp)
 4002edc:	18800836 	bltu	r3,r2,4002f00 <prvWriteMessageToBuffer+0x74>
        {
            /* There is enough space to write both the message length and the message
             * itself into the buffer.  Start by writing the length of the data, the data
             * itself will be written later in this function. */
            xNextHead = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) &( xMessageLength ), sbBYTES_TO_STORE_MESSAGE_LENGTH, xNextHead );
 4002ee0:	e0bffe04 	addi	r2,fp,-8
 4002ee4:	e1ffff17 	ldw	r7,-4(fp)
 4002ee8:	01800104 	movi	r6,4
 4002eec:	100b883a 	mov	r5,r2
 4002ef0:	e13ffd17 	ldw	r4,-12(fp)
 4002ef4:	40034f80 	call	40034f8 <prvWriteBytesToBuffer>
 4002ef8:	e0bfff15 	stw	r2,-4(fp)
 4002efc:	00000706 	br	4002f1c <prvWriteMessageToBuffer+0x90>
        }
        else
        {
            /* Not enough space, so do not write data to the buffer. */
            xDataLengthBytes = 0;
 4002f00:	e03ffb15 	stw	zero,-20(fp)
 4002f04:	00000506 	br	4002f1c <prvWriteMessageToBuffer+0x90>
    else
    {
        /* This is a stream buffer, as opposed to a message buffer, so writing a
         * stream of bytes rather than discrete messages.  Plan to write as many
         * bytes as possible. */
        xDataLengthBytes = configMIN( xDataLengthBytes, xSpace );
 4002f08:	e0fffb17 	ldw	r3,-20(fp)
 4002f0c:	e0bffa17 	ldw	r2,-24(fp)
 4002f10:	1880012e 	bgeu	r3,r2,4002f18 <prvWriteMessageToBuffer+0x8c>
 4002f14:	1805883a 	mov	r2,r3
 4002f18:	e0bffb15 	stw	r2,-20(fp)
    }

    if( xDataLengthBytes != ( size_t ) 0 )
 4002f1c:	e0bffb17 	ldw	r2,-20(fp)
 4002f20:	10000826 	beq	r2,zero,4002f44 <prvWriteMessageToBuffer+0xb8>
    {
        /* Write the data to the buffer. */
        pxStreamBuffer->xHead = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes, xNextHead ); /*lint !e9079 Storage buffer is implemented as uint8_t for ease of sizing, alignment and access. */
 4002f24:	e1ffff17 	ldw	r7,-4(fp)
 4002f28:	e1bffb17 	ldw	r6,-20(fp)
 4002f2c:	e17ffc17 	ldw	r5,-16(fp)
 4002f30:	e13ffd17 	ldw	r4,-12(fp)
 4002f34:	40034f80 	call	40034f8 <prvWriteBytesToBuffer>
 4002f38:	1007883a 	mov	r3,r2
 4002f3c:	e0bffd17 	ldw	r2,-12(fp)
 4002f40:	10c00115 	stw	r3,4(r2)
    }

    return xDataLengthBytes;
 4002f44:	e0bffb17 	ldw	r2,-20(fp)
}
 4002f48:	e037883a 	mov	sp,fp
 4002f4c:	dfc00117 	ldw	ra,4(sp)
 4002f50:	df000017 	ldw	fp,0(sp)
 4002f54:	dec00204 	addi	sp,sp,8
 4002f58:	f800283a 	ret

04002f5c <xStreamBufferReceive>:

size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,
                             void * pvRxData,
                             size_t xBufferLengthBytes,
                             TickType_t xTicksToWait )
{
 4002f5c:	defff504 	addi	sp,sp,-44
 4002f60:	dfc00a15 	stw	ra,40(sp)
 4002f64:	df000915 	stw	fp,36(sp)
 4002f68:	df000904 	addi	fp,sp,36
 4002f6c:	e13ffb15 	stw	r4,-20(fp)
 4002f70:	e17ffa15 	stw	r5,-24(fp)
 4002f74:	e1bff915 	stw	r6,-28(fp)
 4002f78:	e1fff815 	stw	r7,-32(fp)
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 4002f7c:	e0bffb17 	ldw	r2,-20(fp)
 4002f80:	e0bffc15 	stw	r2,-16(fp)
    size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
 4002f84:	e03fff15 	stw	zero,-4(fp)
    /* This receive function is used by both message buffers, which store
     * discrete messages, and stream buffers, which store a continuous stream of
     * bytes.  Discrete messages include an additional
     * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 4002f88:	e0bffc17 	ldw	r2,-16(fp)
 4002f8c:	10800703 	ldbu	r2,28(r2)
 4002f90:	10803fcc 	andi	r2,r2,255
 4002f94:	1080004c 	andi	r2,r2,1
 4002f98:	10000326 	beq	r2,zero,4002fa8 <xStreamBufferReceive+0x4c>
    {
        xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
 4002f9c:	00800104 	movi	r2,4
 4002fa0:	e0bffd15 	stw	r2,-12(fp)
 4002fa4:	00000106 	br	4002fac <xStreamBufferReceive+0x50>
    }
    else
    {
        xBytesToStoreMessageLength = 0;
 4002fa8:	e03ffd15 	stw	zero,-12(fp)
    }

    if( xTicksToWait != ( TickType_t ) 0 )
 4002fac:	e0bff817 	ldw	r2,-32(fp)
 4002fb0:	10001f26 	beq	r2,zero,4003030 <xStreamBufferReceive+0xd4>
    {
        /* Checking if there is data and clearing the notification state must be
         * performed atomically. */
        taskENTER_CRITICAL();
 4002fb4:	4005f740 	call	4005f74 <vTaskEnterCritical>
        {
            xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
 4002fb8:	e13ffc17 	ldw	r4,-16(fp)
 4002fbc:	40036b80 	call	40036b8 <prvBytesInBuffer>
 4002fc0:	e0bffe15 	stw	r2,-8(fp)
            /* If this function was invoked by a message buffer read then
             * xBytesToStoreMessageLength holds the number of bytes used to hold
             * the length of the next discrete message.  If this function was
             * invoked by a stream buffer read then xBytesToStoreMessageLength will
             * be 0. */
            if( xBytesAvailable <= xBytesToStoreMessageLength )
 4002fc4:	e0bffe17 	ldw	r2,-8(fp)
 4002fc8:	e0fffd17 	ldw	r3,-12(fp)
 4002fcc:	18800736 	bltu	r3,r2,4002fec <xStreamBufferReceive+0x90>
            {
                /* Clear notification state as going to wait for data. */
                ( void ) xTaskNotifyStateClear( NULL );
 4002fd0:	000b883a 	mov	r5,zero
 4002fd4:	0009883a 	mov	r4,zero
 4002fd8:	4006cfc0 	call	4006cfc <xTaskGenericNotifyStateClear>

                /* Should only be one reader. */
                configASSERT( pxStreamBuffer->xTaskWaitingToReceive == NULL );
                pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();
 4002fdc:	40059880 	call	4005988 <xTaskGetCurrentTaskHandle>
 4002fe0:	1007883a 	mov	r3,r2
 4002fe4:	e0bffc17 	ldw	r2,-16(fp)
 4002fe8:	10c00415 	stw	r3,16(r2)
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
 4002fec:	4005fc80 	call	4005fc8 <vTaskExitCritical>

        if( xBytesAvailable <= xBytesToStoreMessageLength )
 4002ff0:	e0bffe17 	ldw	r2,-8(fp)
 4002ff4:	e0fffd17 	ldw	r3,-12(fp)
 4002ff8:	18801036 	bltu	r3,r2,400303c <xStreamBufferReceive+0xe0>
        {
            /* Wait for data to be available. */
            traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer );
            ( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
 4002ffc:	e0bff817 	ldw	r2,-32(fp)
 4003000:	d8800015 	stw	r2,0(sp)
 4003004:	000f883a 	mov	r7,zero
 4003008:	000d883a 	mov	r6,zero
 400300c:	000b883a 	mov	r5,zero
 4003010:	0009883a 	mov	r4,zero
 4003014:	40061ac0 	call	40061ac <xTaskGenericNotifyWait>
            pxStreamBuffer->xTaskWaitingToReceive = NULL;
 4003018:	e0bffc17 	ldw	r2,-16(fp)
 400301c:	10000415 	stw	zero,16(r2)

            /* Recheck the data available after blocking. */
            xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
 4003020:	e13ffc17 	ldw	r4,-16(fp)
 4003024:	40036b80 	call	40036b8 <prvBytesInBuffer>
 4003028:	e0bffe15 	stw	r2,-8(fp)
 400302c:	00000306 	br	400303c <xStreamBufferReceive+0xe0>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
 4003030:	e13ffc17 	ldw	r4,-16(fp)
 4003034:	40036b80 	call	40036b8 <prvBytesInBuffer>
 4003038:	e0bffe15 	stw	r2,-8(fp)
    /* Whether receiving a discrete message (where xBytesToStoreMessageLength
     * holds the number of bytes used to store the message length) or a stream of
     * bytes (where xBytesToStoreMessageLength is zero), the number of bytes
     * available must be greater than xBytesToStoreMessageLength to be able to
     * read bytes from the buffer. */
    if( xBytesAvailable > xBytesToStoreMessageLength )
 400303c:	e0bffe17 	ldw	r2,-8(fp)
 4003040:	e0fffd17 	ldw	r3,-12(fp)
 4003044:	1880172e 	bgeu	r3,r2,40030a4 <xStreamBufferReceive+0x148>
    {
        xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable );
 4003048:	e1fffe17 	ldw	r7,-8(fp)
 400304c:	e1bff917 	ldw	r6,-28(fp)
 4003050:	e17ffa17 	ldw	r5,-24(fp)
 4003054:	e13ffc17 	ldw	r4,-16(fp)
 4003058:	40032340 	call	4003234 <prvReadMessageFromBuffer>
 400305c:	e0bfff15 	stw	r2,-4(fp)

        /* Was a task waiting for space in the buffer? */
        if( xReceivedLength != ( size_t ) 0 )
 4003060:	e0bfff17 	ldw	r2,-4(fp)
 4003064:	10000f26 	beq	r2,zero,40030a4 <xStreamBufferReceive+0x148>
        {
            traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength );
            prvRECEIVE_COMPLETED( xStreamBuffer );
 4003068:	40046e80 	call	40046e8 <vTaskSuspendAll>
 400306c:	e0bffb17 	ldw	r2,-20(fp)
 4003070:	10800517 	ldw	r2,20(r2)
 4003074:	10000a26 	beq	r2,zero,40030a0 <xStreamBufferReceive+0x144>
 4003078:	e0bffb17 	ldw	r2,-20(fp)
 400307c:	10800517 	ldw	r2,20(r2)
 4003080:	d8000015 	stw	zero,0(sp)
 4003084:	000f883a 	mov	r7,zero
 4003088:	000d883a 	mov	r6,zero
 400308c:	000b883a 	mov	r5,zero
 4003090:	1009883a 	mov	r4,r2
 4003094:	40063100 	call	4006310 <xTaskGenericNotify>
 4003098:	e0bffb17 	ldw	r2,-20(fp)
 400309c:	10000515 	stw	zero,20(r2)
 40030a0:	40047140 	call	4004714 <xTaskResumeAll>
    {
        traceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer );
        mtCOVERAGE_TEST_MARKER();
    }

    return xReceivedLength;
 40030a4:	e0bfff17 	ldw	r2,-4(fp)
}
 40030a8:	e037883a 	mov	sp,fp
 40030ac:	dfc00117 	ldw	ra,4(sp)
 40030b0:	df000017 	ldw	fp,0(sp)
 40030b4:	dec00204 	addi	sp,sp,8
 40030b8:	f800283a 	ret

040030bc <xStreamBufferNextMessageLengthBytes>:
/*-----------------------------------------------------------*/

size_t xStreamBufferNextMessageLengthBytes( StreamBufferHandle_t xStreamBuffer )
{
 40030bc:	defff904 	addi	sp,sp,-28
 40030c0:	dfc00615 	stw	ra,24(sp)
 40030c4:	df000515 	stw	fp,20(sp)
 40030c8:	df000504 	addi	fp,sp,20
 40030cc:	e13ffb15 	stw	r4,-20(fp)
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 40030d0:	e0bffb17 	ldw	r2,-20(fp)
 40030d4:	e0bffe15 	stw	r2,-8(fp)
    configMESSAGE_BUFFER_LENGTH_TYPE xTempReturn;

    configASSERT( pxStreamBuffer );

    /* Ensure the stream buffer is being used as a message buffer. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 40030d8:	e0bffe17 	ldw	r2,-8(fp)
 40030dc:	10800703 	ldbu	r2,28(r2)
 40030e0:	10803fcc 	andi	r2,r2,255
 40030e4:	1080004c 	andi	r2,r2,1
 40030e8:	10001326 	beq	r2,zero,4003138 <xStreamBufferNextMessageLengthBytes+0x7c>
    {
        xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
 40030ec:	e13ffe17 	ldw	r4,-8(fp)
 40030f0:	40036b80 	call	40036b8 <prvBytesInBuffer>
 40030f4:	e0bffd15 	stw	r2,-12(fp)

        if( xBytesAvailable > sbBYTES_TO_STORE_MESSAGE_LENGTH )
 40030f8:	e0bffd17 	ldw	r2,-12(fp)
 40030fc:	10800170 	cmpltui	r2,r2,5
 4003100:	10000b1e 	bne	r2,zero,4003130 <xStreamBufferNextMessageLengthBytes+0x74>
        {
            /* The number of bytes available is greater than the number of bytes
             * required to hold the length of the next message, so another message
             * is available. */
            ( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempReturn, sbBYTES_TO_STORE_MESSAGE_LENGTH, pxStreamBuffer->xTail );
 4003104:	e0bffe17 	ldw	r2,-8(fp)
 4003108:	10c00017 	ldw	r3,0(r2)
 400310c:	e0bffc04 	addi	r2,fp,-16
 4003110:	180f883a 	mov	r7,r3
 4003114:	01800104 	movi	r6,4
 4003118:	100b883a 	mov	r5,r2
 400311c:	e13ffe17 	ldw	r4,-8(fp)
 4003120:	40035d80 	call	40035d8 <prvReadBytesFromBuffer>
            xReturn = ( size_t ) xTempReturn;
 4003124:	e0bffc17 	ldw	r2,-16(fp)
 4003128:	e0bfff15 	stw	r2,-4(fp)
 400312c:	00000306 	br	400313c <xStreamBufferNextMessageLengthBytes+0x80>
            /* The minimum amount of bytes in a message buffer is
             * ( sbBYTES_TO_STORE_MESSAGE_LENGTH + 1 ), so if xBytesAvailable is
             * less than sbBYTES_TO_STORE_MESSAGE_LENGTH the only other valid
             * value is 0. */
            configASSERT( xBytesAvailable == 0 );
            xReturn = 0;
 4003130:	e03fff15 	stw	zero,-4(fp)
 4003134:	00000106 	br	400313c <xStreamBufferNextMessageLengthBytes+0x80>
        }
    }
    else
    {
        xReturn = 0;
 4003138:	e03fff15 	stw	zero,-4(fp)
    }

    return xReturn;
 400313c:	e0bfff17 	ldw	r2,-4(fp)
}
 4003140:	e037883a 	mov	sp,fp
 4003144:	dfc00117 	ldw	ra,4(sp)
 4003148:	df000017 	ldw	fp,0(sp)
 400314c:	dec00204 	addi	sp,sp,8
 4003150:	f800283a 	ret

04003154 <xStreamBufferReceiveFromISR>:

size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,
                                    void * pvRxData,
                                    size_t xBufferLengthBytes,
                                    BaseType_t * const pxHigherPriorityTaskWoken )
{
 4003154:	defff304 	addi	sp,sp,-52
 4003158:	dfc00c15 	stw	ra,48(sp)
 400315c:	df000b15 	stw	fp,44(sp)
 4003160:	df000b04 	addi	fp,sp,44
 4003164:	e13ffa15 	stw	r4,-24(fp)
 4003168:	e17ff915 	stw	r5,-28(fp)
 400316c:	e1bff815 	stw	r6,-32(fp)
 4003170:	e1fff715 	stw	r7,-36(fp)
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 4003174:	e0bffa17 	ldw	r2,-24(fp)
 4003178:	e0bffd15 	stw	r2,-12(fp)
    size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
 400317c:	e03fff15 	stw	zero,-4(fp)
    /* This receive function is used by both message buffers, which store
     * discrete messages, and stream buffers, which store a continuous stream of
     * bytes.  Discrete messages include an additional
     * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 4003180:	e0bffd17 	ldw	r2,-12(fp)
 4003184:	10800703 	ldbu	r2,28(r2)
 4003188:	10803fcc 	andi	r2,r2,255
 400318c:	1080004c 	andi	r2,r2,1
 4003190:	10000326 	beq	r2,zero,40031a0 <xStreamBufferReceiveFromISR+0x4c>
    {
        xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
 4003194:	00800104 	movi	r2,4
 4003198:	e0bffe15 	stw	r2,-8(fp)
 400319c:	00000106 	br	40031a4 <xStreamBufferReceiveFromISR+0x50>
    }
    else
    {
        xBytesToStoreMessageLength = 0;
 40031a0:	e03ffe15 	stw	zero,-8(fp)
    }

    xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
 40031a4:	e13ffd17 	ldw	r4,-12(fp)
 40031a8:	40036b80 	call	40036b8 <prvBytesInBuffer>
 40031ac:	e0bffc15 	stw	r2,-16(fp)
    /* Whether receiving a discrete message (where xBytesToStoreMessageLength
     * holds the number of bytes used to store the message length) or a stream of
     * bytes (where xBytesToStoreMessageLength is zero), the number of bytes
     * available must be greater than xBytesToStoreMessageLength to be able to
     * read bytes from the buffer. */
    if( xBytesAvailable > xBytesToStoreMessageLength )
 40031b0:	e0bffc17 	ldw	r2,-16(fp)
 40031b4:	e0fffe17 	ldw	r3,-8(fp)
 40031b8:	1880182e 	bgeu	r3,r2,400321c <xStreamBufferReceiveFromISR+0xc8>
    {
        xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable );
 40031bc:	e1fffc17 	ldw	r7,-16(fp)
 40031c0:	e1bff817 	ldw	r6,-32(fp)
 40031c4:	e17ff917 	ldw	r5,-28(fp)
 40031c8:	e13ffd17 	ldw	r4,-12(fp)
 40031cc:	40032340 	call	4003234 <prvReadMessageFromBuffer>
 40031d0:	e0bfff15 	stw	r2,-4(fp)

        /* Was a task waiting for space in the buffer? */
        if( xReceivedLength != ( size_t ) 0 )
 40031d4:	e0bfff17 	ldw	r2,-4(fp)
 40031d8:	10001026 	beq	r2,zero,400321c <xStreamBufferReceiveFromISR+0xc8>
        {
            prvRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
 40031dc:	e03ffb15 	stw	zero,-20(fp)
 40031e0:	e0bffd17 	ldw	r2,-12(fp)
 40031e4:	10800517 	ldw	r2,20(r2)
 40031e8:	10000c26 	beq	r2,zero,400321c <xStreamBufferReceiveFromISR+0xc8>
 40031ec:	e0bffd17 	ldw	r2,-12(fp)
 40031f0:	10c00517 	ldw	r3,20(r2)
 40031f4:	e0bff717 	ldw	r2,-36(fp)
 40031f8:	d8800115 	stw	r2,4(sp)
 40031fc:	d8000015 	stw	zero,0(sp)
 4003200:	000f883a 	mov	r7,zero
 4003204:	000d883a 	mov	r6,zero
 4003208:	000b883a 	mov	r5,zero
 400320c:	1809883a 	mov	r4,r3
 4003210:	40066580 	call	4006658 <xTaskGenericNotifyFromISR>
 4003214:	e0bffd17 	ldw	r2,-12(fp)
 4003218:	10000515 	stw	zero,20(r2)
        mtCOVERAGE_TEST_MARKER();
    }

    traceSTREAM_BUFFER_RECEIVE_FROM_ISR( xStreamBuffer, xReceivedLength );

    return xReceivedLength;
 400321c:	e0bfff17 	ldw	r2,-4(fp)
}
 4003220:	e037883a 	mov	sp,fp
 4003224:	dfc00117 	ldw	ra,4(sp)
 4003228:	df000017 	ldw	fp,0(sp)
 400322c:	dec00204 	addi	sp,sp,8
 4003230:	f800283a 	ret

04003234 <prvReadMessageFromBuffer>:

static size_t prvReadMessageFromBuffer( StreamBuffer_t * pxStreamBuffer,
                                        void * pvRxData,
                                        size_t xBufferLengthBytes,
                                        size_t xBytesAvailable )
{
 4003234:	defff604 	addi	sp,sp,-40
 4003238:	dfc00915 	stw	ra,36(sp)
 400323c:	df000815 	stw	fp,32(sp)
 4003240:	df000804 	addi	fp,sp,32
 4003244:	e13ffb15 	stw	r4,-20(fp)
 4003248:	e17ffa15 	stw	r5,-24(fp)
 400324c:	e1bff915 	stw	r6,-28(fp)
 4003250:	e1fff815 	stw	r7,-32(fp)
    size_t xCount, xNextMessageLength;
    configMESSAGE_BUFFER_LENGTH_TYPE xTempNextMessageLength;
    size_t xNextTail = pxStreamBuffer->xTail;
 4003254:	e0bffb17 	ldw	r2,-20(fp)
 4003258:	10800017 	ldw	r2,0(r2)
 400325c:	e0bffe15 	stw	r2,-8(fp)

    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 4003260:	e0bffb17 	ldw	r2,-20(fp)
 4003264:	10800703 	ldbu	r2,28(r2)
 4003268:	10803fcc 	andi	r2,r2,255
 400326c:	1080004c 	andi	r2,r2,1
 4003270:	10001126 	beq	r2,zero,40032b8 <prvReadMessageFromBuffer+0x84>
    {
        /* A discrete message is being received.  First receive the length
         * of the message. */
        xNextTail = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, sbBYTES_TO_STORE_MESSAGE_LENGTH, xNextTail );
 4003274:	e0bffc04 	addi	r2,fp,-16
 4003278:	e1fffe17 	ldw	r7,-8(fp)
 400327c:	01800104 	movi	r6,4
 4003280:	100b883a 	mov	r5,r2
 4003284:	e13ffb17 	ldw	r4,-20(fp)
 4003288:	40035d80 	call	40035d8 <prvReadBytesFromBuffer>
 400328c:	e0bffe15 	stw	r2,-8(fp)
        xNextMessageLength = ( size_t ) xTempNextMessageLength;
 4003290:	e0bffc17 	ldw	r2,-16(fp)
 4003294:	e0bfff15 	stw	r2,-4(fp)

        /* Reduce the number of bytes available by the number of bytes just
         * read out. */
        xBytesAvailable -= sbBYTES_TO_STORE_MESSAGE_LENGTH;
 4003298:	e0bff817 	ldw	r2,-32(fp)
 400329c:	10bfff04 	addi	r2,r2,-4
 40032a0:	e0bff815 	stw	r2,-32(fp)

        /* Check there is enough space in the buffer provided by the
         * user. */
        if( xNextMessageLength > xBufferLengthBytes )
 40032a4:	e0bfff17 	ldw	r2,-4(fp)
 40032a8:	e0fff917 	ldw	r3,-28(fp)
 40032ac:	1880042e 	bgeu	r3,r2,40032c0 <prvReadMessageFromBuffer+0x8c>
        {
            /* The user has provided insufficient space to read the message. */
            xNextMessageLength = 0;
 40032b0:	e03fff15 	stw	zero,-4(fp)
 40032b4:	00000206 	br	40032c0 <prvReadMessageFromBuffer+0x8c>
    }
    else
    {
        /* A stream of bytes is being received (as opposed to a discrete
         * message), so read as many bytes as possible. */
        xNextMessageLength = xBufferLengthBytes;
 40032b8:	e0bff917 	ldw	r2,-28(fp)
 40032bc:	e0bfff15 	stw	r2,-4(fp)
    }

    /* Use the minimum of the wanted bytes and the available bytes. */
    xCount = configMIN( xNextMessageLength, xBytesAvailable );
 40032c0:	e0ffff17 	ldw	r3,-4(fp)
 40032c4:	e0bff817 	ldw	r2,-32(fp)
 40032c8:	1880012e 	bgeu	r3,r2,40032d0 <prvReadMessageFromBuffer+0x9c>
 40032cc:	1805883a 	mov	r2,r3
 40032d0:	e0bffd15 	stw	r2,-12(fp)

    if( xCount != ( size_t ) 0 )
 40032d4:	e0bffd17 	ldw	r2,-12(fp)
 40032d8:	10000826 	beq	r2,zero,40032fc <prvReadMessageFromBuffer+0xc8>
    {
        /* Read the actual data and update the tail to mark the data as officially consumed. */
        pxStreamBuffer->xTail = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) pvRxData, xCount, xNextTail ); /*lint !e9079 Data storage area is implemented as uint8_t array for ease of sizing, indexing and alignment. */
 40032dc:	e1fffe17 	ldw	r7,-8(fp)
 40032e0:	e1bffd17 	ldw	r6,-12(fp)
 40032e4:	e17ffa17 	ldw	r5,-24(fp)
 40032e8:	e13ffb17 	ldw	r4,-20(fp)
 40032ec:	40035d80 	call	40035d8 <prvReadBytesFromBuffer>
 40032f0:	1007883a 	mov	r3,r2
 40032f4:	e0bffb17 	ldw	r2,-20(fp)
 40032f8:	10c00015 	stw	r3,0(r2)
    }

    return xCount;
 40032fc:	e0bffd17 	ldw	r2,-12(fp)
}
 4003300:	e037883a 	mov	sp,fp
 4003304:	dfc00117 	ldw	ra,4(sp)
 4003308:	df000017 	ldw	fp,0(sp)
 400330c:	dec00204 	addi	sp,sp,8
 4003310:	f800283a 	ret

04003314 <xStreamBufferIsEmpty>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer )
{
 4003314:	defffb04 	addi	sp,sp,-20
 4003318:	df000415 	stw	fp,16(sp)
 400331c:	df000404 	addi	fp,sp,16
 4003320:	e13ffc15 	stw	r4,-16(fp)
    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 4003324:	e0bffc17 	ldw	r2,-16(fp)
 4003328:	e0bffe15 	stw	r2,-8(fp)
    size_t xTail;

    configASSERT( pxStreamBuffer );

    /* True if no bytes are available. */
    xTail = pxStreamBuffer->xTail;
 400332c:	e0bffe17 	ldw	r2,-8(fp)
 4003330:	10800017 	ldw	r2,0(r2)
 4003334:	e0bffd15 	stw	r2,-12(fp)

    if( pxStreamBuffer->xHead == xTail )
 4003338:	e0bffe17 	ldw	r2,-8(fp)
 400333c:	10800117 	ldw	r2,4(r2)
 4003340:	e0fffd17 	ldw	r3,-12(fp)
 4003344:	1880031e 	bne	r3,r2,4003354 <xStreamBufferIsEmpty+0x40>
    {
        xReturn = pdTRUE;
 4003348:	00800044 	movi	r2,1
 400334c:	e0bfff15 	stw	r2,-4(fp)
 4003350:	00000106 	br	4003358 <xStreamBufferIsEmpty+0x44>
    }
    else
    {
        xReturn = pdFALSE;
 4003354:	e03fff15 	stw	zero,-4(fp)
    }

    return xReturn;
 4003358:	e0bfff17 	ldw	r2,-4(fp)
}
 400335c:	e037883a 	mov	sp,fp
 4003360:	df000017 	ldw	fp,0(sp)
 4003364:	dec00104 	addi	sp,sp,4
 4003368:	f800283a 	ret

0400336c <xStreamBufferIsFull>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer )
{
 400336c:	defffa04 	addi	sp,sp,-24
 4003370:	dfc00515 	stw	ra,20(sp)
 4003374:	df000415 	stw	fp,16(sp)
 4003378:	df000404 	addi	fp,sp,16
 400337c:	e13ffc15 	stw	r4,-16(fp)
    BaseType_t xReturn;
    size_t xBytesToStoreMessageLength;
    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 4003380:	e0bffc17 	ldw	r2,-16(fp)
 4003384:	e0bffd15 	stw	r2,-12(fp)

    /* This generic version of the receive function is used by both message
     * buffers, which store discrete messages, and stream buffers, which store a
     * continuous stream of bytes.  Discrete messages include an additional
     * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 4003388:	e0bffd17 	ldw	r2,-12(fp)
 400338c:	10800703 	ldbu	r2,28(r2)
 4003390:	10803fcc 	andi	r2,r2,255
 4003394:	1080004c 	andi	r2,r2,1
 4003398:	10000326 	beq	r2,zero,40033a8 <xStreamBufferIsFull+0x3c>
    {
        xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
 400339c:	00800104 	movi	r2,4
 40033a0:	e0bffe15 	stw	r2,-8(fp)
 40033a4:	00000106 	br	40033ac <xStreamBufferIsFull+0x40>
    }
    else
    {
        xBytesToStoreMessageLength = 0;
 40033a8:	e03ffe15 	stw	zero,-8(fp)
    }

    /* True if the available space equals zero. */
    if( xStreamBufferSpacesAvailable( xStreamBuffer ) <= xBytesToStoreMessageLength )
 40033ac:	e13ffc17 	ldw	r4,-16(fp)
 40033b0:	4002ae40 	call	4002ae4 <xStreamBufferSpacesAvailable>
 40033b4:	1007883a 	mov	r3,r2
 40033b8:	e0bffe17 	ldw	r2,-8(fp)
 40033bc:	10c00336 	bltu	r2,r3,40033cc <xStreamBufferIsFull+0x60>
    {
        xReturn = pdTRUE;
 40033c0:	00800044 	movi	r2,1
 40033c4:	e0bfff15 	stw	r2,-4(fp)
 40033c8:	00000106 	br	40033d0 <xStreamBufferIsFull+0x64>
    }
    else
    {
        xReturn = pdFALSE;
 40033cc:	e03fff15 	stw	zero,-4(fp)
    }

    return xReturn;
 40033d0:	e0bfff17 	ldw	r2,-4(fp)
}
 40033d4:	e037883a 	mov	sp,fp
 40033d8:	dfc00117 	ldw	ra,4(sp)
 40033dc:	df000017 	ldw	fp,0(sp)
 40033e0:	dec00204 	addi	sp,sp,8
 40033e4:	f800283a 	ret

040033e8 <xStreamBufferSendCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer,
                                              BaseType_t * pxHigherPriorityTaskWoken )
{
 40033e8:	defff704 	addi	sp,sp,-36
 40033ec:	dfc00815 	stw	ra,32(sp)
 40033f0:	df000715 	stw	fp,28(sp)
 40033f4:	df000704 	addi	fp,sp,28
 40033f8:	e13ffc15 	stw	r4,-16(fp)
 40033fc:	e17ffb15 	stw	r5,-20(fp)
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 4003400:	e0bffc17 	ldw	r2,-16(fp)
 4003404:	e0bffe15 	stw	r2,-8(fp)
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;

    configASSERT( pxStreamBuffer );

    uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
 4003408:	e03ffd15 	stw	zero,-12(fp)
    {
        if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )
 400340c:	e0bffe17 	ldw	r2,-8(fp)
 4003410:	10800417 	ldw	r2,16(r2)
 4003414:	10000f26 	beq	r2,zero,4003454 <xStreamBufferSendCompletedFromISR+0x6c>
        {
            ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,
 4003418:	e0bffe17 	ldw	r2,-8(fp)
 400341c:	10c00417 	ldw	r3,16(r2)
 4003420:	e0bffb17 	ldw	r2,-20(fp)
 4003424:	d8800115 	stw	r2,4(sp)
 4003428:	d8000015 	stw	zero,0(sp)
 400342c:	000f883a 	mov	r7,zero
 4003430:	000d883a 	mov	r6,zero
 4003434:	000b883a 	mov	r5,zero
 4003438:	1809883a 	mov	r4,r3
 400343c:	40066580 	call	4006658 <xTaskGenericNotifyFromISR>
                                         ( uint32_t ) 0,
                                         eNoAction,
                                         pxHigherPriorityTaskWoken );
            ( pxStreamBuffer )->xTaskWaitingToReceive = NULL;
 4003440:	e0bffe17 	ldw	r2,-8(fp)
 4003444:	10000415 	stw	zero,16(r2)
            xReturn = pdTRUE;
 4003448:	00800044 	movi	r2,1
 400344c:	e0bfff15 	stw	r2,-4(fp)
 4003450:	00000106 	br	4003458 <xStreamBufferSendCompletedFromISR+0x70>
        }
        else
        {
            xReturn = pdFALSE;
 4003454:	e03fff15 	stw	zero,-4(fp)
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
 4003458:	e0bfff17 	ldw	r2,-4(fp)
}
 400345c:	e037883a 	mov	sp,fp
 4003460:	dfc00117 	ldw	ra,4(sp)
 4003464:	df000017 	ldw	fp,0(sp)
 4003468:	dec00204 	addi	sp,sp,8
 400346c:	f800283a 	ret

04003470 <xStreamBufferReceiveCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer,
                                                 BaseType_t * pxHigherPriorityTaskWoken )
{
 4003470:	defff704 	addi	sp,sp,-36
 4003474:	dfc00815 	stw	ra,32(sp)
 4003478:	df000715 	stw	fp,28(sp)
 400347c:	df000704 	addi	fp,sp,28
 4003480:	e13ffc15 	stw	r4,-16(fp)
 4003484:	e17ffb15 	stw	r5,-20(fp)
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 4003488:	e0bffc17 	ldw	r2,-16(fp)
 400348c:	e0bffe15 	stw	r2,-8(fp)
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;

    configASSERT( pxStreamBuffer );

    uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
 4003490:	e03ffd15 	stw	zero,-12(fp)
    {
        if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )
 4003494:	e0bffe17 	ldw	r2,-8(fp)
 4003498:	10800517 	ldw	r2,20(r2)
 400349c:	10000f26 	beq	r2,zero,40034dc <xStreamBufferReceiveCompletedFromISR+0x6c>
        {
            ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,
 40034a0:	e0bffe17 	ldw	r2,-8(fp)
 40034a4:	10c00517 	ldw	r3,20(r2)
 40034a8:	e0bffb17 	ldw	r2,-20(fp)
 40034ac:	d8800115 	stw	r2,4(sp)
 40034b0:	d8000015 	stw	zero,0(sp)
 40034b4:	000f883a 	mov	r7,zero
 40034b8:	000d883a 	mov	r6,zero
 40034bc:	000b883a 	mov	r5,zero
 40034c0:	1809883a 	mov	r4,r3
 40034c4:	40066580 	call	4006658 <xTaskGenericNotifyFromISR>
                                         ( uint32_t ) 0,
                                         eNoAction,
                                         pxHigherPriorityTaskWoken );
            ( pxStreamBuffer )->xTaskWaitingToSend = NULL;
 40034c8:	e0bffe17 	ldw	r2,-8(fp)
 40034cc:	10000515 	stw	zero,20(r2)
            xReturn = pdTRUE;
 40034d0:	00800044 	movi	r2,1
 40034d4:	e0bfff15 	stw	r2,-4(fp)
 40034d8:	00000106 	br	40034e0 <xStreamBufferReceiveCompletedFromISR+0x70>
        }
        else
        {
            xReturn = pdFALSE;
 40034dc:	e03fff15 	stw	zero,-4(fp)
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
 40034e0:	e0bfff17 	ldw	r2,-4(fp)
}
 40034e4:	e037883a 	mov	sp,fp
 40034e8:	dfc00117 	ldw	ra,4(sp)
 40034ec:	df000017 	ldw	fp,0(sp)
 40034f0:	dec00204 	addi	sp,sp,8
 40034f4:	f800283a 	ret

040034f8 <prvWriteBytesToBuffer>:

static size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer,
                                     const uint8_t * pucData,
                                     size_t xCount,
                                     size_t xHead )
{
 40034f8:	defff904 	addi	sp,sp,-28
 40034fc:	dfc00615 	stw	ra,24(sp)
 4003500:	df000515 	stw	fp,20(sp)
 4003504:	df000504 	addi	fp,sp,20
 4003508:	e13ffe15 	stw	r4,-8(fp)
 400350c:	e17ffd15 	stw	r5,-12(fp)
 4003510:	e1bffc15 	stw	r6,-16(fp)
 4003514:	e1fffb15 	stw	r7,-20(fp)
    configASSERT( xCount > ( size_t ) 0 );

    /* Calculate the number of bytes that can be added in the first write -
     * which may be less than the total number of bytes that need to be added if
     * the buffer will wrap back to the beginning. */
    xFirstLength = configMIN( pxStreamBuffer->xLength - xHead, xCount );
 4003518:	e0bffe17 	ldw	r2,-8(fp)
 400351c:	10c00217 	ldw	r3,8(r2)
 4003520:	e0bffb17 	ldw	r2,-20(fp)
 4003524:	1887c83a 	sub	r3,r3,r2
 4003528:	e0bffc17 	ldw	r2,-16(fp)
 400352c:	1880012e 	bgeu	r3,r2,4003534 <prvWriteBytesToBuffer+0x3c>
 4003530:	1805883a 	mov	r2,r3
 4003534:	e0bfff15 	stw	r2,-4(fp)

    /* Write as many bytes as can be written in the first write. */
    configASSERT( ( xHead + xFirstLength ) <= pxStreamBuffer->xLength );
    ( void ) memcpy( ( void * ) ( &( pxStreamBuffer->pucBuffer[ xHead ] ) ), ( const void * ) pucData, xFirstLength ); /*lint !e9087 memcpy() requires void *. */
 4003538:	e0bffe17 	ldw	r2,-8(fp)
 400353c:	10c00617 	ldw	r3,24(r2)
 4003540:	e0bffb17 	ldw	r2,-20(fp)
 4003544:	1885883a 	add	r2,r3,r2
 4003548:	e1bfff17 	ldw	r6,-4(fp)
 400354c:	e17ffd17 	ldw	r5,-12(fp)
 4003550:	1009883a 	mov	r4,r2
 4003554:	40073dc0 	call	40073dc <memcpy>

    /* If the number of bytes written was less than the number that could be
     * written in the first write... */
    if( xCount > xFirstLength )
 4003558:	e0bffc17 	ldw	r2,-16(fp)
 400355c:	e0ffff17 	ldw	r3,-4(fp)
 4003560:	18800a2e 	bgeu	r3,r2,400358c <prvWriteBytesToBuffer+0x94>
    {
        /* ...then write the remaining bytes to the start of the buffer. */
        configASSERT( ( xCount - xFirstLength ) <= pxStreamBuffer->xLength );
        ( void ) memcpy( ( void * ) pxStreamBuffer->pucBuffer, ( const void * ) &( pucData[ xFirstLength ] ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
 4003564:	e0bffe17 	ldw	r2,-8(fp)
 4003568:	11000617 	ldw	r4,24(r2)
 400356c:	e0fffd17 	ldw	r3,-12(fp)
 4003570:	e0bfff17 	ldw	r2,-4(fp)
 4003574:	188b883a 	add	r5,r3,r2
 4003578:	e0fffc17 	ldw	r3,-16(fp)
 400357c:	e0bfff17 	ldw	r2,-4(fp)
 4003580:	1885c83a 	sub	r2,r3,r2
 4003584:	100d883a 	mov	r6,r2
 4003588:	40073dc0 	call	40073dc <memcpy>
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    xHead += xCount;
 400358c:	e0fffb17 	ldw	r3,-20(fp)
 4003590:	e0bffc17 	ldw	r2,-16(fp)
 4003594:	1885883a 	add	r2,r3,r2
 4003598:	e0bffb15 	stw	r2,-20(fp)

    if( xHead >= pxStreamBuffer->xLength )
 400359c:	e0bffe17 	ldw	r2,-8(fp)
 40035a0:	10800217 	ldw	r2,8(r2)
 40035a4:	e0fffb17 	ldw	r3,-20(fp)
 40035a8:	18800536 	bltu	r3,r2,40035c0 <prvWriteBytesToBuffer+0xc8>
    {
        xHead -= pxStreamBuffer->xLength;
 40035ac:	e0bffe17 	ldw	r2,-8(fp)
 40035b0:	10800217 	ldw	r2,8(r2)
 40035b4:	e0fffb17 	ldw	r3,-20(fp)
 40035b8:	1885c83a 	sub	r2,r3,r2
 40035bc:	e0bffb15 	stw	r2,-20(fp)
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xHead;
 40035c0:	e0bffb17 	ldw	r2,-20(fp)
}
 40035c4:	e037883a 	mov	sp,fp
 40035c8:	dfc00117 	ldw	ra,4(sp)
 40035cc:	df000017 	ldw	fp,0(sp)
 40035d0:	dec00204 	addi	sp,sp,8
 40035d4:	f800283a 	ret

040035d8 <prvReadBytesFromBuffer>:

static size_t prvReadBytesFromBuffer( StreamBuffer_t * pxStreamBuffer,
                                      uint8_t * pucData,
                                      size_t xCount,
                                      size_t xTail )
{
 40035d8:	defff904 	addi	sp,sp,-28
 40035dc:	dfc00615 	stw	ra,24(sp)
 40035e0:	df000515 	stw	fp,20(sp)
 40035e4:	df000504 	addi	fp,sp,20
 40035e8:	e13ffe15 	stw	r4,-8(fp)
 40035ec:	e17ffd15 	stw	r5,-12(fp)
 40035f0:	e1bffc15 	stw	r6,-16(fp)
 40035f4:	e1fffb15 	stw	r7,-20(fp)
    configASSERT( xCount != ( size_t ) 0 );

    /* Calculate the number of bytes that can be read - which may be
     * less than the number wanted if the data wraps around to the start of
     * the buffer. */
    xFirstLength = configMIN( pxStreamBuffer->xLength - xTail, xCount );
 40035f8:	e0bffe17 	ldw	r2,-8(fp)
 40035fc:	10c00217 	ldw	r3,8(r2)
 4003600:	e0bffb17 	ldw	r2,-20(fp)
 4003604:	1887c83a 	sub	r3,r3,r2
 4003608:	e0bffc17 	ldw	r2,-16(fp)
 400360c:	1880012e 	bgeu	r3,r2,4003614 <prvReadBytesFromBuffer+0x3c>
 4003610:	1805883a 	mov	r2,r3
 4003614:	e0bfff15 	stw	r2,-4(fp)

    /* Obtain the number of bytes it is possible to obtain in the first
     * read.  Asserts check bounds of read and write. */
    configASSERT( xFirstLength <= xCount );
    configASSERT( ( xTail + xFirstLength ) <= pxStreamBuffer->xLength );
    ( void ) memcpy( ( void * ) pucData, ( const void * ) &( pxStreamBuffer->pucBuffer[ xTail ] ), xFirstLength ); /*lint !e9087 memcpy() requires void *. */
 4003618:	e0bffe17 	ldw	r2,-8(fp)
 400361c:	10c00617 	ldw	r3,24(r2)
 4003620:	e0bffb17 	ldw	r2,-20(fp)
 4003624:	1885883a 	add	r2,r3,r2
 4003628:	e1bfff17 	ldw	r6,-4(fp)
 400362c:	100b883a 	mov	r5,r2
 4003630:	e13ffd17 	ldw	r4,-12(fp)
 4003634:	40073dc0 	call	40073dc <memcpy>

    /* If the total number of wanted bytes is greater than the number
     * that could be read in the first read... */
    if( xCount > xFirstLength )
 4003638:	e0bffc17 	ldw	r2,-16(fp)
 400363c:	e0ffff17 	ldw	r3,-4(fp)
 4003640:	18800a2e 	bgeu	r3,r2,400366c <prvReadBytesFromBuffer+0x94>
    {
        /* ...then read the remaining bytes from the start of the buffer. */
        ( void ) memcpy( ( void * ) &( pucData[ xFirstLength ] ), ( void * ) ( pxStreamBuffer->pucBuffer ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
 4003644:	e0fffd17 	ldw	r3,-12(fp)
 4003648:	e0bfff17 	ldw	r2,-4(fp)
 400364c:	1889883a 	add	r4,r3,r2
 4003650:	e0bffe17 	ldw	r2,-8(fp)
 4003654:	11400617 	ldw	r5,24(r2)
 4003658:	e0fffc17 	ldw	r3,-16(fp)
 400365c:	e0bfff17 	ldw	r2,-4(fp)
 4003660:	1885c83a 	sub	r2,r3,r2
 4003664:	100d883a 	mov	r6,r2
 4003668:	40073dc0 	call	40073dc <memcpy>
    {
        mtCOVERAGE_TEST_MARKER();
    }

    /* Move the tail pointer to effectively remove the data read from the buffer. */
    xTail += xCount;
 400366c:	e0fffb17 	ldw	r3,-20(fp)
 4003670:	e0bffc17 	ldw	r2,-16(fp)
 4003674:	1885883a 	add	r2,r3,r2
 4003678:	e0bffb15 	stw	r2,-20(fp)

    if( xTail >= pxStreamBuffer->xLength )
 400367c:	e0bffe17 	ldw	r2,-8(fp)
 4003680:	10800217 	ldw	r2,8(r2)
 4003684:	e0fffb17 	ldw	r3,-20(fp)
 4003688:	18800536 	bltu	r3,r2,40036a0 <prvReadBytesFromBuffer+0xc8>
    {
        xTail -= pxStreamBuffer->xLength;
 400368c:	e0bffe17 	ldw	r2,-8(fp)
 4003690:	10800217 	ldw	r2,8(r2)
 4003694:	e0fffb17 	ldw	r3,-20(fp)
 4003698:	1885c83a 	sub	r2,r3,r2
 400369c:	e0bffb15 	stw	r2,-20(fp)
    }

    return xTail;
 40036a0:	e0bffb17 	ldw	r2,-20(fp)
}
 40036a4:	e037883a 	mov	sp,fp
 40036a8:	dfc00117 	ldw	ra,4(sp)
 40036ac:	df000017 	ldw	fp,0(sp)
 40036b0:	dec00204 	addi	sp,sp,8
 40036b4:	f800283a 	ret

040036b8 <prvBytesInBuffer>:
/*-----------------------------------------------------------*/

static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
 40036b8:	defffd04 	addi	sp,sp,-12
 40036bc:	df000215 	stw	fp,8(sp)
 40036c0:	df000204 	addi	fp,sp,8
 40036c4:	e13ffe15 	stw	r4,-8(fp)
/* Returns the distance between xTail and xHead. */
    size_t xCount;

    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
 40036c8:	e0bffe17 	ldw	r2,-8(fp)
 40036cc:	10c00217 	ldw	r3,8(r2)
 40036d0:	e0bffe17 	ldw	r2,-8(fp)
 40036d4:	10800117 	ldw	r2,4(r2)
 40036d8:	1885883a 	add	r2,r3,r2
 40036dc:	e0bfff15 	stw	r2,-4(fp)
    xCount -= pxStreamBuffer->xTail;
 40036e0:	e0bffe17 	ldw	r2,-8(fp)
 40036e4:	10800017 	ldw	r2,0(r2)
 40036e8:	e0ffff17 	ldw	r3,-4(fp)
 40036ec:	1885c83a 	sub	r2,r3,r2
 40036f0:	e0bfff15 	stw	r2,-4(fp)

    if( xCount >= pxStreamBuffer->xLength )
 40036f4:	e0bffe17 	ldw	r2,-8(fp)
 40036f8:	10800217 	ldw	r2,8(r2)
 40036fc:	e0ffff17 	ldw	r3,-4(fp)
 4003700:	18800536 	bltu	r3,r2,4003718 <prvBytesInBuffer+0x60>
    {
        xCount -= pxStreamBuffer->xLength;
 4003704:	e0bffe17 	ldw	r2,-8(fp)
 4003708:	10800217 	ldw	r2,8(r2)
 400370c:	e0ffff17 	ldw	r3,-4(fp)
 4003710:	1885c83a 	sub	r2,r3,r2
 4003714:	e0bfff15 	stw	r2,-4(fp)
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xCount;
 4003718:	e0bfff17 	ldw	r2,-4(fp)
}
 400371c:	e037883a 	mov	sp,fp
 4003720:	df000017 	ldw	fp,0(sp)
 4003724:	dec00104 	addi	sp,sp,4
 4003728:	f800283a 	ret

0400372c <prvInitialiseNewStreamBuffer>:
                                          size_t xBufferSizeBytes,
                                          size_t xTriggerLevelBytes,
                                          uint8_t ucFlags,
                                          StreamBufferCallbackFunction_t pxSendCompletedCallback,
                                          StreamBufferCallbackFunction_t pxReceiveCompletedCallback )
{
 400372c:	defff904 	addi	sp,sp,-28
 4003730:	dfc00615 	stw	ra,24(sp)
 4003734:	df000515 	stw	fp,20(sp)
 4003738:	df000504 	addi	fp,sp,20
 400373c:	e13fff15 	stw	r4,-4(fp)
 4003740:	e17ffe15 	stw	r5,-8(fp)
 4003744:	e1bffd15 	stw	r6,-12(fp)
 4003748:	e1fffc15 	stw	r7,-16(fp)
 400374c:	e0800217 	ldw	r2,8(fp)
 4003750:	e0bffb05 	stb	r2,-20(fp)
        const BaseType_t xWriteValue = 0x55;
        configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );
    } /*lint !e529 !e438 xWriteValue is only used if configASSERT() is defined. */
    #endif

    ( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); /*lint !e9087 memset() requires void *. */
 4003754:	01800804 	movi	r6,32
 4003758:	000b883a 	mov	r5,zero
 400375c:	e13fff17 	ldw	r4,-4(fp)
 4003760:	40074dc0 	call	40074dc <memset>
    pxStreamBuffer->pucBuffer = pucBuffer;
 4003764:	e0bfff17 	ldw	r2,-4(fp)
 4003768:	e0fffe17 	ldw	r3,-8(fp)
 400376c:	10c00615 	stw	r3,24(r2)
    pxStreamBuffer->xLength = xBufferSizeBytes;
 4003770:	e0bfff17 	ldw	r2,-4(fp)
 4003774:	e0fffd17 	ldw	r3,-12(fp)
 4003778:	10c00215 	stw	r3,8(r2)
    pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
 400377c:	e0bfff17 	ldw	r2,-4(fp)
 4003780:	e0fffc17 	ldw	r3,-16(fp)
 4003784:	10c00315 	stw	r3,12(r2)
    pxStreamBuffer->ucFlags = ucFlags;
 4003788:	e0bfff17 	ldw	r2,-4(fp)
 400378c:	e0fffb03 	ldbu	r3,-20(fp)
 4003790:	10c00705 	stb	r3,28(r2)
    {
        ( void ) pxSendCompletedCallback;
        ( void ) pxReceiveCompletedCallback;
    }
    #endif
}
 4003794:	0001883a 	nop
 4003798:	e037883a 	mov	sp,fp
 400379c:	dfc00117 	ldw	ra,4(sp)
 40037a0:	df000017 	ldw	fp,0(sp)
 40037a4:	dec00204 	addi	sp,sp,8
 40037a8:	f800283a 	ret

040037ac <xTaskCreate>:
                            const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                            const configSTACK_DEPTH_TYPE usStackDepth,
                            void * const pvParameters,
                            UBaseType_t uxPriority,
                            TaskHandle_t * const pxCreatedTask )
    {
 40037ac:	defff304 	addi	sp,sp,-52
 40037b0:	dfc00c15 	stw	ra,48(sp)
 40037b4:	df000b15 	stw	fp,44(sp)
 40037b8:	df000b04 	addi	fp,sp,44
 40037bc:	e13ffc15 	stw	r4,-16(fp)
 40037c0:	e17ffb15 	stw	r5,-20(fp)
 40037c4:	3005883a 	mov	r2,r6
 40037c8:	e1fff915 	stw	r7,-28(fp)
 40037cc:	e0bffa0d 	sth	r2,-24(fp)
        #else /* portSTACK_GROWTH */
        {
            StackType_t * pxStack;

            /* Allocate space for the stack used by the task being created. */
            pxStack = pvPortMallocStack( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
 40037d0:	e0bffa0b 	ldhu	r2,-24(fp)
 40037d4:	100490ba 	slli	r2,r2,2
 40037d8:	1009883a 	mov	r4,r2
 40037dc:	40010340 	call	4001034 <pvPortMalloc>
 40037e0:	e0bffd15 	stw	r2,-12(fp)

            if( pxStack != NULL )
 40037e4:	e0bffd17 	ldw	r2,-12(fp)
 40037e8:	10001026 	beq	r2,zero,400382c <xTaskCreate+0x80>
            {
                /* Allocate space for the TCB. */
                pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
 40037ec:	01001404 	movi	r4,80
 40037f0:	40010340 	call	4001034 <pvPortMalloc>
 40037f4:	e0bfff15 	stw	r2,-4(fp)

                if( pxNewTCB != NULL )
 40037f8:	e0bfff17 	ldw	r2,-4(fp)
 40037fc:	10000826 	beq	r2,zero,4003820 <xTaskCreate+0x74>
                {
                    memset( ( void * ) pxNewTCB, 0x00, sizeof( TCB_t ) );
 4003800:	01801404 	movi	r6,80
 4003804:	000b883a 	mov	r5,zero
 4003808:	e13fff17 	ldw	r4,-4(fp)
 400380c:	40074dc0 	call	40074dc <memset>

                    /* Store the stack location in the TCB. */
                    pxNewTCB->pxStack = pxStack;
 4003810:	e0bfff17 	ldw	r2,-4(fp)
 4003814:	e0fffd17 	ldw	r3,-12(fp)
 4003818:	10c00c15 	stw	r3,48(r2)
 400381c:	00000406 	br	4003830 <xTaskCreate+0x84>
                }
                else
                {
                    /* The stack cannot be used as the TCB was not created.  Free
                     * it again. */
                    vPortFreeStack( pxStack );
 4003820:	e13ffd17 	ldw	r4,-12(fp)
 4003824:	400111c0 	call	400111c <vPortFree>
 4003828:	00000106 	br	4003830 <xTaskCreate+0x84>
                }
            }
            else
            {
                pxNewTCB = NULL;
 400382c:	e03fff15 	stw	zero,-4(fp)
            }
        }
        #endif /* portSTACK_GROWTH */

        if( pxNewTCB != NULL )
 4003830:	e0bfff17 	ldw	r2,-4(fp)
 4003834:	10001226 	beq	r2,zero,4003880 <xTaskCreate+0xd4>
                 * task was created dynamically in case it is later deleted. */
                pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
            }
            #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

            prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
 4003838:	e0fffa0b 	ldhu	r3,-24(fp)
 400383c:	d8000315 	stw	zero,12(sp)
 4003840:	e0bfff17 	ldw	r2,-4(fp)
 4003844:	d8800215 	stw	r2,8(sp)
 4003848:	e0800317 	ldw	r2,12(fp)
 400384c:	d8800115 	stw	r2,4(sp)
 4003850:	e0800217 	ldw	r2,8(fp)
 4003854:	d8800015 	stw	r2,0(sp)
 4003858:	e1fff917 	ldw	r7,-28(fp)
 400385c:	180d883a 	mov	r6,r3
 4003860:	e17ffb17 	ldw	r5,-20(fp)
 4003864:	e13ffc17 	ldw	r4,-16(fp)
 4003868:	40038a00 	call	40038a0 <prvInitialiseNewTask>
            prvAddNewTaskToReadyList( pxNewTCB );
 400386c:	e13fff17 	ldw	r4,-4(fp)
 4003870:	4003a4c0 	call	4003a4c <prvAddNewTaskToReadyList>
            xReturn = pdPASS;
 4003874:	00800044 	movi	r2,1
 4003878:	e0bffe15 	stw	r2,-8(fp)
 400387c:	00000206 	br	4003888 <xTaskCreate+0xdc>
        }
        else
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 4003880:	00bfffc4 	movi	r2,-1
 4003884:	e0bffe15 	stw	r2,-8(fp)
        }

        return xReturn;
 4003888:	e0bffe17 	ldw	r2,-8(fp)
    }
 400388c:	e037883a 	mov	sp,fp
 4003890:	dfc00117 	ldw	ra,4(sp)
 4003894:	df000017 	ldw	fp,0(sp)
 4003898:	dec00204 	addi	sp,sp,8
 400389c:	f800283a 	ret

040038a0 <prvInitialiseNewTask>:
                                  void * const pvParameters,
                                  UBaseType_t uxPriority,
                                  TaskHandle_t * const pxCreatedTask,
                                  TCB_t * pxNewTCB,
                                  const MemoryRegion_t * const xRegions )
{
 40038a0:	defff804 	addi	sp,sp,-32
 40038a4:	dfc00715 	stw	ra,28(sp)
 40038a8:	df000615 	stw	fp,24(sp)
 40038ac:	df000604 	addi	fp,sp,24
 40038b0:	e13ffd15 	stw	r4,-12(fp)
 40038b4:	e17ffc15 	stw	r5,-16(fp)
 40038b8:	e1bffb15 	stw	r6,-20(fp)
 40038bc:	e1fffa15 	stw	r7,-24(fp)

    /* Avoid dependency on memset() if it is not required. */
    #if ( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
    {
        /* Fill the stack with a known value to assist debugging. */
        ( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 40038c0:	e0800417 	ldw	r2,16(fp)
 40038c4:	10c00c17 	ldw	r3,48(r2)
 40038c8:	e0bffb17 	ldw	r2,-20(fp)
 40038cc:	100490ba 	slli	r2,r2,2
 40038d0:	100d883a 	mov	r6,r2
 40038d4:	01402944 	movi	r5,165
 40038d8:	1809883a 	mov	r4,r3
 40038dc:	40074dc0 	call	40074dc <memset>
     * grows from high memory to low (as per the 80x86) or vice versa.
     * portSTACK_GROWTH is used to make the result positive or negative as required
     * by the port. */
    #if ( portSTACK_GROWTH < 0 )
    {
        pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
 40038e0:	e0800417 	ldw	r2,16(fp)
 40038e4:	10c00c17 	ldw	r3,48(r2)
 40038e8:	e13ffb17 	ldw	r4,-20(fp)
 40038ec:	00900034 	movhi	r2,16384
 40038f0:	10bfffc4 	addi	r2,r2,-1
 40038f4:	2085883a 	add	r2,r4,r2
 40038f8:	100490ba 	slli	r2,r2,2
 40038fc:	1885883a 	add	r2,r3,r2
 4003900:	e0bffe15 	stw	r2,-8(fp)
        pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
 4003904:	e0fffe17 	ldw	r3,-8(fp)
 4003908:	00bfff04 	movi	r2,-4
 400390c:	1884703a 	and	r2,r3,r2
 4003910:	e0bffe15 	stw	r2,-8(fp)
        pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
    }
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
 4003914:	e0bffc17 	ldw	r2,-16(fp)
 4003918:	10001c26 	beq	r2,zero,400398c <prvInitialiseNewTask+0xec>
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 400391c:	e03fff15 	stw	zero,-4(fp)
 4003920:	00001306 	br	4003970 <prvInitialiseNewTask+0xd0>
        {
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 4003924:	e0fffc17 	ldw	r3,-16(fp)
 4003928:	e0bfff17 	ldw	r2,-4(fp)
 400392c:	1885883a 	add	r2,r3,r2
 4003930:	10c00003 	ldbu	r3,0(r2)
 4003934:	e1000417 	ldw	r4,16(fp)
 4003938:	e0bfff17 	ldw	r2,-4(fp)
 400393c:	2085883a 	add	r2,r4,r2
 4003940:	10c00d05 	stb	r3,52(r2)

            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
             * configMAX_TASK_NAME_LEN characters just in case the memory after the
             * string is not accessible (extremely unlikely). */
            if( pcName[ x ] == ( char ) 0x00 )
 4003944:	e0fffc17 	ldw	r3,-16(fp)
 4003948:	e0bfff17 	ldw	r2,-4(fp)
 400394c:	1885883a 	add	r2,r3,r2
 4003950:	10800003 	ldbu	r2,0(r2)
 4003954:	10803fcc 	andi	r2,r2,255
 4003958:	1080201c 	xori	r2,r2,128
 400395c:	10bfe004 	addi	r2,r2,-128
 4003960:	10000726 	beq	r2,zero,4003980 <prvInitialiseNewTask+0xe0>
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 4003964:	e0bfff17 	ldw	r2,-4(fp)
 4003968:	10800044 	addi	r2,r2,1
 400396c:	e0bfff15 	stw	r2,-4(fp)
 4003970:	e0bfff17 	ldw	r2,-4(fp)
 4003974:	10800230 	cmpltui	r2,r2,8
 4003978:	103fea1e 	bne	r2,zero,4003924 <prvInitialiseNewTask+0x84>
 400397c:	00000106 	br	4003984 <prvInitialiseNewTask+0xe4>
            {
                break;
 4003980:	0001883a 	nop
            }
        }

        /* Ensure the name string is terminated in the case that the string length
         * was greater or equal to configMAX_TASK_NAME_LEN. */
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 4003984:	e0800417 	ldw	r2,16(fp)
 4003988:	10000ec5 	stb	zero,59(r2)
    }

    /* This is used as an array index so must ensure it's not too large. */
    configASSERT( uxPriority < configMAX_PRIORITIES );

    if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 400398c:	e0800217 	ldw	r2,8(fp)
 4003990:	10800170 	cmpltui	r2,r2,5
 4003994:	1000021e 	bne	r2,zero,40039a0 <prvInitialiseNewTask+0x100>
    {
        uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 4003998:	00800104 	movi	r2,4
 400399c:	e0800215 	stw	r2,8(fp)
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxNewTCB->uxPriority = uxPriority;
 40039a0:	e0800417 	ldw	r2,16(fp)
 40039a4:	e0c00217 	ldw	r3,8(fp)
 40039a8:	10c00b15 	stw	r3,44(r2)
    #if ( configUSE_MUTEXES == 1 )
    {
        pxNewTCB->uxBasePriority = uxPriority;
 40039ac:	e0800417 	ldw	r2,16(fp)
 40039b0:	e0c00217 	ldw	r3,8(fp)
 40039b4:	10c01015 	stw	r3,64(r2)
    }
    #endif /* configUSE_MUTEXES */

    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 40039b8:	e0800417 	ldw	r2,16(fp)
 40039bc:	10800104 	addi	r2,r2,4
 40039c0:	1009883a 	mov	r4,r2
 40039c4:	4000b080 	call	4000b08 <vListInitialiseItem>
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 40039c8:	e0800417 	ldw	r2,16(fp)
 40039cc:	10800604 	addi	r2,r2,24
 40039d0:	1009883a 	mov	r4,r2
 40039d4:	4000b080 	call	4000b08 <vListInitialiseItem>

    /* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
     * back to  the containing TCB from a generic item in a list. */
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 40039d8:	e0800417 	ldw	r2,16(fp)
 40039dc:	e0c00417 	ldw	r3,16(fp)
 40039e0:	10c00415 	stw	r3,16(r2)

    /* Event lists are always in priority order. */
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 40039e4:	00c00144 	movi	r3,5
 40039e8:	e0800217 	ldw	r2,8(fp)
 40039ec:	1887c83a 	sub	r3,r3,r2
 40039f0:	e0800417 	ldw	r2,16(fp)
 40039f4:	10c00615 	stw	r3,24(r2)
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 40039f8:	e0800417 	ldw	r2,16(fp)
 40039fc:	e0c00417 	ldw	r3,16(fp)
 4003a00:	10c00915 	stw	r3,36(r2)
            }
            #endif /* portSTACK_GROWTH */
        }
        #else /* portHAS_STACK_OVERFLOW_CHECKING */
        {
            pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 4003a04:	e1bffa17 	ldw	r6,-24(fp)
 4003a08:	e17ffd17 	ldw	r5,-12(fp)
 4003a0c:	e13ffe17 	ldw	r4,-8(fp)
 4003a10:	4000d5c0 	call	4000d5c <pxPortInitialiseStack>
 4003a14:	1007883a 	mov	r3,r2
 4003a18:	e0800417 	ldw	r2,16(fp)
 4003a1c:	10c00015 	stw	r3,0(r2)
        }
        #endif /* portHAS_STACK_OVERFLOW_CHECKING */
    }
    #endif /* portUSING_MPU_WRAPPERS */

    if( pxCreatedTask != NULL )
 4003a20:	e0800317 	ldw	r2,12(fp)
 4003a24:	10000326 	beq	r2,zero,4003a34 <prvInitialiseNewTask+0x194>
    {
        /* Pass the handle out in an anonymous way.  The handle can be used to
         * change the created task's priority, delete the created task, etc.*/
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 4003a28:	e0800317 	ldw	r2,12(fp)
 4003a2c:	e0c00417 	ldw	r3,16(fp)
 4003a30:	10c00015 	stw	r3,0(r2)
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
 4003a34:	0001883a 	nop
 4003a38:	e037883a 	mov	sp,fp
 4003a3c:	dfc00117 	ldw	ra,4(sp)
 4003a40:	df000017 	ldw	fp,0(sp)
 4003a44:	dec00204 	addi	sp,sp,8
 4003a48:	f800283a 	ret

04003a4c <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB )
{
 4003a4c:	defffa04 	addi	sp,sp,-24
 4003a50:	dfc00515 	stw	ra,20(sp)
 4003a54:	df000415 	stw	fp,16(sp)
 4003a58:	dc400315 	stw	r17,12(sp)
 4003a5c:	dc000215 	stw	r16,8(sp)
 4003a60:	df000404 	addi	fp,sp,16
 4003a64:	e13ffc15 	stw	r4,-16(fp)
    /* Ensure interrupts don't access the task lists while the lists are being
     * updated. */
    taskENTER_CRITICAL();
 4003a68:	4005f740 	call	4005f74 <vTaskEnterCritical>
    {
        uxCurrentNumberOfTasks++;
 4003a6c:	d0a6b117 	ldw	r2,-25916(gp)
 4003a70:	10800044 	addi	r2,r2,1
 4003a74:	d0a6b115 	stw	r2,-25916(gp)

        if( pxCurrentTCB == NULL )
 4003a78:	d0a6ad17 	ldw	r2,-25932(gp)
 4003a7c:	1000071e 	bne	r2,zero,4003a9c <prvAddNewTaskToReadyList+0x50>
        {
            /* There are no other tasks, or all the other tasks are in
             * the suspended state - make this the current task. */
            pxCurrentTCB = pxNewTCB;
 4003a80:	e0bffc17 	ldw	r2,-16(fp)
 4003a84:	d0a6ad15 	stw	r2,-25932(gp)

            if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 4003a88:	d0a6b117 	ldw	r2,-25916(gp)
 4003a8c:	10800058 	cmpnei	r2,r2,1
 4003a90:	10000b1e 	bne	r2,zero,4003ac0 <prvAddNewTaskToReadyList+0x74>
            {
                /* This is the first task to be created so do the preliminary
                 * initialisation required.  We will not recover if this call
                 * fails, but we will report the failure. */
                prvInitialiseTaskLists();
 4003a94:	40056f80 	call	40056f8 <prvInitialiseTaskLists>
 4003a98:	00000906 	br	4003ac0 <prvAddNewTaskToReadyList+0x74>
        else
        {
            /* If the scheduler is not already running, make this task the
             * current task if it is the highest priority task to be created
             * so far. */
            if( xSchedulerRunning == pdFALSE )
 4003a9c:	d0a6b417 	ldw	r2,-25904(gp)
 4003aa0:	1000071e 	bne	r2,zero,4003ac0 <prvAddNewTaskToReadyList+0x74>
            {
                if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 4003aa4:	d0a6ad17 	ldw	r2,-25932(gp)
 4003aa8:	10800b17 	ldw	r2,44(r2)
 4003aac:	e0fffc17 	ldw	r3,-16(fp)
 4003ab0:	18c00b17 	ldw	r3,44(r3)
 4003ab4:	18800236 	bltu	r3,r2,4003ac0 <prvAddNewTaskToReadyList+0x74>
                {
                    pxCurrentTCB = pxNewTCB;
 4003ab8:	e0bffc17 	ldw	r2,-16(fp)
 4003abc:	d0a6ad15 	stw	r2,-25932(gp)
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }

        uxTaskNumber++;
 4003ac0:	d0a6b817 	ldw	r2,-25888(gp)
 4003ac4:	10800044 	addi	r2,r2,1
 4003ac8:	d0a6b815 	stw	r2,-25888(gp)
            pxNewTCB->uxTCBNumber = uxTaskNumber;
        }
        #endif /* configUSE_TRACE_FACILITY */
        traceTASK_CREATE( pxNewTCB );

        prvAddTaskToReadyList( pxNewTCB );
 4003acc:	e0bffc17 	ldw	r2,-16(fp)
 4003ad0:	10800b17 	ldw	r2,44(r2)
 4003ad4:	d0e6b317 	ldw	r3,-25908(gp)
 4003ad8:	1880032e 	bgeu	r3,r2,4003ae8 <prvAddNewTaskToReadyList+0x9c>
 4003adc:	e0bffc17 	ldw	r2,-16(fp)
 4003ae0:	10800b17 	ldw	r2,44(r2)
 4003ae4:	d0a6b315 	stw	r2,-25908(gp)
 4003ae8:	e0bffc17 	ldw	r2,-16(fp)
 4003aec:	10800b17 	ldw	r2,44(r2)
 4003af0:	01400504 	movi	r5,20
 4003af4:	1009883a 	mov	r4,r2
 4003af8:	40073b40 	call	40073b4 <__mulsi3>
 4003afc:	1007883a 	mov	r3,r2
 4003b00:	00812074 	movhi	r2,1153
 4003b04:	1885883a 	add	r2,r3,r2
 4003b08:	10bfb217 	ldw	r2,-312(r2)
 4003b0c:	e0bffd15 	stw	r2,-12(fp)
 4003b10:	e0bffc17 	ldw	r2,-16(fp)
 4003b14:	e0fffd17 	ldw	r3,-12(fp)
 4003b18:	10c00215 	stw	r3,8(r2)
 4003b1c:	e0bffd17 	ldw	r2,-12(fp)
 4003b20:	10c00217 	ldw	r3,8(r2)
 4003b24:	e0bffc17 	ldw	r2,-16(fp)
 4003b28:	10c00315 	stw	r3,12(r2)
 4003b2c:	e0bffd17 	ldw	r2,-12(fp)
 4003b30:	10800217 	ldw	r2,8(r2)
 4003b34:	e0fffc17 	ldw	r3,-16(fp)
 4003b38:	18c00104 	addi	r3,r3,4
 4003b3c:	10c00115 	stw	r3,4(r2)
 4003b40:	e0bffc17 	ldw	r2,-16(fp)
 4003b44:	10c00104 	addi	r3,r2,4
 4003b48:	e0bffd17 	ldw	r2,-12(fp)
 4003b4c:	10c00215 	stw	r3,8(r2)
 4003b50:	e0bffc17 	ldw	r2,-16(fp)
 4003b54:	10800b17 	ldw	r2,44(r2)
 4003b58:	01400504 	movi	r5,20
 4003b5c:	1009883a 	mov	r4,r2
 4003b60:	40073b40 	call	40073b4 <__mulsi3>
 4003b64:	1007883a 	mov	r3,r2
 4003b68:	00812074 	movhi	r2,1153
 4003b6c:	10bfb104 	addi	r2,r2,-316
 4003b70:	1887883a 	add	r3,r3,r2
 4003b74:	e0bffc17 	ldw	r2,-16(fp)
 4003b78:	10c00515 	stw	r3,20(r2)
 4003b7c:	e0bffc17 	ldw	r2,-16(fp)
 4003b80:	14400b17 	ldw	r17,44(r2)
 4003b84:	01400504 	movi	r5,20
 4003b88:	8809883a 	mov	r4,r17
 4003b8c:	40073b40 	call	40073b4 <__mulsi3>
 4003b90:	1007883a 	mov	r3,r2
 4003b94:	00812074 	movhi	r2,1153
 4003b98:	1885883a 	add	r2,r3,r2
 4003b9c:	10bfb117 	ldw	r2,-316(r2)
 4003ba0:	14000044 	addi	r16,r2,1
 4003ba4:	01400504 	movi	r5,20
 4003ba8:	8809883a 	mov	r4,r17
 4003bac:	40073b40 	call	40073b4 <__mulsi3>
 4003bb0:	1007883a 	mov	r3,r2
 4003bb4:	00812074 	movhi	r2,1153
 4003bb8:	1885883a 	add	r2,r3,r2
 4003bbc:	143fb115 	stw	r16,-316(r2)

        portSETUP_TCB( pxNewTCB );
    }
    taskEXIT_CRITICAL();
 4003bc0:	4005fc80 	call	4005fc8 <vTaskExitCritical>

    if( xSchedulerRunning != pdFALSE )
 4003bc4:	d0a6b417 	ldw	r2,-25904(gp)
 4003bc8:	10000626 	beq	r2,zero,4003be4 <prvAddNewTaskToReadyList+0x198>
    {
        /* If the created task is of a higher priority than the current task
         * then it should run now. */
        if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 4003bcc:	d0a6ad17 	ldw	r2,-25932(gp)
 4003bd0:	10c00b17 	ldw	r3,44(r2)
 4003bd4:	e0bffc17 	ldw	r2,-16(fp)
 4003bd8:	10800b17 	ldw	r2,44(r2)
 4003bdc:	1880012e 	bgeu	r3,r2,4003be4 <prvAddNewTaskToReadyList+0x198>
        {
            taskYIELD_IF_USING_PREEMPTION();
 4003be0:	003b683a 	trap	0
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
 4003be4:	0001883a 	nop
 4003be8:	e6fffe04 	addi	sp,fp,-8
 4003bec:	dfc00317 	ldw	ra,12(sp)
 4003bf0:	df000217 	ldw	fp,8(sp)
 4003bf4:	dc400117 	ldw	r17,4(sp)
 4003bf8:	dc000017 	ldw	r16,0(sp)
 4003bfc:	dec00404 	addi	sp,sp,16
 4003c00:	f800283a 	ret

04003c04 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    void vTaskDelete( TaskHandle_t xTaskToDelete )
    {
 4003c04:	defffc04 	addi	sp,sp,-16
 4003c08:	dfc00315 	stw	ra,12(sp)
 4003c0c:	df000215 	stw	fp,8(sp)
 4003c10:	df000204 	addi	fp,sp,8
 4003c14:	e13ffe15 	stw	r4,-8(fp)
        TCB_t * pxTCB;

        taskENTER_CRITICAL();
 4003c18:	4005f740 	call	4005f74 <vTaskEnterCritical>
        {
            /* If null is passed in here then it is the calling task that is
             * being deleted. */
            pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 4003c1c:	e0bffe17 	ldw	r2,-8(fp)
 4003c20:	1000021e 	bne	r2,zero,4003c2c <vTaskDelete+0x28>
 4003c24:	d0a6ad17 	ldw	r2,-25932(gp)
 4003c28:	00000106 	br	4003c30 <vTaskDelete+0x2c>
 4003c2c:	e0bffe17 	ldw	r2,-8(fp)
 4003c30:	e0bfff15 	stw	r2,-4(fp)

            /* Remove task from the ready/delayed list. */
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 4003c34:	e0bfff17 	ldw	r2,-4(fp)
 4003c38:	10800104 	addi	r2,r2,4
 4003c3c:	1009883a 	mov	r4,r2
 4003c40:	4000c980 	call	4000c98 <uxListRemove>
            {
                mtCOVERAGE_TEST_MARKER();
            }

            /* Is the task waiting on an event also? */
            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 4003c44:	e0bfff17 	ldw	r2,-4(fp)
 4003c48:	10800a17 	ldw	r2,40(r2)
 4003c4c:	10000426 	beq	r2,zero,4003c60 <vTaskDelete+0x5c>
            {
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 4003c50:	e0bfff17 	ldw	r2,-4(fp)
 4003c54:	10800604 	addi	r2,r2,24
 4003c58:	1009883a 	mov	r4,r2
 4003c5c:	4000c980 	call	4000c98 <uxListRemove>

            /* Increment the uxTaskNumber also so kernel aware debuggers can
             * detect that the task lists need re-generating.  This is done before
             * portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
             * not return. */
            uxTaskNumber++;
 4003c60:	d0a6b817 	ldw	r2,-25888(gp)
 4003c64:	10800044 	addi	r2,r2,1
 4003c68:	d0a6b815 	stw	r2,-25888(gp)

            if( pxTCB == pxCurrentTCB )
 4003c6c:	d0a6ad17 	ldw	r2,-25932(gp)
 4003c70:	e0ffff17 	ldw	r3,-4(fp)
 4003c74:	18800a1e 	bne	r3,r2,4003ca0 <vTaskDelete+0x9c>
                /* A task is deleting itself.  This cannot complete within the
                 * task itself, as a context switch to another task is required.
                 * Place the task in the termination list.  The idle task will
                 * check the termination list and free up any memory allocated by
                 * the scheduler for the TCB and stack of the deleted task. */
                vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
 4003c78:	e0bfff17 	ldw	r2,-4(fp)
 4003c7c:	10800104 	addi	r2,r2,4
 4003c80:	100b883a 	mov	r5,r2
 4003c84:	01012074 	movhi	r4,1153
 4003c88:	213fd904 	addi	r4,r4,-156
 4003c8c:	4000b340 	call	4000b34 <vListInsertEnd>

                /* Increment the ucTasksDeleted variable so the idle task knows
                 * there is a task that has been deleted and that it should therefore
                 * check the xTasksWaitingTermination list. */
                ++uxDeletedTasksWaitingCleanUp;
 4003c90:	d0a6b017 	ldw	r2,-25920(gp)
 4003c94:	10800044 	addi	r2,r2,1
 4003c98:	d0a6b015 	stw	r2,-25920(gp)
 4003c9c:	00000406 	br	4003cb0 <vTaskDelete+0xac>
                 * required. */
                portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
            }
            else
            {
                --uxCurrentNumberOfTasks;
 4003ca0:	d0a6b117 	ldw	r2,-25916(gp)
 4003ca4:	10bfffc4 	addi	r2,r2,-1
 4003ca8:	d0a6b115 	stw	r2,-25916(gp)
                traceTASK_DELETE( pxTCB );

                /* Reset the next expected unblock time in case it referred to
                 * the task that has just been deleted. */
                prvResetNextTaskUnblockTime();
 4003cac:	40059400 	call	4005940 <prvResetNextTaskUnblockTime>
            }
        }
        taskEXIT_CRITICAL();
 4003cb0:	4005fc80 	call	4005fc8 <vTaskExitCritical>

        /* If the task is not deleting itself, call prvDeleteTCB from outside of
         * critical section. If a task deletes itself, prvDeleteTCB is called
         * from prvCheckTasksWaitingTermination which is called from Idle task. */
        if( pxTCB != pxCurrentTCB )
 4003cb4:	d0a6ad17 	ldw	r2,-25932(gp)
 4003cb8:	e0ffff17 	ldw	r3,-4(fp)
 4003cbc:	18800226 	beq	r3,r2,4003cc8 <vTaskDelete+0xc4>
        {
            prvDeleteTCB( pxTCB );
 4003cc0:	e13fff17 	ldw	r4,-4(fp)
 4003cc4:	40058fc0 	call	40058fc <prvDeleteTCB>
        }

        /* Force a reschedule if it is the currently running task that has just
         * been deleted. */
        if( xSchedulerRunning != pdFALSE )
 4003cc8:	d0a6b417 	ldw	r2,-25904(gp)
 4003ccc:	10000426 	beq	r2,zero,4003ce0 <vTaskDelete+0xdc>
        {
            if( pxTCB == pxCurrentTCB )
 4003cd0:	d0a6ad17 	ldw	r2,-25932(gp)
 4003cd4:	e0ffff17 	ldw	r3,-4(fp)
 4003cd8:	1880011e 	bne	r3,r2,4003ce0 <vTaskDelete+0xdc>
            {
                configASSERT( uxSchedulerSuspended == 0 );
                portYIELD_WITHIN_API();
 4003cdc:	003b683a 	trap	0
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    }
 4003ce0:	0001883a 	nop
 4003ce4:	e037883a 	mov	sp,fp
 4003ce8:	dfc00117 	ldw	ra,4(sp)
 4003cec:	df000017 	ldw	fp,0(sp)
 4003cf0:	dec00204 	addi	sp,sp,8
 4003cf4:	f800283a 	ret

04003cf8 <xTaskDelayUntil>:

#if ( INCLUDE_xTaskDelayUntil == 1 )

    BaseType_t xTaskDelayUntil( TickType_t * const pxPreviousWakeTime,
                                const TickType_t xTimeIncrement )
    {
 4003cf8:	defff804 	addi	sp,sp,-32
 4003cfc:	dfc00715 	stw	ra,28(sp)
 4003d00:	df000615 	stw	fp,24(sp)
 4003d04:	df000604 	addi	fp,sp,24
 4003d08:	e13ffb15 	stw	r4,-20(fp)
 4003d0c:	e17ffa15 	stw	r5,-24(fp)
        TickType_t xTimeToWake;
        BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
 4003d10:	e03fff15 	stw	zero,-4(fp)

        configASSERT( pxPreviousWakeTime );
        configASSERT( ( xTimeIncrement > 0U ) );
        configASSERT( uxSchedulerSuspended == 0 );

        vTaskSuspendAll();
 4003d14:	40046e80 	call	40046e8 <vTaskSuspendAll>
        {
            /* Minor optimisation.  The tick count cannot change in this
             * block. */
            const TickType_t xConstTickCount = xTickCount;
 4003d18:	d0a6b217 	ldw	r2,-25912(gp)
 4003d1c:	e0bffe15 	stw	r2,-8(fp)

            /* Generate the tick time at which the task wants to wake. */
            xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 4003d20:	e0bffb17 	ldw	r2,-20(fp)
 4003d24:	10800017 	ldw	r2,0(r2)
 4003d28:	e0fffa17 	ldw	r3,-24(fp)
 4003d2c:	1885883a 	add	r2,r3,r2
 4003d30:	e0bffd15 	stw	r2,-12(fp)

            if( xConstTickCount < *pxPreviousWakeTime )
 4003d34:	e0bffb17 	ldw	r2,-20(fp)
 4003d38:	10800017 	ldw	r2,0(r2)
 4003d3c:	e0fffe17 	ldw	r3,-8(fp)
 4003d40:	18800a2e 	bgeu	r3,r2,4003d6c <xTaskDelayUntil+0x74>
                /* The tick count has overflowed since this function was
                 * lasted called.  In this case the only time we should ever
                 * actually delay is if the wake time has also  overflowed,
                 * and the wake time is greater than the tick time.  When this
                 * is the case it is as if neither time had overflowed. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
 4003d44:	e0bffb17 	ldw	r2,-20(fp)
 4003d48:	10800017 	ldw	r2,0(r2)
 4003d4c:	e0fffd17 	ldw	r3,-12(fp)
 4003d50:	18800f2e 	bgeu	r3,r2,4003d90 <xTaskDelayUntil+0x98>
 4003d54:	e0bffd17 	ldw	r2,-12(fp)
 4003d58:	e0fffe17 	ldw	r3,-8(fp)
 4003d5c:	18800c2e 	bgeu	r3,r2,4003d90 <xTaskDelayUntil+0x98>
                {
                    xShouldDelay = pdTRUE;
 4003d60:	00800044 	movi	r2,1
 4003d64:	e0bfff15 	stw	r2,-4(fp)
 4003d68:	00000906 	br	4003d90 <xTaskDelayUntil+0x98>
            else
            {
                /* The tick time has not overflowed.  In this case we will
                 * delay if either the wake time has overflowed, and/or the
                 * tick time is less than the wake time. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
 4003d6c:	e0bffb17 	ldw	r2,-20(fp)
 4003d70:	10800017 	ldw	r2,0(r2)
 4003d74:	e0fffd17 	ldw	r3,-12(fp)
 4003d78:	18800336 	bltu	r3,r2,4003d88 <xTaskDelayUntil+0x90>
 4003d7c:	e0bffd17 	ldw	r2,-12(fp)
 4003d80:	e0fffe17 	ldw	r3,-8(fp)
 4003d84:	1880022e 	bgeu	r3,r2,4003d90 <xTaskDelayUntil+0x98>
                {
                    xShouldDelay = pdTRUE;
 4003d88:	00800044 	movi	r2,1
 4003d8c:	e0bfff15 	stw	r2,-4(fp)
                    mtCOVERAGE_TEST_MARKER();
                }
            }

            /* Update the wake time ready for the next call. */
            *pxPreviousWakeTime = xTimeToWake;
 4003d90:	e0bffb17 	ldw	r2,-20(fp)
 4003d94:	e0fffd17 	ldw	r3,-12(fp)
 4003d98:	10c00015 	stw	r3,0(r2)

            if( xShouldDelay != pdFALSE )
 4003d9c:	e0bfff17 	ldw	r2,-4(fp)
 4003da0:	10000626 	beq	r2,zero,4003dbc <xTaskDelayUntil+0xc4>
            {
                traceTASK_DELAY_UNTIL( xTimeToWake );

                /* prvAddCurrentTaskToDelayedList() needs the block time, not
                 * the time to wake, so subtract the current tick count. */
                prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
 4003da4:	e0fffd17 	ldw	r3,-12(fp)
 4003da8:	e0bffe17 	ldw	r2,-8(fp)
 4003dac:	1885c83a 	sub	r2,r3,r2
 4003db0:	000b883a 	mov	r5,zero
 4003db4:	1009883a 	mov	r4,r2
 4003db8:	4006e340 	call	4006e34 <prvAddCurrentTaskToDelayedList>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        xAlreadyYielded = xTaskResumeAll();
 4003dbc:	40047140 	call	4004714 <xTaskResumeAll>
 4003dc0:	e0bffc15 	stw	r2,-16(fp)

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
 4003dc4:	e0bffc17 	ldw	r2,-16(fp)
 4003dc8:	1000011e 	bne	r2,zero,4003dd0 <xTaskDelayUntil+0xd8>
        {
            portYIELD_WITHIN_API();
 4003dcc:	003b683a 	trap	0
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xShouldDelay;
 4003dd0:	e0bfff17 	ldw	r2,-4(fp)
    }
 4003dd4:	e037883a 	mov	sp,fp
 4003dd8:	dfc00117 	ldw	ra,4(sp)
 4003ddc:	df000017 	ldw	fp,0(sp)
 4003de0:	dec00204 	addi	sp,sp,8
 4003de4:	f800283a 	ret

04003de8 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

    void vTaskDelay( const TickType_t xTicksToDelay )
    {
 4003de8:	defffc04 	addi	sp,sp,-16
 4003dec:	dfc00315 	stw	ra,12(sp)
 4003df0:	df000215 	stw	fp,8(sp)
 4003df4:	df000204 	addi	fp,sp,8
 4003df8:	e13ffe15 	stw	r4,-8(fp)
        BaseType_t xAlreadyYielded = pdFALSE;
 4003dfc:	e03fff15 	stw	zero,-4(fp)

        /* A delay time of zero just forces a reschedule. */
        if( xTicksToDelay > ( TickType_t ) 0U )
 4003e00:	e0bffe17 	ldw	r2,-8(fp)
 4003e04:	10000626 	beq	r2,zero,4003e20 <vTaskDelay+0x38>
        {
            configASSERT( uxSchedulerSuspended == 0 );
            vTaskSuspendAll();
 4003e08:	40046e80 	call	40046e8 <vTaskSuspendAll>
                 * list or removed from the blocked list until the scheduler
                 * is resumed.
                 *
                 * This task cannot be in an event list as it is the currently
                 * executing task. */
                prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 4003e0c:	000b883a 	mov	r5,zero
 4003e10:	e13ffe17 	ldw	r4,-8(fp)
 4003e14:	4006e340 	call	4006e34 <prvAddCurrentTaskToDelayedList>
            }
            xAlreadyYielded = xTaskResumeAll();
 4003e18:	40047140 	call	4004714 <xTaskResumeAll>
 4003e1c:	e0bfff15 	stw	r2,-4(fp)
            mtCOVERAGE_TEST_MARKER();
        }

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
 4003e20:	e0bfff17 	ldw	r2,-4(fp)
 4003e24:	1000011e 	bne	r2,zero,4003e2c <vTaskDelay+0x44>
        {
            portYIELD_WITHIN_API();
 4003e28:	003b683a 	trap	0
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
 4003e2c:	0001883a 	nop
 4003e30:	e037883a 	mov	sp,fp
 4003e34:	dfc00117 	ldw	ra,4(sp)
 4003e38:	df000017 	ldw	fp,0(sp)
 4003e3c:	dec00204 	addi	sp,sp,8
 4003e40:	f800283a 	ret

04003e44 <uxTaskPriorityGet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

    UBaseType_t uxTaskPriorityGet( const TaskHandle_t xTask )
    {
 4003e44:	defffb04 	addi	sp,sp,-20
 4003e48:	dfc00415 	stw	ra,16(sp)
 4003e4c:	df000315 	stw	fp,12(sp)
 4003e50:	df000304 	addi	fp,sp,12
 4003e54:	e13ffd15 	stw	r4,-12(fp)
        TCB_t const * pxTCB;
        UBaseType_t uxReturn;

        taskENTER_CRITICAL();
 4003e58:	4005f740 	call	4005f74 <vTaskEnterCritical>
        {
            /* If null is passed in here then it is the priority of the task
             * that called uxTaskPriorityGet() that is being queried. */
            pxTCB = prvGetTCBFromHandle( xTask );
 4003e5c:	e0bffd17 	ldw	r2,-12(fp)
 4003e60:	1000021e 	bne	r2,zero,4003e6c <uxTaskPriorityGet+0x28>
 4003e64:	d0a6ad17 	ldw	r2,-25932(gp)
 4003e68:	00000106 	br	4003e70 <uxTaskPriorityGet+0x2c>
 4003e6c:	e0bffd17 	ldw	r2,-12(fp)
 4003e70:	e0bfff15 	stw	r2,-4(fp)
            uxReturn = pxTCB->uxPriority;
 4003e74:	e0bfff17 	ldw	r2,-4(fp)
 4003e78:	10800b17 	ldw	r2,44(r2)
 4003e7c:	e0bffe15 	stw	r2,-8(fp)
        }
        taskEXIT_CRITICAL();
 4003e80:	4005fc80 	call	4005fc8 <vTaskExitCritical>

        return uxReturn;
 4003e84:	e0bffe17 	ldw	r2,-8(fp)
    }
 4003e88:	e037883a 	mov	sp,fp
 4003e8c:	dfc00117 	ldw	ra,4(sp)
 4003e90:	df000017 	ldw	fp,0(sp)
 4003e94:	dec00204 	addi	sp,sp,8
 4003e98:	f800283a 	ret

04003e9c <uxTaskPriorityGetFromISR>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

    UBaseType_t uxTaskPriorityGetFromISR( const TaskHandle_t xTask )
    {
 4003e9c:	defffb04 	addi	sp,sp,-20
 4003ea0:	df000415 	stw	fp,16(sp)
 4003ea4:	df000404 	addi	fp,sp,16
 4003ea8:	e13ffc15 	stw	r4,-16(fp)
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
 4003eac:	e03fff15 	stw	zero,-4(fp)
        {
            /* If null is passed in here then it is the priority of the calling
             * task that is being queried. */
            pxTCB = prvGetTCBFromHandle( xTask );
 4003eb0:	e0bffc17 	ldw	r2,-16(fp)
 4003eb4:	1000021e 	bne	r2,zero,4003ec0 <uxTaskPriorityGetFromISR+0x24>
 4003eb8:	d0a6ad17 	ldw	r2,-25932(gp)
 4003ebc:	00000106 	br	4003ec4 <uxTaskPriorityGetFromISR+0x28>
 4003ec0:	e0bffc17 	ldw	r2,-16(fp)
 4003ec4:	e0bffe15 	stw	r2,-8(fp)
            uxReturn = pxTCB->uxPriority;
 4003ec8:	e0bffe17 	ldw	r2,-8(fp)
 4003ecc:	10800b17 	ldw	r2,44(r2)
 4003ed0:	e0bffd15 	stw	r2,-12(fp)
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );

        return uxReturn;
 4003ed4:	e0bffd17 	ldw	r2,-12(fp)
    }
 4003ed8:	e037883a 	mov	sp,fp
 4003edc:	df000017 	ldw	fp,0(sp)
 4003ee0:	dec00104 	addi	sp,sp,4
 4003ee4:	f800283a 	ret

04003ee8 <vTaskPrioritySet>:

#if ( INCLUDE_vTaskPrioritySet == 1 )

    void vTaskPrioritySet( TaskHandle_t xTask,
                           UBaseType_t uxNewPriority )
    {
 4003ee8:	defff504 	addi	sp,sp,-44
 4003eec:	dfc00a15 	stw	ra,40(sp)
 4003ef0:	df000915 	stw	fp,36(sp)
 4003ef4:	dc400815 	stw	r17,32(sp)
 4003ef8:	dc000715 	stw	r16,28(sp)
 4003efc:	df000904 	addi	fp,sp,36
 4003f00:	e13ff815 	stw	r4,-32(fp)
 4003f04:	e17ff715 	stw	r5,-36(fp)
        TCB_t * pxTCB;
        UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
        BaseType_t xYieldRequired = pdFALSE;
 4003f08:	e03ffd15 	stw	zero,-12(fp)

        configASSERT( uxNewPriority < configMAX_PRIORITIES );

        /* Ensure the new priority is valid. */
        if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 4003f0c:	e0bff717 	ldw	r2,-36(fp)
 4003f10:	10800170 	cmpltui	r2,r2,5
 4003f14:	1000021e 	bne	r2,zero,4003f20 <vTaskPrioritySet+0x38>
        {
            uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 4003f18:	00800104 	movi	r2,4
 4003f1c:	e0bff715 	stw	r2,-36(fp)
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        taskENTER_CRITICAL();
 4003f20:	4005f740 	call	4005f74 <vTaskEnterCritical>
        {
            /* If null is passed in here then it is the priority of the calling
             * task that is being changed. */
            pxTCB = prvGetTCBFromHandle( xTask );
 4003f24:	e0bff817 	ldw	r2,-32(fp)
 4003f28:	1000021e 	bne	r2,zero,4003f34 <vTaskPrioritySet+0x4c>
 4003f2c:	d0a6ad17 	ldw	r2,-25932(gp)
 4003f30:	00000106 	br	4003f38 <vTaskPrioritySet+0x50>
 4003f34:	e0bff817 	ldw	r2,-32(fp)
 4003f38:	e0bffc15 	stw	r2,-16(fp)

            traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );

            #if ( configUSE_MUTEXES == 1 )
            {
                uxCurrentBasePriority = pxTCB->uxBasePriority;
 4003f3c:	e0bffc17 	ldw	r2,-16(fp)
 4003f40:	10801017 	ldw	r2,64(r2)
 4003f44:	e0bffb15 	stw	r2,-20(fp)
            {
                uxCurrentBasePriority = pxTCB->uxPriority;
            }
            #endif

            if( uxCurrentBasePriority != uxNewPriority )
 4003f48:	e0fffb17 	ldw	r3,-20(fp)
 4003f4c:	e0bff717 	ldw	r2,-36(fp)
 4003f50:	18807626 	beq	r3,r2,400412c <vTaskPrioritySet+0x244>
            {
                /* The priority change may have readied a task of higher
                 * priority than the calling task. */
                if( uxNewPriority > uxCurrentBasePriority )
 4003f54:	e0bff717 	ldw	r2,-36(fp)
 4003f58:	e0fffb17 	ldw	r3,-20(fp)
 4003f5c:	18800a2e 	bgeu	r3,r2,4003f88 <vTaskPrioritySet+0xa0>
                {
                    if( pxTCB != pxCurrentTCB )
 4003f60:	d0a6ad17 	ldw	r2,-25932(gp)
 4003f64:	e0fffc17 	ldw	r3,-16(fp)
 4003f68:	18800c26 	beq	r3,r2,4003f9c <vTaskPrioritySet+0xb4>
                    {
                        /* The priority of a task other than the currently
                         * running task is being raised.  Is the priority being
                         * raised above that of the running task? */
                        if( uxNewPriority >= pxCurrentTCB->uxPriority )
 4003f6c:	d0a6ad17 	ldw	r2,-25932(gp)
 4003f70:	10800b17 	ldw	r2,44(r2)
 4003f74:	e0fff717 	ldw	r3,-36(fp)
 4003f78:	18800836 	bltu	r3,r2,4003f9c <vTaskPrioritySet+0xb4>
                        {
                            xYieldRequired = pdTRUE;
 4003f7c:	00800044 	movi	r2,1
 4003f80:	e0bffd15 	stw	r2,-12(fp)
 4003f84:	00000506 	br	4003f9c <vTaskPrioritySet+0xb4>
                        /* The priority of the running task is being raised,
                         * but the running task must already be the highest
                         * priority task able to run so no yield is required. */
                    }
                }
                else if( pxTCB == pxCurrentTCB )
 4003f88:	d0a6ad17 	ldw	r2,-25932(gp)
 4003f8c:	e0fffc17 	ldw	r3,-16(fp)
 4003f90:	1880021e 	bne	r3,r2,4003f9c <vTaskPrioritySet+0xb4>
                {
                    /* Setting the priority of the running task down means
                     * there may now be another task of higher priority that
                     * is ready to execute. */
                    xYieldRequired = pdTRUE;
 4003f94:	00800044 	movi	r2,1
 4003f98:	e0bffd15 	stw	r2,-12(fp)
                }

                /* Remember the ready list the task might be referenced from
                 * before its uxPriority member is changed so the
                 * taskRESET_READY_PRIORITY() macro can function correctly. */
                uxPriorityUsedOnEntry = pxTCB->uxPriority;
 4003f9c:	e0bffc17 	ldw	r2,-16(fp)
 4003fa0:	10800b17 	ldw	r2,44(r2)
 4003fa4:	e0bffa15 	stw	r2,-24(fp)

                #if ( configUSE_MUTEXES == 1 )
                {
                    /* Only change the priority being used if the task is not
                     * currently using an inherited priority. */
                    if( pxTCB->uxBasePriority == pxTCB->uxPriority )
 4003fa8:	e0bffc17 	ldw	r2,-16(fp)
 4003fac:	10c01017 	ldw	r3,64(r2)
 4003fb0:	e0bffc17 	ldw	r2,-16(fp)
 4003fb4:	10800b17 	ldw	r2,44(r2)
 4003fb8:	1880031e 	bne	r3,r2,4003fc8 <vTaskPrioritySet+0xe0>
                    {
                        pxTCB->uxPriority = uxNewPriority;
 4003fbc:	e0bffc17 	ldw	r2,-16(fp)
 4003fc0:	e0fff717 	ldw	r3,-36(fp)
 4003fc4:	10c00b15 	stw	r3,44(r2)
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* The base priority gets set whatever. */
                    pxTCB->uxBasePriority = uxNewPriority;
 4003fc8:	e0bffc17 	ldw	r2,-16(fp)
 4003fcc:	e0fff717 	ldw	r3,-36(fp)
 4003fd0:	10c01015 	stw	r3,64(r2)
                }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                /* Only reset the event list item value if the value is not
                 * being used for anything else. */
                if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 4003fd4:	e0bffc17 	ldw	r2,-16(fp)
 4003fd8:	10800617 	ldw	r2,24(r2)
 4003fdc:	10000516 	blt	r2,zero,4003ff4 <vTaskPrioritySet+0x10c>
                {
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 4003fe0:	00c00144 	movi	r3,5
 4003fe4:	e0bff717 	ldw	r2,-36(fp)
 4003fe8:	1887c83a 	sub	r3,r3,r2
 4003fec:	e0bffc17 	ldw	r2,-16(fp)
 4003ff0:	10c00615 	stw	r3,24(r2)

                /* If the task is in the blocked or suspended list we need do
                 * nothing more than change its priority variable. However, if
                 * the task is in a ready list it needs to be removed and placed
                 * in the list appropriate to its new priority. */
                if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 4003ff4:	e0bffc17 	ldw	r2,-16(fp)
 4003ff8:	14000517 	ldw	r16,20(r2)
 4003ffc:	01400504 	movi	r5,20
 4004000:	e13ffa17 	ldw	r4,-24(fp)
 4004004:	40073b40 	call	40073b4 <__mulsi3>
 4004008:	1007883a 	mov	r3,r2
 400400c:	00812074 	movhi	r2,1153
 4004010:	10bfb104 	addi	r2,r2,-316
 4004014:	1885883a 	add	r2,r3,r2
 4004018:	8080411e 	bne	r16,r2,4004120 <vTaskPrioritySet+0x238>
                {
                    /* The task is currently in its ready list - remove before
                     * adding it to its new ready list.  As we are in a critical
                     * section we can do this even if the scheduler is suspended. */
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 400401c:	e0bffc17 	ldw	r2,-16(fp)
 4004020:	10800104 	addi	r2,r2,4
 4004024:	1009883a 	mov	r4,r2
 4004028:	4000c980 	call	4000c98 <uxListRemove>
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    prvAddTaskToReadyList( pxTCB );
 400402c:	e0bffc17 	ldw	r2,-16(fp)
 4004030:	10800b17 	ldw	r2,44(r2)
 4004034:	d0e6b317 	ldw	r3,-25908(gp)
 4004038:	1880032e 	bgeu	r3,r2,4004048 <vTaskPrioritySet+0x160>
 400403c:	e0bffc17 	ldw	r2,-16(fp)
 4004040:	10800b17 	ldw	r2,44(r2)
 4004044:	d0a6b315 	stw	r2,-25908(gp)
 4004048:	e0bffc17 	ldw	r2,-16(fp)
 400404c:	10800b17 	ldw	r2,44(r2)
 4004050:	01400504 	movi	r5,20
 4004054:	1009883a 	mov	r4,r2
 4004058:	40073b40 	call	40073b4 <__mulsi3>
 400405c:	1007883a 	mov	r3,r2
 4004060:	00812074 	movhi	r2,1153
 4004064:	1885883a 	add	r2,r3,r2
 4004068:	10bfb217 	ldw	r2,-312(r2)
 400406c:	e0bff915 	stw	r2,-28(fp)
 4004070:	e0bffc17 	ldw	r2,-16(fp)
 4004074:	e0fff917 	ldw	r3,-28(fp)
 4004078:	10c00215 	stw	r3,8(r2)
 400407c:	e0bff917 	ldw	r2,-28(fp)
 4004080:	10c00217 	ldw	r3,8(r2)
 4004084:	e0bffc17 	ldw	r2,-16(fp)
 4004088:	10c00315 	stw	r3,12(r2)
 400408c:	e0bff917 	ldw	r2,-28(fp)
 4004090:	10800217 	ldw	r2,8(r2)
 4004094:	e0fffc17 	ldw	r3,-16(fp)
 4004098:	18c00104 	addi	r3,r3,4
 400409c:	10c00115 	stw	r3,4(r2)
 40040a0:	e0bffc17 	ldw	r2,-16(fp)
 40040a4:	10c00104 	addi	r3,r2,4
 40040a8:	e0bff917 	ldw	r2,-28(fp)
 40040ac:	10c00215 	stw	r3,8(r2)
 40040b0:	e0bffc17 	ldw	r2,-16(fp)
 40040b4:	10800b17 	ldw	r2,44(r2)
 40040b8:	01400504 	movi	r5,20
 40040bc:	1009883a 	mov	r4,r2
 40040c0:	40073b40 	call	40073b4 <__mulsi3>
 40040c4:	1007883a 	mov	r3,r2
 40040c8:	00812074 	movhi	r2,1153
 40040cc:	10bfb104 	addi	r2,r2,-316
 40040d0:	1887883a 	add	r3,r3,r2
 40040d4:	e0bffc17 	ldw	r2,-16(fp)
 40040d8:	10c00515 	stw	r3,20(r2)
 40040dc:	e0bffc17 	ldw	r2,-16(fp)
 40040e0:	14400b17 	ldw	r17,44(r2)
 40040e4:	01400504 	movi	r5,20
 40040e8:	8809883a 	mov	r4,r17
 40040ec:	40073b40 	call	40073b4 <__mulsi3>
 40040f0:	1007883a 	mov	r3,r2
 40040f4:	00812074 	movhi	r2,1153
 40040f8:	1885883a 	add	r2,r3,r2
 40040fc:	10bfb117 	ldw	r2,-316(r2)
 4004100:	14000044 	addi	r16,r2,1
 4004104:	01400504 	movi	r5,20
 4004108:	8809883a 	mov	r4,r17
 400410c:	40073b40 	call	40073b4 <__mulsi3>
 4004110:	1007883a 	mov	r3,r2
 4004114:	00812074 	movhi	r2,1153
 4004118:	1885883a 	add	r2,r3,r2
 400411c:	143fb115 	stw	r16,-316(r2)
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                if( xYieldRequired != pdFALSE )
 4004120:	e0bffd17 	ldw	r2,-12(fp)
 4004124:	10000126 	beq	r2,zero,400412c <vTaskPrioritySet+0x244>
                {
                    taskYIELD_IF_USING_PREEMPTION();
 4004128:	003b683a 	trap	0
                /* Remove compiler warning about unused variables when the port
                 * optimised task selection is not being used. */
                ( void ) uxPriorityUsedOnEntry;
            }
        }
        taskEXIT_CRITICAL();
 400412c:	4005fc80 	call	4005fc8 <vTaskExitCritical>
    }
 4004130:	0001883a 	nop
 4004134:	e6fffe04 	addi	sp,fp,-8
 4004138:	dfc00317 	ldw	ra,12(sp)
 400413c:	df000217 	ldw	fp,8(sp)
 4004140:	dc400117 	ldw	r17,4(sp)
 4004144:	dc000017 	ldw	r16,0(sp)
 4004148:	dec00404 	addi	sp,sp,16
 400414c:	f800283a 	ret

04004150 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

    void vTaskSuspend( TaskHandle_t xTaskToSuspend )
    {
 4004150:	defffb04 	addi	sp,sp,-20
 4004154:	dfc00415 	stw	ra,16(sp)
 4004158:	df000315 	stw	fp,12(sp)
 400415c:	df000304 	addi	fp,sp,12
 4004160:	e13ffd15 	stw	r4,-12(fp)
        TCB_t * pxTCB;

        taskENTER_CRITICAL();
 4004164:	4005f740 	call	4005f74 <vTaskEnterCritical>
        {
            /* If null is passed in here then it is the running task that is
             * being suspended. */
            pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
 4004168:	e0bffd17 	ldw	r2,-12(fp)
 400416c:	1000021e 	bne	r2,zero,4004178 <vTaskSuspend+0x28>
 4004170:	d0a6ad17 	ldw	r2,-25932(gp)
 4004174:	00000106 	br	400417c <vTaskSuspend+0x2c>
 4004178:	e0bffd17 	ldw	r2,-12(fp)
 400417c:	e0bffe15 	stw	r2,-8(fp)

            traceTASK_SUSPEND( pxTCB );

            /* Remove task from the ready/delayed list and place in the
             * suspended list. */
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 4004180:	e0bffe17 	ldw	r2,-8(fp)
 4004184:	10800104 	addi	r2,r2,4
 4004188:	1009883a 	mov	r4,r2
 400418c:	4000c980 	call	4000c98 <uxListRemove>
            {
                mtCOVERAGE_TEST_MARKER();
            }

            /* Is the task waiting on an event also? */
            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 4004190:	e0bffe17 	ldw	r2,-8(fp)
 4004194:	10800a17 	ldw	r2,40(r2)
 4004198:	10000426 	beq	r2,zero,40041ac <vTaskSuspend+0x5c>
            {
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 400419c:	e0bffe17 	ldw	r2,-8(fp)
 40041a0:	10800604 	addi	r2,r2,24
 40041a4:	1009883a 	mov	r4,r2
 40041a8:	4000c980 	call	4000c98 <uxListRemove>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
 40041ac:	e0bffe17 	ldw	r2,-8(fp)
 40041b0:	10800104 	addi	r2,r2,4
 40041b4:	100b883a 	mov	r5,r2
 40041b8:	01012074 	movhi	r4,1153
 40041bc:	213fde04 	addi	r4,r4,-136
 40041c0:	4000b340 	call	4000b34 <vListInsertEnd>

            #if ( configUSE_TASK_NOTIFICATIONS == 1 )
            {
                BaseType_t x;

                for( x = 0; x < configTASK_NOTIFICATION_ARRAY_ENTRIES; x++ )
 40041c4:	e03fff15 	stw	zero,-4(fp)
 40041c8:	00000e06 	br	4004204 <vTaskSuspend+0xb4>
                {
                    if( pxTCB->ucNotifyState[ x ] == taskWAITING_NOTIFICATION )
 40041cc:	e0fffe17 	ldw	r3,-8(fp)
 40041d0:	e0bfff17 	ldw	r2,-4(fp)
 40041d4:	1885883a 	add	r2,r3,r2
 40041d8:	10801303 	ldbu	r2,76(r2)
 40041dc:	10803fcc 	andi	r2,r2,255
 40041e0:	10800058 	cmpnei	r2,r2,1
 40041e4:	1000041e 	bne	r2,zero,40041f8 <vTaskSuspend+0xa8>
                    {
                        /* The task was blocked to wait for a notification, but is
                         * now suspended, so no notification was received. */
                        pxTCB->ucNotifyState[ x ] = taskNOT_WAITING_NOTIFICATION;
 40041e8:	e0fffe17 	ldw	r3,-8(fp)
 40041ec:	e0bfff17 	ldw	r2,-4(fp)
 40041f0:	1885883a 	add	r2,r3,r2
 40041f4:	10001305 	stb	zero,76(r2)
                for( x = 0; x < configTASK_NOTIFICATION_ARRAY_ENTRIES; x++ )
 40041f8:	e0bfff17 	ldw	r2,-4(fp)
 40041fc:	10800044 	addi	r2,r2,1
 4004200:	e0bfff15 	stw	r2,-4(fp)
 4004204:	e0bfff17 	ldw	r2,-4(fp)
 4004208:	00bff00e 	bge	zero,r2,40041cc <vTaskSuspend+0x7c>
                    }
                }
            }
            #endif /* if ( configUSE_TASK_NOTIFICATIONS == 1 ) */
        }
        taskEXIT_CRITICAL();
 400420c:	4005fc80 	call	4005fc8 <vTaskExitCritical>

        if( xSchedulerRunning != pdFALSE )
 4004210:	d0a6b417 	ldw	r2,-25904(gp)
 4004214:	10000326 	beq	r2,zero,4004224 <vTaskSuspend+0xd4>
        {
            /* Reset the next expected unblock time in case it referred to the
             * task that is now in the Suspended state. */
            taskENTER_CRITICAL();
 4004218:	4005f740 	call	4005f74 <vTaskEnterCritical>
            {
                prvResetNextTaskUnblockTime();
 400421c:	40059400 	call	4005940 <prvResetNextTaskUnblockTime>
            }
            taskEXIT_CRITICAL();
 4004220:	4005fc80 	call	4005fc8 <vTaskExitCritical>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( pxTCB == pxCurrentTCB )
 4004224:	d0a6ad17 	ldw	r2,-25932(gp)
 4004228:	e0fffe17 	ldw	r3,-8(fp)
 400422c:	18800b1e 	bne	r3,r2,400425c <vTaskSuspend+0x10c>
        {
            if( xSchedulerRunning != pdFALSE )
 4004230:	d0a6b417 	ldw	r2,-25904(gp)
 4004234:	10000226 	beq	r2,zero,4004240 <vTaskSuspend+0xf0>
            {
                /* The current task has just been suspended. */
                configASSERT( uxSchedulerSuspended == 0 );
                portYIELD_WITHIN_API();
 4004238:	003b683a 	trap	0
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
 400423c:	00000706 	br	400425c <vTaskSuspend+0x10c>
                if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
 4004240:	00812074 	movhi	r2,1153
 4004244:	10ffde17 	ldw	r3,-136(r2)
 4004248:	d0a6b117 	ldw	r2,-25916(gp)
 400424c:	1880021e 	bne	r3,r2,4004258 <vTaskSuspend+0x108>
                    pxCurrentTCB = NULL;
 4004250:	d026ad15 	stw	zero,-25932(gp)
    }
 4004254:	00000106 	br	400425c <vTaskSuspend+0x10c>
                    vTaskSwitchContext();
 4004258:	4004e280 	call	4004e28 <vTaskSwitchContext>
    }
 400425c:	0001883a 	nop
 4004260:	e037883a 	mov	sp,fp
 4004264:	dfc00117 	ldw	ra,4(sp)
 4004268:	df000017 	ldw	fp,0(sp)
 400426c:	dec00204 	addi	sp,sp,8
 4004270:	f800283a 	ret

04004274 <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

    static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
    {
 4004274:	defffc04 	addi	sp,sp,-16
 4004278:	df000315 	stw	fp,12(sp)
 400427c:	df000304 	addi	fp,sp,12
 4004280:	e13ffd15 	stw	r4,-12(fp)
        BaseType_t xReturn = pdFALSE;
 4004284:	e03fff15 	stw	zero,-4(fp)
        const TCB_t * const pxTCB = xTask;
 4004288:	e0bffd17 	ldw	r2,-12(fp)
 400428c:	e0bffe15 	stw	r2,-8(fp)

        /* It does not make sense to check if the calling task is suspended. */
        configASSERT( xTask );

        /* Is the task being resumed actually in the suspended list? */
        if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
 4004290:	e0bffe17 	ldw	r2,-8(fp)
 4004294:	10c00517 	ldw	r3,20(r2)
 4004298:	00812074 	movhi	r2,1153
 400429c:	10bfde04 	addi	r2,r2,-136
 40042a0:	18800a1e 	bne	r3,r2,40042cc <prvTaskIsTaskSuspended+0x58>
        {
            /* Has the task already been resumed from within an ISR? */
            if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
 40042a4:	e0bffe17 	ldw	r2,-8(fp)
 40042a8:	10c00a17 	ldw	r3,40(r2)
 40042ac:	00812074 	movhi	r2,1153
 40042b0:	10bfd404 	addi	r2,r2,-176
 40042b4:	18800526 	beq	r3,r2,40042cc <prvTaskIsTaskSuspended+0x58>
            {
                /* Is it in the suspended list because it is in the Suspended
                 * state, or because is is blocked with no timeout? */
                if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
 40042b8:	e0bffe17 	ldw	r2,-8(fp)
 40042bc:	10800a17 	ldw	r2,40(r2)
 40042c0:	1000021e 	bne	r2,zero,40042cc <prvTaskIsTaskSuspended+0x58>
                {
                    xReturn = pdTRUE;
 40042c4:	00800044 	movi	r2,1
 40042c8:	e0bfff15 	stw	r2,-4(fp)
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
 40042cc:	e0bfff17 	ldw	r2,-4(fp)
    } /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
 40042d0:	e037883a 	mov	sp,fp
 40042d4:	df000017 	ldw	fp,0(sp)
 40042d8:	dec00104 	addi	sp,sp,4
 40042dc:	f800283a 	ret

040042e0 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

    void vTaskResume( TaskHandle_t xTaskToResume )
    {
 40042e0:	defff904 	addi	sp,sp,-28
 40042e4:	dfc00615 	stw	ra,24(sp)
 40042e8:	df000515 	stw	fp,20(sp)
 40042ec:	dc400415 	stw	r17,16(sp)
 40042f0:	dc000315 	stw	r16,12(sp)
 40042f4:	df000504 	addi	fp,sp,20
 40042f8:	e13ffb15 	stw	r4,-20(fp)
        TCB_t * const pxTCB = xTaskToResume;
 40042fc:	e0bffb17 	ldw	r2,-20(fp)
 4004300:	e0bffd15 	stw	r2,-12(fp)
        /* It does not make sense to resume the calling task. */
        configASSERT( xTaskToResume );

        /* The parameter cannot be NULL as it is impossible to resume the
         * currently executing task. */
        if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
 4004304:	d0a6ad17 	ldw	r2,-25932(gp)
 4004308:	e0fffd17 	ldw	r3,-12(fp)
 400430c:	18804e26 	beq	r3,r2,4004448 <vTaskResume+0x168>
 4004310:	e0bffd17 	ldw	r2,-12(fp)
 4004314:	10004c26 	beq	r2,zero,4004448 <vTaskResume+0x168>
        {
            taskENTER_CRITICAL();
 4004318:	4005f740 	call	4005f74 <vTaskEnterCritical>
            {
                if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
 400431c:	e13ffd17 	ldw	r4,-12(fp)
 4004320:	40042740 	call	4004274 <prvTaskIsTaskSuspended>
 4004324:	10004726 	beq	r2,zero,4004444 <vTaskResume+0x164>
                {
                    traceTASK_RESUME( pxTCB );

                    /* The ready list can be accessed even if the scheduler is
                     * suspended because this is inside a critical section. */
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 4004328:	e0bffd17 	ldw	r2,-12(fp)
 400432c:	10800104 	addi	r2,r2,4
 4004330:	1009883a 	mov	r4,r2
 4004334:	4000c980 	call	4000c98 <uxListRemove>
                    prvAddTaskToReadyList( pxTCB );
 4004338:	e0bffd17 	ldw	r2,-12(fp)
 400433c:	10800b17 	ldw	r2,44(r2)
 4004340:	d0e6b317 	ldw	r3,-25908(gp)
 4004344:	1880032e 	bgeu	r3,r2,4004354 <vTaskResume+0x74>
 4004348:	e0bffd17 	ldw	r2,-12(fp)
 400434c:	10800b17 	ldw	r2,44(r2)
 4004350:	d0a6b315 	stw	r2,-25908(gp)
 4004354:	e0bffd17 	ldw	r2,-12(fp)
 4004358:	10800b17 	ldw	r2,44(r2)
 400435c:	01400504 	movi	r5,20
 4004360:	1009883a 	mov	r4,r2
 4004364:	40073b40 	call	40073b4 <__mulsi3>
 4004368:	1007883a 	mov	r3,r2
 400436c:	00812074 	movhi	r2,1153
 4004370:	1885883a 	add	r2,r3,r2
 4004374:	10bfb217 	ldw	r2,-312(r2)
 4004378:	e0bffc15 	stw	r2,-16(fp)
 400437c:	e0bffd17 	ldw	r2,-12(fp)
 4004380:	e0fffc17 	ldw	r3,-16(fp)
 4004384:	10c00215 	stw	r3,8(r2)
 4004388:	e0bffc17 	ldw	r2,-16(fp)
 400438c:	10c00217 	ldw	r3,8(r2)
 4004390:	e0bffd17 	ldw	r2,-12(fp)
 4004394:	10c00315 	stw	r3,12(r2)
 4004398:	e0bffc17 	ldw	r2,-16(fp)
 400439c:	10800217 	ldw	r2,8(r2)
 40043a0:	e0fffd17 	ldw	r3,-12(fp)
 40043a4:	18c00104 	addi	r3,r3,4
 40043a8:	10c00115 	stw	r3,4(r2)
 40043ac:	e0bffd17 	ldw	r2,-12(fp)
 40043b0:	10c00104 	addi	r3,r2,4
 40043b4:	e0bffc17 	ldw	r2,-16(fp)
 40043b8:	10c00215 	stw	r3,8(r2)
 40043bc:	e0bffd17 	ldw	r2,-12(fp)
 40043c0:	10800b17 	ldw	r2,44(r2)
 40043c4:	01400504 	movi	r5,20
 40043c8:	1009883a 	mov	r4,r2
 40043cc:	40073b40 	call	40073b4 <__mulsi3>
 40043d0:	1007883a 	mov	r3,r2
 40043d4:	00812074 	movhi	r2,1153
 40043d8:	10bfb104 	addi	r2,r2,-316
 40043dc:	1887883a 	add	r3,r3,r2
 40043e0:	e0bffd17 	ldw	r2,-12(fp)
 40043e4:	10c00515 	stw	r3,20(r2)
 40043e8:	e0bffd17 	ldw	r2,-12(fp)
 40043ec:	14400b17 	ldw	r17,44(r2)
 40043f0:	01400504 	movi	r5,20
 40043f4:	8809883a 	mov	r4,r17
 40043f8:	40073b40 	call	40073b4 <__mulsi3>
 40043fc:	1007883a 	mov	r3,r2
 4004400:	00812074 	movhi	r2,1153
 4004404:	1885883a 	add	r2,r3,r2
 4004408:	10bfb117 	ldw	r2,-316(r2)
 400440c:	14000044 	addi	r16,r2,1
 4004410:	01400504 	movi	r5,20
 4004414:	8809883a 	mov	r4,r17
 4004418:	40073b40 	call	40073b4 <__mulsi3>
 400441c:	1007883a 	mov	r3,r2
 4004420:	00812074 	movhi	r2,1153
 4004424:	1885883a 	add	r2,r3,r2
 4004428:	143fb115 	stw	r16,-316(r2)

                    /* A higher priority task may have just been resumed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 400442c:	e0bffd17 	ldw	r2,-12(fp)
 4004430:	10c00b17 	ldw	r3,44(r2)
 4004434:	d0a6ad17 	ldw	r2,-25932(gp)
 4004438:	10800b17 	ldw	r2,44(r2)
 400443c:	18800136 	bltu	r3,r2,4004444 <vTaskResume+0x164>
                    {
                        /* This yield may not cause the task just resumed to run,
                         * but will leave the lists in the correct state for the
                         * next yield. */
                        taskYIELD_IF_USING_PREEMPTION();
 4004440:	003b683a 	trap	0
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            taskEXIT_CRITICAL();
 4004444:	4005fc80 	call	4005fc8 <vTaskExitCritical>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
 4004448:	0001883a 	nop
 400444c:	e6fffe04 	addi	sp,fp,-8
 4004450:	dfc00317 	ldw	ra,12(sp)
 4004454:	df000217 	ldw	fp,8(sp)
 4004458:	dc400117 	ldw	r17,4(sp)
 400445c:	dc000017 	ldw	r16,0(sp)
 4004460:	dec00404 	addi	sp,sp,16
 4004464:	f800283a 	ret

04004468 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

    BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
    {
 4004468:	defff704 	addi	sp,sp,-36
 400446c:	dfc00815 	stw	ra,32(sp)
 4004470:	df000715 	stw	fp,28(sp)
 4004474:	dc400615 	stw	r17,24(sp)
 4004478:	dc000515 	stw	r16,20(sp)
 400447c:	df000704 	addi	fp,sp,28
 4004480:	e13ff915 	stw	r4,-28(fp)
        BaseType_t xYieldRequired = pdFALSE;
 4004484:	e03ffd15 	stw	zero,-12(fp)
        TCB_t * const pxTCB = xTaskToResume;
 4004488:	e0bff917 	ldw	r2,-28(fp)
 400448c:	e0bffc15 	stw	r2,-16(fp)
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 4004490:	e03ffb15 	stw	zero,-20(fp)
        {
            if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
 4004494:	e13ffc17 	ldw	r4,-16(fp)
 4004498:	40042740 	call	4004274 <prvTaskIsTaskSuspended>
 400449c:	10005326 	beq	r2,zero,40045ec <xTaskResumeFromISR+0x184>
            {
                traceTASK_RESUME_FROM_ISR( pxTCB );

                /* Check the ready lists can be accessed. */
                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 40044a0:	d0a6bb17 	ldw	r2,-25876(gp)
 40044a4:	10004b1e 	bne	r2,zero,40045d4 <xTaskResumeFromISR+0x16c>
                {
                    /* Ready lists can be accessed so move the task from the
                     * suspended list to the ready list directly. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 40044a8:	e0bffc17 	ldw	r2,-16(fp)
 40044ac:	10c00b17 	ldw	r3,44(r2)
 40044b0:	d0a6ad17 	ldw	r2,-25932(gp)
 40044b4:	10800b17 	ldw	r2,44(r2)
 40044b8:	18800436 	bltu	r3,r2,40044cc <xTaskResumeFromISR+0x64>
                    {
                        xYieldRequired = pdTRUE;
 40044bc:	00800044 	movi	r2,1
 40044c0:	e0bffd15 	stw	r2,-12(fp)

                        /* Mark that a yield is pending in case the user is not
                         * using the return value to initiate a context switch
                         * from the ISR using portYIELD_FROM_ISR. */
                        xYieldPending = pdTRUE;
 40044c4:	00800044 	movi	r2,1
 40044c8:	d0a6b615 	stw	r2,-25896(gp)
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 40044cc:	e0bffc17 	ldw	r2,-16(fp)
 40044d0:	10800104 	addi	r2,r2,4
 40044d4:	1009883a 	mov	r4,r2
 40044d8:	4000c980 	call	4000c98 <uxListRemove>
                    prvAddTaskToReadyList( pxTCB );
 40044dc:	e0bffc17 	ldw	r2,-16(fp)
 40044e0:	10800b17 	ldw	r2,44(r2)
 40044e4:	d0e6b317 	ldw	r3,-25908(gp)
 40044e8:	1880032e 	bgeu	r3,r2,40044f8 <xTaskResumeFromISR+0x90>
 40044ec:	e0bffc17 	ldw	r2,-16(fp)
 40044f0:	10800b17 	ldw	r2,44(r2)
 40044f4:	d0a6b315 	stw	r2,-25908(gp)
 40044f8:	e0bffc17 	ldw	r2,-16(fp)
 40044fc:	10800b17 	ldw	r2,44(r2)
 4004500:	01400504 	movi	r5,20
 4004504:	1009883a 	mov	r4,r2
 4004508:	40073b40 	call	40073b4 <__mulsi3>
 400450c:	1007883a 	mov	r3,r2
 4004510:	00812074 	movhi	r2,1153
 4004514:	1885883a 	add	r2,r3,r2
 4004518:	10bfb217 	ldw	r2,-312(r2)
 400451c:	e0bffa15 	stw	r2,-24(fp)
 4004520:	e0bffc17 	ldw	r2,-16(fp)
 4004524:	e0fffa17 	ldw	r3,-24(fp)
 4004528:	10c00215 	stw	r3,8(r2)
 400452c:	e0bffa17 	ldw	r2,-24(fp)
 4004530:	10c00217 	ldw	r3,8(r2)
 4004534:	e0bffc17 	ldw	r2,-16(fp)
 4004538:	10c00315 	stw	r3,12(r2)
 400453c:	e0bffa17 	ldw	r2,-24(fp)
 4004540:	10800217 	ldw	r2,8(r2)
 4004544:	e0fffc17 	ldw	r3,-16(fp)
 4004548:	18c00104 	addi	r3,r3,4
 400454c:	10c00115 	stw	r3,4(r2)
 4004550:	e0bffc17 	ldw	r2,-16(fp)
 4004554:	10c00104 	addi	r3,r2,4
 4004558:	e0bffa17 	ldw	r2,-24(fp)
 400455c:	10c00215 	stw	r3,8(r2)
 4004560:	e0bffc17 	ldw	r2,-16(fp)
 4004564:	10800b17 	ldw	r2,44(r2)
 4004568:	01400504 	movi	r5,20
 400456c:	1009883a 	mov	r4,r2
 4004570:	40073b40 	call	40073b4 <__mulsi3>
 4004574:	1007883a 	mov	r3,r2
 4004578:	00812074 	movhi	r2,1153
 400457c:	10bfb104 	addi	r2,r2,-316
 4004580:	1887883a 	add	r3,r3,r2
 4004584:	e0bffc17 	ldw	r2,-16(fp)
 4004588:	10c00515 	stw	r3,20(r2)
 400458c:	e0bffc17 	ldw	r2,-16(fp)
 4004590:	14400b17 	ldw	r17,44(r2)
 4004594:	01400504 	movi	r5,20
 4004598:	8809883a 	mov	r4,r17
 400459c:	40073b40 	call	40073b4 <__mulsi3>
 40045a0:	1007883a 	mov	r3,r2
 40045a4:	00812074 	movhi	r2,1153
 40045a8:	1885883a 	add	r2,r3,r2
 40045ac:	10bfb117 	ldw	r2,-316(r2)
 40045b0:	14000044 	addi	r16,r2,1
 40045b4:	01400504 	movi	r5,20
 40045b8:	8809883a 	mov	r4,r17
 40045bc:	40073b40 	call	40073b4 <__mulsi3>
 40045c0:	1007883a 	mov	r3,r2
 40045c4:	00812074 	movhi	r2,1153
 40045c8:	1885883a 	add	r2,r3,r2
 40045cc:	143fb115 	stw	r16,-316(r2)
 40045d0:	00000606 	br	40045ec <xTaskResumeFromISR+0x184>
                else
                {
                    /* The delayed or ready lists cannot be accessed so the task
                     * is held in the pending ready list until the scheduler is
                     * unsuspended. */
                    vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 40045d4:	e0bffc17 	ldw	r2,-16(fp)
 40045d8:	10800604 	addi	r2,r2,24
 40045dc:	100b883a 	mov	r5,r2
 40045e0:	01012074 	movhi	r4,1153
 40045e4:	213fd404 	addi	r4,r4,-176
 40045e8:	4000b340 	call	4000b34 <vListInsertEnd>
                mtCOVERAGE_TEST_MARKER();
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

        return xYieldRequired;
 40045ec:	e0bffd17 	ldw	r2,-12(fp)
    }
 40045f0:	e6fffe04 	addi	sp,fp,-8
 40045f4:	dfc00317 	ldw	ra,12(sp)
 40045f8:	df000217 	ldw	fp,8(sp)
 40045fc:	dc400117 	ldw	r17,4(sp)
 4004600:	dc000017 	ldw	r16,0(sp)
 4004604:	dec00404 	addi	sp,sp,16
 4004608:	f800283a 	ret

0400460c <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
 400460c:	defffa04 	addi	sp,sp,-24
 4004610:	dfc00515 	stw	ra,20(sp)
 4004614:	df000415 	stw	fp,16(sp)
 4004618:	df000404 	addi	fp,sp,16
        }
    }
    #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
    {
        /* The Idle task is being created using dynamically allocated RAM. */
        xReturn = xTaskCreate( prvIdleTask,
 400461c:	d0a6ba04 	addi	r2,gp,-25880
 4004620:	d8800115 	stw	r2,4(sp)
 4004624:	d8000015 	stw	zero,0(sp)
 4004628:	000f883a 	mov	r7,zero
 400462c:	01810004 	movi	r6,1024
 4004630:	01410074 	movhi	r5,1025
 4004634:	29723e04 	addi	r5,r5,-14088
 4004638:	01010034 	movhi	r4,1024
 400463c:	2115b704 	addi	r4,r4,22236
 4004640:	40037ac0 	call	40037ac <xTaskCreate>
 4004644:	e0bfff15 	stw	r2,-4(fp)
            mtCOVERAGE_TEST_MARKER();
        }
    }
    #endif /* configUSE_TIMERS */

    if( xReturn == pdPASS )
 4004648:	e0bfff17 	ldw	r2,-4(fp)
 400464c:	10800058 	cmpnei	r2,r2,1
 4004650:	10000c1e 	bne	r2,zero,4004684 <vTaskStartScheduler+0x78>
  NIOS2_READ_STATUS (context);
 4004654:	0005303a 	rdctl	r2,status
 4004658:	e0bffe15 	stw	r2,-8(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 400465c:	e0fffe17 	ldw	r3,-8(fp)
 4004660:	00bfff84 	movi	r2,-2
 4004664:	1884703a 	and	r2,r3,r2
 4004668:	1001703a 	wrctl	status,r2
             * block specific to the task that will run first. */
            configSET_TLS_BLOCK( pxCurrentTCB->xTLSBlock );
        }
        #endif

        xNextTaskUnblockTime = portMAX_DELAY;
 400466c:	00bfffc4 	movi	r2,-1
 4004670:	d0a6b915 	stw	r2,-25884(gp)
        xSchedulerRunning = pdTRUE;
 4004674:	00800044 	movi	r2,1
 4004678:	d0a6b415 	stw	r2,-25904(gp)
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
 400467c:	d026b215 	stw	zero,-25912(gp)

        traceTASK_SWITCHED_IN();

        /* Setting up the timer tick is hardware specific and thus in the
         * portable interface. */
        xPortStartScheduler();
 4004680:	4000e3c0 	call	4000e3c <xPortStartScheduler>
     * meaning xIdleTaskHandle is not used anywhere else. */
    ( void ) xIdleTaskHandle;

    /* OpenOCD makes use of uxTopUsedPriority for thread debugging. Prevent uxTopUsedPriority
     * from getting optimized out as it is no longer used by the kernel. */
    ( void ) uxTopUsedPriority;
 4004684:	d0a00017 	ldw	r2,-32768(gp)
}
 4004688:	0001883a 	nop
 400468c:	e037883a 	mov	sp,fp
 4004690:	dfc00117 	ldw	ra,4(sp)
 4004694:	df000017 	ldw	fp,0(sp)
 4004698:	dec00204 	addi	sp,sp,8
 400469c:	f800283a 	ret

040046a0 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
 40046a0:	defffd04 	addi	sp,sp,-12
 40046a4:	dfc00215 	stw	ra,8(sp)
 40046a8:	df000115 	stw	fp,4(sp)
 40046ac:	df000104 	addi	fp,sp,4
  NIOS2_READ_STATUS (context);
 40046b0:	0005303a 	rdctl	r2,status
 40046b4:	e0bfff15 	stw	r2,-4(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 40046b8:	e0ffff17 	ldw	r3,-4(fp)
 40046bc:	00bfff84 	movi	r2,-2
 40046c0:	1884703a 	and	r2,r3,r2
 40046c4:	1001703a 	wrctl	status,r2
    /* Stop the scheduler interrupts and call the portable scheduler end
     * routine so the original ISRs can be restored if necessary.  The port
     * layer must ensure interrupts enable  bit is left in the correct state. */
    portDISABLE_INTERRUPTS();
    xSchedulerRunning = pdFALSE;
 40046c8:	d026b415 	stw	zero,-25904(gp)
    vPortEndScheduler();
 40046cc:	4000e740 	call	4000e74 <vPortEndScheduler>
}
 40046d0:	0001883a 	nop
 40046d4:	e037883a 	mov	sp,fp
 40046d8:	dfc00117 	ldw	ra,4(sp)
 40046dc:	df000017 	ldw	fp,0(sp)
 40046e0:	dec00204 	addi	sp,sp,8
 40046e4:	f800283a 	ret

040046e8 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
 40046e8:	deffff04 	addi	sp,sp,-4
 40046ec:	df000015 	stw	fp,0(sp)
 40046f0:	d839883a 	mov	fp,sp
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
 40046f4:	d0a6bb17 	ldw	r2,-25876(gp)
 40046f8:	10800044 	addi	r2,r2,1
 40046fc:	d0a6bb15 	stw	r2,-25876(gp)

    /* Enforces ordering for ports and optimised compilers that may otherwise place
     * the above increment elsewhere. */
    portMEMORY_BARRIER();
}
 4004700:	0001883a 	nop
 4004704:	e037883a 	mov	sp,fp
 4004708:	df000017 	ldw	fp,0(sp)
 400470c:	dec00104 	addi	sp,sp,4
 4004710:	f800283a 	ret

04004714 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
 4004714:	defff604 	addi	sp,sp,-40
 4004718:	dfc00915 	stw	ra,36(sp)
 400471c:	df000815 	stw	fp,32(sp)
 4004720:	dc400715 	stw	r17,28(sp)
 4004724:	dc000615 	stw	r16,24(sp)
 4004728:	df000804 	addi	fp,sp,32
    TCB_t * pxTCB = NULL;
 400472c:	e03ffd15 	stw	zero,-12(fp)
    BaseType_t xAlreadyYielded = pdFALSE;
 4004730:	e03ffc15 	stw	zero,-16(fp)
    /* It is possible that an ISR caused a task to be removed from an event
     * list while the scheduler was suspended.  If this was the case then the
     * removed task will have been added to the xPendingReadyList.  Once the
     * scheduler has been resumed it is safe to move all the pending ready
     * tasks from this list into their appropriate ready list. */
    taskENTER_CRITICAL();
 4004734:	4005f740 	call	4005f74 <vTaskEnterCritical>
    {
        --uxSchedulerSuspended;
 4004738:	d0a6bb17 	ldw	r2,-25876(gp)
 400473c:	10bfffc4 	addi	r2,r2,-1
 4004740:	d0a6bb15 	stw	r2,-25876(gp)

        if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 4004744:	d0a6bb17 	ldw	r2,-25876(gp)
 4004748:	10009e1e 	bne	r2,zero,40049c4 <xTaskResumeAll+0x2b0>
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 400474c:	d0a6b117 	ldw	r2,-25916(gp)
 4004750:	10009c26 	beq	r2,zero,40049c4 <xTaskResumeAll+0x2b0>
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 4004754:	00008206 	br	4004960 <xTaskResumeAll+0x24c>
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 4004758:	00812074 	movhi	r2,1153
 400475c:	10bfd717 	ldw	r2,-164(r2)
 4004760:	10800317 	ldw	r2,12(r2)
 4004764:	e0bffd15 	stw	r2,-12(fp)
                    listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
 4004768:	e0bffd17 	ldw	r2,-12(fp)
 400476c:	10800a17 	ldw	r2,40(r2)
 4004770:	e0bffa15 	stw	r2,-24(fp)
 4004774:	e0bffd17 	ldw	r2,-12(fp)
 4004778:	10800717 	ldw	r2,28(r2)
 400477c:	e0fffd17 	ldw	r3,-12(fp)
 4004780:	18c00817 	ldw	r3,32(r3)
 4004784:	10c00215 	stw	r3,8(r2)
 4004788:	e0bffd17 	ldw	r2,-12(fp)
 400478c:	10800817 	ldw	r2,32(r2)
 4004790:	e0fffd17 	ldw	r3,-12(fp)
 4004794:	18c00717 	ldw	r3,28(r3)
 4004798:	10c00115 	stw	r3,4(r2)
 400479c:	e0bffa17 	ldw	r2,-24(fp)
 40047a0:	10c00117 	ldw	r3,4(r2)
 40047a4:	e0bffd17 	ldw	r2,-12(fp)
 40047a8:	10800604 	addi	r2,r2,24
 40047ac:	1880041e 	bne	r3,r2,40047c0 <xTaskResumeAll+0xac>
 40047b0:	e0bffd17 	ldw	r2,-12(fp)
 40047b4:	10c00817 	ldw	r3,32(r2)
 40047b8:	e0bffa17 	ldw	r2,-24(fp)
 40047bc:	10c00115 	stw	r3,4(r2)
 40047c0:	e0bffd17 	ldw	r2,-12(fp)
 40047c4:	10000a15 	stw	zero,40(r2)
 40047c8:	e0bffa17 	ldw	r2,-24(fp)
 40047cc:	10800017 	ldw	r2,0(r2)
 40047d0:	10ffffc4 	addi	r3,r2,-1
 40047d4:	e0bffa17 	ldw	r2,-24(fp)
 40047d8:	10c00015 	stw	r3,0(r2)
                    portMEMORY_BARRIER();
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 40047dc:	e0bffd17 	ldw	r2,-12(fp)
 40047e0:	10800517 	ldw	r2,20(r2)
 40047e4:	e0bff915 	stw	r2,-28(fp)
 40047e8:	e0bffd17 	ldw	r2,-12(fp)
 40047ec:	10800217 	ldw	r2,8(r2)
 40047f0:	e0fffd17 	ldw	r3,-12(fp)
 40047f4:	18c00317 	ldw	r3,12(r3)
 40047f8:	10c00215 	stw	r3,8(r2)
 40047fc:	e0bffd17 	ldw	r2,-12(fp)
 4004800:	10800317 	ldw	r2,12(r2)
 4004804:	e0fffd17 	ldw	r3,-12(fp)
 4004808:	18c00217 	ldw	r3,8(r3)
 400480c:	10c00115 	stw	r3,4(r2)
 4004810:	e0bff917 	ldw	r2,-28(fp)
 4004814:	10c00117 	ldw	r3,4(r2)
 4004818:	e0bffd17 	ldw	r2,-12(fp)
 400481c:	10800104 	addi	r2,r2,4
 4004820:	1880041e 	bne	r3,r2,4004834 <xTaskResumeAll+0x120>
 4004824:	e0bffd17 	ldw	r2,-12(fp)
 4004828:	10c00317 	ldw	r3,12(r2)
 400482c:	e0bff917 	ldw	r2,-28(fp)
 4004830:	10c00115 	stw	r3,4(r2)
 4004834:	e0bffd17 	ldw	r2,-12(fp)
 4004838:	10000515 	stw	zero,20(r2)
 400483c:	e0bff917 	ldw	r2,-28(fp)
 4004840:	10800017 	ldw	r2,0(r2)
 4004844:	10ffffc4 	addi	r3,r2,-1
 4004848:	e0bff917 	ldw	r2,-28(fp)
 400484c:	10c00015 	stw	r3,0(r2)
                    prvAddTaskToReadyList( pxTCB );
 4004850:	e0bffd17 	ldw	r2,-12(fp)
 4004854:	10800b17 	ldw	r2,44(r2)
 4004858:	d0e6b317 	ldw	r3,-25908(gp)
 400485c:	1880032e 	bgeu	r3,r2,400486c <xTaskResumeAll+0x158>
 4004860:	e0bffd17 	ldw	r2,-12(fp)
 4004864:	10800b17 	ldw	r2,44(r2)
 4004868:	d0a6b315 	stw	r2,-25908(gp)
 400486c:	e0bffd17 	ldw	r2,-12(fp)
 4004870:	10800b17 	ldw	r2,44(r2)
 4004874:	01400504 	movi	r5,20
 4004878:	1009883a 	mov	r4,r2
 400487c:	40073b40 	call	40073b4 <__mulsi3>
 4004880:	1007883a 	mov	r3,r2
 4004884:	00812074 	movhi	r2,1153
 4004888:	1885883a 	add	r2,r3,r2
 400488c:	10bfb217 	ldw	r2,-312(r2)
 4004890:	e0bff815 	stw	r2,-32(fp)
 4004894:	e0bffd17 	ldw	r2,-12(fp)
 4004898:	e0fff817 	ldw	r3,-32(fp)
 400489c:	10c00215 	stw	r3,8(r2)
 40048a0:	e0bff817 	ldw	r2,-32(fp)
 40048a4:	10c00217 	ldw	r3,8(r2)
 40048a8:	e0bffd17 	ldw	r2,-12(fp)
 40048ac:	10c00315 	stw	r3,12(r2)
 40048b0:	e0bff817 	ldw	r2,-32(fp)
 40048b4:	10800217 	ldw	r2,8(r2)
 40048b8:	e0fffd17 	ldw	r3,-12(fp)
 40048bc:	18c00104 	addi	r3,r3,4
 40048c0:	10c00115 	stw	r3,4(r2)
 40048c4:	e0bffd17 	ldw	r2,-12(fp)
 40048c8:	10c00104 	addi	r3,r2,4
 40048cc:	e0bff817 	ldw	r2,-32(fp)
 40048d0:	10c00215 	stw	r3,8(r2)
 40048d4:	e0bffd17 	ldw	r2,-12(fp)
 40048d8:	10800b17 	ldw	r2,44(r2)
 40048dc:	01400504 	movi	r5,20
 40048e0:	1009883a 	mov	r4,r2
 40048e4:	40073b40 	call	40073b4 <__mulsi3>
 40048e8:	1007883a 	mov	r3,r2
 40048ec:	00812074 	movhi	r2,1153
 40048f0:	10bfb104 	addi	r2,r2,-316
 40048f4:	1887883a 	add	r3,r3,r2
 40048f8:	e0bffd17 	ldw	r2,-12(fp)
 40048fc:	10c00515 	stw	r3,20(r2)
 4004900:	e0bffd17 	ldw	r2,-12(fp)
 4004904:	14400b17 	ldw	r17,44(r2)
 4004908:	01400504 	movi	r5,20
 400490c:	8809883a 	mov	r4,r17
 4004910:	40073b40 	call	40073b4 <__mulsi3>
 4004914:	1007883a 	mov	r3,r2
 4004918:	00812074 	movhi	r2,1153
 400491c:	1885883a 	add	r2,r3,r2
 4004920:	10bfb117 	ldw	r2,-316(r2)
 4004924:	14000044 	addi	r16,r2,1
 4004928:	01400504 	movi	r5,20
 400492c:	8809883a 	mov	r4,r17
 4004930:	40073b40 	call	40073b4 <__mulsi3>
 4004934:	1007883a 	mov	r3,r2
 4004938:	00812074 	movhi	r2,1153
 400493c:	1885883a 	add	r2,r3,r2
 4004940:	143fb115 	stw	r16,-316(r2)

                    /* If the moved task has a priority higher than or equal to
                     * the current task then a yield must be performed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 4004944:	e0bffd17 	ldw	r2,-12(fp)
 4004948:	10c00b17 	ldw	r3,44(r2)
 400494c:	d0a6ad17 	ldw	r2,-25932(gp)
 4004950:	10800b17 	ldw	r2,44(r2)
 4004954:	18800236 	bltu	r3,r2,4004960 <xTaskResumeAll+0x24c>
                    {
                        xYieldPending = pdTRUE;
 4004958:	00800044 	movi	r2,1
 400495c:	d0a6b615 	stw	r2,-25896(gp)
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 4004960:	00812074 	movhi	r2,1153
 4004964:	10bfd417 	ldw	r2,-176(r2)
 4004968:	103f7b1e 	bne	r2,zero,4004758 <xTaskResumeAll+0x44>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( pxTCB != NULL )
 400496c:	e0bffd17 	ldw	r2,-12(fp)
 4004970:	10000126 	beq	r2,zero,4004978 <xTaskResumeAll+0x264>
                     * which may have prevented the next unblock time from being
                     * re-calculated, in which case re-calculate it now.  Mainly
                     * important for low power tickless implementations, where
                     * this can prevent an unnecessary exit from low power
                     * state. */
                    prvResetNextTaskUnblockTime();
 4004974:	40059400 	call	4005940 <prvResetNextTaskUnblockTime>
                /* If any ticks occurred while the scheduler was suspended then
                 * they should be processed now.  This ensures the tick count does
                 * not  slip, and that any delayed tasks are resumed at the correct
                 * time. */
                {
                    TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
 4004978:	d0a6b517 	ldw	r2,-25900(gp)
 400497c:	e0bffb15 	stw	r2,-20(fp)

                    if( xPendedCounts > ( TickType_t ) 0U )
 4004980:	e0bffb17 	ldw	r2,-20(fp)
 4004984:	10000a26 	beq	r2,zero,40049b0 <xTaskResumeAll+0x29c>
                    {
                        do
                        {
                            if( xTaskIncrementTick() != pdFALSE )
 4004988:	4004aec0 	call	4004aec <xTaskIncrementTick>
 400498c:	10000226 	beq	r2,zero,4004998 <xTaskResumeAll+0x284>
                            {
                                xYieldPending = pdTRUE;
 4004990:	00800044 	movi	r2,1
 4004994:	d0a6b615 	stw	r2,-25896(gp)
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }

                            --xPendedCounts;
 4004998:	e0bffb17 	ldw	r2,-20(fp)
 400499c:	10bfffc4 	addi	r2,r2,-1
 40049a0:	e0bffb15 	stw	r2,-20(fp)
                        } while( xPendedCounts > ( TickType_t ) 0U );
 40049a4:	e0bffb17 	ldw	r2,-20(fp)
 40049a8:	103ff71e 	bne	r2,zero,4004988 <xTaskResumeAll+0x274>

                        xPendedTicks = 0;
 40049ac:	d026b515 	stw	zero,-25900(gp)
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( xYieldPending != pdFALSE )
 40049b0:	d0a6b617 	ldw	r2,-25896(gp)
 40049b4:	10000326 	beq	r2,zero,40049c4 <xTaskResumeAll+0x2b0>
                {
                    #if ( configUSE_PREEMPTION != 0 )
                    {
                        xAlreadyYielded = pdTRUE;
 40049b8:	00800044 	movi	r2,1
 40049bc:	e0bffc15 	stw	r2,-16(fp)
                    }
                    #endif
                    taskYIELD_IF_USING_PREEMPTION();
 40049c0:	003b683a 	trap	0
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    taskEXIT_CRITICAL();
 40049c4:	4005fc80 	call	4005fc8 <vTaskExitCritical>

    return xAlreadyYielded;
 40049c8:	e0bffc17 	ldw	r2,-16(fp)
}
 40049cc:	e6fffe04 	addi	sp,fp,-8
 40049d0:	dfc00317 	ldw	ra,12(sp)
 40049d4:	df000217 	ldw	fp,8(sp)
 40049d8:	dc400117 	ldw	r17,4(sp)
 40049dc:	dc000017 	ldw	r16,0(sp)
 40049e0:	dec00404 	addi	sp,sp,16
 40049e4:	f800283a 	ret

040049e8 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
 40049e8:	defffe04 	addi	sp,sp,-8
 40049ec:	df000115 	stw	fp,4(sp)
 40049f0:	df000104 	addi	fp,sp,4
    TickType_t xTicks;

    /* Critical section required if running on a 16 bit processor. */
    portTICK_TYPE_ENTER_CRITICAL();
    {
        xTicks = xTickCount;
 40049f4:	d0a6b217 	ldw	r2,-25912(gp)
 40049f8:	e0bfff15 	stw	r2,-4(fp)
    }
    portTICK_TYPE_EXIT_CRITICAL();

    return xTicks;
 40049fc:	e0bfff17 	ldw	r2,-4(fp)
}
 4004a00:	e037883a 	mov	sp,fp
 4004a04:	df000017 	ldw	fp,0(sp)
 4004a08:	dec00104 	addi	sp,sp,4
 4004a0c:	f800283a 	ret

04004a10 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
 4004a10:	defffd04 	addi	sp,sp,-12
 4004a14:	df000215 	stw	fp,8(sp)
 4004a18:	df000204 	addi	fp,sp,8
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
 4004a1c:	e03fff15 	stw	zero,-4(fp)
    {
        xReturn = xTickCount;
 4004a20:	d0a6b217 	ldw	r2,-25912(gp)
 4004a24:	e0bffe15 	stw	r2,-8(fp)
    }
    portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
 4004a28:	e0bffe17 	ldw	r2,-8(fp)
}
 4004a2c:	e037883a 	mov	sp,fp
 4004a30:	df000017 	ldw	fp,0(sp)
 4004a34:	dec00104 	addi	sp,sp,4
 4004a38:	f800283a 	ret

04004a3c <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
 4004a3c:	deffff04 	addi	sp,sp,-4
 4004a40:	df000015 	stw	fp,0(sp)
 4004a44:	d839883a 	mov	fp,sp
    /* A critical section is not required because the variables are of type
     * BaseType_t. */
    return uxCurrentNumberOfTasks;
 4004a48:	d0a6b117 	ldw	r2,-25916(gp)
}
 4004a4c:	e037883a 	mov	sp,fp
 4004a50:	df000017 	ldw	fp,0(sp)
 4004a54:	dec00104 	addi	sp,sp,4
 4004a58:	f800283a 	ret

04004a5c <pcTaskGetName>:
/*-----------------------------------------------------------*/

char * pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
 4004a5c:	defffd04 	addi	sp,sp,-12
 4004a60:	df000215 	stw	fp,8(sp)
 4004a64:	df000204 	addi	fp,sp,8
 4004a68:	e13ffe15 	stw	r4,-8(fp)
    TCB_t * pxTCB;

    /* If null is passed in here then the name of the calling task is being
     * queried. */
    pxTCB = prvGetTCBFromHandle( xTaskToQuery );
 4004a6c:	e0bffe17 	ldw	r2,-8(fp)
 4004a70:	1000021e 	bne	r2,zero,4004a7c <pcTaskGetName+0x20>
 4004a74:	d0a6ad17 	ldw	r2,-25932(gp)
 4004a78:	00000106 	br	4004a80 <pcTaskGetName+0x24>
 4004a7c:	e0bffe17 	ldw	r2,-8(fp)
 4004a80:	e0bfff15 	stw	r2,-4(fp)
    configASSERT( pxTCB );
    return &( pxTCB->pcTaskName[ 0 ] );
 4004a84:	e0bfff17 	ldw	r2,-4(fp)
 4004a88:	10800d04 	addi	r2,r2,52
}
 4004a8c:	e037883a 	mov	sp,fp
 4004a90:	df000017 	ldw	fp,0(sp)
 4004a94:	dec00104 	addi	sp,sp,4
 4004a98:	f800283a 	ret

04004a9c <xTaskCatchUpTicks>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp )
{
 4004a9c:	defffc04 	addi	sp,sp,-16
 4004aa0:	dfc00315 	stw	ra,12(sp)
 4004aa4:	df000215 	stw	fp,8(sp)
 4004aa8:	df000204 	addi	fp,sp,8
 4004aac:	e13ffe15 	stw	r4,-8(fp)
     * relies on xPendedTicks being wound down to 0 in xTaskResumeAll(). */
    configASSERT( uxSchedulerSuspended == 0 );

    /* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
     * the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
    vTaskSuspendAll();
 4004ab0:	40046e80 	call	40046e8 <vTaskSuspendAll>

    /* Prevent the tick interrupt modifying xPendedTicks simultaneously. */
    taskENTER_CRITICAL();
 4004ab4:	4005f740 	call	4005f74 <vTaskEnterCritical>
    {
        xPendedTicks += xTicksToCatchUp;
 4004ab8:	d0e6b517 	ldw	r3,-25900(gp)
 4004abc:	e0bffe17 	ldw	r2,-8(fp)
 4004ac0:	1885883a 	add	r2,r3,r2
 4004ac4:	d0a6b515 	stw	r2,-25900(gp)
    }
    taskEXIT_CRITICAL();
 4004ac8:	4005fc80 	call	4005fc8 <vTaskExitCritical>
    xYieldOccurred = xTaskResumeAll();
 4004acc:	40047140 	call	4004714 <xTaskResumeAll>
 4004ad0:	e0bfff15 	stw	r2,-4(fp)

    return xYieldOccurred;
 4004ad4:	e0bfff17 	ldw	r2,-4(fp)
}
 4004ad8:	e037883a 	mov	sp,fp
 4004adc:	dfc00117 	ldw	ra,4(sp)
 4004ae0:	df000017 	ldw	fp,0(sp)
 4004ae4:	dec00204 	addi	sp,sp,8
 4004ae8:	f800283a 	ret

04004aec <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
 4004aec:	defff404 	addi	sp,sp,-48
 4004af0:	dfc00b15 	stw	ra,44(sp)
 4004af4:	df000a15 	stw	fp,40(sp)
 4004af8:	dc400915 	stw	r17,36(sp)
 4004afc:	dc000815 	stw	r16,32(sp)
 4004b00:	df000a04 	addi	fp,sp,40
    TCB_t * pxTCB;
    TickType_t xItemValue;
    BaseType_t xSwitchRequired = pdFALSE;
 4004b04:	e03ffd15 	stw	zero,-12(fp)
    /* Called by the portable layer each time a tick interrupt occurs.
     * Increments the tick then checks to see if the new tick value will cause any
     * tasks to be unblocked. */
    traceTASK_INCREMENT_TICK( xTickCount );

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 4004b08:	d0a6bb17 	ldw	r2,-25876(gp)
 4004b0c:	1000bb1e 	bne	r2,zero,4004dfc <xTaskIncrementTick+0x310>
    {
        /* Minor optimisation.  The tick count cannot change in this
         * block. */
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
 4004b10:	d0a6b217 	ldw	r2,-25912(gp)
 4004b14:	10800044 	addi	r2,r2,1
 4004b18:	e0bffc15 	stw	r2,-16(fp)

        /* Increment the RTOS tick, switching the delayed and overflowed
         * delayed lists if it wraps to 0. */
        xTickCount = xConstTickCount;
 4004b1c:	e0bffc17 	ldw	r2,-16(fp)
 4004b20:	d0a6b215 	stw	r2,-25912(gp)

        if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
 4004b24:	e0bffc17 	ldw	r2,-16(fp)
 4004b28:	10000a1e 	bne	r2,zero,4004b54 <xTaskIncrementTick+0x68>
        {
            taskSWITCH_DELAYED_LISTS();
 4004b2c:	d0a6ae17 	ldw	r2,-25928(gp)
 4004b30:	e0bffb15 	stw	r2,-20(fp)
 4004b34:	d0a6af17 	ldw	r2,-25924(gp)
 4004b38:	d0a6ae15 	stw	r2,-25928(gp)
 4004b3c:	e0bffb17 	ldw	r2,-20(fp)
 4004b40:	d0a6af15 	stw	r2,-25924(gp)
 4004b44:	d0a6b717 	ldw	r2,-25892(gp)
 4004b48:	10800044 	addi	r2,r2,1
 4004b4c:	d0a6b715 	stw	r2,-25892(gp)
 4004b50:	40059400 	call	4005940 <prvResetNextTaskUnblockTime>

        /* See if this tick has made a timeout expire.  Tasks are stored in
         * the  queue in the order of their wake time - meaning once one task
         * has been found whose block time has not expired there is no need to
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
 4004b54:	d0a6b917 	ldw	r2,-25884(gp)
 4004b58:	e0fffc17 	ldw	r3,-16(fp)
 4004b5c:	18809536 	bltu	r3,r2,4004db4 <xTaskIncrementTick+0x2c8>
        {
            for( ; ; )
            {
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 4004b60:	d0a6ae17 	ldw	r2,-25928(gp)
 4004b64:	10800017 	ldw	r2,0(r2)
 4004b68:	1000031e 	bne	r2,zero,4004b78 <xTaskIncrementTick+0x8c>
                    /* The delayed list is empty.  Set xNextTaskUnblockTime
                     * to the maximum possible value so it is extremely
                     * unlikely that the
                     * if( xTickCount >= xNextTaskUnblockTime ) test will pass
                     * next time through. */
                    xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 4004b6c:	00bfffc4 	movi	r2,-1
 4004b70:	d0a6b915 	stw	r2,-25884(gp)
                    break;
 4004b74:	00008f06 	br	4004db4 <xTaskIncrementTick+0x2c8>
                {
                    /* The delayed list is not empty, get the value of the
                     * item at the head of the delayed list.  This is the time
                     * at which the task at the head of the delayed list must
                     * be removed from the Blocked state. */
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 4004b78:	d0a6ae17 	ldw	r2,-25928(gp)
 4004b7c:	10800317 	ldw	r2,12(r2)
 4004b80:	10800317 	ldw	r2,12(r2)
 4004b84:	e0bffa15 	stw	r2,-24(fp)
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 4004b88:	e0bffa17 	ldw	r2,-24(fp)
 4004b8c:	10800117 	ldw	r2,4(r2)
 4004b90:	e0bff915 	stw	r2,-28(fp)

                    if( xConstTickCount < xItemValue )
 4004b94:	e0fffc17 	ldw	r3,-16(fp)
 4004b98:	e0bff917 	ldw	r2,-28(fp)
 4004b9c:	1880032e 	bgeu	r3,r2,4004bac <xTaskIncrementTick+0xc0>
                        /* It is not time to unblock this item yet, but the
                         * item value is the time at which the task at the head
                         * of the blocked list must be removed from the Blocked
                         * state -  so record the item value in
                         * xNextTaskUnblockTime. */
                        xNextTaskUnblockTime = xItemValue;
 4004ba0:	e0bff917 	ldw	r2,-28(fp)
 4004ba4:	d0a6b915 	stw	r2,-25884(gp)
                        break; /*lint !e9011 Code structure here is deemed easier to understand with multiple breaks. */
 4004ba8:	00008206 	br	4004db4 <xTaskIncrementTick+0x2c8>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* It is time to remove the item from the Blocked state. */
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 4004bac:	e0bffa17 	ldw	r2,-24(fp)
 4004bb0:	10800517 	ldw	r2,20(r2)
 4004bb4:	e0bff815 	stw	r2,-32(fp)
 4004bb8:	e0bffa17 	ldw	r2,-24(fp)
 4004bbc:	10800217 	ldw	r2,8(r2)
 4004bc0:	e0fffa17 	ldw	r3,-24(fp)
 4004bc4:	18c00317 	ldw	r3,12(r3)
 4004bc8:	10c00215 	stw	r3,8(r2)
 4004bcc:	e0bffa17 	ldw	r2,-24(fp)
 4004bd0:	10800317 	ldw	r2,12(r2)
 4004bd4:	e0fffa17 	ldw	r3,-24(fp)
 4004bd8:	18c00217 	ldw	r3,8(r3)
 4004bdc:	10c00115 	stw	r3,4(r2)
 4004be0:	e0bff817 	ldw	r2,-32(fp)
 4004be4:	10c00117 	ldw	r3,4(r2)
 4004be8:	e0bffa17 	ldw	r2,-24(fp)
 4004bec:	10800104 	addi	r2,r2,4
 4004bf0:	1880041e 	bne	r3,r2,4004c04 <xTaskIncrementTick+0x118>
 4004bf4:	e0bffa17 	ldw	r2,-24(fp)
 4004bf8:	10c00317 	ldw	r3,12(r2)
 4004bfc:	e0bff817 	ldw	r2,-32(fp)
 4004c00:	10c00115 	stw	r3,4(r2)
 4004c04:	e0bffa17 	ldw	r2,-24(fp)
 4004c08:	10000515 	stw	zero,20(r2)
 4004c0c:	e0bff817 	ldw	r2,-32(fp)
 4004c10:	10800017 	ldw	r2,0(r2)
 4004c14:	10ffffc4 	addi	r3,r2,-1
 4004c18:	e0bff817 	ldw	r2,-32(fp)
 4004c1c:	10c00015 	stw	r3,0(r2)

                    /* Is the task waiting on an event also?  If so remove
                     * it from the event list. */
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 4004c20:	e0bffa17 	ldw	r2,-24(fp)
 4004c24:	10800a17 	ldw	r2,40(r2)
 4004c28:	10001d26 	beq	r2,zero,4004ca0 <xTaskIncrementTick+0x1b4>
                    {
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
 4004c2c:	e0bffa17 	ldw	r2,-24(fp)
 4004c30:	10800a17 	ldw	r2,40(r2)
 4004c34:	e0bff715 	stw	r2,-36(fp)
 4004c38:	e0bffa17 	ldw	r2,-24(fp)
 4004c3c:	10800717 	ldw	r2,28(r2)
 4004c40:	e0fffa17 	ldw	r3,-24(fp)
 4004c44:	18c00817 	ldw	r3,32(r3)
 4004c48:	10c00215 	stw	r3,8(r2)
 4004c4c:	e0bffa17 	ldw	r2,-24(fp)
 4004c50:	10800817 	ldw	r2,32(r2)
 4004c54:	e0fffa17 	ldw	r3,-24(fp)
 4004c58:	18c00717 	ldw	r3,28(r3)
 4004c5c:	10c00115 	stw	r3,4(r2)
 4004c60:	e0bff717 	ldw	r2,-36(fp)
 4004c64:	10c00117 	ldw	r3,4(r2)
 4004c68:	e0bffa17 	ldw	r2,-24(fp)
 4004c6c:	10800604 	addi	r2,r2,24
 4004c70:	1880041e 	bne	r3,r2,4004c84 <xTaskIncrementTick+0x198>
 4004c74:	e0bffa17 	ldw	r2,-24(fp)
 4004c78:	10c00817 	ldw	r3,32(r2)
 4004c7c:	e0bff717 	ldw	r2,-36(fp)
 4004c80:	10c00115 	stw	r3,4(r2)
 4004c84:	e0bffa17 	ldw	r2,-24(fp)
 4004c88:	10000a15 	stw	zero,40(r2)
 4004c8c:	e0bff717 	ldw	r2,-36(fp)
 4004c90:	10800017 	ldw	r2,0(r2)
 4004c94:	10ffffc4 	addi	r3,r2,-1
 4004c98:	e0bff717 	ldw	r2,-36(fp)
 4004c9c:	10c00015 	stw	r3,0(r2)
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
 4004ca0:	e0bffa17 	ldw	r2,-24(fp)
 4004ca4:	10800b17 	ldw	r2,44(r2)
 4004ca8:	d0e6b317 	ldw	r3,-25908(gp)
 4004cac:	1880032e 	bgeu	r3,r2,4004cbc <xTaskIncrementTick+0x1d0>
 4004cb0:	e0bffa17 	ldw	r2,-24(fp)
 4004cb4:	10800b17 	ldw	r2,44(r2)
 4004cb8:	d0a6b315 	stw	r2,-25908(gp)
 4004cbc:	e0bffa17 	ldw	r2,-24(fp)
 4004cc0:	10800b17 	ldw	r2,44(r2)
 4004cc4:	01400504 	movi	r5,20
 4004cc8:	1009883a 	mov	r4,r2
 4004ccc:	40073b40 	call	40073b4 <__mulsi3>
 4004cd0:	1007883a 	mov	r3,r2
 4004cd4:	00812074 	movhi	r2,1153
 4004cd8:	1885883a 	add	r2,r3,r2
 4004cdc:	10bfb217 	ldw	r2,-312(r2)
 4004ce0:	e0bff615 	stw	r2,-40(fp)
 4004ce4:	e0bffa17 	ldw	r2,-24(fp)
 4004ce8:	e0fff617 	ldw	r3,-40(fp)
 4004cec:	10c00215 	stw	r3,8(r2)
 4004cf0:	e0bff617 	ldw	r2,-40(fp)
 4004cf4:	10c00217 	ldw	r3,8(r2)
 4004cf8:	e0bffa17 	ldw	r2,-24(fp)
 4004cfc:	10c00315 	stw	r3,12(r2)
 4004d00:	e0bff617 	ldw	r2,-40(fp)
 4004d04:	10800217 	ldw	r2,8(r2)
 4004d08:	e0fffa17 	ldw	r3,-24(fp)
 4004d0c:	18c00104 	addi	r3,r3,4
 4004d10:	10c00115 	stw	r3,4(r2)
 4004d14:	e0bffa17 	ldw	r2,-24(fp)
 4004d18:	10c00104 	addi	r3,r2,4
 4004d1c:	e0bff617 	ldw	r2,-40(fp)
 4004d20:	10c00215 	stw	r3,8(r2)
 4004d24:	e0bffa17 	ldw	r2,-24(fp)
 4004d28:	10800b17 	ldw	r2,44(r2)
 4004d2c:	01400504 	movi	r5,20
 4004d30:	1009883a 	mov	r4,r2
 4004d34:	40073b40 	call	40073b4 <__mulsi3>
 4004d38:	1007883a 	mov	r3,r2
 4004d3c:	00812074 	movhi	r2,1153
 4004d40:	10bfb104 	addi	r2,r2,-316
 4004d44:	1887883a 	add	r3,r3,r2
 4004d48:	e0bffa17 	ldw	r2,-24(fp)
 4004d4c:	10c00515 	stw	r3,20(r2)
 4004d50:	e0bffa17 	ldw	r2,-24(fp)
 4004d54:	14400b17 	ldw	r17,44(r2)
 4004d58:	01400504 	movi	r5,20
 4004d5c:	8809883a 	mov	r4,r17
 4004d60:	40073b40 	call	40073b4 <__mulsi3>
 4004d64:	1007883a 	mov	r3,r2
 4004d68:	00812074 	movhi	r2,1153
 4004d6c:	1885883a 	add	r2,r3,r2
 4004d70:	10bfb117 	ldw	r2,-316(r2)
 4004d74:	14000044 	addi	r16,r2,1
 4004d78:	01400504 	movi	r5,20
 4004d7c:	8809883a 	mov	r4,r17
 4004d80:	40073b40 	call	40073b4 <__mulsi3>
 4004d84:	1007883a 	mov	r3,r2
 4004d88:	00812074 	movhi	r2,1153
 4004d8c:	1885883a 	add	r2,r3,r2
 4004d90:	143fb115 	stw	r16,-316(r2)
                         * task.
                         * The case of equal priority tasks sharing
                         * processing time (which happens when both
                         * preemption and time slicing are on) is
                         * handled below.*/
                        if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 4004d94:	e0bffa17 	ldw	r2,-24(fp)
 4004d98:	10800b17 	ldw	r2,44(r2)
 4004d9c:	d0e6ad17 	ldw	r3,-25932(gp)
 4004da0:	18c00b17 	ldw	r3,44(r3)
 4004da4:	18bf6e2e 	bgeu	r3,r2,4004b60 <xTaskIncrementTick+0x74>
                        {
                            xSwitchRequired = pdTRUE;
 4004da8:	00800044 	movi	r2,1
 4004dac:	e0bffd15 	stw	r2,-12(fp)
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 4004db0:	003f6b06 	br	4004b60 <xTaskIncrementTick+0x74>
        /* Tasks of equal priority to the currently running task will share
         * processing time (time slice) if preemption is on, and the application
         * writer has not explicitly turned time slicing off. */
        #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
        {
            if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 4004db4:	d0a6ad17 	ldw	r2,-25932(gp)
 4004db8:	10800b17 	ldw	r2,44(r2)
 4004dbc:	01400504 	movi	r5,20
 4004dc0:	1009883a 	mov	r4,r2
 4004dc4:	40073b40 	call	40073b4 <__mulsi3>
 4004dc8:	1007883a 	mov	r3,r2
 4004dcc:	00812074 	movhi	r2,1153
 4004dd0:	1885883a 	add	r2,r3,r2
 4004dd4:	10bfb117 	ldw	r2,-316(r2)
 4004dd8:	108000b0 	cmpltui	r2,r2,2
 4004ddc:	1000021e 	bne	r2,zero,4004de8 <xTaskIncrementTick+0x2fc>
            {
                xSwitchRequired = pdTRUE;
 4004de0:	00800044 	movi	r2,1
 4004de4:	e0bffd15 	stw	r2,-12(fp)
        }
        #endif /* configUSE_TICK_HOOK */

        #if ( configUSE_PREEMPTION == 1 )
        {
            if( xYieldPending != pdFALSE )
 4004de8:	d0a6b617 	ldw	r2,-25896(gp)
 4004dec:	10000626 	beq	r2,zero,4004e08 <xTaskIncrementTick+0x31c>
            {
                xSwitchRequired = pdTRUE;
 4004df0:	00800044 	movi	r2,1
 4004df4:	e0bffd15 	stw	r2,-12(fp)
 4004df8:	00000306 	br	4004e08 <xTaskIncrementTick+0x31c>
        }
        #endif /* configUSE_PREEMPTION */
    }
    else
    {
        ++xPendedTicks;
 4004dfc:	d0a6b517 	ldw	r2,-25900(gp)
 4004e00:	10800044 	addi	r2,r2,1
 4004e04:	d0a6b515 	stw	r2,-25900(gp)
            vApplicationTickHook();
        }
        #endif
    }

    return xSwitchRequired;
 4004e08:	e0bffd17 	ldw	r2,-12(fp)
}
 4004e0c:	e6fffe04 	addi	sp,fp,-8
 4004e10:	dfc00317 	ldw	ra,12(sp)
 4004e14:	df000217 	ldw	fp,8(sp)
 4004e18:	dc400117 	ldw	r17,4(sp)
 4004e1c:	dc000017 	ldw	r16,0(sp)
 4004e20:	dec00404 	addi	sp,sp,16
 4004e24:	f800283a 	ret

04004e28 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
 4004e28:	defffc04 	addi	sp,sp,-16
 4004e2c:	dfc00315 	stw	ra,12(sp)
 4004e30:	df000215 	stw	fp,8(sp)
 4004e34:	df000204 	addi	fp,sp,8
    if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 4004e38:	d0a6bb17 	ldw	r2,-25876(gp)
 4004e3c:	10000326 	beq	r2,zero,4004e4c <vTaskSwitchContext+0x24>
    {
        /* The scheduler is currently suspended - do not allow a context
         * switch. */
        xYieldPending = pdTRUE;
 4004e40:	00800044 	movi	r2,1
 4004e44:	d0a6b615 	stw	r2,-25896(gp)
             * Block specific to this task. */
            configSET_TLS_BLOCK( pxCurrentTCB->xTLSBlock );
        }
        #endif
    }
}
 4004e48:	00002d06 	br	4004f00 <vTaskSwitchContext+0xd8>
        xYieldPending = pdFALSE;
 4004e4c:	d026b615 	stw	zero,-25896(gp)
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 4004e50:	d0a6b317 	ldw	r2,-25908(gp)
 4004e54:	e0bfff15 	stw	r2,-4(fp)
 4004e58:	00000306 	br	4004e68 <vTaskSwitchContext+0x40>
 4004e5c:	e0bfff17 	ldw	r2,-4(fp)
 4004e60:	10bfffc4 	addi	r2,r2,-1
 4004e64:	e0bfff15 	stw	r2,-4(fp)
 4004e68:	e0bfff17 	ldw	r2,-4(fp)
 4004e6c:	01400504 	movi	r5,20
 4004e70:	1009883a 	mov	r4,r2
 4004e74:	40073b40 	call	40073b4 <__mulsi3>
 4004e78:	1007883a 	mov	r3,r2
 4004e7c:	00812074 	movhi	r2,1153
 4004e80:	1885883a 	add	r2,r3,r2
 4004e84:	10bfb117 	ldw	r2,-316(r2)
 4004e88:	103ff426 	beq	r2,zero,4004e5c <vTaskSwitchContext+0x34>
 4004e8c:	01400504 	movi	r5,20
 4004e90:	e13fff17 	ldw	r4,-4(fp)
 4004e94:	40073b40 	call	40073b4 <__mulsi3>
 4004e98:	1007883a 	mov	r3,r2
 4004e9c:	00812074 	movhi	r2,1153
 4004ea0:	10bfb104 	addi	r2,r2,-316
 4004ea4:	1885883a 	add	r2,r3,r2
 4004ea8:	e0bffe15 	stw	r2,-8(fp)
 4004eac:	e0bffe17 	ldw	r2,-8(fp)
 4004eb0:	10800117 	ldw	r2,4(r2)
 4004eb4:	10c00117 	ldw	r3,4(r2)
 4004eb8:	e0bffe17 	ldw	r2,-8(fp)
 4004ebc:	10c00115 	stw	r3,4(r2)
 4004ec0:	e0bffe17 	ldw	r2,-8(fp)
 4004ec4:	10c00117 	ldw	r3,4(r2)
 4004ec8:	e0bffe17 	ldw	r2,-8(fp)
 4004ecc:	10800204 	addi	r2,r2,8
 4004ed0:	1880051e 	bne	r3,r2,4004ee8 <vTaskSwitchContext+0xc0>
 4004ed4:	e0bffe17 	ldw	r2,-8(fp)
 4004ed8:	10800117 	ldw	r2,4(r2)
 4004edc:	10c00117 	ldw	r3,4(r2)
 4004ee0:	e0bffe17 	ldw	r2,-8(fp)
 4004ee4:	10c00115 	stw	r3,4(r2)
 4004ee8:	e0bffe17 	ldw	r2,-8(fp)
 4004eec:	10800117 	ldw	r2,4(r2)
 4004ef0:	10800317 	ldw	r2,12(r2)
 4004ef4:	d0a6ad15 	stw	r2,-25932(gp)
 4004ef8:	e0bfff17 	ldw	r2,-4(fp)
 4004efc:	d0a6b315 	stw	r2,-25908(gp)
}
 4004f00:	0001883a 	nop
 4004f04:	e037883a 	mov	sp,fp
 4004f08:	dfc00117 	ldw	ra,4(sp)
 4004f0c:	df000017 	ldw	fp,0(sp)
 4004f10:	dec00204 	addi	sp,sp,8
 4004f14:	f800283a 	ret

04004f18 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList,
                            const TickType_t xTicksToWait )
{
 4004f18:	defffc04 	addi	sp,sp,-16
 4004f1c:	dfc00315 	stw	ra,12(sp)
 4004f20:	df000215 	stw	fp,8(sp)
 4004f24:	df000204 	addi	fp,sp,8
 4004f28:	e13fff15 	stw	r4,-4(fp)
 4004f2c:	e17ffe15 	stw	r5,-8(fp)
     *      xItemValue = ( configMAX_PRIORITIES - uxPriority )
     * Therefore, the event list is sorted in descending priority order.
     *
     * The queue that contains the event list is locked, preventing
     * simultaneous access from interrupts. */
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 4004f30:	d0a6ad17 	ldw	r2,-25932(gp)
 4004f34:	10800604 	addi	r2,r2,24
 4004f38:	100b883a 	mov	r5,r2
 4004f3c:	e13fff17 	ldw	r4,-4(fp)
 4004f40:	4000bc00 	call	4000bc0 <vListInsert>

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 4004f44:	01400044 	movi	r5,1
 4004f48:	e13ffe17 	ldw	r4,-8(fp)
 4004f4c:	4006e340 	call	4006e34 <prvAddCurrentTaskToDelayedList>
}
 4004f50:	0001883a 	nop
 4004f54:	e037883a 	mov	sp,fp
 4004f58:	dfc00117 	ldw	ra,4(sp)
 4004f5c:	df000017 	ldw	fp,0(sp)
 4004f60:	dec00204 	addi	sp,sp,8
 4004f64:	f800283a 	ret

04004f68 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList,
                                     const TickType_t xItemValue,
                                     const TickType_t xTicksToWait )
{
 4004f68:	defffa04 	addi	sp,sp,-24
 4004f6c:	dfc00515 	stw	ra,20(sp)
 4004f70:	df000415 	stw	fp,16(sp)
 4004f74:	df000404 	addi	fp,sp,16
 4004f78:	e13ffe15 	stw	r4,-8(fp)
 4004f7c:	e17ffd15 	stw	r5,-12(fp)
 4004f80:	e1bffc15 	stw	r6,-16(fp)
    configASSERT( uxSchedulerSuspended != 0 );

    /* Store the item value in the event list item.  It is safe to access the
     * event list item here as interrupts won't access the event list item of a
     * task that is not in the Blocked state. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
 4004f84:	d0a6ad17 	ldw	r2,-25932(gp)
 4004f88:	e0fffd17 	ldw	r3,-12(fp)
 4004f8c:	18e00034 	orhi	r3,r3,32768
 4004f90:	10c00615 	stw	r3,24(r2)
    /* Place the event list item of the TCB at the end of the appropriate event
     * list.  It is safe to access the event list here because it is part of an
     * event group implementation - and interrupts don't access event groups
     * directly (instead they access them indirectly by pending function calls to
     * the task level). */
    listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 4004f94:	e0bffe17 	ldw	r2,-8(fp)
 4004f98:	10800117 	ldw	r2,4(r2)
 4004f9c:	e0bfff15 	stw	r2,-4(fp)
 4004fa0:	d0a6ad17 	ldw	r2,-25932(gp)
 4004fa4:	e0ffff17 	ldw	r3,-4(fp)
 4004fa8:	10c00715 	stw	r3,28(r2)
 4004fac:	d0a6ad17 	ldw	r2,-25932(gp)
 4004fb0:	e0ffff17 	ldw	r3,-4(fp)
 4004fb4:	18c00217 	ldw	r3,8(r3)
 4004fb8:	10c00815 	stw	r3,32(r2)
 4004fbc:	d0e6ad17 	ldw	r3,-25932(gp)
 4004fc0:	e0bfff17 	ldw	r2,-4(fp)
 4004fc4:	10800217 	ldw	r2,8(r2)
 4004fc8:	18c00604 	addi	r3,r3,24
 4004fcc:	10c00115 	stw	r3,4(r2)
 4004fd0:	d0a6ad17 	ldw	r2,-25932(gp)
 4004fd4:	10c00604 	addi	r3,r2,24
 4004fd8:	e0bfff17 	ldw	r2,-4(fp)
 4004fdc:	10c00215 	stw	r3,8(r2)
 4004fe0:	d0a6ad17 	ldw	r2,-25932(gp)
 4004fe4:	e0fffe17 	ldw	r3,-8(fp)
 4004fe8:	10c00a15 	stw	r3,40(r2)
 4004fec:	e0bffe17 	ldw	r2,-8(fp)
 4004ff0:	10800017 	ldw	r2,0(r2)
 4004ff4:	10c00044 	addi	r3,r2,1
 4004ff8:	e0bffe17 	ldw	r2,-8(fp)
 4004ffc:	10c00015 	stw	r3,0(r2)

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 4005000:	01400044 	movi	r5,1
 4005004:	e13ffc17 	ldw	r4,-16(fp)
 4005008:	4006e340 	call	4006e34 <prvAddCurrentTaskToDelayedList>
}
 400500c:	0001883a 	nop
 4005010:	e037883a 	mov	sp,fp
 4005014:	dfc00117 	ldw	ra,4(sp)
 4005018:	df000017 	ldw	fp,0(sp)
 400501c:	dec00204 	addi	sp,sp,8
 4005020:	f800283a 	ret

04005024 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
 4005024:	defff504 	addi	sp,sp,-44
 4005028:	dfc00a15 	stw	ra,40(sp)
 400502c:	df000915 	stw	fp,36(sp)
 4005030:	dc400815 	stw	r17,32(sp)
 4005034:	dc000715 	stw	r16,28(sp)
 4005038:	df000904 	addi	fp,sp,36
 400503c:	e13ff715 	stw	r4,-36(fp)
     * get called - the lock count on the queue will get modified instead.  This
     * means exclusive access to the event list is guaranteed here.
     *
     * This function assumes that a check has already been made to ensure that
     * pxEventList is not empty. */
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 4005040:	e0bff717 	ldw	r2,-36(fp)
 4005044:	10800317 	ldw	r2,12(r2)
 4005048:	10800317 	ldw	r2,12(r2)
 400504c:	e0bffc15 	stw	r2,-16(fp)
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( &( pxUnblockedTCB->xEventListItem ) );
 4005050:	e0bffc17 	ldw	r2,-16(fp)
 4005054:	10800a17 	ldw	r2,40(r2)
 4005058:	e0bffb15 	stw	r2,-20(fp)
 400505c:	e0bffc17 	ldw	r2,-16(fp)
 4005060:	10800717 	ldw	r2,28(r2)
 4005064:	e0fffc17 	ldw	r3,-16(fp)
 4005068:	18c00817 	ldw	r3,32(r3)
 400506c:	10c00215 	stw	r3,8(r2)
 4005070:	e0bffc17 	ldw	r2,-16(fp)
 4005074:	10800817 	ldw	r2,32(r2)
 4005078:	e0fffc17 	ldw	r3,-16(fp)
 400507c:	18c00717 	ldw	r3,28(r3)
 4005080:	10c00115 	stw	r3,4(r2)
 4005084:	e0bffb17 	ldw	r2,-20(fp)
 4005088:	10c00117 	ldw	r3,4(r2)
 400508c:	e0bffc17 	ldw	r2,-16(fp)
 4005090:	10800604 	addi	r2,r2,24
 4005094:	1880041e 	bne	r3,r2,40050a8 <xTaskRemoveFromEventList+0x84>
 4005098:	e0bffc17 	ldw	r2,-16(fp)
 400509c:	10c00817 	ldw	r3,32(r2)
 40050a0:	e0bffb17 	ldw	r2,-20(fp)
 40050a4:	10c00115 	stw	r3,4(r2)
 40050a8:	e0bffc17 	ldw	r2,-16(fp)
 40050ac:	10000a15 	stw	zero,40(r2)
 40050b0:	e0bffb17 	ldw	r2,-20(fp)
 40050b4:	10800017 	ldw	r2,0(r2)
 40050b8:	10ffffc4 	addi	r3,r2,-1
 40050bc:	e0bffb17 	ldw	r2,-20(fp)
 40050c0:	10c00015 	stw	r3,0(r2)

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 40050c4:	d0a6bb17 	ldw	r2,-25876(gp)
 40050c8:	10005b1e 	bne	r2,zero,4005238 <xTaskRemoveFromEventList+0x214>
    {
        listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
 40050cc:	e0bffc17 	ldw	r2,-16(fp)
 40050d0:	10800517 	ldw	r2,20(r2)
 40050d4:	e0bff915 	stw	r2,-28(fp)
 40050d8:	e0bffc17 	ldw	r2,-16(fp)
 40050dc:	10800217 	ldw	r2,8(r2)
 40050e0:	e0fffc17 	ldw	r3,-16(fp)
 40050e4:	18c00317 	ldw	r3,12(r3)
 40050e8:	10c00215 	stw	r3,8(r2)
 40050ec:	e0bffc17 	ldw	r2,-16(fp)
 40050f0:	10800317 	ldw	r2,12(r2)
 40050f4:	e0fffc17 	ldw	r3,-16(fp)
 40050f8:	18c00217 	ldw	r3,8(r3)
 40050fc:	10c00115 	stw	r3,4(r2)
 4005100:	e0bff917 	ldw	r2,-28(fp)
 4005104:	10c00117 	ldw	r3,4(r2)
 4005108:	e0bffc17 	ldw	r2,-16(fp)
 400510c:	10800104 	addi	r2,r2,4
 4005110:	1880041e 	bne	r3,r2,4005124 <xTaskRemoveFromEventList+0x100>
 4005114:	e0bffc17 	ldw	r2,-16(fp)
 4005118:	10c00317 	ldw	r3,12(r2)
 400511c:	e0bff917 	ldw	r2,-28(fp)
 4005120:	10c00115 	stw	r3,4(r2)
 4005124:	e0bffc17 	ldw	r2,-16(fp)
 4005128:	10000515 	stw	zero,20(r2)
 400512c:	e0bff917 	ldw	r2,-28(fp)
 4005130:	10800017 	ldw	r2,0(r2)
 4005134:	10ffffc4 	addi	r3,r2,-1
 4005138:	e0bff917 	ldw	r2,-28(fp)
 400513c:	10c00015 	stw	r3,0(r2)
        prvAddTaskToReadyList( pxUnblockedTCB );
 4005140:	e0bffc17 	ldw	r2,-16(fp)
 4005144:	10800b17 	ldw	r2,44(r2)
 4005148:	d0e6b317 	ldw	r3,-25908(gp)
 400514c:	1880032e 	bgeu	r3,r2,400515c <xTaskRemoveFromEventList+0x138>
 4005150:	e0bffc17 	ldw	r2,-16(fp)
 4005154:	10800b17 	ldw	r2,44(r2)
 4005158:	d0a6b315 	stw	r2,-25908(gp)
 400515c:	e0bffc17 	ldw	r2,-16(fp)
 4005160:	10800b17 	ldw	r2,44(r2)
 4005164:	01400504 	movi	r5,20
 4005168:	1009883a 	mov	r4,r2
 400516c:	40073b40 	call	40073b4 <__mulsi3>
 4005170:	1007883a 	mov	r3,r2
 4005174:	00812074 	movhi	r2,1153
 4005178:	1885883a 	add	r2,r3,r2
 400517c:	10bfb217 	ldw	r2,-312(r2)
 4005180:	e0bff815 	stw	r2,-32(fp)
 4005184:	e0bffc17 	ldw	r2,-16(fp)
 4005188:	e0fff817 	ldw	r3,-32(fp)
 400518c:	10c00215 	stw	r3,8(r2)
 4005190:	e0bff817 	ldw	r2,-32(fp)
 4005194:	10c00217 	ldw	r3,8(r2)
 4005198:	e0bffc17 	ldw	r2,-16(fp)
 400519c:	10c00315 	stw	r3,12(r2)
 40051a0:	e0bff817 	ldw	r2,-32(fp)
 40051a4:	10800217 	ldw	r2,8(r2)
 40051a8:	e0fffc17 	ldw	r3,-16(fp)
 40051ac:	18c00104 	addi	r3,r3,4
 40051b0:	10c00115 	stw	r3,4(r2)
 40051b4:	e0bffc17 	ldw	r2,-16(fp)
 40051b8:	10c00104 	addi	r3,r2,4
 40051bc:	e0bff817 	ldw	r2,-32(fp)
 40051c0:	10c00215 	stw	r3,8(r2)
 40051c4:	e0bffc17 	ldw	r2,-16(fp)
 40051c8:	10800b17 	ldw	r2,44(r2)
 40051cc:	01400504 	movi	r5,20
 40051d0:	1009883a 	mov	r4,r2
 40051d4:	40073b40 	call	40073b4 <__mulsi3>
 40051d8:	1007883a 	mov	r3,r2
 40051dc:	00812074 	movhi	r2,1153
 40051e0:	10bfb104 	addi	r2,r2,-316
 40051e4:	1887883a 	add	r3,r3,r2
 40051e8:	e0bffc17 	ldw	r2,-16(fp)
 40051ec:	10c00515 	stw	r3,20(r2)
 40051f0:	e0bffc17 	ldw	r2,-16(fp)
 40051f4:	14400b17 	ldw	r17,44(r2)
 40051f8:	01400504 	movi	r5,20
 40051fc:	8809883a 	mov	r4,r17
 4005200:	40073b40 	call	40073b4 <__mulsi3>
 4005204:	1007883a 	mov	r3,r2
 4005208:	00812074 	movhi	r2,1153
 400520c:	1885883a 	add	r2,r3,r2
 4005210:	10bfb117 	ldw	r2,-316(r2)
 4005214:	14000044 	addi	r16,r2,1
 4005218:	01400504 	movi	r5,20
 400521c:	8809883a 	mov	r4,r17
 4005220:	40073b40 	call	40073b4 <__mulsi3>
 4005224:	1007883a 	mov	r3,r2
 4005228:	00812074 	movhi	r2,1153
 400522c:	1885883a 	add	r2,r3,r2
 4005230:	143fb115 	stw	r16,-316(r2)
 4005234:	00001c06 	br	40052a8 <xTaskRemoveFromEventList+0x284>
    }
    else
    {
        /* The delayed and ready lists cannot be accessed, so hold this task
         * pending until the scheduler is resumed. */
        listINSERT_END( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 4005238:	00812074 	movhi	r2,1153
 400523c:	10bfd517 	ldw	r2,-172(r2)
 4005240:	e0bffa15 	stw	r2,-24(fp)
 4005244:	e0bffc17 	ldw	r2,-16(fp)
 4005248:	e0fffa17 	ldw	r3,-24(fp)
 400524c:	10c00715 	stw	r3,28(r2)
 4005250:	e0bffa17 	ldw	r2,-24(fp)
 4005254:	10c00217 	ldw	r3,8(r2)
 4005258:	e0bffc17 	ldw	r2,-16(fp)
 400525c:	10c00815 	stw	r3,32(r2)
 4005260:	e0bffa17 	ldw	r2,-24(fp)
 4005264:	10800217 	ldw	r2,8(r2)
 4005268:	e0fffc17 	ldw	r3,-16(fp)
 400526c:	18c00604 	addi	r3,r3,24
 4005270:	10c00115 	stw	r3,4(r2)
 4005274:	e0bffc17 	ldw	r2,-16(fp)
 4005278:	10c00604 	addi	r3,r2,24
 400527c:	e0bffa17 	ldw	r2,-24(fp)
 4005280:	10c00215 	stw	r3,8(r2)
 4005284:	e0fffc17 	ldw	r3,-16(fp)
 4005288:	00812074 	movhi	r2,1153
 400528c:	10bfd404 	addi	r2,r2,-176
 4005290:	18800a15 	stw	r2,40(r3)
 4005294:	00812074 	movhi	r2,1153
 4005298:	10bfd417 	ldw	r2,-176(r2)
 400529c:	10c00044 	addi	r3,r2,1
 40052a0:	00812074 	movhi	r2,1153
 40052a4:	10ffd415 	stw	r3,-176(r2)
    }

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 40052a8:	e0bffc17 	ldw	r2,-16(fp)
 40052ac:	10800b17 	ldw	r2,44(r2)
 40052b0:	d0e6ad17 	ldw	r3,-25932(gp)
 40052b4:	18c00b17 	ldw	r3,44(r3)
 40052b8:	1880052e 	bgeu	r3,r2,40052d0 <xTaskRemoveFromEventList+0x2ac>
    {
        /* Return true if the task removed from the event list has a higher
         * priority than the calling task.  This allows the calling task to know if
         * it should force a context switch now. */
        xReturn = pdTRUE;
 40052bc:	00800044 	movi	r2,1
 40052c0:	e0bffd15 	stw	r2,-12(fp)

        /* Mark that a yield is pending in case the user is not using the
         * "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
        xYieldPending = pdTRUE;
 40052c4:	00800044 	movi	r2,1
 40052c8:	d0a6b615 	stw	r2,-25896(gp)
 40052cc:	00000106 	br	40052d4 <xTaskRemoveFromEventList+0x2b0>
    }
    else
    {
        xReturn = pdFALSE;
 40052d0:	e03ffd15 	stw	zero,-12(fp)
    }

    return xReturn;
 40052d4:	e0bffd17 	ldw	r2,-12(fp)
}
 40052d8:	e6fffe04 	addi	sp,fp,-8
 40052dc:	dfc00317 	ldw	ra,12(sp)
 40052e0:	df000217 	ldw	fp,8(sp)
 40052e4:	dc400117 	ldw	r17,4(sp)
 40052e8:	dc000017 	ldw	r16,0(sp)
 40052ec:	dec00404 	addi	sp,sp,16
 40052f0:	f800283a 	ret

040052f4 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem,
                                        const TickType_t xItemValue )
{
 40052f4:	defff604 	addi	sp,sp,-40
 40052f8:	dfc00915 	stw	ra,36(sp)
 40052fc:	df000815 	stw	fp,32(sp)
 4005300:	dc400715 	stw	r17,28(sp)
 4005304:	dc000615 	stw	r16,24(sp)
 4005308:	df000804 	addi	fp,sp,32
 400530c:	e13ff915 	stw	r4,-28(fp)
 4005310:	e17ff815 	stw	r5,-32(fp)
    /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
     * the event flags implementation. */
    configASSERT( uxSchedulerSuspended != pdFALSE );

    /* Store the new item value in the event list. */
    listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
 4005314:	e0bff817 	ldw	r2,-32(fp)
 4005318:	10e00034 	orhi	r3,r2,32768
 400531c:	e0bff917 	ldw	r2,-28(fp)
 4005320:	10c00015 	stw	r3,0(r2)

    /* Remove the event list form the event flag.  Interrupts do not access
     * event flags. */
    pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 4005324:	e0bff917 	ldw	r2,-28(fp)
 4005328:	10800317 	ldw	r2,12(r2)
 400532c:	e0bffd15 	stw	r2,-12(fp)
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( pxEventListItem );
 4005330:	e0bff917 	ldw	r2,-28(fp)
 4005334:	10800417 	ldw	r2,16(r2)
 4005338:	e0bffc15 	stw	r2,-16(fp)
 400533c:	e0bff917 	ldw	r2,-28(fp)
 4005340:	10800117 	ldw	r2,4(r2)
 4005344:	e0fff917 	ldw	r3,-28(fp)
 4005348:	18c00217 	ldw	r3,8(r3)
 400534c:	10c00215 	stw	r3,8(r2)
 4005350:	e0bff917 	ldw	r2,-28(fp)
 4005354:	10800217 	ldw	r2,8(r2)
 4005358:	e0fff917 	ldw	r3,-28(fp)
 400535c:	18c00117 	ldw	r3,4(r3)
 4005360:	10c00115 	stw	r3,4(r2)
 4005364:	e0bffc17 	ldw	r2,-16(fp)
 4005368:	10800117 	ldw	r2,4(r2)
 400536c:	e0fff917 	ldw	r3,-28(fp)
 4005370:	1880041e 	bne	r3,r2,4005384 <vTaskRemoveFromUnorderedEventList+0x90>
 4005374:	e0bff917 	ldw	r2,-28(fp)
 4005378:	10c00217 	ldw	r3,8(r2)
 400537c:	e0bffc17 	ldw	r2,-16(fp)
 4005380:	10c00115 	stw	r3,4(r2)
 4005384:	e0bff917 	ldw	r2,-28(fp)
 4005388:	10000415 	stw	zero,16(r2)
 400538c:	e0bffc17 	ldw	r2,-16(fp)
 4005390:	10800017 	ldw	r2,0(r2)
 4005394:	10ffffc4 	addi	r3,r2,-1
 4005398:	e0bffc17 	ldw	r2,-16(fp)
 400539c:	10c00015 	stw	r3,0(r2)
    #endif

    /* Remove the task from the delayed list and add it to the ready list.  The
     * scheduler is suspended so interrupts will not be accessing the ready
     * lists. */
    listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
 40053a0:	e0bffd17 	ldw	r2,-12(fp)
 40053a4:	10800517 	ldw	r2,20(r2)
 40053a8:	e0bffb15 	stw	r2,-20(fp)
 40053ac:	e0bffd17 	ldw	r2,-12(fp)
 40053b0:	10800217 	ldw	r2,8(r2)
 40053b4:	e0fffd17 	ldw	r3,-12(fp)
 40053b8:	18c00317 	ldw	r3,12(r3)
 40053bc:	10c00215 	stw	r3,8(r2)
 40053c0:	e0bffd17 	ldw	r2,-12(fp)
 40053c4:	10800317 	ldw	r2,12(r2)
 40053c8:	e0fffd17 	ldw	r3,-12(fp)
 40053cc:	18c00217 	ldw	r3,8(r3)
 40053d0:	10c00115 	stw	r3,4(r2)
 40053d4:	e0bffb17 	ldw	r2,-20(fp)
 40053d8:	10c00117 	ldw	r3,4(r2)
 40053dc:	e0bffd17 	ldw	r2,-12(fp)
 40053e0:	10800104 	addi	r2,r2,4
 40053e4:	1880041e 	bne	r3,r2,40053f8 <vTaskRemoveFromUnorderedEventList+0x104>
 40053e8:	e0bffd17 	ldw	r2,-12(fp)
 40053ec:	10c00317 	ldw	r3,12(r2)
 40053f0:	e0bffb17 	ldw	r2,-20(fp)
 40053f4:	10c00115 	stw	r3,4(r2)
 40053f8:	e0bffd17 	ldw	r2,-12(fp)
 40053fc:	10000515 	stw	zero,20(r2)
 4005400:	e0bffb17 	ldw	r2,-20(fp)
 4005404:	10800017 	ldw	r2,0(r2)
 4005408:	10ffffc4 	addi	r3,r2,-1
 400540c:	e0bffb17 	ldw	r2,-20(fp)
 4005410:	10c00015 	stw	r3,0(r2)
    prvAddTaskToReadyList( pxUnblockedTCB );
 4005414:	e0bffd17 	ldw	r2,-12(fp)
 4005418:	10800b17 	ldw	r2,44(r2)
 400541c:	d0e6b317 	ldw	r3,-25908(gp)
 4005420:	1880032e 	bgeu	r3,r2,4005430 <vTaskRemoveFromUnorderedEventList+0x13c>
 4005424:	e0bffd17 	ldw	r2,-12(fp)
 4005428:	10800b17 	ldw	r2,44(r2)
 400542c:	d0a6b315 	stw	r2,-25908(gp)
 4005430:	e0bffd17 	ldw	r2,-12(fp)
 4005434:	10800b17 	ldw	r2,44(r2)
 4005438:	01400504 	movi	r5,20
 400543c:	1009883a 	mov	r4,r2
 4005440:	40073b40 	call	40073b4 <__mulsi3>
 4005444:	1007883a 	mov	r3,r2
 4005448:	00812074 	movhi	r2,1153
 400544c:	1885883a 	add	r2,r3,r2
 4005450:	10bfb217 	ldw	r2,-312(r2)
 4005454:	e0bffa15 	stw	r2,-24(fp)
 4005458:	e0bffd17 	ldw	r2,-12(fp)
 400545c:	e0fffa17 	ldw	r3,-24(fp)
 4005460:	10c00215 	stw	r3,8(r2)
 4005464:	e0bffa17 	ldw	r2,-24(fp)
 4005468:	10c00217 	ldw	r3,8(r2)
 400546c:	e0bffd17 	ldw	r2,-12(fp)
 4005470:	10c00315 	stw	r3,12(r2)
 4005474:	e0bffa17 	ldw	r2,-24(fp)
 4005478:	10800217 	ldw	r2,8(r2)
 400547c:	e0fffd17 	ldw	r3,-12(fp)
 4005480:	18c00104 	addi	r3,r3,4
 4005484:	10c00115 	stw	r3,4(r2)
 4005488:	e0bffd17 	ldw	r2,-12(fp)
 400548c:	10c00104 	addi	r3,r2,4
 4005490:	e0bffa17 	ldw	r2,-24(fp)
 4005494:	10c00215 	stw	r3,8(r2)
 4005498:	e0bffd17 	ldw	r2,-12(fp)
 400549c:	10800b17 	ldw	r2,44(r2)
 40054a0:	01400504 	movi	r5,20
 40054a4:	1009883a 	mov	r4,r2
 40054a8:	40073b40 	call	40073b4 <__mulsi3>
 40054ac:	1007883a 	mov	r3,r2
 40054b0:	00812074 	movhi	r2,1153
 40054b4:	10bfb104 	addi	r2,r2,-316
 40054b8:	1887883a 	add	r3,r3,r2
 40054bc:	e0bffd17 	ldw	r2,-12(fp)
 40054c0:	10c00515 	stw	r3,20(r2)
 40054c4:	e0bffd17 	ldw	r2,-12(fp)
 40054c8:	14400b17 	ldw	r17,44(r2)
 40054cc:	01400504 	movi	r5,20
 40054d0:	8809883a 	mov	r4,r17
 40054d4:	40073b40 	call	40073b4 <__mulsi3>
 40054d8:	1007883a 	mov	r3,r2
 40054dc:	00812074 	movhi	r2,1153
 40054e0:	1885883a 	add	r2,r3,r2
 40054e4:	10bfb117 	ldw	r2,-316(r2)
 40054e8:	14000044 	addi	r16,r2,1
 40054ec:	01400504 	movi	r5,20
 40054f0:	8809883a 	mov	r4,r17
 40054f4:	40073b40 	call	40073b4 <__mulsi3>
 40054f8:	1007883a 	mov	r3,r2
 40054fc:	00812074 	movhi	r2,1153
 4005500:	1885883a 	add	r2,r3,r2
 4005504:	143fb115 	stw	r16,-316(r2)

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 4005508:	e0bffd17 	ldw	r2,-12(fp)
 400550c:	10800b17 	ldw	r2,44(r2)
 4005510:	d0e6ad17 	ldw	r3,-25932(gp)
 4005514:	18c00b17 	ldw	r3,44(r3)
 4005518:	1880022e 	bgeu	r3,r2,4005524 <vTaskRemoveFromUnorderedEventList+0x230>
    {
        /* The unblocked task has a priority above that of the calling task, so
         * a context switch is required.  This function is called with the
         * scheduler suspended so xYieldPending is set so the context switch
         * occurs immediately that the scheduler is resumed (unsuspended). */
        xYieldPending = pdTRUE;
 400551c:	00800044 	movi	r2,1
 4005520:	d0a6b615 	stw	r2,-25896(gp)
    }
}
 4005524:	0001883a 	nop
 4005528:	e6fffe04 	addi	sp,fp,-8
 400552c:	dfc00317 	ldw	ra,12(sp)
 4005530:	df000217 	ldw	fp,8(sp)
 4005534:	dc400117 	ldw	r17,4(sp)
 4005538:	dc000017 	ldw	r16,0(sp)
 400553c:	dec00404 	addi	sp,sp,16
 4005540:	f800283a 	ret

04005544 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
 4005544:	defffd04 	addi	sp,sp,-12
 4005548:	dfc00215 	stw	ra,8(sp)
 400554c:	df000115 	stw	fp,4(sp)
 4005550:	df000104 	addi	fp,sp,4
 4005554:	e13fff15 	stw	r4,-4(fp)
    configASSERT( pxTimeOut );
    taskENTER_CRITICAL();
 4005558:	4005f740 	call	4005f74 <vTaskEnterCritical>
    {
        pxTimeOut->xOverflowCount = xNumOfOverflows;
 400555c:	d0e6b717 	ldw	r3,-25892(gp)
 4005560:	e0bfff17 	ldw	r2,-4(fp)
 4005564:	10c00015 	stw	r3,0(r2)
        pxTimeOut->xTimeOnEntering = xTickCount;
 4005568:	d0e6b217 	ldw	r3,-25912(gp)
 400556c:	e0bfff17 	ldw	r2,-4(fp)
 4005570:	10c00115 	stw	r3,4(r2)
    }
    taskEXIT_CRITICAL();
 4005574:	4005fc80 	call	4005fc8 <vTaskExitCritical>
}
 4005578:	0001883a 	nop
 400557c:	e037883a 	mov	sp,fp
 4005580:	dfc00117 	ldw	ra,4(sp)
 4005584:	df000017 	ldw	fp,0(sp)
 4005588:	dec00204 	addi	sp,sp,8
 400558c:	f800283a 	ret

04005590 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
 4005590:	defffe04 	addi	sp,sp,-8
 4005594:	df000115 	stw	fp,4(sp)
 4005598:	df000104 	addi	fp,sp,4
 400559c:	e13fff15 	stw	r4,-4(fp)
    /* For internal use only as it does not use a critical section. */
    pxTimeOut->xOverflowCount = xNumOfOverflows;
 40055a0:	d0e6b717 	ldw	r3,-25892(gp)
 40055a4:	e0bfff17 	ldw	r2,-4(fp)
 40055a8:	10c00015 	stw	r3,0(r2)
    pxTimeOut->xTimeOnEntering = xTickCount;
 40055ac:	d0e6b217 	ldw	r3,-25912(gp)
 40055b0:	e0bfff17 	ldw	r2,-4(fp)
 40055b4:	10c00115 	stw	r3,4(r2)
}
 40055b8:	0001883a 	nop
 40055bc:	e037883a 	mov	sp,fp
 40055c0:	df000017 	ldw	fp,0(sp)
 40055c4:	dec00104 	addi	sp,sp,4
 40055c8:	f800283a 	ret

040055cc <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,
                                 TickType_t * const pxTicksToWait )
{
 40055cc:	defff904 	addi	sp,sp,-28
 40055d0:	dfc00615 	stw	ra,24(sp)
 40055d4:	df000515 	stw	fp,20(sp)
 40055d8:	df000504 	addi	fp,sp,20
 40055dc:	e13ffc15 	stw	r4,-16(fp)
 40055e0:	e17ffb15 	stw	r5,-20(fp)
    BaseType_t xReturn;

    configASSERT( pxTimeOut );
    configASSERT( pxTicksToWait );

    taskENTER_CRITICAL();
 40055e4:	4005f740 	call	4005f74 <vTaskEnterCritical>
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
 40055e8:	d0a6b217 	ldw	r2,-25912(gp)
 40055ec:	e0bffe15 	stw	r2,-8(fp)
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 40055f0:	e0bffc17 	ldw	r2,-16(fp)
 40055f4:	10800117 	ldw	r2,4(r2)
 40055f8:	e0fffe17 	ldw	r3,-8(fp)
 40055fc:	1885c83a 	sub	r2,r3,r2
 4005600:	e0bffd15 	stw	r2,-12(fp)
            }
            else
        #endif

        #if ( INCLUDE_vTaskSuspend == 1 )
            if( *pxTicksToWait == portMAX_DELAY )
 4005604:	e0bffb17 	ldw	r2,-20(fp)
 4005608:	10800017 	ldw	r2,0(r2)
 400560c:	10bfffd8 	cmpnei	r2,r2,-1
 4005610:	1000021e 	bne	r2,zero,400561c <xTaskCheckForTimeOut+0x50>
            {
                /* If INCLUDE_vTaskSuspend is set to 1 and the block time
                 * specified is the maximum block time then the task should block
                 * indefinitely, and therefore never time out. */
                xReturn = pdFALSE;
 4005614:	e03fff15 	stw	zero,-4(fp)
 4005618:	00001f06 	br	4005698 <xTaskCheckForTimeOut+0xcc>
            }
            else
        #endif

        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 400561c:	e0bffc17 	ldw	r2,-16(fp)
 4005620:	10c00017 	ldw	r3,0(r2)
 4005624:	d0a6b717 	ldw	r2,-25892(gp)
 4005628:	18800926 	beq	r3,r2,4005650 <xTaskCheckForTimeOut+0x84>
 400562c:	e0bffc17 	ldw	r2,-16(fp)
 4005630:	10800117 	ldw	r2,4(r2)
 4005634:	e0fffe17 	ldw	r3,-8(fp)
 4005638:	18800536 	bltu	r3,r2,4005650 <xTaskCheckForTimeOut+0x84>
            /* The tick count is greater than the time at which
             * vTaskSetTimeout() was called, but has also overflowed since
             * vTaskSetTimeOut() was called.  It must have wrapped all the way
             * around and gone past again. This passed since vTaskSetTimeout()
             * was called. */
            xReturn = pdTRUE;
 400563c:	00800044 	movi	r2,1
 4005640:	e0bfff15 	stw	r2,-4(fp)
            *pxTicksToWait = ( TickType_t ) 0;
 4005644:	e0bffb17 	ldw	r2,-20(fp)
 4005648:	10000015 	stw	zero,0(r2)
 400564c:	00001206 	br	4005698 <xTaskCheckForTimeOut+0xcc>
        }
        else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
 4005650:	e0bffb17 	ldw	r2,-20(fp)
 4005654:	10800017 	ldw	r2,0(r2)
 4005658:	e0fffd17 	ldw	r3,-12(fp)
 400565c:	18800a2e 	bgeu	r3,r2,4005688 <xTaskCheckForTimeOut+0xbc>
        {
            /* Not a genuine timeout. Adjust parameters for time remaining. */
            *pxTicksToWait -= xElapsedTime;
 4005660:	e0bffb17 	ldw	r2,-20(fp)
 4005664:	10c00017 	ldw	r3,0(r2)
 4005668:	e0bffd17 	ldw	r2,-12(fp)
 400566c:	1887c83a 	sub	r3,r3,r2
 4005670:	e0bffb17 	ldw	r2,-20(fp)
 4005674:	10c00015 	stw	r3,0(r2)
            vTaskInternalSetTimeOutState( pxTimeOut );
 4005678:	e13ffc17 	ldw	r4,-16(fp)
 400567c:	40055900 	call	4005590 <vTaskInternalSetTimeOutState>
            xReturn = pdFALSE;
 4005680:	e03fff15 	stw	zero,-4(fp)
 4005684:	00000406 	br	4005698 <xTaskCheckForTimeOut+0xcc>
        }
        else
        {
            *pxTicksToWait = ( TickType_t ) 0;
 4005688:	e0bffb17 	ldw	r2,-20(fp)
 400568c:	10000015 	stw	zero,0(r2)
            xReturn = pdTRUE;
 4005690:	00800044 	movi	r2,1
 4005694:	e0bfff15 	stw	r2,-4(fp)
        }
    }
    taskEXIT_CRITICAL();
 4005698:	4005fc80 	call	4005fc8 <vTaskExitCritical>

    return xReturn;
 400569c:	e0bfff17 	ldw	r2,-4(fp)
}
 40056a0:	e037883a 	mov	sp,fp
 40056a4:	dfc00117 	ldw	ra,4(sp)
 40056a8:	df000017 	ldw	fp,0(sp)
 40056ac:	dec00204 	addi	sp,sp,8
 40056b0:	f800283a 	ret

040056b4 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
 40056b4:	deffff04 	addi	sp,sp,-4
 40056b8:	df000015 	stw	fp,0(sp)
 40056bc:	d839883a 	mov	fp,sp
    xYieldPending = pdTRUE;
 40056c0:	00800044 	movi	r2,1
 40056c4:	d0a6b615 	stw	r2,-25896(gp)
}
 40056c8:	0001883a 	nop
 40056cc:	e037883a 	mov	sp,fp
 40056d0:	df000017 	ldw	fp,0(sp)
 40056d4:	dec00104 	addi	sp,sp,4
 40056d8:	f800283a 	ret

040056dc <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
 40056dc:	defffd04 	addi	sp,sp,-12
 40056e0:	dfc00215 	stw	ra,8(sp)
 40056e4:	df000115 	stw	fp,4(sp)
 40056e8:	df000104 	addi	fp,sp,4
 40056ec:	e13fff15 	stw	r4,-4(fp)

    for( ; ; )
    {
        /* See if any tasks have deleted themselves - if so then the idle task
         * is responsible for freeing the deleted task's TCB and stack. */
        prvCheckTasksWaitingTermination();
 40056f0:	40057b80 	call	40057b8 <prvCheckTasksWaitingTermination>
 40056f4:	003ffe06 	br	40056f0 <prvIdleTask+0x14>

040056f8 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
 40056f8:	defffd04 	addi	sp,sp,-12
 40056fc:	dfc00215 	stw	ra,8(sp)
 4005700:	df000115 	stw	fp,4(sp)
 4005704:	df000104 	addi	fp,sp,4
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 4005708:	e03fff15 	stw	zero,-4(fp)
 400570c:	00000c06 	br	4005740 <prvInitialiseTaskLists+0x48>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 4005710:	01400504 	movi	r5,20
 4005714:	e13fff17 	ldw	r4,-4(fp)
 4005718:	40073b40 	call	40073b4 <__mulsi3>
 400571c:	1007883a 	mov	r3,r2
 4005720:	00812074 	movhi	r2,1153
 4005724:	10bfb104 	addi	r2,r2,-316
 4005728:	1885883a 	add	r2,r3,r2
 400572c:	1009883a 	mov	r4,r2
 4005730:	4000aa00 	call	4000aa0 <vListInitialise>
    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 4005734:	e0bfff17 	ldw	r2,-4(fp)
 4005738:	10800044 	addi	r2,r2,1
 400573c:	e0bfff15 	stw	r2,-4(fp)
 4005740:	e0bfff17 	ldw	r2,-4(fp)
 4005744:	10800170 	cmpltui	r2,r2,5
 4005748:	103ff11e 	bne	r2,zero,4005710 <prvInitialiseTaskLists+0x18>
    }

    vListInitialise( &xDelayedTaskList1 );
 400574c:	01012074 	movhi	r4,1153
 4005750:	213fca04 	addi	r4,r4,-216
 4005754:	4000aa00 	call	4000aa0 <vListInitialise>
    vListInitialise( &xDelayedTaskList2 );
 4005758:	01012074 	movhi	r4,1153
 400575c:	213fcf04 	addi	r4,r4,-196
 4005760:	4000aa00 	call	4000aa0 <vListInitialise>
    vListInitialise( &xPendingReadyList );
 4005764:	01012074 	movhi	r4,1153
 4005768:	213fd404 	addi	r4,r4,-176
 400576c:	4000aa00 	call	4000aa0 <vListInitialise>

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        vListInitialise( &xTasksWaitingTermination );
 4005770:	01012074 	movhi	r4,1153
 4005774:	213fd904 	addi	r4,r4,-156
 4005778:	4000aa00 	call	4000aa0 <vListInitialise>
    }
    #endif /* INCLUDE_vTaskDelete */

    #if ( INCLUDE_vTaskSuspend == 1 )
    {
        vListInitialise( &xSuspendedTaskList );
 400577c:	01012074 	movhi	r4,1153
 4005780:	213fde04 	addi	r4,r4,-136
 4005784:	4000aa00 	call	4000aa0 <vListInitialise>
    }
    #endif /* INCLUDE_vTaskSuspend */

    /* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
     * using list2. */
    pxDelayedTaskList = &xDelayedTaskList1;
 4005788:	00812074 	movhi	r2,1153
 400578c:	10bfca04 	addi	r2,r2,-216
 4005790:	d0a6ae15 	stw	r2,-25928(gp)
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
 4005794:	00812074 	movhi	r2,1153
 4005798:	10bfcf04 	addi	r2,r2,-196
 400579c:	d0a6af15 	stw	r2,-25924(gp)
}
 40057a0:	0001883a 	nop
 40057a4:	e037883a 	mov	sp,fp
 40057a8:	dfc00117 	ldw	ra,4(sp)
 40057ac:	df000017 	ldw	fp,0(sp)
 40057b0:	dec00204 	addi	sp,sp,8
 40057b4:	f800283a 	ret

040057b8 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
 40057b8:	defffd04 	addi	sp,sp,-12
 40057bc:	dfc00215 	stw	ra,8(sp)
 40057c0:	df000115 	stw	fp,4(sp)
 40057c4:	df000104 	addi	fp,sp,4
    {
        TCB_t * pxTCB;

        /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
         * being called too often in the idle task. */
        while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 40057c8:	00001206 	br	4005814 <prvCheckTasksWaitingTermination+0x5c>
        {
            taskENTER_CRITICAL();
 40057cc:	4005f740 	call	4005f74 <vTaskEnterCritical>
            {
                pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 40057d0:	00812074 	movhi	r2,1153
 40057d4:	10bfdc17 	ldw	r2,-144(r2)
 40057d8:	10800317 	ldw	r2,12(r2)
 40057dc:	e0bfff15 	stw	r2,-4(fp)
                ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 40057e0:	e0bfff17 	ldw	r2,-4(fp)
 40057e4:	10800104 	addi	r2,r2,4
 40057e8:	1009883a 	mov	r4,r2
 40057ec:	4000c980 	call	4000c98 <uxListRemove>
                --uxCurrentNumberOfTasks;
 40057f0:	d0a6b117 	ldw	r2,-25916(gp)
 40057f4:	10bfffc4 	addi	r2,r2,-1
 40057f8:	d0a6b115 	stw	r2,-25916(gp)
                --uxDeletedTasksWaitingCleanUp;
 40057fc:	d0a6b017 	ldw	r2,-25920(gp)
 4005800:	10bfffc4 	addi	r2,r2,-1
 4005804:	d0a6b015 	stw	r2,-25920(gp)
            }
            taskEXIT_CRITICAL();
 4005808:	4005fc80 	call	4005fc8 <vTaskExitCritical>

            prvDeleteTCB( pxTCB );
 400580c:	e13fff17 	ldw	r4,-4(fp)
 4005810:	40058fc0 	call	40058fc <prvDeleteTCB>
        while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 4005814:	d0a6b017 	ldw	r2,-25920(gp)
 4005818:	103fec1e 	bne	r2,zero,40057cc <prvCheckTasksWaitingTermination+0x14>
        }
    }
    #endif /* INCLUDE_vTaskDelete */
}
 400581c:	0001883a 	nop
 4005820:	0001883a 	nop
 4005824:	e037883a 	mov	sp,fp
 4005828:	dfc00117 	ldw	ra,4(sp)
 400582c:	df000017 	ldw	fp,0(sp)
 4005830:	dec00204 	addi	sp,sp,8
 4005834:	f800283a 	ret

04005838 <prvTaskCheckFreeStackSpace>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark2 == 1 ) )

    static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
    {
 4005838:	defffd04 	addi	sp,sp,-12
 400583c:	df000215 	stw	fp,8(sp)
 4005840:	df000204 	addi	fp,sp,8
 4005844:	e13ffe15 	stw	r4,-8(fp)
        uint32_t ulCount = 0U;
 4005848:	e03fff15 	stw	zero,-4(fp)

        while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
 400584c:	00000606 	br	4005868 <prvTaskCheckFreeStackSpace+0x30>
        {
            pucStackByte -= portSTACK_GROWTH;
 4005850:	e0bffe17 	ldw	r2,-8(fp)
 4005854:	10800044 	addi	r2,r2,1
 4005858:	e0bffe15 	stw	r2,-8(fp)
            ulCount++;
 400585c:	e0bfff17 	ldw	r2,-4(fp)
 4005860:	10800044 	addi	r2,r2,1
 4005864:	e0bfff15 	stw	r2,-4(fp)
        while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
 4005868:	e0bffe17 	ldw	r2,-8(fp)
 400586c:	10800003 	ldbu	r2,0(r2)
 4005870:	10803fcc 	andi	r2,r2,255
 4005874:	10802960 	cmpeqi	r2,r2,165
 4005878:	103ff51e 	bne	r2,zero,4005850 <prvTaskCheckFreeStackSpace+0x18>
        }

        ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller architectures. */
 400587c:	e0bfff17 	ldw	r2,-4(fp)
 4005880:	1004d0ba 	srli	r2,r2,2
 4005884:	e0bfff15 	stw	r2,-4(fp)

        return ( configSTACK_DEPTH_TYPE ) ulCount;
 4005888:	e0bfff17 	ldw	r2,-4(fp)
    }
 400588c:	e037883a 	mov	sp,fp
 4005890:	df000017 	ldw	fp,0(sp)
 4005894:	dec00104 	addi	sp,sp,4
 4005898:	f800283a 	ret

0400589c <uxTaskGetStackHighWaterMark>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )

    UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
    {
 400589c:	defffa04 	addi	sp,sp,-24
 40058a0:	dfc00515 	stw	ra,20(sp)
 40058a4:	df000415 	stw	fp,16(sp)
 40058a8:	df000404 	addi	fp,sp,16
 40058ac:	e13ffc15 	stw	r4,-16(fp)
        TCB_t * pxTCB;
        uint8_t * pucEndOfStack;
        UBaseType_t uxReturn;

        pxTCB = prvGetTCBFromHandle( xTask );
 40058b0:	e0bffc17 	ldw	r2,-16(fp)
 40058b4:	1000021e 	bne	r2,zero,40058c0 <uxTaskGetStackHighWaterMark+0x24>
 40058b8:	d0a6ad17 	ldw	r2,-25932(gp)
 40058bc:	00000106 	br	40058c4 <uxTaskGetStackHighWaterMark+0x28>
 40058c0:	e0bffc17 	ldw	r2,-16(fp)
 40058c4:	e0bfff15 	stw	r2,-4(fp)

        #if portSTACK_GROWTH < 0
        {
            pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
 40058c8:	e0bfff17 	ldw	r2,-4(fp)
 40058cc:	10800c17 	ldw	r2,48(r2)
 40058d0:	e0bffe15 	stw	r2,-8(fp)
        {
            pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
        }
        #endif

        uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
 40058d4:	e13ffe17 	ldw	r4,-8(fp)
 40058d8:	40058380 	call	4005838 <prvTaskCheckFreeStackSpace>
 40058dc:	10bfffcc 	andi	r2,r2,65535
 40058e0:	e0bffd15 	stw	r2,-12(fp)

        return uxReturn;
 40058e4:	e0bffd17 	ldw	r2,-12(fp)
    }
 40058e8:	e037883a 	mov	sp,fp
 40058ec:	dfc00117 	ldw	ra,4(sp)
 40058f0:	df000017 	ldw	fp,0(sp)
 40058f4:	dec00204 	addi	sp,sp,8
 40058f8:	f800283a 	ret

040058fc <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    static void prvDeleteTCB( TCB_t * pxTCB )
    {
 40058fc:	defffd04 	addi	sp,sp,-12
 4005900:	dfc00215 	stw	ra,8(sp)
 4005904:	df000115 	stw	fp,4(sp)
 4005908:	df000104 	addi	fp,sp,4
 400590c:	e13fff15 	stw	r4,-4(fp)

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
        {
            /* The task can only have been allocated dynamically - free both
             * the stack and TCB. */
            vPortFreeStack( pxTCB->pxStack );
 4005910:	e0bfff17 	ldw	r2,-4(fp)
 4005914:	10800c17 	ldw	r2,48(r2)
 4005918:	1009883a 	mov	r4,r2
 400591c:	400111c0 	call	400111c <vPortFree>
            vPortFree( pxTCB );
 4005920:	e13fff17 	ldw	r4,-4(fp)
 4005924:	400111c0 	call	400111c <vPortFree>
                configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB );
                mtCOVERAGE_TEST_MARKER();
            }
        }
        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    }
 4005928:	0001883a 	nop
 400592c:	e037883a 	mov	sp,fp
 4005930:	dfc00117 	ldw	ra,4(sp)
 4005934:	df000017 	ldw	fp,0(sp)
 4005938:	dec00204 	addi	sp,sp,8
 400593c:	f800283a 	ret

04005940 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
 4005940:	deffff04 	addi	sp,sp,-4
 4005944:	df000015 	stw	fp,0(sp)
 4005948:	d839883a 	mov	fp,sp
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 400594c:	d0a6ae17 	ldw	r2,-25928(gp)
 4005950:	10800017 	ldw	r2,0(r2)
 4005954:	1000031e 	bne	r2,zero,4005964 <prvResetNextTaskUnblockTime+0x24>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
 4005958:	00bfffc4 	movi	r2,-1
 400595c:	d0a6b915 	stw	r2,-25884(gp)
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    }
}
 4005960:	00000406 	br	4005974 <prvResetNextTaskUnblockTime+0x34>
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
 4005964:	d0a6ae17 	ldw	r2,-25928(gp)
 4005968:	10800317 	ldw	r2,12(r2)
 400596c:	10800017 	ldw	r2,0(r2)
 4005970:	d0a6b915 	stw	r2,-25884(gp)
}
 4005974:	0001883a 	nop
 4005978:	e037883a 	mov	sp,fp
 400597c:	df000017 	ldw	fp,0(sp)
 4005980:	dec00104 	addi	sp,sp,4
 4005984:	f800283a 	ret

04005988 <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

    TaskHandle_t xTaskGetCurrentTaskHandle( void )
    {
 4005988:	defffe04 	addi	sp,sp,-8
 400598c:	df000115 	stw	fp,4(sp)
 4005990:	df000104 	addi	fp,sp,4
        TaskHandle_t xReturn;

        /* A critical section is not required as this is not called from
         * an interrupt and the current TCB will always be the same for any
         * individual execution thread. */
        xReturn = pxCurrentTCB;
 4005994:	d0a6ad17 	ldw	r2,-25932(gp)
 4005998:	e0bfff15 	stw	r2,-4(fp)

        return xReturn;
 400599c:	e0bfff17 	ldw	r2,-4(fp)
    }
 40059a0:	e037883a 	mov	sp,fp
 40059a4:	df000017 	ldw	fp,0(sp)
 40059a8:	dec00104 	addi	sp,sp,4
 40059ac:	f800283a 	ret

040059b0 <xTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
    {
 40059b0:	defff804 	addi	sp,sp,-32
 40059b4:	dfc00715 	stw	ra,28(sp)
 40059b8:	df000615 	stw	fp,24(sp)
 40059bc:	dc400515 	stw	r17,20(sp)
 40059c0:	dc000415 	stw	r16,16(sp)
 40059c4:	df000604 	addi	fp,sp,24
 40059c8:	e13ffa15 	stw	r4,-24(fp)
        TCB_t * const pxMutexHolderTCB = pxMutexHolder;
 40059cc:	e0bffa17 	ldw	r2,-24(fp)
 40059d0:	e0bffc15 	stw	r2,-16(fp)
        BaseType_t xReturn = pdFALSE;
 40059d4:	e03ffd15 	stw	zero,-12(fp)

        /* If the mutex was given back by an interrupt while the queue was
         * locked then the mutex holder might now be NULL.  _RB_ Is this still
         * needed as interrupts can no longer use mutexes? */
        if( pxMutexHolder != NULL )
 40059d8:	e0bffa17 	ldw	r2,-24(fp)
 40059dc:	10006e26 	beq	r2,zero,4005b98 <xTaskPriorityInherit+0x1e8>
        {
            /* If the holder of the mutex has a priority below the priority of
             * the task attempting to obtain the mutex then it will temporarily
             * inherit the priority of the task attempting to obtain the mutex. */
            if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
 40059e0:	e0bffc17 	ldw	r2,-16(fp)
 40059e4:	10c00b17 	ldw	r3,44(r2)
 40059e8:	d0a6ad17 	ldw	r2,-25932(gp)
 40059ec:	10800b17 	ldw	r2,44(r2)
 40059f0:	1880622e 	bgeu	r3,r2,4005b7c <xTaskPriorityInherit+0x1cc>
            {
                /* Adjust the mutex holder state to account for its new
                 * priority.  Only reset the event list item value if the value is
                 * not being used for anything else. */
                if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 40059f4:	e0bffc17 	ldw	r2,-16(fp)
 40059f8:	10800617 	ldw	r2,24(r2)
 40059fc:	10000616 	blt	r2,zero,4005a18 <xTaskPriorityInherit+0x68>
                {
                    listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 4005a00:	d0a6ad17 	ldw	r2,-25932(gp)
 4005a04:	10800b17 	ldw	r2,44(r2)
 4005a08:	00c00144 	movi	r3,5
 4005a0c:	1887c83a 	sub	r3,r3,r2
 4005a10:	e0bffc17 	ldw	r2,-16(fp)
 4005a14:	10c00615 	stw	r3,24(r2)
                    mtCOVERAGE_TEST_MARKER();
                }

                /* If the task being modified is in the ready state it will need
                 * to be moved into a new list. */
                if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
 4005a18:	e0bffc17 	ldw	r2,-16(fp)
 4005a1c:	14000517 	ldw	r16,20(r2)
 4005a20:	e0bffc17 	ldw	r2,-16(fp)
 4005a24:	10800b17 	ldw	r2,44(r2)
 4005a28:	01400504 	movi	r5,20
 4005a2c:	1009883a 	mov	r4,r2
 4005a30:	40073b40 	call	40073b4 <__mulsi3>
 4005a34:	1007883a 	mov	r3,r2
 4005a38:	00812074 	movhi	r2,1153
 4005a3c:	10bfb104 	addi	r2,r2,-316
 4005a40:	1885883a 	add	r2,r3,r2
 4005a44:	8080461e 	bne	r16,r2,4005b60 <xTaskPriorityInherit+0x1b0>
                {
                    if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 4005a48:	e0bffc17 	ldw	r2,-16(fp)
 4005a4c:	10800104 	addi	r2,r2,4
 4005a50:	1009883a 	mov	r4,r2
 4005a54:	4000c980 	call	4000c98 <uxListRemove>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Inherit the priority before being moved into the new list. */
                    pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 4005a58:	d0a6ad17 	ldw	r2,-25932(gp)
 4005a5c:	10c00b17 	ldw	r3,44(r2)
 4005a60:	e0bffc17 	ldw	r2,-16(fp)
 4005a64:	10c00b15 	stw	r3,44(r2)
                    prvAddTaskToReadyList( pxMutexHolderTCB );
 4005a68:	e0bffc17 	ldw	r2,-16(fp)
 4005a6c:	10800b17 	ldw	r2,44(r2)
 4005a70:	d0e6b317 	ldw	r3,-25908(gp)
 4005a74:	1880032e 	bgeu	r3,r2,4005a84 <xTaskPriorityInherit+0xd4>
 4005a78:	e0bffc17 	ldw	r2,-16(fp)
 4005a7c:	10800b17 	ldw	r2,44(r2)
 4005a80:	d0a6b315 	stw	r2,-25908(gp)
 4005a84:	e0bffc17 	ldw	r2,-16(fp)
 4005a88:	10800b17 	ldw	r2,44(r2)
 4005a8c:	01400504 	movi	r5,20
 4005a90:	1009883a 	mov	r4,r2
 4005a94:	40073b40 	call	40073b4 <__mulsi3>
 4005a98:	1007883a 	mov	r3,r2
 4005a9c:	00812074 	movhi	r2,1153
 4005aa0:	1885883a 	add	r2,r3,r2
 4005aa4:	10bfb217 	ldw	r2,-312(r2)
 4005aa8:	e0bffb15 	stw	r2,-20(fp)
 4005aac:	e0bffc17 	ldw	r2,-16(fp)
 4005ab0:	e0fffb17 	ldw	r3,-20(fp)
 4005ab4:	10c00215 	stw	r3,8(r2)
 4005ab8:	e0bffb17 	ldw	r2,-20(fp)
 4005abc:	10c00217 	ldw	r3,8(r2)
 4005ac0:	e0bffc17 	ldw	r2,-16(fp)
 4005ac4:	10c00315 	stw	r3,12(r2)
 4005ac8:	e0bffb17 	ldw	r2,-20(fp)
 4005acc:	10800217 	ldw	r2,8(r2)
 4005ad0:	e0fffc17 	ldw	r3,-16(fp)
 4005ad4:	18c00104 	addi	r3,r3,4
 4005ad8:	10c00115 	stw	r3,4(r2)
 4005adc:	e0bffc17 	ldw	r2,-16(fp)
 4005ae0:	10c00104 	addi	r3,r2,4
 4005ae4:	e0bffb17 	ldw	r2,-20(fp)
 4005ae8:	10c00215 	stw	r3,8(r2)
 4005aec:	e0bffc17 	ldw	r2,-16(fp)
 4005af0:	10800b17 	ldw	r2,44(r2)
 4005af4:	01400504 	movi	r5,20
 4005af8:	1009883a 	mov	r4,r2
 4005afc:	40073b40 	call	40073b4 <__mulsi3>
 4005b00:	1007883a 	mov	r3,r2
 4005b04:	00812074 	movhi	r2,1153
 4005b08:	10bfb104 	addi	r2,r2,-316
 4005b0c:	1887883a 	add	r3,r3,r2
 4005b10:	e0bffc17 	ldw	r2,-16(fp)
 4005b14:	10c00515 	stw	r3,20(r2)
 4005b18:	e0bffc17 	ldw	r2,-16(fp)
 4005b1c:	14400b17 	ldw	r17,44(r2)
 4005b20:	01400504 	movi	r5,20
 4005b24:	8809883a 	mov	r4,r17
 4005b28:	40073b40 	call	40073b4 <__mulsi3>
 4005b2c:	1007883a 	mov	r3,r2
 4005b30:	00812074 	movhi	r2,1153
 4005b34:	1885883a 	add	r2,r3,r2
 4005b38:	10bfb117 	ldw	r2,-316(r2)
 4005b3c:	14000044 	addi	r16,r2,1
 4005b40:	01400504 	movi	r5,20
 4005b44:	8809883a 	mov	r4,r17
 4005b48:	40073b40 	call	40073b4 <__mulsi3>
 4005b4c:	1007883a 	mov	r3,r2
 4005b50:	00812074 	movhi	r2,1153
 4005b54:	1885883a 	add	r2,r3,r2
 4005b58:	143fb115 	stw	r16,-316(r2)
 4005b5c:	00000406 	br	4005b70 <xTaskPriorityInherit+0x1c0>
                }
                else
                {
                    /* Just inherit the priority. */
                    pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 4005b60:	d0a6ad17 	ldw	r2,-25932(gp)
 4005b64:	10c00b17 	ldw	r3,44(r2)
 4005b68:	e0bffc17 	ldw	r2,-16(fp)
 4005b6c:	10c00b15 	stw	r3,44(r2)
                }

                traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );

                /* Inheritance occurred. */
                xReturn = pdTRUE;
 4005b70:	00800044 	movi	r2,1
 4005b74:	e0bffd15 	stw	r2,-12(fp)
 4005b78:	00000706 	br	4005b98 <xTaskPriorityInherit+0x1e8>
            }
            else
            {
                if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
 4005b7c:	e0bffc17 	ldw	r2,-16(fp)
 4005b80:	10c01017 	ldw	r3,64(r2)
 4005b84:	d0a6ad17 	ldw	r2,-25932(gp)
 4005b88:	10800b17 	ldw	r2,44(r2)
 4005b8c:	1880022e 	bgeu	r3,r2,4005b98 <xTaskPriorityInherit+0x1e8>
                     * current priority of the mutex holder is not lower than the
                     * priority of the task attempting to take the mutex.
                     * Therefore the mutex holder must have already inherited a
                     * priority, but inheritance would have occurred if that had
                     * not been the case. */
                    xReturn = pdTRUE;
 4005b90:	00800044 	movi	r2,1
 4005b94:	e0bffd15 	stw	r2,-12(fp)
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
 4005b98:	e0bffd17 	ldw	r2,-12(fp)
    }
 4005b9c:	e6fffe04 	addi	sp,fp,-8
 4005ba0:	dfc00317 	ldw	ra,12(sp)
 4005ba4:	df000217 	ldw	fp,8(sp)
 4005ba8:	dc400117 	ldw	r17,4(sp)
 4005bac:	dc000017 	ldw	r16,0(sp)
 4005bb0:	dec00404 	addi	sp,sp,16
 4005bb4:	f800283a 	ret

04005bb8 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
 4005bb8:	defff804 	addi	sp,sp,-32
 4005bbc:	dfc00715 	stw	ra,28(sp)
 4005bc0:	df000615 	stw	fp,24(sp)
 4005bc4:	dc400515 	stw	r17,20(sp)
 4005bc8:	dc000415 	stw	r16,16(sp)
 4005bcc:	df000604 	addi	fp,sp,24
 4005bd0:	e13ffa15 	stw	r4,-24(fp)
        TCB_t * const pxTCB = pxMutexHolder;
 4005bd4:	e0bffa17 	ldw	r2,-24(fp)
 4005bd8:	e0bffc15 	stw	r2,-16(fp)
        BaseType_t xReturn = pdFALSE;
 4005bdc:	e03ffd15 	stw	zero,-12(fp)

        if( pxMutexHolder != NULL )
 4005be0:	e0bffa17 	ldw	r2,-24(fp)
 4005be4:	10005a26 	beq	r2,zero,4005d50 <xTaskPriorityDisinherit+0x198>
             * If the mutex is held by a task then it cannot be given from an
             * interrupt, and if a mutex is given by the holding task then it must
             * be the running state task. */
            configASSERT( pxTCB == pxCurrentTCB );
            configASSERT( pxTCB->uxMutexesHeld );
            ( pxTCB->uxMutexesHeld )--;
 4005be8:	e0bffc17 	ldw	r2,-16(fp)
 4005bec:	10801117 	ldw	r2,68(r2)
 4005bf0:	10ffffc4 	addi	r3,r2,-1
 4005bf4:	e0bffc17 	ldw	r2,-16(fp)
 4005bf8:	10c01115 	stw	r3,68(r2)

            /* Has the holder of the mutex inherited the priority of another
             * task? */
            if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 4005bfc:	e0bffc17 	ldw	r2,-16(fp)
 4005c00:	10c00b17 	ldw	r3,44(r2)
 4005c04:	e0bffc17 	ldw	r2,-16(fp)
 4005c08:	10801017 	ldw	r2,64(r2)
 4005c0c:	18805026 	beq	r3,r2,4005d50 <xTaskPriorityDisinherit+0x198>
            {
                /* Only disinherit if no other mutexes are held. */
                if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
 4005c10:	e0bffc17 	ldw	r2,-16(fp)
 4005c14:	10801117 	ldw	r2,68(r2)
 4005c18:	10004d1e 	bne	r2,zero,4005d50 <xTaskPriorityDisinherit+0x198>
                    /* A task can only have an inherited priority if it holds
                     * the mutex.  If the mutex is held by a task then it cannot be
                     * given from an interrupt, and if a mutex is given by the
                     * holding task then it must be the running state task.  Remove
                     * the holding task from the ready list. */
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 4005c1c:	e0bffc17 	ldw	r2,-16(fp)
 4005c20:	10800104 	addi	r2,r2,4
 4005c24:	1009883a 	mov	r4,r2
 4005c28:	4000c980 	call	4000c98 <uxListRemove>
                    }

                    /* Disinherit the priority before adding the task into the
                     * new  ready list. */
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
                    pxTCB->uxPriority = pxTCB->uxBasePriority;
 4005c2c:	e0bffc17 	ldw	r2,-16(fp)
 4005c30:	10c01017 	ldw	r3,64(r2)
 4005c34:	e0bffc17 	ldw	r2,-16(fp)
 4005c38:	10c00b15 	stw	r3,44(r2)

                    /* Reset the event list item value.  It cannot be in use for
                     * any other purpose if this task is running, and it must be
                     * running to give back the mutex. */
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 4005c3c:	e0bffc17 	ldw	r2,-16(fp)
 4005c40:	10800b17 	ldw	r2,44(r2)
 4005c44:	00c00144 	movi	r3,5
 4005c48:	1887c83a 	sub	r3,r3,r2
 4005c4c:	e0bffc17 	ldw	r2,-16(fp)
 4005c50:	10c00615 	stw	r3,24(r2)
                    prvAddTaskToReadyList( pxTCB );
 4005c54:	e0bffc17 	ldw	r2,-16(fp)
 4005c58:	10800b17 	ldw	r2,44(r2)
 4005c5c:	d0e6b317 	ldw	r3,-25908(gp)
 4005c60:	1880032e 	bgeu	r3,r2,4005c70 <xTaskPriorityDisinherit+0xb8>
 4005c64:	e0bffc17 	ldw	r2,-16(fp)
 4005c68:	10800b17 	ldw	r2,44(r2)
 4005c6c:	d0a6b315 	stw	r2,-25908(gp)
 4005c70:	e0bffc17 	ldw	r2,-16(fp)
 4005c74:	10800b17 	ldw	r2,44(r2)
 4005c78:	01400504 	movi	r5,20
 4005c7c:	1009883a 	mov	r4,r2
 4005c80:	40073b40 	call	40073b4 <__mulsi3>
 4005c84:	1007883a 	mov	r3,r2
 4005c88:	00812074 	movhi	r2,1153
 4005c8c:	1885883a 	add	r2,r3,r2
 4005c90:	10bfb217 	ldw	r2,-312(r2)
 4005c94:	e0bffb15 	stw	r2,-20(fp)
 4005c98:	e0bffc17 	ldw	r2,-16(fp)
 4005c9c:	e0fffb17 	ldw	r3,-20(fp)
 4005ca0:	10c00215 	stw	r3,8(r2)
 4005ca4:	e0bffb17 	ldw	r2,-20(fp)
 4005ca8:	10c00217 	ldw	r3,8(r2)
 4005cac:	e0bffc17 	ldw	r2,-16(fp)
 4005cb0:	10c00315 	stw	r3,12(r2)
 4005cb4:	e0bffb17 	ldw	r2,-20(fp)
 4005cb8:	10800217 	ldw	r2,8(r2)
 4005cbc:	e0fffc17 	ldw	r3,-16(fp)
 4005cc0:	18c00104 	addi	r3,r3,4
 4005cc4:	10c00115 	stw	r3,4(r2)
 4005cc8:	e0bffc17 	ldw	r2,-16(fp)
 4005ccc:	10c00104 	addi	r3,r2,4
 4005cd0:	e0bffb17 	ldw	r2,-20(fp)
 4005cd4:	10c00215 	stw	r3,8(r2)
 4005cd8:	e0bffc17 	ldw	r2,-16(fp)
 4005cdc:	10800b17 	ldw	r2,44(r2)
 4005ce0:	01400504 	movi	r5,20
 4005ce4:	1009883a 	mov	r4,r2
 4005ce8:	40073b40 	call	40073b4 <__mulsi3>
 4005cec:	1007883a 	mov	r3,r2
 4005cf0:	00812074 	movhi	r2,1153
 4005cf4:	10bfb104 	addi	r2,r2,-316
 4005cf8:	1887883a 	add	r3,r3,r2
 4005cfc:	e0bffc17 	ldw	r2,-16(fp)
 4005d00:	10c00515 	stw	r3,20(r2)
 4005d04:	e0bffc17 	ldw	r2,-16(fp)
 4005d08:	14400b17 	ldw	r17,44(r2)
 4005d0c:	01400504 	movi	r5,20
 4005d10:	8809883a 	mov	r4,r17
 4005d14:	40073b40 	call	40073b4 <__mulsi3>
 4005d18:	1007883a 	mov	r3,r2
 4005d1c:	00812074 	movhi	r2,1153
 4005d20:	1885883a 	add	r2,r3,r2
 4005d24:	10bfb117 	ldw	r2,-316(r2)
 4005d28:	14000044 	addi	r16,r2,1
 4005d2c:	01400504 	movi	r5,20
 4005d30:	8809883a 	mov	r4,r17
 4005d34:	40073b40 	call	40073b4 <__mulsi3>
 4005d38:	1007883a 	mov	r3,r2
 4005d3c:	00812074 	movhi	r2,1153
 4005d40:	1885883a 	add	r2,r3,r2
 4005d44:	143fb115 	stw	r16,-316(r2)
                     * in an order different to that in which they were taken.
                     * If a context switch did not occur when the first mutex was
                     * returned, even if a task was waiting on it, then a context
                     * switch should occur when the last mutex is returned whether
                     * a task is waiting on it or not. */
                    xReturn = pdTRUE;
 4005d48:	00800044 	movi	r2,1
 4005d4c:	e0bffd15 	stw	r2,-12(fp)
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
 4005d50:	e0bffd17 	ldw	r2,-12(fp)
    }
 4005d54:	e6fffe04 	addi	sp,fp,-8
 4005d58:	dfc00317 	ldw	ra,12(sp)
 4005d5c:	df000217 	ldw	fp,8(sp)
 4005d60:	dc400117 	ldw	r17,4(sp)
 4005d64:	dc000017 	ldw	r16,0(sp)
 4005d68:	dec00404 	addi	sp,sp,16
 4005d6c:	f800283a 	ret

04005d70 <vTaskPriorityDisinheritAfterTimeout>:

#if ( configUSE_MUTEXES == 1 )

    void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder,
                                              UBaseType_t uxHighestPriorityWaitingTask )
    {
 4005d70:	defff504 	addi	sp,sp,-44
 4005d74:	dfc00a15 	stw	ra,40(sp)
 4005d78:	df000915 	stw	fp,36(sp)
 4005d7c:	dc400815 	stw	r17,32(sp)
 4005d80:	dc000715 	stw	r16,28(sp)
 4005d84:	df000904 	addi	fp,sp,36
 4005d88:	e13ff815 	stw	r4,-32(fp)
 4005d8c:	e17ff715 	stw	r5,-36(fp)
        TCB_t * const pxTCB = pxMutexHolder;
 4005d90:	e0bff817 	ldw	r2,-32(fp)
 4005d94:	e0bffc15 	stw	r2,-16(fp)
        UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
        const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
 4005d98:	00800044 	movi	r2,1
 4005d9c:	e0bffb15 	stw	r2,-20(fp)

        if( pxMutexHolder != NULL )
 4005da0:	e0bff817 	ldw	r2,-32(fp)
 4005da4:	10006b26 	beq	r2,zero,4005f54 <vTaskPriorityDisinheritAfterTimeout+0x1e4>

            /* Determine the priority to which the priority of the task that
             * holds the mutex should be set.  This will be the greater of the
             * holding task's base priority and the priority of the highest
             * priority task that is waiting to obtain the mutex. */
            if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
 4005da8:	e0bffc17 	ldw	r2,-16(fp)
 4005dac:	10c01017 	ldw	r3,64(r2)
 4005db0:	e0bff717 	ldw	r2,-36(fp)
 4005db4:	1880032e 	bgeu	r3,r2,4005dc4 <vTaskPriorityDisinheritAfterTimeout+0x54>
            {
                uxPriorityToUse = uxHighestPriorityWaitingTask;
 4005db8:	e0bff717 	ldw	r2,-36(fp)
 4005dbc:	e0bffd15 	stw	r2,-12(fp)
 4005dc0:	00000306 	br	4005dd0 <vTaskPriorityDisinheritAfterTimeout+0x60>
            }
            else
            {
                uxPriorityToUse = pxTCB->uxBasePriority;
 4005dc4:	e0bffc17 	ldw	r2,-16(fp)
 4005dc8:	10801017 	ldw	r2,64(r2)
 4005dcc:	e0bffd15 	stw	r2,-12(fp)
            }

            /* Does the priority need to change? */
            if( pxTCB->uxPriority != uxPriorityToUse )
 4005dd0:	e0bffc17 	ldw	r2,-16(fp)
 4005dd4:	10800b17 	ldw	r2,44(r2)
 4005dd8:	e0fffd17 	ldw	r3,-12(fp)
 4005ddc:	18805d26 	beq	r3,r2,4005f54 <vTaskPriorityDisinheritAfterTimeout+0x1e4>
            {
                /* Only disinherit if no other mutexes are held.  This is a
                 * simplification in the priority inheritance implementation.  If
                 * the task that holds the mutex is also holding other mutexes then
                 * the other mutexes may have caused the priority inheritance. */
                if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
 4005de0:	e0bffc17 	ldw	r2,-16(fp)
 4005de4:	10801117 	ldw	r2,68(r2)
 4005de8:	e0fffb17 	ldw	r3,-20(fp)
 4005dec:	1880591e 	bne	r3,r2,4005f54 <vTaskPriorityDisinheritAfterTimeout+0x1e4>

                    /* Disinherit the priority, remembering the previous
                     * priority to facilitate determining the subject task's
                     * state. */
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, uxPriorityToUse );
                    uxPriorityUsedOnEntry = pxTCB->uxPriority;
 4005df0:	e0bffc17 	ldw	r2,-16(fp)
 4005df4:	10800b17 	ldw	r2,44(r2)
 4005df8:	e0bffa15 	stw	r2,-24(fp)
                    pxTCB->uxPriority = uxPriorityToUse;
 4005dfc:	e0bffc17 	ldw	r2,-16(fp)
 4005e00:	e0fffd17 	ldw	r3,-12(fp)
 4005e04:	10c00b15 	stw	r3,44(r2)

                    /* Only reset the event list item value if the value is not
                     * being used for anything else. */
                    if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 4005e08:	e0bffc17 	ldw	r2,-16(fp)
 4005e0c:	10800617 	ldw	r2,24(r2)
 4005e10:	10000516 	blt	r2,zero,4005e28 <vTaskPriorityDisinheritAfterTimeout+0xb8>
                    {
                        listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 4005e14:	00c00144 	movi	r3,5
 4005e18:	e0bffd17 	ldw	r2,-12(fp)
 4005e1c:	1887c83a 	sub	r3,r3,r2
 4005e20:	e0bffc17 	ldw	r2,-16(fp)
 4005e24:	10c00615 	stw	r3,24(r2)
                     * then the task that holds the mutex could be in either the
                     * Ready, Blocked or Suspended states.  Only remove the task
                     * from its current state list if it is in the Ready state as
                     * the task's priority is going to change and there is one
                     * Ready list per priority. */
                    if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 4005e28:	e0bffc17 	ldw	r2,-16(fp)
 4005e2c:	14000517 	ldw	r16,20(r2)
 4005e30:	01400504 	movi	r5,20
 4005e34:	e13ffa17 	ldw	r4,-24(fp)
 4005e38:	40073b40 	call	40073b4 <__mulsi3>
 4005e3c:	1007883a 	mov	r3,r2
 4005e40:	00812074 	movhi	r2,1153
 4005e44:	10bfb104 	addi	r2,r2,-316
 4005e48:	1885883a 	add	r2,r3,r2
 4005e4c:	8080411e 	bne	r16,r2,4005f54 <vTaskPriorityDisinheritAfterTimeout+0x1e4>
                    {
                        if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 4005e50:	e0bffc17 	ldw	r2,-16(fp)
 4005e54:	10800104 	addi	r2,r2,4
 4005e58:	1009883a 	mov	r4,r2
 4005e5c:	4000c980 	call	4000c98 <uxListRemove>
                        else
                        {
                            mtCOVERAGE_TEST_MARKER();
                        }

                        prvAddTaskToReadyList( pxTCB );
 4005e60:	e0bffc17 	ldw	r2,-16(fp)
 4005e64:	10800b17 	ldw	r2,44(r2)
 4005e68:	d0e6b317 	ldw	r3,-25908(gp)
 4005e6c:	1880032e 	bgeu	r3,r2,4005e7c <vTaskPriorityDisinheritAfterTimeout+0x10c>
 4005e70:	e0bffc17 	ldw	r2,-16(fp)
 4005e74:	10800b17 	ldw	r2,44(r2)
 4005e78:	d0a6b315 	stw	r2,-25908(gp)
 4005e7c:	e0bffc17 	ldw	r2,-16(fp)
 4005e80:	10800b17 	ldw	r2,44(r2)
 4005e84:	01400504 	movi	r5,20
 4005e88:	1009883a 	mov	r4,r2
 4005e8c:	40073b40 	call	40073b4 <__mulsi3>
 4005e90:	1007883a 	mov	r3,r2
 4005e94:	00812074 	movhi	r2,1153
 4005e98:	1885883a 	add	r2,r3,r2
 4005e9c:	10bfb217 	ldw	r2,-312(r2)
 4005ea0:	e0bff915 	stw	r2,-28(fp)
 4005ea4:	e0bffc17 	ldw	r2,-16(fp)
 4005ea8:	e0fff917 	ldw	r3,-28(fp)
 4005eac:	10c00215 	stw	r3,8(r2)
 4005eb0:	e0bff917 	ldw	r2,-28(fp)
 4005eb4:	10c00217 	ldw	r3,8(r2)
 4005eb8:	e0bffc17 	ldw	r2,-16(fp)
 4005ebc:	10c00315 	stw	r3,12(r2)
 4005ec0:	e0bff917 	ldw	r2,-28(fp)
 4005ec4:	10800217 	ldw	r2,8(r2)
 4005ec8:	e0fffc17 	ldw	r3,-16(fp)
 4005ecc:	18c00104 	addi	r3,r3,4
 4005ed0:	10c00115 	stw	r3,4(r2)
 4005ed4:	e0bffc17 	ldw	r2,-16(fp)
 4005ed8:	10c00104 	addi	r3,r2,4
 4005edc:	e0bff917 	ldw	r2,-28(fp)
 4005ee0:	10c00215 	stw	r3,8(r2)
 4005ee4:	e0bffc17 	ldw	r2,-16(fp)
 4005ee8:	10800b17 	ldw	r2,44(r2)
 4005eec:	01400504 	movi	r5,20
 4005ef0:	1009883a 	mov	r4,r2
 4005ef4:	40073b40 	call	40073b4 <__mulsi3>
 4005ef8:	1007883a 	mov	r3,r2
 4005efc:	00812074 	movhi	r2,1153
 4005f00:	10bfb104 	addi	r2,r2,-316
 4005f04:	1887883a 	add	r3,r3,r2
 4005f08:	e0bffc17 	ldw	r2,-16(fp)
 4005f0c:	10c00515 	stw	r3,20(r2)
 4005f10:	e0bffc17 	ldw	r2,-16(fp)
 4005f14:	14400b17 	ldw	r17,44(r2)
 4005f18:	01400504 	movi	r5,20
 4005f1c:	8809883a 	mov	r4,r17
 4005f20:	40073b40 	call	40073b4 <__mulsi3>
 4005f24:	1007883a 	mov	r3,r2
 4005f28:	00812074 	movhi	r2,1153
 4005f2c:	1885883a 	add	r2,r3,r2
 4005f30:	10bfb117 	ldw	r2,-316(r2)
 4005f34:	14000044 	addi	r16,r2,1
 4005f38:	01400504 	movi	r5,20
 4005f3c:	8809883a 	mov	r4,r17
 4005f40:	40073b40 	call	40073b4 <__mulsi3>
 4005f44:	1007883a 	mov	r3,r2
 4005f48:	00812074 	movhi	r2,1153
 4005f4c:	1885883a 	add	r2,r3,r2
 4005f50:	143fb115 	stw	r16,-316(r2)
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
 4005f54:	0001883a 	nop
 4005f58:	e6fffe04 	addi	sp,fp,-8
 4005f5c:	dfc00317 	ldw	ra,12(sp)
 4005f60:	df000217 	ldw	fp,8(sp)
 4005f64:	dc400117 	ldw	r17,4(sp)
 4005f68:	dc000017 	ldw	r16,0(sp)
 4005f6c:	dec00404 	addi	sp,sp,16
 4005f70:	f800283a 	ret

04005f74 <vTaskEnterCritical>:
/*-----------------------------------------------------------*/

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

    void vTaskEnterCritical( void )
    {
 4005f74:	defffe04 	addi	sp,sp,-8
 4005f78:	df000115 	stw	fp,4(sp)
 4005f7c:	df000104 	addi	fp,sp,4
  NIOS2_READ_STATUS (context);
 4005f80:	0005303a 	rdctl	r2,status
 4005f84:	e0bfff15 	stw	r2,-4(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 4005f88:	e0ffff17 	ldw	r3,-4(fp)
 4005f8c:	00bfff84 	movi	r2,-2
 4005f90:	1884703a 	and	r2,r3,r2
 4005f94:	1001703a 	wrctl	status,r2
        portDISABLE_INTERRUPTS();

        if( xSchedulerRunning != pdFALSE )
 4005f98:	d0a6b417 	ldw	r2,-25904(gp)
 4005f9c:	10000526 	beq	r2,zero,4005fb4 <vTaskEnterCritical+0x40>
        {
            ( pxCurrentTCB->uxCriticalNesting )++;
 4005fa0:	d0a6ad17 	ldw	r2,-25932(gp)
 4005fa4:	10c00f17 	ldw	r3,60(r2)
 4005fa8:	18c00044 	addi	r3,r3,1
 4005fac:	10c00f15 	stw	r3,60(r2)
             * function so  assert() if it is being called from an interrupt
             * context.  Only API functions that end in "FromISR" can be used in an
             * interrupt.  Only assert if the critical nesting count is 1 to
             * protect against recursive calls if the assert function also uses a
             * critical section. */
            if( pxCurrentTCB->uxCriticalNesting == 1 )
 4005fb0:	d0a6ad17 	ldw	r2,-25932(gp)
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
 4005fb4:	0001883a 	nop
 4005fb8:	e037883a 	mov	sp,fp
 4005fbc:	df000017 	ldw	fp,0(sp)
 4005fc0:	dec00104 	addi	sp,sp,4
 4005fc4:	f800283a 	ret

04005fc8 <vTaskExitCritical>:
/*-----------------------------------------------------------*/

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

    void vTaskExitCritical( void )
    {
 4005fc8:	defffe04 	addi	sp,sp,-8
 4005fcc:	df000115 	stw	fp,4(sp)
 4005fd0:	df000104 	addi	fp,sp,4
        if( xSchedulerRunning != pdFALSE )
 4005fd4:	d0a6b417 	ldw	r2,-25904(gp)
 4005fd8:	10000f26 	beq	r2,zero,4006018 <vTaskExitCritical+0x50>
        {
            if( pxCurrentTCB->uxCriticalNesting > 0U )
 4005fdc:	d0a6ad17 	ldw	r2,-25932(gp)
 4005fe0:	10800f17 	ldw	r2,60(r2)
 4005fe4:	10000c26 	beq	r2,zero,4006018 <vTaskExitCritical+0x50>
            {
                ( pxCurrentTCB->uxCriticalNesting )--;
 4005fe8:	d0a6ad17 	ldw	r2,-25932(gp)
 4005fec:	10c00f17 	ldw	r3,60(r2)
 4005ff0:	18ffffc4 	addi	r3,r3,-1
 4005ff4:	10c00f15 	stw	r3,60(r2)

                if( pxCurrentTCB->uxCriticalNesting == 0U )
 4005ff8:	d0a6ad17 	ldw	r2,-25932(gp)
 4005ffc:	10800f17 	ldw	r2,60(r2)
 4006000:	1000051e 	bne	r2,zero,4006018 <vTaskExitCritical+0x50>
 4006004:	00800044 	movi	r2,1
 4006008:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 400600c:	e0bfff17 	ldw	r2,-4(fp)
 4006010:	1001703a 	wrctl	status,r2
#endif
}
 4006014:	0001883a 	nop
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
 4006018:	0001883a 	nop
 400601c:	e037883a 	mov	sp,fp
 4006020:	df000017 	ldw	fp,0(sp)
 4006024:	dec00104 	addi	sp,sp,4
 4006028:	f800283a 	ret

0400602c <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
 400602c:	defffe04 	addi	sp,sp,-8
 4006030:	df000115 	stw	fp,4(sp)
 4006034:	df000104 	addi	fp,sp,4
    TickType_t uxReturn;

    uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
 4006038:	d0a6ad17 	ldw	r2,-25932(gp)
 400603c:	10800617 	ldw	r2,24(r2)
 4006040:	e0bfff15 	stw	r2,-4(fp)

    /* Reset the event list item to its normal value - so it can be used with
     * queues and semaphores. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 4006044:	d0a6ad17 	ldw	r2,-25932(gp)
 4006048:	10c00b17 	ldw	r3,44(r2)
 400604c:	d0a6ad17 	ldw	r2,-25932(gp)
 4006050:	01000144 	movi	r4,5
 4006054:	20c7c83a 	sub	r3,r4,r3
 4006058:	10c00615 	stw	r3,24(r2)

    return uxReturn;
 400605c:	e0bfff17 	ldw	r2,-4(fp)
}
 4006060:	e037883a 	mov	sp,fp
 4006064:	df000017 	ldw	fp,0(sp)
 4006068:	dec00104 	addi	sp,sp,4
 400606c:	f800283a 	ret

04006070 <pvTaskIncrementMutexHeldCount>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    TaskHandle_t pvTaskIncrementMutexHeldCount( void )
    {
 4006070:	deffff04 	addi	sp,sp,-4
 4006074:	df000015 	stw	fp,0(sp)
 4006078:	d839883a 	mov	fp,sp
        /* If xSemaphoreCreateMutex() is called before any tasks have been created
         * then pxCurrentTCB will be NULL. */
        if( pxCurrentTCB != NULL )
 400607c:	d0a6ad17 	ldw	r2,-25932(gp)
 4006080:	10000426 	beq	r2,zero,4006094 <pvTaskIncrementMutexHeldCount+0x24>
        {
            ( pxCurrentTCB->uxMutexesHeld )++;
 4006084:	d0a6ad17 	ldw	r2,-25932(gp)
 4006088:	10c01117 	ldw	r3,68(r2)
 400608c:	18c00044 	addi	r3,r3,1
 4006090:	10c01115 	stw	r3,68(r2)
        }

        return pxCurrentTCB;
 4006094:	d0a6ad17 	ldw	r2,-25932(gp)
    }
 4006098:	e037883a 	mov	sp,fp
 400609c:	df000017 	ldw	fp,0(sp)
 40060a0:	dec00104 	addi	sp,sp,4
 40060a4:	f800283a 	ret

040060a8 <ulTaskGenericNotifyTake>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyTake( UBaseType_t uxIndexToWait,
                                      BaseType_t xClearCountOnExit,
                                      TickType_t xTicksToWait )
    {
 40060a8:	defffa04 	addi	sp,sp,-24
 40060ac:	dfc00515 	stw	ra,20(sp)
 40060b0:	df000415 	stw	fp,16(sp)
 40060b4:	df000404 	addi	fp,sp,16
 40060b8:	e13ffe15 	stw	r4,-8(fp)
 40060bc:	e17ffd15 	stw	r5,-12(fp)
 40060c0:	e1bffc15 	stw	r6,-16(fp)
        uint32_t ulReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
 40060c4:	4005f740 	call	4005f74 <vTaskEnterCritical>
        {
            /* Only block if the notification count is not already non-zero. */
            if( pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] == 0UL )
 40060c8:	d0e6ad17 	ldw	r3,-25932(gp)
 40060cc:	e0bffe17 	ldw	r2,-8(fp)
 40060d0:	10800484 	addi	r2,r2,18
 40060d4:	100490ba 	slli	r2,r2,2
 40060d8:	1885883a 	add	r2,r3,r2
 40060dc:	10800017 	ldw	r2,0(r2)
 40060e0:	10000b1e 	bne	r2,zero,4006110 <ulTaskGenericNotifyTake+0x68>
            {
                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
 40060e4:	d0e6ad17 	ldw	r3,-25932(gp)
 40060e8:	e0bffe17 	ldw	r2,-8(fp)
 40060ec:	1885883a 	add	r2,r3,r2
 40060f0:	00c00044 	movi	r3,1
 40060f4:	10c01305 	stb	r3,76(r2)

                if( xTicksToWait > ( TickType_t ) 0 )
 40060f8:	e0bffc17 	ldw	r2,-16(fp)
 40060fc:	10000426 	beq	r2,zero,4006110 <ulTaskGenericNotifyTake+0x68>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 4006100:	01400044 	movi	r5,1
 4006104:	e13ffc17 	ldw	r4,-16(fp)
 4006108:	4006e340 	call	4006e34 <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
 400610c:	003b683a 	trap	0
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
 4006110:	4005fc80 	call	4005fc8 <vTaskExitCritical>

        taskENTER_CRITICAL();
 4006114:	4005f740 	call	4005f74 <vTaskEnterCritical>
        {
            traceTASK_NOTIFY_TAKE( uxIndexToWait );
            ulReturn = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
 4006118:	d0e6ad17 	ldw	r3,-25932(gp)
 400611c:	e0bffe17 	ldw	r2,-8(fp)
 4006120:	10800484 	addi	r2,r2,18
 4006124:	100490ba 	slli	r2,r2,2
 4006128:	1885883a 	add	r2,r3,r2
 400612c:	10800017 	ldw	r2,0(r2)
 4006130:	e0bfff15 	stw	r2,-4(fp)

            if( ulReturn != 0UL )
 4006134:	e0bfff17 	ldw	r2,-4(fp)
 4006138:	10001126 	beq	r2,zero,4006180 <ulTaskGenericNotifyTake+0xd8>
            {
                if( xClearCountOnExit != pdFALSE )
 400613c:	e0bffd17 	ldw	r2,-12(fp)
 4006140:	10000726 	beq	r2,zero,4006160 <ulTaskGenericNotifyTake+0xb8>
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = 0UL;
 4006144:	d0e6ad17 	ldw	r3,-25932(gp)
 4006148:	e0bffe17 	ldw	r2,-8(fp)
 400614c:	10800484 	addi	r2,r2,18
 4006150:	100490ba 	slli	r2,r2,2
 4006154:	1885883a 	add	r2,r3,r2
 4006158:	10000015 	stw	zero,0(r2)
 400615c:	00000806 	br	4006180 <ulTaskGenericNotifyTake+0xd8>
                }
                else
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = ulReturn - ( uint32_t ) 1;
 4006160:	d126ad17 	ldw	r4,-25932(gp)
 4006164:	e0bfff17 	ldw	r2,-4(fp)
 4006168:	10ffffc4 	addi	r3,r2,-1
 400616c:	e0bffe17 	ldw	r2,-8(fp)
 4006170:	10800484 	addi	r2,r2,18
 4006174:	100490ba 	slli	r2,r2,2
 4006178:	2085883a 	add	r2,r4,r2
 400617c:	10c00015 	stw	r3,0(r2)
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
 4006180:	d0e6ad17 	ldw	r3,-25932(gp)
 4006184:	e0bffe17 	ldw	r2,-8(fp)
 4006188:	1885883a 	add	r2,r3,r2
 400618c:	10001305 	stb	zero,76(r2)
        }
        taskEXIT_CRITICAL();
 4006190:	4005fc80 	call	4005fc8 <vTaskExitCritical>

        return ulReturn;
 4006194:	e0bfff17 	ldw	r2,-4(fp)
    }
 4006198:	e037883a 	mov	sp,fp
 400619c:	dfc00117 	ldw	ra,4(sp)
 40061a0:	df000017 	ldw	fp,0(sp)
 40061a4:	dec00204 	addi	sp,sp,8
 40061a8:	f800283a 	ret

040061ac <xTaskGenericNotifyWait>:
    BaseType_t xTaskGenericNotifyWait( UBaseType_t uxIndexToWait,
                                       uint32_t ulBitsToClearOnEntry,
                                       uint32_t ulBitsToClearOnExit,
                                       uint32_t * pulNotificationValue,
                                       TickType_t xTicksToWait )
    {
 40061ac:	defff904 	addi	sp,sp,-28
 40061b0:	dfc00615 	stw	ra,24(sp)
 40061b4:	df000515 	stw	fp,20(sp)
 40061b8:	df000504 	addi	fp,sp,20
 40061bc:	e13ffe15 	stw	r4,-8(fp)
 40061c0:	e17ffd15 	stw	r5,-12(fp)
 40061c4:	e1bffc15 	stw	r6,-16(fp)
 40061c8:	e1fffb15 	stw	r7,-20(fp)
        BaseType_t xReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
 40061cc:	4005f740 	call	4005f74 <vTaskEnterCritical>
        {
            /* Only block if a notification is not already pending. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
 40061d0:	d0e6ad17 	ldw	r3,-25932(gp)
 40061d4:	e0bffe17 	ldw	r2,-8(fp)
 40061d8:	1885883a 	add	r2,r3,r2
 40061dc:	10801303 	ldbu	r2,76(r2)
 40061e0:	10803fcc 	andi	r2,r2,255
 40061e4:	108000a0 	cmpeqi	r2,r2,2
 40061e8:	1000191e 	bne	r2,zero,4006250 <xTaskGenericNotifyWait+0xa4>
            {
                /* Clear bits in the task's notification value as bits may get
                 * set  by the notifying task or interrupt.  This can be used to
                 * clear the value to zero. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnEntry;
 40061ec:	d0a6ad17 	ldw	r2,-25932(gp)
 40061f0:	e0fffe17 	ldw	r3,-8(fp)
 40061f4:	18c00484 	addi	r3,r3,18
 40061f8:	180690ba 	slli	r3,r3,2
 40061fc:	10c7883a 	add	r3,r2,r3
 4006200:	19000017 	ldw	r4,0(r3)
 4006204:	e0fffd17 	ldw	r3,-12(fp)
 4006208:	00c6303a 	nor	r3,zero,r3
 400620c:	20c6703a 	and	r3,r4,r3
 4006210:	e13ffe17 	ldw	r4,-8(fp)
 4006214:	21000484 	addi	r4,r4,18
 4006218:	200890ba 	slli	r4,r4,2
 400621c:	1105883a 	add	r2,r2,r4
 4006220:	10c00015 	stw	r3,0(r2)

                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
 4006224:	d0e6ad17 	ldw	r3,-25932(gp)
 4006228:	e0bffe17 	ldw	r2,-8(fp)
 400622c:	1885883a 	add	r2,r3,r2
 4006230:	00c00044 	movi	r3,1
 4006234:	10c01305 	stb	r3,76(r2)

                if( xTicksToWait > ( TickType_t ) 0 )
 4006238:	e0800217 	ldw	r2,8(fp)
 400623c:	10000426 	beq	r2,zero,4006250 <xTaskGenericNotifyWait+0xa4>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 4006240:	01400044 	movi	r5,1
 4006244:	e1000217 	ldw	r4,8(fp)
 4006248:	4006e340 	call	4006e34 <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
 400624c:	003b683a 	trap	0
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
 4006250:	4005fc80 	call	4005fc8 <vTaskExitCritical>

        taskENTER_CRITICAL();
 4006254:	4005f740 	call	4005f74 <vTaskEnterCritical>
        {
            traceTASK_NOTIFY_WAIT( uxIndexToWait );

            if( pulNotificationValue != NULL )
 4006258:	e0bffb17 	ldw	r2,-20(fp)
 400625c:	10000826 	beq	r2,zero,4006280 <xTaskGenericNotifyWait+0xd4>
            {
                /* Output the current notification value, which may or may not
                 * have changed. */
                *pulNotificationValue = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
 4006260:	d0e6ad17 	ldw	r3,-25932(gp)
 4006264:	e0bffe17 	ldw	r2,-8(fp)
 4006268:	10800484 	addi	r2,r2,18
 400626c:	100490ba 	slli	r2,r2,2
 4006270:	1885883a 	add	r2,r3,r2
 4006274:	10c00017 	ldw	r3,0(r2)
 4006278:	e0bffb17 	ldw	r2,-20(fp)
 400627c:	10c00015 	stw	r3,0(r2)

            /* If ucNotifyValue is set then either the task never entered the
             * blocked state (because a notification was already pending) or the
             * task unblocked because of a notification.  Otherwise the task
             * unblocked because of a timeout. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
 4006280:	d0e6ad17 	ldw	r3,-25932(gp)
 4006284:	e0bffe17 	ldw	r2,-8(fp)
 4006288:	1885883a 	add	r2,r3,r2
 400628c:	10801303 	ldbu	r2,76(r2)
 4006290:	10803fcc 	andi	r2,r2,255
 4006294:	108000a0 	cmpeqi	r2,r2,2
 4006298:	1000021e 	bne	r2,zero,40062a4 <xTaskGenericNotifyWait+0xf8>
            {
                /* A notification was not received. */
                xReturn = pdFALSE;
 400629c:	e03fff15 	stw	zero,-4(fp)
 40062a0:	00001006 	br	40062e4 <xTaskGenericNotifyWait+0x138>
            }
            else
            {
                /* A notification was already pending or a notification was
                 * received while the task was waiting. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnExit;
 40062a4:	d0a6ad17 	ldw	r2,-25932(gp)
 40062a8:	e0fffe17 	ldw	r3,-8(fp)
 40062ac:	18c00484 	addi	r3,r3,18
 40062b0:	180690ba 	slli	r3,r3,2
 40062b4:	10c7883a 	add	r3,r2,r3
 40062b8:	19000017 	ldw	r4,0(r3)
 40062bc:	e0fffc17 	ldw	r3,-16(fp)
 40062c0:	00c6303a 	nor	r3,zero,r3
 40062c4:	20c6703a 	and	r3,r4,r3
 40062c8:	e13ffe17 	ldw	r4,-8(fp)
 40062cc:	21000484 	addi	r4,r4,18
 40062d0:	200890ba 	slli	r4,r4,2
 40062d4:	1105883a 	add	r2,r2,r4
 40062d8:	10c00015 	stw	r3,0(r2)
                xReturn = pdTRUE;
 40062dc:	00800044 	movi	r2,1
 40062e0:	e0bfff15 	stw	r2,-4(fp)
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
 40062e4:	d0e6ad17 	ldw	r3,-25932(gp)
 40062e8:	e0bffe17 	ldw	r2,-8(fp)
 40062ec:	1885883a 	add	r2,r3,r2
 40062f0:	10001305 	stb	zero,76(r2)
        }
        taskEXIT_CRITICAL();
 40062f4:	4005fc80 	call	4005fc8 <vTaskExitCritical>

        return xReturn;
 40062f8:	e0bfff17 	ldw	r2,-4(fp)
    }
 40062fc:	e037883a 	mov	sp,fp
 4006300:	dfc00117 	ldw	ra,4(sp)
 4006304:	df000017 	ldw	fp,0(sp)
 4006308:	dec00204 	addi	sp,sp,8
 400630c:	f800283a 	ret

04006310 <xTaskGenericNotify>:
    BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify,
                                   UBaseType_t uxIndexToNotify,
                                   uint32_t ulValue,
                                   eNotifyAction eAction,
                                   uint32_t * pulPreviousNotificationValue )
    {
 4006310:	defff304 	addi	sp,sp,-52
 4006314:	dfc00c15 	stw	ra,48(sp)
 4006318:	df000b15 	stw	fp,44(sp)
 400631c:	dc400a15 	stw	r17,40(sp)
 4006320:	dc000915 	stw	r16,36(sp)
 4006324:	df000b04 	addi	fp,sp,44
 4006328:	e13ff815 	stw	r4,-32(fp)
 400632c:	e17ff715 	stw	r5,-36(fp)
 4006330:	e1bff615 	stw	r6,-40(fp)
 4006334:	e1fff515 	stw	r7,-44(fp)
        TCB_t * pxTCB;
        BaseType_t xReturn = pdPASS;
 4006338:	00800044 	movi	r2,1
 400633c:	e0bffd15 	stw	r2,-12(fp)
        uint8_t ucOriginalNotifyState;

        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
        configASSERT( xTaskToNotify );
        pxTCB = xTaskToNotify;
 4006340:	e0bff817 	ldw	r2,-32(fp)
 4006344:	e0bffc15 	stw	r2,-16(fp)

        taskENTER_CRITICAL();
 4006348:	4005f740 	call	4005f74 <vTaskEnterCritical>
        {
            if( pulPreviousNotificationValue != NULL )
 400634c:	e0800217 	ldw	r2,8(fp)
 4006350:	10000826 	beq	r2,zero,4006374 <xTaskGenericNotify+0x64>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
 4006354:	e0fffc17 	ldw	r3,-16(fp)
 4006358:	e0bff717 	ldw	r2,-36(fp)
 400635c:	10800484 	addi	r2,r2,18
 4006360:	100490ba 	slli	r2,r2,2
 4006364:	1885883a 	add	r2,r3,r2
 4006368:	10c00017 	ldw	r3,0(r2)
 400636c:	e0800217 	ldw	r2,8(fp)
 4006370:	10c00015 	stw	r3,0(r2)
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
 4006374:	e0fffc17 	ldw	r3,-16(fp)
 4006378:	e0bff717 	ldw	r2,-36(fp)
 400637c:	1885883a 	add	r2,r3,r2
 4006380:	10801303 	ldbu	r2,76(r2)
 4006384:	e0bffbc5 	stb	r2,-17(fp)

            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
 4006388:	e0fffc17 	ldw	r3,-16(fp)
 400638c:	e0bff717 	ldw	r2,-36(fp)
 4006390:	1885883a 	add	r2,r3,r2
 4006394:	00c00084 	movi	r3,2
 4006398:	10c01305 	stb	r3,76(r2)

            switch( eAction )
 400639c:	e0bff517 	ldw	r2,-44(fp)
 40063a0:	10800168 	cmpgeui	r2,r2,5
 40063a4:	10003d1e 	bne	r2,zero,400649c <xTaskGenericNotify+0x18c>
 40063a8:	e0bff517 	ldw	r2,-44(fp)
 40063ac:	100690ba 	slli	r3,r2,2
 40063b0:	00810034 	movhi	r2,1024
 40063b4:	1885883a 	add	r2,r3,r2
 40063b8:	1098f017 	ldw	r2,25536(r2)
 40063bc:	1000683a 	jmp	r2
 40063c0:	040064a4 	muli	r16,zero,402
 40063c4:	040063d4 	movui	r16,399
 40063c8:	04006410 	cmplti	r16,zero,400
 40063cc:	04006448 	cmpgei	r16,zero,401
 40063d0:	04006468 	cmpgeui	r16,zero,401
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
 40063d4:	e0fffc17 	ldw	r3,-16(fp)
 40063d8:	e0bff717 	ldw	r2,-36(fp)
 40063dc:	10800484 	addi	r2,r2,18
 40063e0:	100490ba 	slli	r2,r2,2
 40063e4:	1885883a 	add	r2,r3,r2
 40063e8:	10c00017 	ldw	r3,0(r2)
 40063ec:	e0bff617 	ldw	r2,-40(fp)
 40063f0:	1886b03a 	or	r3,r3,r2
 40063f4:	e13ffc17 	ldw	r4,-16(fp)
 40063f8:	e0bff717 	ldw	r2,-36(fp)
 40063fc:	10800484 	addi	r2,r2,18
 4006400:	100490ba 	slli	r2,r2,2
 4006404:	2085883a 	add	r2,r4,r2
 4006408:	10c00015 	stw	r3,0(r2)
                    break;
 400640c:	00002606 	br	40064a8 <xTaskGenericNotify+0x198>

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
 4006410:	e0fffc17 	ldw	r3,-16(fp)
 4006414:	e0bff717 	ldw	r2,-36(fp)
 4006418:	10800484 	addi	r2,r2,18
 400641c:	100490ba 	slli	r2,r2,2
 4006420:	1885883a 	add	r2,r3,r2
 4006424:	10800017 	ldw	r2,0(r2)
 4006428:	10c00044 	addi	r3,r2,1
 400642c:	e13ffc17 	ldw	r4,-16(fp)
 4006430:	e0bff717 	ldw	r2,-36(fp)
 4006434:	10800484 	addi	r2,r2,18
 4006438:	100490ba 	slli	r2,r2,2
 400643c:	2085883a 	add	r2,r4,r2
 4006440:	10c00015 	stw	r3,0(r2)
                    break;
 4006444:	00001806 	br	40064a8 <xTaskGenericNotify+0x198>

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
 4006448:	e0fffc17 	ldw	r3,-16(fp)
 400644c:	e0bff717 	ldw	r2,-36(fp)
 4006450:	10800484 	addi	r2,r2,18
 4006454:	100490ba 	slli	r2,r2,2
 4006458:	1885883a 	add	r2,r3,r2
 400645c:	e0fff617 	ldw	r3,-40(fp)
 4006460:	10c00015 	stw	r3,0(r2)
                    break;
 4006464:	00001006 	br	40064a8 <xTaskGenericNotify+0x198>

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
 4006468:	e0bffbc3 	ldbu	r2,-17(fp)
 400646c:	108000a0 	cmpeqi	r2,r2,2
 4006470:	1000081e 	bne	r2,zero,4006494 <xTaskGenericNotify+0x184>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
 4006474:	e0fffc17 	ldw	r3,-16(fp)
 4006478:	e0bff717 	ldw	r2,-36(fp)
 400647c:	10800484 	addi	r2,r2,18
 4006480:	100490ba 	slli	r2,r2,2
 4006484:	1885883a 	add	r2,r3,r2
 4006488:	e0fff617 	ldw	r3,-40(fp)
 400648c:	10c00015 	stw	r3,0(r2)
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
                    }

                    break;
 4006490:	00000506 	br	40064a8 <xTaskGenericNotify+0x198>
                        xReturn = pdFAIL;
 4006494:	e03ffd15 	stw	zero,-12(fp)
                    break;
 4006498:	00000306 	br	40064a8 <xTaskGenericNotify+0x198>
                    /* Should not get here if all enums are handled.
                     * Artificially force an assert by testing a value the
                     * compiler can't assume is const. */
                    configASSERT( xTickCount == ( TickType_t ) 0 );

                    break;
 400649c:	0001883a 	nop
 40064a0:	00000106 	br	40064a8 <xTaskGenericNotify+0x198>
                    break;
 40064a4:	0001883a 	nop

            traceTASK_NOTIFY( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 40064a8:	e0bffbc3 	ldbu	r2,-17(fp)
 40064ac:	10800058 	cmpnei	r2,r2,1
 40064b0:	1000601e 	bne	r2,zero,4006634 <xTaskGenericNotify+0x324>
            {
                listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 40064b4:	e0bffc17 	ldw	r2,-16(fp)
 40064b8:	10800517 	ldw	r2,20(r2)
 40064bc:	e0bffa15 	stw	r2,-24(fp)
 40064c0:	e0bffc17 	ldw	r2,-16(fp)
 40064c4:	10800217 	ldw	r2,8(r2)
 40064c8:	e0fffc17 	ldw	r3,-16(fp)
 40064cc:	18c00317 	ldw	r3,12(r3)
 40064d0:	10c00215 	stw	r3,8(r2)
 40064d4:	e0bffc17 	ldw	r2,-16(fp)
 40064d8:	10800317 	ldw	r2,12(r2)
 40064dc:	e0fffc17 	ldw	r3,-16(fp)
 40064e0:	18c00217 	ldw	r3,8(r3)
 40064e4:	10c00115 	stw	r3,4(r2)
 40064e8:	e0bffa17 	ldw	r2,-24(fp)
 40064ec:	10c00117 	ldw	r3,4(r2)
 40064f0:	e0bffc17 	ldw	r2,-16(fp)
 40064f4:	10800104 	addi	r2,r2,4
 40064f8:	1880041e 	bne	r3,r2,400650c <xTaskGenericNotify+0x1fc>
 40064fc:	e0bffc17 	ldw	r2,-16(fp)
 4006500:	10c00317 	ldw	r3,12(r2)
 4006504:	e0bffa17 	ldw	r2,-24(fp)
 4006508:	10c00115 	stw	r3,4(r2)
 400650c:	e0bffc17 	ldw	r2,-16(fp)
 4006510:	10000515 	stw	zero,20(r2)
 4006514:	e0bffa17 	ldw	r2,-24(fp)
 4006518:	10800017 	ldw	r2,0(r2)
 400651c:	10ffffc4 	addi	r3,r2,-1
 4006520:	e0bffa17 	ldw	r2,-24(fp)
 4006524:	10c00015 	stw	r3,0(r2)
                prvAddTaskToReadyList( pxTCB );
 4006528:	e0bffc17 	ldw	r2,-16(fp)
 400652c:	10800b17 	ldw	r2,44(r2)
 4006530:	d0e6b317 	ldw	r3,-25908(gp)
 4006534:	1880032e 	bgeu	r3,r2,4006544 <xTaskGenericNotify+0x234>
 4006538:	e0bffc17 	ldw	r2,-16(fp)
 400653c:	10800b17 	ldw	r2,44(r2)
 4006540:	d0a6b315 	stw	r2,-25908(gp)
 4006544:	e0bffc17 	ldw	r2,-16(fp)
 4006548:	10800b17 	ldw	r2,44(r2)
 400654c:	01400504 	movi	r5,20
 4006550:	1009883a 	mov	r4,r2
 4006554:	40073b40 	call	40073b4 <__mulsi3>
 4006558:	1007883a 	mov	r3,r2
 400655c:	00812074 	movhi	r2,1153
 4006560:	1885883a 	add	r2,r3,r2
 4006564:	10bfb217 	ldw	r2,-312(r2)
 4006568:	e0bff915 	stw	r2,-28(fp)
 400656c:	e0bffc17 	ldw	r2,-16(fp)
 4006570:	e0fff917 	ldw	r3,-28(fp)
 4006574:	10c00215 	stw	r3,8(r2)
 4006578:	e0bff917 	ldw	r2,-28(fp)
 400657c:	10c00217 	ldw	r3,8(r2)
 4006580:	e0bffc17 	ldw	r2,-16(fp)
 4006584:	10c00315 	stw	r3,12(r2)
 4006588:	e0bff917 	ldw	r2,-28(fp)
 400658c:	10800217 	ldw	r2,8(r2)
 4006590:	e0fffc17 	ldw	r3,-16(fp)
 4006594:	18c00104 	addi	r3,r3,4
 4006598:	10c00115 	stw	r3,4(r2)
 400659c:	e0bffc17 	ldw	r2,-16(fp)
 40065a0:	10c00104 	addi	r3,r2,4
 40065a4:	e0bff917 	ldw	r2,-28(fp)
 40065a8:	10c00215 	stw	r3,8(r2)
 40065ac:	e0bffc17 	ldw	r2,-16(fp)
 40065b0:	10800b17 	ldw	r2,44(r2)
 40065b4:	01400504 	movi	r5,20
 40065b8:	1009883a 	mov	r4,r2
 40065bc:	40073b40 	call	40073b4 <__mulsi3>
 40065c0:	1007883a 	mov	r3,r2
 40065c4:	00812074 	movhi	r2,1153
 40065c8:	10bfb104 	addi	r2,r2,-316
 40065cc:	1887883a 	add	r3,r3,r2
 40065d0:	e0bffc17 	ldw	r2,-16(fp)
 40065d4:	10c00515 	stw	r3,20(r2)
 40065d8:	e0bffc17 	ldw	r2,-16(fp)
 40065dc:	14400b17 	ldw	r17,44(r2)
 40065e0:	01400504 	movi	r5,20
 40065e4:	8809883a 	mov	r4,r17
 40065e8:	40073b40 	call	40073b4 <__mulsi3>
 40065ec:	1007883a 	mov	r3,r2
 40065f0:	00812074 	movhi	r2,1153
 40065f4:	1885883a 	add	r2,r3,r2
 40065f8:	10bfb117 	ldw	r2,-316(r2)
 40065fc:	14000044 	addi	r16,r2,1
 4006600:	01400504 	movi	r5,20
 4006604:	8809883a 	mov	r4,r17
 4006608:	40073b40 	call	40073b4 <__mulsi3>
 400660c:	1007883a 	mov	r3,r2
 4006610:	00812074 	movhi	r2,1153
 4006614:	1885883a 	add	r2,r3,r2
 4006618:	143fb115 	stw	r16,-316(r2)
                     * earliest possible time. */
                    prvResetNextTaskUnblockTime();
                }
                #endif

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 400661c:	e0bffc17 	ldw	r2,-16(fp)
 4006620:	10800b17 	ldw	r2,44(r2)
 4006624:	d0e6ad17 	ldw	r3,-25932(gp)
 4006628:	18c00b17 	ldw	r3,44(r3)
 400662c:	1880012e 	bgeu	r3,r2,4006634 <xTaskGenericNotify+0x324>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    taskYIELD_IF_USING_PREEMPTION();
 4006630:	003b683a 	trap	0
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
 4006634:	4005fc80 	call	4005fc8 <vTaskExitCritical>

        return xReturn;
 4006638:	e0bffd17 	ldw	r2,-12(fp)
    }
 400663c:	e6fffe04 	addi	sp,fp,-8
 4006640:	dfc00317 	ldw	ra,12(sp)
 4006644:	df000217 	ldw	fp,8(sp)
 4006648:	dc400117 	ldw	r17,4(sp)
 400664c:	dc000017 	ldw	r16,0(sp)
 4006650:	dec00404 	addi	sp,sp,16
 4006654:	f800283a 	ret

04006658 <xTaskGenericNotifyFromISR>:
                                          UBaseType_t uxIndexToNotify,
                                          uint32_t ulValue,
                                          eNotifyAction eAction,
                                          uint32_t * pulPreviousNotificationValue,
                                          BaseType_t * pxHigherPriorityTaskWoken )
    {
 4006658:	defff104 	addi	sp,sp,-60
 400665c:	dfc00e15 	stw	ra,56(sp)
 4006660:	df000d15 	stw	fp,52(sp)
 4006664:	dc400c15 	stw	r17,48(sp)
 4006668:	dc000b15 	stw	r16,44(sp)
 400666c:	df000d04 	addi	fp,sp,52
 4006670:	e13ff615 	stw	r4,-40(fp)
 4006674:	e17ff515 	stw	r5,-44(fp)
 4006678:	e1bff415 	stw	r6,-48(fp)
 400667c:	e1fff315 	stw	r7,-52(fp)
        TCB_t * pxTCB;
        uint8_t ucOriginalNotifyState;
        BaseType_t xReturn = pdPASS;
 4006680:	00800044 	movi	r2,1
 4006684:	e0bffd15 	stw	r2,-12(fp)
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;
 4006688:	e0bff617 	ldw	r2,-40(fp)
 400668c:	e0bffc15 	stw	r2,-16(fp)

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 4006690:	e03ffb15 	stw	zero,-20(fp)
        {
            if( pulPreviousNotificationValue != NULL )
 4006694:	e0800217 	ldw	r2,8(fp)
 4006698:	10000826 	beq	r2,zero,40066bc <xTaskGenericNotifyFromISR+0x64>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
 400669c:	e0fffc17 	ldw	r3,-16(fp)
 40066a0:	e0bff517 	ldw	r2,-44(fp)
 40066a4:	10800484 	addi	r2,r2,18
 40066a8:	100490ba 	slli	r2,r2,2
 40066ac:	1885883a 	add	r2,r3,r2
 40066b0:	10c00017 	ldw	r3,0(r2)
 40066b4:	e0800217 	ldw	r2,8(fp)
 40066b8:	10c00015 	stw	r3,0(r2)
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
 40066bc:	e0fffc17 	ldw	r3,-16(fp)
 40066c0:	e0bff517 	ldw	r2,-44(fp)
 40066c4:	1885883a 	add	r2,r3,r2
 40066c8:	10801303 	ldbu	r2,76(r2)
 40066cc:	e0bffac5 	stb	r2,-21(fp)
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
 40066d0:	e0fffc17 	ldw	r3,-16(fp)
 40066d4:	e0bff517 	ldw	r2,-44(fp)
 40066d8:	1885883a 	add	r2,r3,r2
 40066dc:	00c00084 	movi	r3,2
 40066e0:	10c01305 	stb	r3,76(r2)

            switch( eAction )
 40066e4:	e0bff317 	ldw	r2,-52(fp)
 40066e8:	10800168 	cmpgeui	r2,r2,5
 40066ec:	10003d1e 	bne	r2,zero,40067e4 <xTaskGenericNotifyFromISR+0x18c>
 40066f0:	e0bff317 	ldw	r2,-52(fp)
 40066f4:	100690ba 	slli	r3,r2,2
 40066f8:	00810034 	movhi	r2,1024
 40066fc:	1885883a 	add	r2,r3,r2
 4006700:	1099c217 	ldw	r2,26376(r2)
 4006704:	1000683a 	jmp	r2
 4006708:	040067ec 	andhi	r16,zero,415
 400670c:	0400671c 	xori	r16,zero,412
 4006710:	04006758 	cmpnei	r16,zero,413
 4006714:	04006790 	cmplti	r16,zero,414
 4006718:	040067b0 	cmpltui	r16,zero,414
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
 400671c:	e0fffc17 	ldw	r3,-16(fp)
 4006720:	e0bff517 	ldw	r2,-44(fp)
 4006724:	10800484 	addi	r2,r2,18
 4006728:	100490ba 	slli	r2,r2,2
 400672c:	1885883a 	add	r2,r3,r2
 4006730:	10c00017 	ldw	r3,0(r2)
 4006734:	e0bff417 	ldw	r2,-48(fp)
 4006738:	1886b03a 	or	r3,r3,r2
 400673c:	e13ffc17 	ldw	r4,-16(fp)
 4006740:	e0bff517 	ldw	r2,-44(fp)
 4006744:	10800484 	addi	r2,r2,18
 4006748:	100490ba 	slli	r2,r2,2
 400674c:	2085883a 	add	r2,r4,r2
 4006750:	10c00015 	stw	r3,0(r2)
                    break;
 4006754:	00002606 	br	40067f0 <xTaskGenericNotifyFromISR+0x198>

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
 4006758:	e0fffc17 	ldw	r3,-16(fp)
 400675c:	e0bff517 	ldw	r2,-44(fp)
 4006760:	10800484 	addi	r2,r2,18
 4006764:	100490ba 	slli	r2,r2,2
 4006768:	1885883a 	add	r2,r3,r2
 400676c:	10800017 	ldw	r2,0(r2)
 4006770:	10c00044 	addi	r3,r2,1
 4006774:	e13ffc17 	ldw	r4,-16(fp)
 4006778:	e0bff517 	ldw	r2,-44(fp)
 400677c:	10800484 	addi	r2,r2,18
 4006780:	100490ba 	slli	r2,r2,2
 4006784:	2085883a 	add	r2,r4,r2
 4006788:	10c00015 	stw	r3,0(r2)
                    break;
 400678c:	00001806 	br	40067f0 <xTaskGenericNotifyFromISR+0x198>

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
 4006790:	e0fffc17 	ldw	r3,-16(fp)
 4006794:	e0bff517 	ldw	r2,-44(fp)
 4006798:	10800484 	addi	r2,r2,18
 400679c:	100490ba 	slli	r2,r2,2
 40067a0:	1885883a 	add	r2,r3,r2
 40067a4:	e0fff417 	ldw	r3,-48(fp)
 40067a8:	10c00015 	stw	r3,0(r2)
                    break;
 40067ac:	00001006 	br	40067f0 <xTaskGenericNotifyFromISR+0x198>

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
 40067b0:	e0bffac3 	ldbu	r2,-21(fp)
 40067b4:	108000a0 	cmpeqi	r2,r2,2
 40067b8:	1000081e 	bne	r2,zero,40067dc <xTaskGenericNotifyFromISR+0x184>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
 40067bc:	e0fffc17 	ldw	r3,-16(fp)
 40067c0:	e0bff517 	ldw	r2,-44(fp)
 40067c4:	10800484 	addi	r2,r2,18
 40067c8:	100490ba 	slli	r2,r2,2
 40067cc:	1885883a 	add	r2,r3,r2
 40067d0:	e0fff417 	ldw	r3,-48(fp)
 40067d4:	10c00015 	stw	r3,0(r2)
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
                    }

                    break;
 40067d8:	00000506 	br	40067f0 <xTaskGenericNotifyFromISR+0x198>
                        xReturn = pdFAIL;
 40067dc:	e03ffd15 	stw	zero,-12(fp)
                    break;
 40067e0:	00000306 	br	40067f0 <xTaskGenericNotifyFromISR+0x198>

                    /* Should not get here if all enums are handled.
                     * Artificially force an assert by testing a value the
                     * compiler can't assume is const. */
                    configASSERT( xTickCount == ( TickType_t ) 0 );
                    break;
 40067e4:	0001883a 	nop
 40067e8:	00000106 	br	40067f0 <xTaskGenericNotifyFromISR+0x198>
                    break;
 40067ec:	0001883a 	nop

            traceTASK_NOTIFY_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 40067f0:	e0bffac3 	ldbu	r2,-21(fp)
 40067f4:	10800058 	cmpnei	r2,r2,1
 40067f8:	1000851e 	bne	r2,zero,4006a10 <xTaskGenericNotifyFromISR+0x3b8>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 40067fc:	d0a6bb17 	ldw	r2,-25876(gp)
 4006800:	10005b1e 	bne	r2,zero,4006970 <xTaskGenericNotifyFromISR+0x318>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 4006804:	e0bffc17 	ldw	r2,-16(fp)
 4006808:	10800517 	ldw	r2,20(r2)
 400680c:	e0bff815 	stw	r2,-32(fp)
 4006810:	e0bffc17 	ldw	r2,-16(fp)
 4006814:	10800217 	ldw	r2,8(r2)
 4006818:	e0fffc17 	ldw	r3,-16(fp)
 400681c:	18c00317 	ldw	r3,12(r3)
 4006820:	10c00215 	stw	r3,8(r2)
 4006824:	e0bffc17 	ldw	r2,-16(fp)
 4006828:	10800317 	ldw	r2,12(r2)
 400682c:	e0fffc17 	ldw	r3,-16(fp)
 4006830:	18c00217 	ldw	r3,8(r3)
 4006834:	10c00115 	stw	r3,4(r2)
 4006838:	e0bff817 	ldw	r2,-32(fp)
 400683c:	10c00117 	ldw	r3,4(r2)
 4006840:	e0bffc17 	ldw	r2,-16(fp)
 4006844:	10800104 	addi	r2,r2,4
 4006848:	1880041e 	bne	r3,r2,400685c <xTaskGenericNotifyFromISR+0x204>
 400684c:	e0bffc17 	ldw	r2,-16(fp)
 4006850:	10c00317 	ldw	r3,12(r2)
 4006854:	e0bff817 	ldw	r2,-32(fp)
 4006858:	10c00115 	stw	r3,4(r2)
 400685c:	e0bffc17 	ldw	r2,-16(fp)
 4006860:	10000515 	stw	zero,20(r2)
 4006864:	e0bff817 	ldw	r2,-32(fp)
 4006868:	10800017 	ldw	r2,0(r2)
 400686c:	10ffffc4 	addi	r3,r2,-1
 4006870:	e0bff817 	ldw	r2,-32(fp)
 4006874:	10c00015 	stw	r3,0(r2)
                    prvAddTaskToReadyList( pxTCB );
 4006878:	e0bffc17 	ldw	r2,-16(fp)
 400687c:	10800b17 	ldw	r2,44(r2)
 4006880:	d0e6b317 	ldw	r3,-25908(gp)
 4006884:	1880032e 	bgeu	r3,r2,4006894 <xTaskGenericNotifyFromISR+0x23c>
 4006888:	e0bffc17 	ldw	r2,-16(fp)
 400688c:	10800b17 	ldw	r2,44(r2)
 4006890:	d0a6b315 	stw	r2,-25908(gp)
 4006894:	e0bffc17 	ldw	r2,-16(fp)
 4006898:	10800b17 	ldw	r2,44(r2)
 400689c:	01400504 	movi	r5,20
 40068a0:	1009883a 	mov	r4,r2
 40068a4:	40073b40 	call	40073b4 <__mulsi3>
 40068a8:	1007883a 	mov	r3,r2
 40068ac:	00812074 	movhi	r2,1153
 40068b0:	1885883a 	add	r2,r3,r2
 40068b4:	10bfb217 	ldw	r2,-312(r2)
 40068b8:	e0bff715 	stw	r2,-36(fp)
 40068bc:	e0bffc17 	ldw	r2,-16(fp)
 40068c0:	e0fff717 	ldw	r3,-36(fp)
 40068c4:	10c00215 	stw	r3,8(r2)
 40068c8:	e0bff717 	ldw	r2,-36(fp)
 40068cc:	10c00217 	ldw	r3,8(r2)
 40068d0:	e0bffc17 	ldw	r2,-16(fp)
 40068d4:	10c00315 	stw	r3,12(r2)
 40068d8:	e0bff717 	ldw	r2,-36(fp)
 40068dc:	10800217 	ldw	r2,8(r2)
 40068e0:	e0fffc17 	ldw	r3,-16(fp)
 40068e4:	18c00104 	addi	r3,r3,4
 40068e8:	10c00115 	stw	r3,4(r2)
 40068ec:	e0bffc17 	ldw	r2,-16(fp)
 40068f0:	10c00104 	addi	r3,r2,4
 40068f4:	e0bff717 	ldw	r2,-36(fp)
 40068f8:	10c00215 	stw	r3,8(r2)
 40068fc:	e0bffc17 	ldw	r2,-16(fp)
 4006900:	10800b17 	ldw	r2,44(r2)
 4006904:	01400504 	movi	r5,20
 4006908:	1009883a 	mov	r4,r2
 400690c:	40073b40 	call	40073b4 <__mulsi3>
 4006910:	1007883a 	mov	r3,r2
 4006914:	00812074 	movhi	r2,1153
 4006918:	10bfb104 	addi	r2,r2,-316
 400691c:	1887883a 	add	r3,r3,r2
 4006920:	e0bffc17 	ldw	r2,-16(fp)
 4006924:	10c00515 	stw	r3,20(r2)
 4006928:	e0bffc17 	ldw	r2,-16(fp)
 400692c:	14400b17 	ldw	r17,44(r2)
 4006930:	01400504 	movi	r5,20
 4006934:	8809883a 	mov	r4,r17
 4006938:	40073b40 	call	40073b4 <__mulsi3>
 400693c:	1007883a 	mov	r3,r2
 4006940:	00812074 	movhi	r2,1153
 4006944:	1885883a 	add	r2,r3,r2
 4006948:	10bfb117 	ldw	r2,-316(r2)
 400694c:	14000044 	addi	r16,r2,1
 4006950:	01400504 	movi	r5,20
 4006954:	8809883a 	mov	r4,r17
 4006958:	40073b40 	call	40073b4 <__mulsi3>
 400695c:	1007883a 	mov	r3,r2
 4006960:	00812074 	movhi	r2,1153
 4006964:	1885883a 	add	r2,r3,r2
 4006968:	143fb115 	stw	r16,-316(r2)
 400696c:	00001c06 	br	40069e0 <xTaskGenericNotifyFromISR+0x388>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 4006970:	00812074 	movhi	r2,1153
 4006974:	10bfd517 	ldw	r2,-172(r2)
 4006978:	e0bff915 	stw	r2,-28(fp)
 400697c:	e0bffc17 	ldw	r2,-16(fp)
 4006980:	e0fff917 	ldw	r3,-28(fp)
 4006984:	10c00715 	stw	r3,28(r2)
 4006988:	e0bff917 	ldw	r2,-28(fp)
 400698c:	10c00217 	ldw	r3,8(r2)
 4006990:	e0bffc17 	ldw	r2,-16(fp)
 4006994:	10c00815 	stw	r3,32(r2)
 4006998:	e0bff917 	ldw	r2,-28(fp)
 400699c:	10800217 	ldw	r2,8(r2)
 40069a0:	e0fffc17 	ldw	r3,-16(fp)
 40069a4:	18c00604 	addi	r3,r3,24
 40069a8:	10c00115 	stw	r3,4(r2)
 40069ac:	e0bffc17 	ldw	r2,-16(fp)
 40069b0:	10c00604 	addi	r3,r2,24
 40069b4:	e0bff917 	ldw	r2,-28(fp)
 40069b8:	10c00215 	stw	r3,8(r2)
 40069bc:	e0fffc17 	ldw	r3,-16(fp)
 40069c0:	00812074 	movhi	r2,1153
 40069c4:	10bfd404 	addi	r2,r2,-176
 40069c8:	18800a15 	stw	r2,40(r3)
 40069cc:	00812074 	movhi	r2,1153
 40069d0:	10bfd417 	ldw	r2,-176(r2)
 40069d4:	10c00044 	addi	r3,r2,1
 40069d8:	00812074 	movhi	r2,1153
 40069dc:	10ffd415 	stw	r3,-176(r2)
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 40069e0:	e0bffc17 	ldw	r2,-16(fp)
 40069e4:	10800b17 	ldw	r2,44(r2)
 40069e8:	d0e6ad17 	ldw	r3,-25932(gp)
 40069ec:	18c00b17 	ldw	r3,44(r3)
 40069f0:	1880072e 	bgeu	r3,r2,4006a10 <xTaskGenericNotifyFromISR+0x3b8>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
 40069f4:	e0800317 	ldw	r2,12(fp)
 40069f8:	10000326 	beq	r2,zero,4006a08 <xTaskGenericNotifyFromISR+0x3b0>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
 40069fc:	e0800317 	ldw	r2,12(fp)
 4006a00:	00c00044 	movi	r3,1
 4006a04:	10c00015 	stw	r3,0(r2)
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter to an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
 4006a08:	00800044 	movi	r2,1
 4006a0c:	d0a6b615 	stw	r2,-25896(gp)
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

        return xReturn;
 4006a10:	e0bffd17 	ldw	r2,-12(fp)
    }
 4006a14:	e6fffe04 	addi	sp,fp,-8
 4006a18:	dfc00317 	ldw	ra,12(sp)
 4006a1c:	df000217 	ldw	fp,8(sp)
 4006a20:	dc400117 	ldw	r17,4(sp)
 4006a24:	dc000017 	ldw	r16,0(sp)
 4006a28:	dec00404 	addi	sp,sp,16
 4006a2c:	f800283a 	ret

04006a30 <vTaskGenericNotifyGiveFromISR>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    void vTaskGenericNotifyGiveFromISR( TaskHandle_t xTaskToNotify,
                                        UBaseType_t uxIndexToNotify,
                                        BaseType_t * pxHigherPriorityTaskWoken )
    {
 4006a30:	defff304 	addi	sp,sp,-52
 4006a34:	dfc00c15 	stw	ra,48(sp)
 4006a38:	df000b15 	stw	fp,44(sp)
 4006a3c:	dc400a15 	stw	r17,40(sp)
 4006a40:	dc000915 	stw	r16,36(sp)
 4006a44:	df000b04 	addi	fp,sp,44
 4006a48:	e13ff715 	stw	r4,-36(fp)
 4006a4c:	e17ff615 	stw	r5,-40(fp)
 4006a50:	e1bff515 	stw	r6,-44(fp)
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;
 4006a54:	e0bff717 	ldw	r2,-36(fp)
 4006a58:	e0bffd15 	stw	r2,-12(fp)

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 4006a5c:	e03ffc15 	stw	zero,-16(fp)
        {
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
 4006a60:	e0fffd17 	ldw	r3,-12(fp)
 4006a64:	e0bff617 	ldw	r2,-40(fp)
 4006a68:	1885883a 	add	r2,r3,r2
 4006a6c:	10801303 	ldbu	r2,76(r2)
 4006a70:	e0bffbc5 	stb	r2,-17(fp)
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
 4006a74:	e0fffd17 	ldw	r3,-12(fp)
 4006a78:	e0bff617 	ldw	r2,-40(fp)
 4006a7c:	1885883a 	add	r2,r3,r2
 4006a80:	00c00084 	movi	r3,2
 4006a84:	10c01305 	stb	r3,76(r2)

            /* 'Giving' is equivalent to incrementing a count in a counting
             * semaphore. */
            ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
 4006a88:	e0fffd17 	ldw	r3,-12(fp)
 4006a8c:	e0bff617 	ldw	r2,-40(fp)
 4006a90:	10800484 	addi	r2,r2,18
 4006a94:	100490ba 	slli	r2,r2,2
 4006a98:	1885883a 	add	r2,r3,r2
 4006a9c:	10800017 	ldw	r2,0(r2)
 4006aa0:	10c00044 	addi	r3,r2,1
 4006aa4:	e13ffd17 	ldw	r4,-12(fp)
 4006aa8:	e0bff617 	ldw	r2,-40(fp)
 4006aac:	10800484 	addi	r2,r2,18
 4006ab0:	100490ba 	slli	r2,r2,2
 4006ab4:	2085883a 	add	r2,r4,r2
 4006ab8:	10c00015 	stw	r3,0(r2)

            traceTASK_NOTIFY_GIVE_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 4006abc:	e0bffbc3 	ldbu	r2,-17(fp)
 4006ac0:	10800058 	cmpnei	r2,r2,1
 4006ac4:	1000851e 	bne	r2,zero,4006cdc <vTaskGenericNotifyGiveFromISR+0x2ac>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 4006ac8:	d0a6bb17 	ldw	r2,-25876(gp)
 4006acc:	10005b1e 	bne	r2,zero,4006c3c <vTaskGenericNotifyGiveFromISR+0x20c>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 4006ad0:	e0bffd17 	ldw	r2,-12(fp)
 4006ad4:	10800517 	ldw	r2,20(r2)
 4006ad8:	e0bff915 	stw	r2,-28(fp)
 4006adc:	e0bffd17 	ldw	r2,-12(fp)
 4006ae0:	10800217 	ldw	r2,8(r2)
 4006ae4:	e0fffd17 	ldw	r3,-12(fp)
 4006ae8:	18c00317 	ldw	r3,12(r3)
 4006aec:	10c00215 	stw	r3,8(r2)
 4006af0:	e0bffd17 	ldw	r2,-12(fp)
 4006af4:	10800317 	ldw	r2,12(r2)
 4006af8:	e0fffd17 	ldw	r3,-12(fp)
 4006afc:	18c00217 	ldw	r3,8(r3)
 4006b00:	10c00115 	stw	r3,4(r2)
 4006b04:	e0bff917 	ldw	r2,-28(fp)
 4006b08:	10c00117 	ldw	r3,4(r2)
 4006b0c:	e0bffd17 	ldw	r2,-12(fp)
 4006b10:	10800104 	addi	r2,r2,4
 4006b14:	1880041e 	bne	r3,r2,4006b28 <vTaskGenericNotifyGiveFromISR+0xf8>
 4006b18:	e0bffd17 	ldw	r2,-12(fp)
 4006b1c:	10c00317 	ldw	r3,12(r2)
 4006b20:	e0bff917 	ldw	r2,-28(fp)
 4006b24:	10c00115 	stw	r3,4(r2)
 4006b28:	e0bffd17 	ldw	r2,-12(fp)
 4006b2c:	10000515 	stw	zero,20(r2)
 4006b30:	e0bff917 	ldw	r2,-28(fp)
 4006b34:	10800017 	ldw	r2,0(r2)
 4006b38:	10ffffc4 	addi	r3,r2,-1
 4006b3c:	e0bff917 	ldw	r2,-28(fp)
 4006b40:	10c00015 	stw	r3,0(r2)
                    prvAddTaskToReadyList( pxTCB );
 4006b44:	e0bffd17 	ldw	r2,-12(fp)
 4006b48:	10800b17 	ldw	r2,44(r2)
 4006b4c:	d0e6b317 	ldw	r3,-25908(gp)
 4006b50:	1880032e 	bgeu	r3,r2,4006b60 <vTaskGenericNotifyGiveFromISR+0x130>
 4006b54:	e0bffd17 	ldw	r2,-12(fp)
 4006b58:	10800b17 	ldw	r2,44(r2)
 4006b5c:	d0a6b315 	stw	r2,-25908(gp)
 4006b60:	e0bffd17 	ldw	r2,-12(fp)
 4006b64:	10800b17 	ldw	r2,44(r2)
 4006b68:	01400504 	movi	r5,20
 4006b6c:	1009883a 	mov	r4,r2
 4006b70:	40073b40 	call	40073b4 <__mulsi3>
 4006b74:	1007883a 	mov	r3,r2
 4006b78:	00812074 	movhi	r2,1153
 4006b7c:	1885883a 	add	r2,r3,r2
 4006b80:	10bfb217 	ldw	r2,-312(r2)
 4006b84:	e0bff815 	stw	r2,-32(fp)
 4006b88:	e0bffd17 	ldw	r2,-12(fp)
 4006b8c:	e0fff817 	ldw	r3,-32(fp)
 4006b90:	10c00215 	stw	r3,8(r2)
 4006b94:	e0bff817 	ldw	r2,-32(fp)
 4006b98:	10c00217 	ldw	r3,8(r2)
 4006b9c:	e0bffd17 	ldw	r2,-12(fp)
 4006ba0:	10c00315 	stw	r3,12(r2)
 4006ba4:	e0bff817 	ldw	r2,-32(fp)
 4006ba8:	10800217 	ldw	r2,8(r2)
 4006bac:	e0fffd17 	ldw	r3,-12(fp)
 4006bb0:	18c00104 	addi	r3,r3,4
 4006bb4:	10c00115 	stw	r3,4(r2)
 4006bb8:	e0bffd17 	ldw	r2,-12(fp)
 4006bbc:	10c00104 	addi	r3,r2,4
 4006bc0:	e0bff817 	ldw	r2,-32(fp)
 4006bc4:	10c00215 	stw	r3,8(r2)
 4006bc8:	e0bffd17 	ldw	r2,-12(fp)
 4006bcc:	10800b17 	ldw	r2,44(r2)
 4006bd0:	01400504 	movi	r5,20
 4006bd4:	1009883a 	mov	r4,r2
 4006bd8:	40073b40 	call	40073b4 <__mulsi3>
 4006bdc:	1007883a 	mov	r3,r2
 4006be0:	00812074 	movhi	r2,1153
 4006be4:	10bfb104 	addi	r2,r2,-316
 4006be8:	1887883a 	add	r3,r3,r2
 4006bec:	e0bffd17 	ldw	r2,-12(fp)
 4006bf0:	10c00515 	stw	r3,20(r2)
 4006bf4:	e0bffd17 	ldw	r2,-12(fp)
 4006bf8:	14400b17 	ldw	r17,44(r2)
 4006bfc:	01400504 	movi	r5,20
 4006c00:	8809883a 	mov	r4,r17
 4006c04:	40073b40 	call	40073b4 <__mulsi3>
 4006c08:	1007883a 	mov	r3,r2
 4006c0c:	00812074 	movhi	r2,1153
 4006c10:	1885883a 	add	r2,r3,r2
 4006c14:	10bfb117 	ldw	r2,-316(r2)
 4006c18:	14000044 	addi	r16,r2,1
 4006c1c:	01400504 	movi	r5,20
 4006c20:	8809883a 	mov	r4,r17
 4006c24:	40073b40 	call	40073b4 <__mulsi3>
 4006c28:	1007883a 	mov	r3,r2
 4006c2c:	00812074 	movhi	r2,1153
 4006c30:	1885883a 	add	r2,r3,r2
 4006c34:	143fb115 	stw	r16,-316(r2)
 4006c38:	00001c06 	br	4006cac <vTaskGenericNotifyGiveFromISR+0x27c>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 4006c3c:	00812074 	movhi	r2,1153
 4006c40:	10bfd517 	ldw	r2,-172(r2)
 4006c44:	e0bffa15 	stw	r2,-24(fp)
 4006c48:	e0bffd17 	ldw	r2,-12(fp)
 4006c4c:	e0fffa17 	ldw	r3,-24(fp)
 4006c50:	10c00715 	stw	r3,28(r2)
 4006c54:	e0bffa17 	ldw	r2,-24(fp)
 4006c58:	10c00217 	ldw	r3,8(r2)
 4006c5c:	e0bffd17 	ldw	r2,-12(fp)
 4006c60:	10c00815 	stw	r3,32(r2)
 4006c64:	e0bffa17 	ldw	r2,-24(fp)
 4006c68:	10800217 	ldw	r2,8(r2)
 4006c6c:	e0fffd17 	ldw	r3,-12(fp)
 4006c70:	18c00604 	addi	r3,r3,24
 4006c74:	10c00115 	stw	r3,4(r2)
 4006c78:	e0bffd17 	ldw	r2,-12(fp)
 4006c7c:	10c00604 	addi	r3,r2,24
 4006c80:	e0bffa17 	ldw	r2,-24(fp)
 4006c84:	10c00215 	stw	r3,8(r2)
 4006c88:	e0fffd17 	ldw	r3,-12(fp)
 4006c8c:	00812074 	movhi	r2,1153
 4006c90:	10bfd404 	addi	r2,r2,-176
 4006c94:	18800a15 	stw	r2,40(r3)
 4006c98:	00812074 	movhi	r2,1153
 4006c9c:	10bfd417 	ldw	r2,-176(r2)
 4006ca0:	10c00044 	addi	r3,r2,1
 4006ca4:	00812074 	movhi	r2,1153
 4006ca8:	10ffd415 	stw	r3,-176(r2)
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 4006cac:	e0bffd17 	ldw	r2,-12(fp)
 4006cb0:	10800b17 	ldw	r2,44(r2)
 4006cb4:	d0e6ad17 	ldw	r3,-25932(gp)
 4006cb8:	18c00b17 	ldw	r3,44(r3)
 4006cbc:	1880072e 	bgeu	r3,r2,4006cdc <vTaskGenericNotifyGiveFromISR+0x2ac>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
 4006cc0:	e0bff517 	ldw	r2,-44(fp)
 4006cc4:	10000326 	beq	r2,zero,4006cd4 <vTaskGenericNotifyGiveFromISR+0x2a4>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
 4006cc8:	e0bff517 	ldw	r2,-44(fp)
 4006ccc:	00c00044 	movi	r3,1
 4006cd0:	10c00015 	stw	r3,0(r2)
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter in an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
 4006cd4:	00800044 	movi	r2,1
 4006cd8:	d0a6b615 	stw	r2,-25896(gp)
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
    }
 4006cdc:	0001883a 	nop
 4006ce0:	e6fffe04 	addi	sp,fp,-8
 4006ce4:	dfc00317 	ldw	ra,12(sp)
 4006ce8:	df000217 	ldw	fp,8(sp)
 4006cec:	dc400117 	ldw	r17,4(sp)
 4006cf0:	dc000017 	ldw	r16,0(sp)
 4006cf4:	dec00404 	addi	sp,sp,16
 4006cf8:	f800283a 	ret

04006cfc <xTaskGenericNotifyStateClear>:

#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    BaseType_t xTaskGenericNotifyStateClear( TaskHandle_t xTask,
                                             UBaseType_t uxIndexToClear )
    {
 4006cfc:	defffa04 	addi	sp,sp,-24
 4006d00:	dfc00515 	stw	ra,20(sp)
 4006d04:	df000415 	stw	fp,16(sp)
 4006d08:	df000404 	addi	fp,sp,16
 4006d0c:	e13ffd15 	stw	r4,-12(fp)
 4006d10:	e17ffc15 	stw	r5,-16(fp)

        configASSERT( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
 4006d14:	e0bffd17 	ldw	r2,-12(fp)
 4006d18:	1000021e 	bne	r2,zero,4006d24 <xTaskGenericNotifyStateClear+0x28>
 4006d1c:	d0a6ad17 	ldw	r2,-25932(gp)
 4006d20:	00000106 	br	4006d28 <xTaskGenericNotifyStateClear+0x2c>
 4006d24:	e0bffd17 	ldw	r2,-12(fp)
 4006d28:	e0bffe15 	stw	r2,-8(fp)

        taskENTER_CRITICAL();
 4006d2c:	4005f740 	call	4005f74 <vTaskEnterCritical>
        {
            if( pxTCB->ucNotifyState[ uxIndexToClear ] == taskNOTIFICATION_RECEIVED )
 4006d30:	e0fffe17 	ldw	r3,-8(fp)
 4006d34:	e0bffc17 	ldw	r2,-16(fp)
 4006d38:	1885883a 	add	r2,r3,r2
 4006d3c:	10801303 	ldbu	r2,76(r2)
 4006d40:	10803fcc 	andi	r2,r2,255
 4006d44:	10800098 	cmpnei	r2,r2,2
 4006d48:	1000071e 	bne	r2,zero,4006d68 <xTaskGenericNotifyStateClear+0x6c>
            {
                pxTCB->ucNotifyState[ uxIndexToClear ] = taskNOT_WAITING_NOTIFICATION;
 4006d4c:	e0fffe17 	ldw	r3,-8(fp)
 4006d50:	e0bffc17 	ldw	r2,-16(fp)
 4006d54:	1885883a 	add	r2,r3,r2
 4006d58:	10001305 	stb	zero,76(r2)
                xReturn = pdPASS;
 4006d5c:	00800044 	movi	r2,1
 4006d60:	e0bfff15 	stw	r2,-4(fp)
 4006d64:	00000106 	br	4006d6c <xTaskGenericNotifyStateClear+0x70>
            }
            else
            {
                xReturn = pdFAIL;
 4006d68:	e03fff15 	stw	zero,-4(fp)
            }
        }
        taskEXIT_CRITICAL();
 4006d6c:	4005fc80 	call	4005fc8 <vTaskExitCritical>

        return xReturn;
 4006d70:	e0bfff17 	ldw	r2,-4(fp)
    }
 4006d74:	e037883a 	mov	sp,fp
 4006d78:	dfc00117 	ldw	ra,4(sp)
 4006d7c:	df000017 	ldw	fp,0(sp)
 4006d80:	dec00204 	addi	sp,sp,8
 4006d84:	f800283a 	ret

04006d88 <ulTaskGenericNotifyValueClear>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyValueClear( TaskHandle_t xTask,
                                            UBaseType_t uxIndexToClear,
                                            uint32_t ulBitsToClear )
    {
 4006d88:	defff904 	addi	sp,sp,-28
 4006d8c:	dfc00615 	stw	ra,24(sp)
 4006d90:	df000515 	stw	fp,20(sp)
 4006d94:	df000504 	addi	fp,sp,20
 4006d98:	e13ffd15 	stw	r4,-12(fp)
 4006d9c:	e17ffc15 	stw	r5,-16(fp)
 4006da0:	e1bffb15 	stw	r6,-20(fp)
        TCB_t * pxTCB;
        uint32_t ulReturn;

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
 4006da4:	e0bffd17 	ldw	r2,-12(fp)
 4006da8:	1000021e 	bne	r2,zero,4006db4 <ulTaskGenericNotifyValueClear+0x2c>
 4006dac:	d0a6ad17 	ldw	r2,-25932(gp)
 4006db0:	00000106 	br	4006db8 <ulTaskGenericNotifyValueClear+0x30>
 4006db4:	e0bffd17 	ldw	r2,-12(fp)
 4006db8:	e0bfff15 	stw	r2,-4(fp)

        taskENTER_CRITICAL();
 4006dbc:	4005f740 	call	4005f74 <vTaskEnterCritical>
        {
            /* Return the notification as it was before the bits were cleared,
             * then clear the bit mask. */
            ulReturn = pxTCB->ulNotifiedValue[ uxIndexToClear ];
 4006dc0:	e0ffff17 	ldw	r3,-4(fp)
 4006dc4:	e0bffc17 	ldw	r2,-16(fp)
 4006dc8:	10800484 	addi	r2,r2,18
 4006dcc:	100490ba 	slli	r2,r2,2
 4006dd0:	1885883a 	add	r2,r3,r2
 4006dd4:	10800017 	ldw	r2,0(r2)
 4006dd8:	e0bffe15 	stw	r2,-8(fp)
            pxTCB->ulNotifiedValue[ uxIndexToClear ] &= ~ulBitsToClear;
 4006ddc:	e0ffff17 	ldw	r3,-4(fp)
 4006de0:	e0bffc17 	ldw	r2,-16(fp)
 4006de4:	10800484 	addi	r2,r2,18
 4006de8:	100490ba 	slli	r2,r2,2
 4006dec:	1885883a 	add	r2,r3,r2
 4006df0:	10c00017 	ldw	r3,0(r2)
 4006df4:	e0bffb17 	ldw	r2,-20(fp)
 4006df8:	0084303a 	nor	r2,zero,r2
 4006dfc:	1886703a 	and	r3,r3,r2
 4006e00:	e13fff17 	ldw	r4,-4(fp)
 4006e04:	e0bffc17 	ldw	r2,-16(fp)
 4006e08:	10800484 	addi	r2,r2,18
 4006e0c:	100490ba 	slli	r2,r2,2
 4006e10:	2085883a 	add	r2,r4,r2
 4006e14:	10c00015 	stw	r3,0(r2)
        }
        taskEXIT_CRITICAL();
 4006e18:	4005fc80 	call	4005fc8 <vTaskExitCritical>

        return ulReturn;
 4006e1c:	e0bffe17 	ldw	r2,-8(fp)
    }
 4006e20:	e037883a 	mov	sp,fp
 4006e24:	dfc00117 	ldw	ra,4(sp)
 4006e28:	df000017 	ldw	fp,0(sp)
 4006e2c:	dec00204 	addi	sp,sp,8
 4006e30:	f800283a 	ret

04006e34 <prvAddCurrentTaskToDelayedList>:
#endif /* if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) ) */
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
                                            const BaseType_t xCanBlockIndefinitely )
{
 4006e34:	defff904 	addi	sp,sp,-28
 4006e38:	dfc00615 	stw	ra,24(sp)
 4006e3c:	df000515 	stw	fp,20(sp)
 4006e40:	df000504 	addi	fp,sp,20
 4006e44:	e13ffc15 	stw	r4,-16(fp)
 4006e48:	e17ffb15 	stw	r5,-20(fp)
    TickType_t xTimeToWake;
    const TickType_t xConstTickCount = xTickCount;
 4006e4c:	d0a6b217 	ldw	r2,-25912(gp)
 4006e50:	e0bfff15 	stw	r2,-4(fp)
    }
    #endif

    /* Remove the task from the ready list before adding it to the blocked list
     * as the same list item is used for both lists. */
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 4006e54:	d0a6ad17 	ldw	r2,-25932(gp)
 4006e58:	10800104 	addi	r2,r2,4
 4006e5c:	1009883a 	mov	r4,r2
 4006e60:	4000c980 	call	4000c98 <uxListRemove>
        mtCOVERAGE_TEST_MARKER();
    }

    #if ( INCLUDE_vTaskSuspend == 1 )
    {
        if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 4006e64:	e0bffc17 	ldw	r2,-16(fp)
 4006e68:	10bfffd8 	cmpnei	r2,r2,-1
 4006e6c:	1000201e 	bne	r2,zero,4006ef0 <prvAddCurrentTaskToDelayedList+0xbc>
 4006e70:	e0bffb17 	ldw	r2,-20(fp)
 4006e74:	10001e26 	beq	r2,zero,4006ef0 <prvAddCurrentTaskToDelayedList+0xbc>
        {
            /* Add the task to the suspended task list instead of a delayed task
             * list to ensure it is not woken by a timing event.  It will block
             * indefinitely. */
            listINSERT_END( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 4006e78:	00812074 	movhi	r2,1153
 4006e7c:	10bfdf17 	ldw	r2,-132(r2)
 4006e80:	e0bffe15 	stw	r2,-8(fp)
 4006e84:	d0a6ad17 	ldw	r2,-25932(gp)
 4006e88:	e0fffe17 	ldw	r3,-8(fp)
 4006e8c:	10c00215 	stw	r3,8(r2)
 4006e90:	d0a6ad17 	ldw	r2,-25932(gp)
 4006e94:	e0fffe17 	ldw	r3,-8(fp)
 4006e98:	18c00217 	ldw	r3,8(r3)
 4006e9c:	10c00315 	stw	r3,12(r2)
 4006ea0:	d0e6ad17 	ldw	r3,-25932(gp)
 4006ea4:	e0bffe17 	ldw	r2,-8(fp)
 4006ea8:	10800217 	ldw	r2,8(r2)
 4006eac:	18c00104 	addi	r3,r3,4
 4006eb0:	10c00115 	stw	r3,4(r2)
 4006eb4:	d0a6ad17 	ldw	r2,-25932(gp)
 4006eb8:	10c00104 	addi	r3,r2,4
 4006ebc:	e0bffe17 	ldw	r2,-8(fp)
 4006ec0:	10c00215 	stw	r3,8(r2)
 4006ec4:	d0e6ad17 	ldw	r3,-25932(gp)
 4006ec8:	00812074 	movhi	r2,1153
 4006ecc:	10bfde04 	addi	r2,r2,-136
 4006ed0:	18800515 	stw	r2,20(r3)
 4006ed4:	00812074 	movhi	r2,1153
 4006ed8:	10bfde17 	ldw	r2,-136(r2)
 4006edc:	10c00044 	addi	r3,r2,1
 4006ee0:	00812074 	movhi	r2,1153
 4006ee4:	10ffde15 	stw	r3,-136(r2)
 4006ee8:	0001883a 	nop

        /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
        ( void ) xCanBlockIndefinitely;
    }
    #endif /* INCLUDE_vTaskSuspend */
}
 4006eec:	00001c06 	br	4006f60 <prvAddCurrentTaskToDelayedList+0x12c>
            xTimeToWake = xConstTickCount + xTicksToWait;
 4006ef0:	e0ffff17 	ldw	r3,-4(fp)
 4006ef4:	e0bffc17 	ldw	r2,-16(fp)
 4006ef8:	1885883a 	add	r2,r3,r2
 4006efc:	e0bffd15 	stw	r2,-12(fp)
            listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 4006f00:	d0a6ad17 	ldw	r2,-25932(gp)
 4006f04:	e0fffd17 	ldw	r3,-12(fp)
 4006f08:	10c00115 	stw	r3,4(r2)
            if( xTimeToWake < xConstTickCount )
 4006f0c:	e0fffd17 	ldw	r3,-12(fp)
 4006f10:	e0bfff17 	ldw	r2,-4(fp)
 4006f14:	1880072e 	bgeu	r3,r2,4006f34 <prvAddCurrentTaskToDelayedList+0x100>
                vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 4006f18:	d0e6af17 	ldw	r3,-25924(gp)
 4006f1c:	d0a6ad17 	ldw	r2,-25932(gp)
 4006f20:	10800104 	addi	r2,r2,4
 4006f24:	100b883a 	mov	r5,r2
 4006f28:	1809883a 	mov	r4,r3
 4006f2c:	4000bc00 	call	4000bc0 <vListInsert>
}
 4006f30:	00000b06 	br	4006f60 <prvAddCurrentTaskToDelayedList+0x12c>
                vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 4006f34:	d0e6ae17 	ldw	r3,-25928(gp)
 4006f38:	d0a6ad17 	ldw	r2,-25932(gp)
 4006f3c:	10800104 	addi	r2,r2,4
 4006f40:	100b883a 	mov	r5,r2
 4006f44:	1809883a 	mov	r4,r3
 4006f48:	4000bc00 	call	4000bc0 <vListInsert>
                if( xTimeToWake < xNextTaskUnblockTime )
 4006f4c:	d0a6b917 	ldw	r2,-25884(gp)
 4006f50:	e0fffd17 	ldw	r3,-12(fp)
 4006f54:	1880022e 	bgeu	r3,r2,4006f60 <prvAddCurrentTaskToDelayedList+0x12c>
                    xNextTaskUnblockTime = xTimeToWake;
 4006f58:	e0bffd17 	ldw	r2,-12(fp)
 4006f5c:	d0a6b915 	stw	r2,-25884(gp)
}
 4006f60:	0001883a 	nop
 4006f64:	e037883a 	mov	sp,fp
 4006f68:	dfc00117 	ldw	ra,4(sp)
 4006f6c:	df000017 	ldw	fp,0(sp)
 4006f70:	dec00204 	addi	sp,sp,8
 4006f74:	f800283a 	ret

04006f78 <main>:

//Variable Declarations
QueueHandle_t pushbutton_queue;		//Queue for communication b/w LED tasks and PB task

int main()
{
 4006f78:	defffc04 	addi	sp,sp,-16
 4006f7c:	dfc00315 	stw	ra,12(sp)
 4006f80:	df000215 	stw	fp,8(sp)
 4006f84:	df000204 	addi	fp,sp,8
  printf("Hello from Nios II running FreeRTOS!\n");
 4006f88:	01010074 	movhi	r4,1025
 4006f8c:	21324004 	addi	r4,r4,-14080
 4006f90:	40076ec0 	call	40076ec <puts>

  //Create Queues
  pushbutton_queue = xQueueCreate(1, sizeof(uint8_t));	//LED task and PB task queue
 4006f94:	000d883a 	mov	r6,zero
 4006f98:	01400044 	movi	r5,1
 4006f9c:	01000044 	movi	r4,1
 4006fa0:	40013d00 	call	40013d0 <xQueueGenericCreate>
 4006fa4:	d0a6bc15 	stw	r2,-25872(gp)

  //Create Tasks
  xTaskCreate(taskLEDControl, "LED Task", 512, NULL, 2, NULL);
 4006fa8:	d8000115 	stw	zero,4(sp)
 4006fac:	00800084 	movi	r2,2
 4006fb0:	d8800015 	stw	r2,0(sp)
 4006fb4:	000f883a 	mov	r7,zero
 4006fb8:	01808004 	movi	r6,512
 4006fbc:	01410074 	movhi	r5,1025
 4006fc0:	29724a04 	addi	r5,r5,-14040
 4006fc4:	01010034 	movhi	r4,1024
 4006fc8:	211c1904 	addi	r4,r4,28772
 4006fcc:	40037ac0 	call	40037ac <xTaskCreate>
  xTaskCreate(taskReadPBs, "Pushbutton Task", 512, NULL, 2, NULL);
 4006fd0:	d8000115 	stw	zero,4(sp)
 4006fd4:	00800084 	movi	r2,2
 4006fd8:	d8800015 	stw	r2,0(sp)
 4006fdc:	000f883a 	mov	r7,zero
 4006fe0:	01808004 	movi	r6,512
 4006fe4:	01410074 	movhi	r5,1025
 4006fe8:	29724d04 	addi	r5,r5,-14028
 4006fec:	01010034 	movhi	r4,1024
 4006ff0:	211c0104 	addi	r4,r4,28676
 4006ff4:	40037ac0 	call	40037ac <xTaskCreate>

  //Start Scheduler
  vTaskStartScheduler();
 4006ff8:	400460c0 	call	400460c <vTaskStartScheduler>

  while(1)//Should not reach here
 4006ffc:	0001883a 	nop
 4007000:	003ffe06 	br	4006ffc <main+0x84>

04007004 <taskReadPBs>:
* Postcondition:
*		   Records 4-bit value of which buttons are pressed and sends them
*		   to a queue.
************************************************************************/
void taskReadPBs (void* p)
{
 4007004:	defffc04 	addi	sp,sp,-16
 4007008:	dfc00315 	stw	ra,12(sp)
 400700c:	df000215 	stw	fp,8(sp)
 4007010:	df000204 	addi	fp,sp,8
 4007014:	e13ffe15 	stw	r4,-8(fp)
	//PBs are already debounced
	uint8_t pb_num = 0;
 4007018:	e03fffc5 	stb	zero,-1(fp)

	while(1)
	{
		//Scan PBs, negate, and send to queue
		pb_num = (0x0F & (~(IORD_ALTERA_AVALON_PIO_DATA(PUSHBUTTONS_BASE))));//PBs are active low
 400701c:	00820034 	movhi	r2,2048
 4007020:	10841037 	ldwio	r2,4160(r2)
 4007024:	0084303a 	nor	r2,zero,r2
 4007028:	108003cc 	andi	r2,r2,15
 400702c:	e0bfffc5 	stb	r2,-1(fp)
		if(pb_num != 0)
 4007030:	e0bfffc3 	ldbu	r2,-1(fp)
 4007034:	10803fcc 	andi	r2,r2,255
 4007038:	10000726 	beq	r2,zero,4007058 <taskReadPBs+0x54>
			xQueueSendToBack(pushbutton_queue, &pb_num, 0);
 400703c:	d0a6bc17 	ldw	r2,-25872(gp)
 4007040:	e0ffffc4 	addi	r3,fp,-1
 4007044:	000f883a 	mov	r7,zero
 4007048:	000d883a 	mov	r6,zero
 400704c:	180b883a 	mov	r5,r3
 4007050:	1009883a 	mov	r4,r2
 4007054:	40018500 	call	4001850 <xQueueGenericSend>
		vTaskDelay(100);
 4007058:	01001904 	movi	r4,100
 400705c:	4003de80 	call	4003de8 <vTaskDelay>
		pb_num = (0x0F & (~(IORD_ALTERA_AVALON_PIO_DATA(PUSHBUTTONS_BASE))));//PBs are active low
 4007060:	003fee06 	br	400701c <taskReadPBs+0x18>

04007064 <taskLEDControl>:
*
* Postcondition:
*		   Illuminates LEDs in cylon, up counter, blink, or TBird sequences.
************************************************************************/
void taskLEDControl (void* p)
{
 4007064:	defffa04 	addi	sp,sp,-24
 4007068:	dfc00515 	stw	ra,20(sp)
 400706c:	df000415 	stw	fp,16(sp)
 4007070:	df000404 	addi	fp,sp,16
 4007074:	e13ffc15 	stw	r4,-16(fp)
	uint8_t pb_num = 0;			//Var to store queue PB value
 4007078:	e03ffd45 	stb	zero,-11(fp)
	uint8_t cur_seq = 0;		//Var to store current LED pattern
 400707c:	e03fffc5 	stb	zero,-1(fp)
	uint16_t displayVal = 0;	//Var to store LED values to be written
 4007080:	e03fff0d 	sth	zero,-4(fp)
	uint8_t startSeq = 1;		//Var to track initial start of patterns
 4007084:	00800044 	movi	r2,1
 4007088:	e0bffec5 	stb	r2,-5(fp)
	uint8_t seqFlags = 1;		//Var to track cases within patters (i.e. cylon traveling left/right)
 400708c:	00800044 	movi	r2,1
 4007090:	e0bffe85 	stb	r2,-6(fp)
	uint16_t TBSeqL = 0;		//T-bird tail light pattern for left
 4007094:	e03ffe0d 	sth	zero,-8(fp)
	uint16_t TBSeqR = 0;		//T-bird tail light pattern for right
 4007098:	e03ffd8d 	sth	zero,-10(fp)

	while(1)
	{
		if(xQueueReceive(pushbutton_queue, &pb_num, 0))//Receive from queue
 400709c:	d0a6bc17 	ldw	r2,-25872(gp)
 40070a0:	e0fffd44 	addi	r3,fp,-11
 40070a4:	000d883a 	mov	r6,zero
 40070a8:	180b883a 	mov	r5,r3
 40070ac:	1009883a 	mov	r4,r2
 40070b0:	4001bfc0 	call	4001bfc <xQueueReceive>
 40070b4:	10000926 	beq	r2,zero,40070dc <taskLEDControl+0x78>
		{
			if(!(pb_num & cur_seq))
 40070b8:	e0bffd43 	ldbu	r2,-11(fp)
 40070bc:	e0ffffc3 	ldbu	r3,-1(fp)
 40070c0:	1884703a 	and	r2,r3,r2
 40070c4:	10803fcc 	andi	r2,r2,255
 40070c8:	1000041e 	bne	r2,zero,40070dc <taskLEDControl+0x78>
			{
				cur_seq = pb_num;
 40070cc:	e0bffd43 	ldbu	r2,-11(fp)
 40070d0:	e0bfffc5 	stb	r2,-1(fp)
				startSeq = 1;
 40070d4:	00800044 	movi	r2,1
 40070d8:	e0bffec5 	stb	r2,-5(fp)
			}
		}

		switch(cur_seq)//Run specified pattern
 40070dc:	e0bfffc3 	ldbu	r2,-1(fp)
 40070e0:	10c00220 	cmpeqi	r3,r2,8
 40070e4:	1800481e 	bne	r3,zero,4007208 <taskLEDControl+0x1a4>
 40070e8:	10c00248 	cmpgei	r3,r2,9
 40070ec:	1800a91e 	bne	r3,zero,4007394 <taskLEDControl+0x330>
 40070f0:	10c00120 	cmpeqi	r3,r2,4
 40070f4:	1800371e 	bne	r3,zero,40071d4 <taskLEDControl+0x170>
 40070f8:	10c00148 	cmpgei	r3,r2,5
 40070fc:	1800a51e 	bne	r3,zero,4007394 <taskLEDControl+0x330>
 4007100:	10c00060 	cmpeqi	r3,r2,1
 4007104:	1800031e 	bne	r3,zero,4007114 <taskLEDControl+0xb0>
 4007108:	108000a0 	cmpeqi	r2,r2,2
 400710c:	1000201e 	bne	r2,zero,4007190 <taskLEDControl+0x12c>
 4007110:	0000a006 	br	4007394 <taskLEDControl+0x330>
		{
		case 1:	//0001 --> Cylon
			if(startSeq)
 4007114:	e0bffec3 	ldbu	r2,-5(fp)
 4007118:	10000526 	beq	r2,zero,4007130 <taskLEDControl+0xcc>
			{
				displayVal = 3;
 400711c:	008000c4 	movi	r2,3
 4007120:	e0bfff0d 	sth	r2,-4(fp)
				startSeq = 0;
 4007124:	e03ffec5 	stb	zero,-5(fp)
				seqFlags = 1;
 4007128:	00800044 	movi	r2,1
 400712c:	e0bffe85 	stb	r2,-6(fp)
			}

			IOWR_ALTERA_AVALON_PIO_DATA(LEDS_BASE, displayVal);//Make sure it is fine to send 16bits
 4007130:	e0ffff0b 	ldhu	r3,-4(fp)
 4007134:	00820034 	movhi	r2,2048
 4007138:	10c40035 	stwio	r3,4096(r2)

			if(seqFlags)//Travel left
 400713c:	e0bffe83 	ldbu	r2,-6(fp)
 4007140:	10000826 	beq	r2,zero,4007164 <taskLEDControl+0x100>
			{
				displayVal = (displayVal << 1);
 4007144:	e0bfff0b 	ldhu	r2,-4(fp)
 4007148:	1085883a 	add	r2,r2,r2
 400714c:	e0bfff0d 	sth	r2,-4(fp)
				if(displayVal == 0x300)
 4007150:	e0bfff0b 	ldhu	r2,-4(fp)
 4007154:	1080c018 	cmpnei	r2,r2,768
 4007158:	10000a1e 	bne	r2,zero,4007184 <taskLEDControl+0x120>
					seqFlags = 0;
 400715c:	e03ffe85 	stb	zero,-6(fp)
 4007160:	00000806 	br	4007184 <taskLEDControl+0x120>
			}
			else		//Travel right
			{
				displayVal = (displayVal >> 1);
 4007164:	e0bfff0b 	ldhu	r2,-4(fp)
 4007168:	1004d07a 	srli	r2,r2,1
 400716c:	e0bfff0d 	sth	r2,-4(fp)
				if(displayVal == 3)
 4007170:	e0bfff0b 	ldhu	r2,-4(fp)
 4007174:	108000d8 	cmpnei	r2,r2,3
 4007178:	1000021e 	bne	r2,zero,4007184 <taskLEDControl+0x120>
					seqFlags = 1;
 400717c:	00800044 	movi	r2,1
 4007180:	e0bffe85 	stb	r2,-6(fp)
			}
			vTaskDelay(75);
 4007184:	010012c4 	movi	r4,75
 4007188:	4003de80 	call	4003de8 <vTaskDelay>
			break;
 400718c:	00008806 	br	40073b0 <taskLEDControl+0x34c>
		case 2:	//0010 --> Up Counter
			if(startSeq)
 4007190:	e0bffec3 	ldbu	r2,-5(fp)
 4007194:	10000226 	beq	r2,zero,40071a0 <taskLEDControl+0x13c>
			{
				startSeq = 0;
 4007198:	e03ffec5 	stb	zero,-5(fp)
				displayVal = 0;
 400719c:	e03fff0d 	sth	zero,-4(fp)
			}

			IOWR_ALTERA_AVALON_PIO_DATA(LEDS_BASE, displayVal);
 40071a0:	e0ffff0b 	ldhu	r3,-4(fp)
 40071a4:	00820034 	movhi	r2,2048
 40071a8:	10c40035 	stwio	r3,4096(r2)

			displayVal++;
 40071ac:	e0bfff0b 	ldhu	r2,-4(fp)
 40071b0:	10800044 	addi	r2,r2,1
 40071b4:	e0bfff0d 	sth	r2,-4(fp)
			if(displayVal == 0x3FF)//Reset counter
 40071b8:	e0bfff0b 	ldhu	r2,-4(fp)
 40071bc:	1080ffd8 	cmpnei	r2,r2,1023
 40071c0:	1000011e 	bne	r2,zero,40071c8 <taskLEDControl+0x164>
			{
				displayVal = 0;
 40071c4:	e03fff0d 	sth	zero,-4(fp)
			}
			vTaskDelay(50);
 40071c8:	01000c84 	movi	r4,50
 40071cc:	4003de80 	call	4003de8 <vTaskDelay>
			break;
 40071d0:	00007706 	br	40073b0 <taskLEDControl+0x34c>
		case 4:	//0100 --> Blink
			if(startSeq)
 40071d4:	e0bffec3 	ldbu	r2,-5(fp)
 40071d8:	10000226 	beq	r2,zero,40071e4 <taskLEDControl+0x180>
			{
				startSeq = 0;
 40071dc:	e03ffec5 	stb	zero,-5(fp)
				displayVal = 0;
 40071e0:	e03fff0d 	sth	zero,-4(fp)
			}

			IOWR_ALTERA_AVALON_PIO_DATA(LEDS_BASE, displayVal);
 40071e4:	e0ffff0b 	ldhu	r3,-4(fp)
 40071e8:	00820034 	movhi	r2,2048
 40071ec:	10c40035 	stwio	r3,4096(r2)

			displayVal = ~displayVal;	//Toggle LEDs
 40071f0:	e0bfff0b 	ldhu	r2,-4(fp)
 40071f4:	0084303a 	nor	r2,zero,r2
 40071f8:	e0bfff0d 	sth	r2,-4(fp)
			vTaskDelay(300);
 40071fc:	01004b04 	movi	r4,300
 4007200:	4003de80 	call	4003de8 <vTaskDelay>
			break;
 4007204:	00006a06 	br	40073b0 <taskLEDControl+0x34c>
		case 8:	//1000 --> TB Tail Light Sequence
			if(startSeq == 1)
 4007208:	e0bffec3 	ldbu	r2,-5(fp)
 400720c:	10800058 	cmpnei	r2,r2,1
 4007210:	1000051e 	bne	r2,zero,4007228 <taskLEDControl+0x1c4>
			{
				startSeq = 0;
 4007214:	e03ffec5 	stb	zero,-5(fp)
				displayVal = 0;
 4007218:	e03fff0d 	sth	zero,-4(fp)
				seqFlags = 0;
 400721c:	e03ffe85 	stb	zero,-6(fp)
				TBSeqL = 0;
 4007220:	e03ffe0d 	sth	zero,-8(fp)
				TBSeqR = 0;
 4007224:	e03ffd8d 	sth	zero,-10(fp)
			}

			switch(seqFlags)
 4007228:	e0bffe83 	ldbu	r2,-6(fp)
 400722c:	10c000a0 	cmpeqi	r3,r2,2
 4007230:	1800311e 	bne	r3,zero,40072f8 <taskLEDControl+0x294>
 4007234:	10c000c8 	cmpgei	r3,r2,3
 4007238:	18003f1e 	bne	r3,zero,4007338 <taskLEDControl+0x2d4>
 400723c:	10000326 	beq	r2,zero,400724c <taskLEDControl+0x1e8>
 4007240:	10800060 	cmpeqi	r2,r2,1
 4007244:	10001f1e 	bne	r2,zero,40072c4 <taskLEDControl+0x260>
 4007248:	00003b06 	br	4007338 <taskLEDControl+0x2d4>
			{
			case 0://Left and Right
				TBSeqL |= ((TBSeqL << 1) | 0x1)&0x1F;
 400724c:	e0bffe0b 	ldhu	r2,-8(fp)
 4007250:	1085883a 	add	r2,r2,r2
 4007254:	1080078c 	andi	r2,r2,30
 4007258:	1007883a 	mov	r3,r2
 400725c:	e0bffe0b 	ldhu	r2,-8(fp)
 4007260:	10c4b03a 	or	r2,r2,r3
 4007264:	10800054 	ori	r2,r2,1
 4007268:	e0bffe0d 	sth	r2,-8(fp)
				TBSeqR |= ((TBSeqR >> 1) | 0x10)&0x1F;
 400726c:	e0bffd8b 	ldhu	r2,-10(fp)
 4007270:	1004d07a 	srli	r2,r2,1
 4007274:	10800414 	ori	r2,r2,16
 4007278:	108007cc 	andi	r2,r2,31
 400727c:	1007883a 	mov	r3,r2
 4007280:	e0bffd8b 	ldhu	r2,-10(fp)
 4007284:	1884b03a 	or	r2,r3,r2
 4007288:	e0bffd8d 	sth	r2,-10(fp)
				displayVal = (((displayVal >> 5) | (TBSeqL)) << 5) | (displayVal | TBSeqR);
 400728c:	e0bfff0b 	ldhu	r2,-4(fp)
 4007290:	1004d17a 	srli	r2,r2,5
 4007294:	1007883a 	mov	r3,r2
 4007298:	e0bffe0b 	ldhu	r2,-8(fp)
 400729c:	10c4b03a 	or	r2,r2,r3
 40072a0:	10bfffcc 	andi	r2,r2,65535
 40072a4:	1004917a 	slli	r2,r2,5
 40072a8:	1009883a 	mov	r4,r2
 40072ac:	e0ffff0b 	ldhu	r3,-4(fp)
 40072b0:	e0bffd8b 	ldhu	r2,-10(fp)
 40072b4:	1884b03a 	or	r2,r3,r2
 40072b8:	2084b03a 	or	r2,r4,r2
 40072bc:	e0bfff0d 	sth	r2,-4(fp)
				break;
 40072c0:	00001d06 	br	4007338 <taskLEDControl+0x2d4>
			case 1://Right
				TBSeqR |= ((TBSeqR >> 1) | 0x10)&0x1F;
 40072c4:	e0bffd8b 	ldhu	r2,-10(fp)
 40072c8:	1004d07a 	srli	r2,r2,1
 40072cc:	10800414 	ori	r2,r2,16
 40072d0:	108007cc 	andi	r2,r2,31
 40072d4:	1007883a 	mov	r3,r2
 40072d8:	e0bffd8b 	ldhu	r2,-10(fp)
 40072dc:	1884b03a 	or	r2,r3,r2
 40072e0:	e0bffd8d 	sth	r2,-10(fp)
				displayVal = (0b00000 | ((displayVal)|(TBSeqR)));
 40072e4:	e0ffff0b 	ldhu	r3,-4(fp)
 40072e8:	e0bffd8b 	ldhu	r2,-10(fp)
 40072ec:	1884b03a 	or	r2,r3,r2
 40072f0:	e0bfff0d 	sth	r2,-4(fp)
				break;
 40072f4:	00001006 	br	4007338 <taskLEDControl+0x2d4>
			case 2://Left
				TBSeqL |= ((TBSeqL << 1) | 0x1)&0x1F;
 40072f8:	e0bffe0b 	ldhu	r2,-8(fp)
 40072fc:	1085883a 	add	r2,r2,r2
 4007300:	1080078c 	andi	r2,r2,30
 4007304:	1007883a 	mov	r3,r2
 4007308:	e0bffe0b 	ldhu	r2,-8(fp)
 400730c:	10c4b03a 	or	r2,r2,r3
 4007310:	10800054 	ori	r2,r2,1
 4007314:	e0bffe0d 	sth	r2,-8(fp)
				displayVal = ((((displayVal >> 5) | (TBSeqL)) << 5) | 0b00000);
 4007318:	e0bfff0b 	ldhu	r2,-4(fp)
 400731c:	1004d17a 	srli	r2,r2,5
 4007320:	1007883a 	mov	r3,r2
 4007324:	e0bffe0b 	ldhu	r2,-8(fp)
 4007328:	10c4b03a 	or	r2,r2,r3
 400732c:	1004917a 	slli	r2,r2,5
 4007330:	e0bfff0d 	sth	r2,-4(fp)
				break;
 4007334:	0001883a 	nop
			}

			IOWR_ALTERA_AVALON_PIO_DATA(LEDS_BASE, displayVal);
 4007338:	e0ffff0b 	ldhu	r3,-4(fp)
 400733c:	00820034 	movhi	r2,2048
 4007340:	10c40035 	stwio	r3,4096(r2)

			if(TBSeqL == 0x1F || TBSeqR == 0x1F)//Reset sequence
 4007344:	e0bffe0b 	ldhu	r2,-8(fp)
 4007348:	108007e0 	cmpeqi	r2,r2,31
 400734c:	1000031e 	bne	r2,zero,400735c <taskLEDControl+0x2f8>
 4007350:	e0bffd8b 	ldhu	r2,-10(fp)
 4007354:	108007d8 	cmpnei	r2,r2,31
 4007358:	10000b1e 	bne	r2,zero,4007388 <taskLEDControl+0x324>
			{
				displayVal = 0;
 400735c:	e03fff0d 	sth	zero,-4(fp)
				TBSeqL = 0;
 4007360:	e03ffe0d 	sth	zero,-8(fp)
				TBSeqR = 0;
 4007364:	e03ffd8d 	sth	zero,-10(fp)
				if(seqFlags < 2)
 4007368:	e0bffe83 	ldbu	r2,-6(fp)
 400736c:	108000a8 	cmpgeui	r2,r2,2
 4007370:	1000041e 	bne	r2,zero,4007384 <taskLEDControl+0x320>
					seqFlags++;
 4007374:	e0bffe83 	ldbu	r2,-6(fp)
 4007378:	10800044 	addi	r2,r2,1
 400737c:	e0bffe85 	stb	r2,-6(fp)
 4007380:	00000106 	br	4007388 <taskLEDControl+0x324>
				else
					seqFlags = 0;
 4007384:	e03ffe85 	stb	zero,-6(fp)
			}


			vTaskDelay(100);
 4007388:	01001904 	movi	r4,100
 400738c:	4003de80 	call	4003de8 <vTaskDelay>
			break;
 4007390:	00000706 	br	40073b0 <taskLEDControl+0x34c>
		default:
			displayVal = 0;
 4007394:	e03fff0d 	sth	zero,-4(fp)
			IOWR_ALTERA_AVALON_PIO_DATA(LEDS_BASE, displayVal);
 4007398:	e0ffff0b 	ldhu	r3,-4(fp)
 400739c:	00820034 	movhi	r2,2048
 40073a0:	10c40035 	stwio	r3,4096(r2)
			vTaskDelay(200);
 40073a4:	01003204 	movi	r4,200
 40073a8:	4003de80 	call	4003de8 <vTaskDelay>
			break;
 40073ac:	0001883a 	nop
		if(xQueueReceive(pushbutton_queue, &pb_num, 0))//Receive from queue
 40073b0:	003f3a06 	br	400709c <taskLEDControl+0x38>

040073b4 <__mulsi3>:
 40073b4:	0005883a 	mov	r2,zero
 40073b8:	20000726 	beq	r4,zero,40073d8 <__mulsi3+0x24>
 40073bc:	20c0004c 	andi	r3,r4,1
 40073c0:	2008d07a 	srli	r4,r4,1
 40073c4:	18000126 	beq	r3,zero,40073cc <__mulsi3+0x18>
 40073c8:	1145883a 	add	r2,r2,r5
 40073cc:	294b883a 	add	r5,r5,r5
 40073d0:	203ffa1e 	bne	r4,zero,40073bc <__mulsi3+0x8>
 40073d4:	f800283a 	ret
 40073d8:	f800283a 	ret

040073dc <memcpy>:
 40073dc:	30c00428 	cmpgeui	r3,r6,16
 40073e0:	2005883a 	mov	r2,r4
 40073e4:	18000b1e 	bne	r3,zero,4007414 <memcpy+0x38>
 40073e8:	2007883a 	mov	r3,r4
 40073ec:	31ffffc4 	addi	r7,r6,-1
 40073f0:	30003426 	beq	r6,zero,40074c4 <memcpy+0xe8>
 40073f4:	39c00044 	addi	r7,r7,1
 40073f8:	19cf883a 	add	r7,r3,r7
 40073fc:	29800003 	ldbu	r6,0(r5)
 4007400:	18c00044 	addi	r3,r3,1
 4007404:	29400044 	addi	r5,r5,1
 4007408:	19bfffc5 	stb	r6,-1(r3)
 400740c:	19fffb1e 	bne	r3,r7,40073fc <memcpy+0x20>
 4007410:	f800283a 	ret
 4007414:	2146b03a 	or	r3,r4,r5
 4007418:	18c000cc 	andi	r3,r3,3
 400741c:	18002a1e 	bne	r3,zero,40074c8 <memcpy+0xec>
 4007420:	333ffc04 	addi	r12,r6,-16
 4007424:	6018d13a 	srli	r12,r12,4
 4007428:	2811883a 	mov	r8,r5
 400742c:	200f883a 	mov	r7,r4
 4007430:	63000044 	addi	r12,r12,1
 4007434:	6018913a 	slli	r12,r12,4
 4007438:	2307883a 	add	r3,r4,r12
 400743c:	42c00017 	ldw	r11,0(r8)
 4007440:	42800117 	ldw	r10,4(r8)
 4007444:	42400217 	ldw	r9,8(r8)
 4007448:	41000317 	ldw	r4,12(r8)
 400744c:	39c00404 	addi	r7,r7,16
 4007450:	3afffc15 	stw	r11,-16(r7)
 4007454:	3abffd15 	stw	r10,-12(r7)
 4007458:	3a7ffe15 	stw	r9,-8(r7)
 400745c:	393fff15 	stw	r4,-4(r7)
 4007460:	42000404 	addi	r8,r8,16
 4007464:	38fff51e 	bne	r7,r3,400743c <memcpy+0x60>
 4007468:	3100030c 	andi	r4,r6,12
 400746c:	2b0b883a 	add	r5,r5,r12
 4007470:	324003cc 	andi	r9,r6,15
 4007474:	20001726 	beq	r4,zero,40074d4 <memcpy+0xf8>
 4007478:	2811883a 	mov	r8,r5
 400747c:	1809883a 	mov	r4,r3
 4007480:	1a57883a 	add	r11,r3,r9
 4007484:	42800017 	ldw	r10,0(r8)
 4007488:	21000104 	addi	r4,r4,4
 400748c:	590fc83a 	sub	r7,r11,r4
 4007490:	39c00128 	cmpgeui	r7,r7,4
 4007494:	22bfff15 	stw	r10,-4(r4)
 4007498:	42000104 	addi	r8,r8,4
 400749c:	383ff91e 	bne	r7,zero,4007484 <memcpy+0xa8>
 40074a0:	493fff04 	addi	r4,r9,-4
 40074a4:	2008d0ba 	srli	r4,r4,2
 40074a8:	318000cc 	andi	r6,r6,3
 40074ac:	31ffffc4 	addi	r7,r6,-1
 40074b0:	21000044 	addi	r4,r4,1
 40074b4:	200890ba 	slli	r4,r4,2
 40074b8:	1907883a 	add	r3,r3,r4
 40074bc:	290b883a 	add	r5,r5,r4
 40074c0:	303fcc1e 	bne	r6,zero,40073f4 <memcpy+0x18>
 40074c4:	f800283a 	ret
 40074c8:	31ffffc4 	addi	r7,r6,-1
 40074cc:	2007883a 	mov	r3,r4
 40074d0:	003fc806 	br	40073f4 <memcpy+0x18>
 40074d4:	480d883a 	mov	r6,r9
 40074d8:	003fc406 	br	40073ec <memcpy+0x10>

040074dc <memset>:
 40074dc:	defffb04 	addi	sp,sp,-20
 40074e0:	dc800215 	stw	r18,8(sp)
 40074e4:	dc400115 	stw	r17,4(sp)
 40074e8:	dfc00415 	stw	ra,16(sp)
 40074ec:	dcc00315 	stw	r19,12(sp)
 40074f0:	dc000015 	stw	r16,0(sp)
 40074f4:	208000cc 	andi	r2,r4,3
 40074f8:	2023883a 	mov	r17,r4
 40074fc:	2825883a 	mov	r18,r5
 4007500:	10004026 	beq	r2,zero,4007604 <memset+0x128>
 4007504:	34ffffc4 	addi	r19,r6,-1
 4007508:	30003326 	beq	r6,zero,40075d8 <memset+0xfc>
 400750c:	280f883a 	mov	r7,r5
 4007510:	2021883a 	mov	r16,r4
 4007514:	00000306 	br	4007524 <memset+0x48>
 4007518:	9cffffc4 	addi	r19,r19,-1
 400751c:	99bfffe0 	cmpeqi	r6,r19,-1
 4007520:	30002d1e 	bne	r6,zero,40075d8 <memset+0xfc>
 4007524:	84000044 	addi	r16,r16,1
 4007528:	818000cc 	andi	r6,r16,3
 400752c:	81ffffc5 	stb	r7,-1(r16)
 4007530:	303ff91e 	bne	r6,zero,4007518 <memset+0x3c>
 4007534:	98800128 	cmpgeui	r2,r19,4
 4007538:	10002126 	beq	r2,zero,40075c0 <memset+0xe4>
 400753c:	01404074 	movhi	r5,257
 4007540:	29404044 	addi	r5,r5,257
 4007544:	91003fcc 	andi	r4,r18,255
 4007548:	40073b40 	call	40073b4 <__mulsi3>
 400754c:	98c00430 	cmpltui	r3,r19,16
 4007550:	18002f1e 	bne	r3,zero,4007610 <memset+0x134>
 4007554:	99bffc04 	addi	r6,r19,-16
 4007558:	300cd13a 	srli	r6,r6,4
 400755c:	31800044 	addi	r6,r6,1
 4007560:	300c913a 	slli	r6,r6,4
 4007564:	818d883a 	add	r6,r16,r6
 4007568:	80800015 	stw	r2,0(r16)
 400756c:	80800115 	stw	r2,4(r16)
 4007570:	80800215 	stw	r2,8(r16)
 4007574:	80800315 	stw	r2,12(r16)
 4007578:	84000404 	addi	r16,r16,16
 400757c:	81bffa1e 	bne	r16,r6,4007568 <memset+0x8c>
 4007580:	9900030c 	andi	r4,r19,12
 4007584:	98c003cc 	andi	r3,r19,15
 4007588:	20001b26 	beq	r4,zero,40075f8 <memset+0x11c>
 400758c:	3009883a 	mov	r4,r6
 4007590:	30cb883a 	add	r5,r6,r3
 4007594:	21000104 	addi	r4,r4,4
 4007598:	290fc83a 	sub	r7,r5,r4
 400759c:	39c00128 	cmpgeui	r7,r7,4
 40075a0:	20bfff15 	stw	r2,-4(r4)
 40075a4:	383ffb1e 	bne	r7,zero,4007594 <memset+0xb8>
 40075a8:	1c3fff04 	addi	r16,r3,-4
 40075ac:	8020d0ba 	srli	r16,r16,2
 40075b0:	1cc000cc 	andi	r19,r3,3
 40075b4:	84000044 	addi	r16,r16,1
 40075b8:	802090ba 	slli	r16,r16,2
 40075bc:	3421883a 	add	r16,r6,r16
 40075c0:	98000526 	beq	r19,zero,40075d8 <memset+0xfc>
 40075c4:	900b883a 	mov	r5,r18
 40075c8:	84c7883a 	add	r3,r16,r19
 40075cc:	84000044 	addi	r16,r16,1
 40075d0:	817fffc5 	stb	r5,-1(r16)
 40075d4:	1c3ffd1e 	bne	r3,r16,40075cc <memset+0xf0>
 40075d8:	8805883a 	mov	r2,r17
 40075dc:	dfc00417 	ldw	ra,16(sp)
 40075e0:	dcc00317 	ldw	r19,12(sp)
 40075e4:	dc800217 	ldw	r18,8(sp)
 40075e8:	dc400117 	ldw	r17,4(sp)
 40075ec:	dc000017 	ldw	r16,0(sp)
 40075f0:	dec00504 	addi	sp,sp,20
 40075f4:	f800283a 	ret
 40075f8:	1827883a 	mov	r19,r3
 40075fc:	983ff11e 	bne	r19,zero,40075c4 <memset+0xe8>
 4007600:	003ff506 	br	40075d8 <memset+0xfc>
 4007604:	2021883a 	mov	r16,r4
 4007608:	3027883a 	mov	r19,r6
 400760c:	003fc906 	br	4007534 <memset+0x58>
 4007610:	800d883a 	mov	r6,r16
 4007614:	9807883a 	mov	r3,r19
 4007618:	003fdc06 	br	400758c <memset+0xb0>

0400761c <_puts_r>:
 400761c:	defff504 	addi	sp,sp,-44
 4007620:	dc000815 	stw	r16,32(sp)
 4007624:	2021883a 	mov	r16,r4
 4007628:	2809883a 	mov	r4,r5
 400762c:	dc400915 	stw	r17,36(sp)
 4007630:	dfc00a15 	stw	ra,40(sp)
 4007634:	2823883a 	mov	r17,r5
 4007638:	40076fc0 	call	40076fc <strlen>
 400763c:	11000044 	addi	r4,r2,1
 4007640:	d8800515 	stw	r2,20(sp)
 4007644:	00800044 	movi	r2,1
 4007648:	00c10074 	movhi	r3,1025
 400764c:	d8800715 	stw	r2,28(sp)
 4007650:	d8800404 	addi	r2,sp,16
 4007654:	18f25104 	addi	r3,r3,-14012
 4007658:	d8800115 	stw	r2,4(sp)
 400765c:	00800084 	movi	r2,2
 4007660:	dc400415 	stw	r17,16(sp)
 4007664:	d8c00615 	stw	r3,24(sp)
 4007668:	d9000315 	stw	r4,12(sp)
 400766c:	d8800215 	stw	r2,8(sp)
 4007670:	81400217 	ldw	r5,8(r16)
 4007674:	80000226 	beq	r16,zero,4007680 <_puts_r+0x64>
 4007678:	80800e17 	ldw	r2,56(r16)
 400767c:	10001426 	beq	r2,zero,40076d0 <_puts_r+0xb4>
 4007680:	2880030b 	ldhu	r2,12(r5)
 4007684:	10c8000c 	andi	r3,r2,8192
 4007688:	1800061e 	bne	r3,zero,40076a4 <_puts_r+0x88>
 400768c:	28c01917 	ldw	r3,100(r5)
 4007690:	0137ffc4 	movi	r4,-8193
 4007694:	10880014 	ori	r2,r2,8192
 4007698:	1906703a 	and	r3,r3,r4
 400769c:	2880030d 	sth	r2,12(r5)
 40076a0:	28c01915 	stw	r3,100(r5)
 40076a4:	d9800104 	addi	r6,sp,4
 40076a8:	8009883a 	mov	r4,r16
 40076ac:	4007b200 	call	4007b20 <__sfvwrite_r>
 40076b0:	1007883a 	mov	r3,r2
 40076b4:	00800284 	movi	r2,10
 40076b8:	18000a1e 	bne	r3,zero,40076e4 <_puts_r+0xc8>
 40076bc:	dfc00a17 	ldw	ra,40(sp)
 40076c0:	dc400917 	ldw	r17,36(sp)
 40076c4:	dc000817 	ldw	r16,32(sp)
 40076c8:	dec00b04 	addi	sp,sp,44
 40076cc:	f800283a 	ret
 40076d0:	8009883a 	mov	r4,r16
 40076d4:	d9400015 	stw	r5,0(sp)
 40076d8:	4007ad80 	call	4007ad8 <__sinit>
 40076dc:	d9400017 	ldw	r5,0(sp)
 40076e0:	003fe706 	br	4007680 <_puts_r+0x64>
 40076e4:	00bfffc4 	movi	r2,-1
 40076e8:	003ff406 	br	40076bc <_puts_r+0xa0>

040076ec <puts>:
 40076ec:	00810074 	movhi	r2,1025
 40076f0:	200b883a 	mov	r5,r4
 40076f4:	1138ea17 	ldw	r4,-7256(r2)
 40076f8:	400761c1 	jmpi	400761c <_puts_r>

040076fc <strlen>:
 40076fc:	208000cc 	andi	r2,r4,3
 4007700:	10000926 	beq	r2,zero,4007728 <strlen+0x2c>
 4007704:	2005883a 	mov	r2,r4
 4007708:	00000306 	br	4007718 <strlen+0x1c>
 400770c:	10800044 	addi	r2,r2,1
 4007710:	10c000cc 	andi	r3,r2,3
 4007714:	18000526 	beq	r3,zero,400772c <strlen+0x30>
 4007718:	10c00007 	ldb	r3,0(r2)
 400771c:	183ffb1e 	bne	r3,zero,400770c <strlen+0x10>
 4007720:	1105c83a 	sub	r2,r2,r4
 4007724:	f800283a 	ret
 4007728:	2005883a 	mov	r2,r4
 400772c:	11400017 	ldw	r5,0(r2)
 4007730:	01ffbff4 	movhi	r7,65279
 4007734:	39ffbfc4 	addi	r7,r7,-257
 4007738:	29c7883a 	add	r3,r5,r7
 400773c:	01a02074 	movhi	r6,32897
 4007740:	014a303a 	nor	r5,zero,r5
 4007744:	1946703a 	and	r3,r3,r5
 4007748:	31a02004 	addi	r6,r6,-32640
 400774c:	1986703a 	and	r3,r3,r6
 4007750:	1800071e 	bne	r3,zero,4007770 <strlen+0x74>
 4007754:	11400117 	ldw	r5,4(r2)
 4007758:	10800104 	addi	r2,r2,4
 400775c:	29c7883a 	add	r3,r5,r7
 4007760:	014a303a 	nor	r5,zero,r5
 4007764:	1946703a 	and	r3,r3,r5
 4007768:	1986703a 	and	r3,r3,r6
 400776c:	183ff926 	beq	r3,zero,4007754 <strlen+0x58>
 4007770:	10c00007 	ldb	r3,0(r2)
 4007774:	183fea26 	beq	r3,zero,4007720 <strlen+0x24>
 4007778:	10c00047 	ldb	r3,1(r2)
 400777c:	10800044 	addi	r2,r2,1
 4007780:	183fe726 	beq	r3,zero,4007720 <strlen+0x24>
 4007784:	10c00047 	ldb	r3,1(r2)
 4007788:	10800044 	addi	r2,r2,1
 400778c:	183ffa1e 	bne	r3,zero,4007778 <strlen+0x7c>
 4007790:	003fe306 	br	4007720 <strlen+0x24>

04007794 <__fp_lock>:
 4007794:	0005883a 	mov	r2,zero
 4007798:	f800283a 	ret

0400779c <_cleanup_r>:
 400779c:	01410074 	movhi	r5,1025
 40077a0:	29651d04 	addi	r5,r5,-27532
 40077a4:	40080601 	jmpi	4008060 <_fwalk_reent>

040077a8 <__fp_unlock>:
 40077a8:	0005883a 	mov	r2,zero
 40077ac:	f800283a 	ret

040077b0 <__sinit.part.0>:
 40077b0:	00c10034 	movhi	r3,1024
 40077b4:	20800117 	ldw	r2,4(r4)
 40077b8:	18dde704 	addi	r3,r3,30620
 40077bc:	20c00f15 	stw	r3,60(r4)
 40077c0:	2140bb04 	addi	r5,r4,748
 40077c4:	00c000c4 	movi	r3,3
 40077c8:	20c0b915 	stw	r3,740(r4)
 40077cc:	2140ba15 	stw	r5,744(r4)
 40077d0:	2000b815 	stw	zero,736(r4)
 40077d4:	10001705 	stb	zero,92(r2)
 40077d8:	10001745 	stb	zero,93(r2)
 40077dc:	10001785 	stb	zero,94(r2)
 40077e0:	100017c5 	stb	zero,95(r2)
 40077e4:	10001805 	stb	zero,96(r2)
 40077e8:	10001845 	stb	zero,97(r2)
 40077ec:	10001885 	stb	zero,98(r2)
 40077f0:	100018c5 	stb	zero,99(r2)
 40077f4:	00c00104 	movi	r3,4
 40077f8:	10c00315 	stw	r3,12(r2)
 40077fc:	02010074 	movhi	r8,1025
 4007800:	20c00217 	ldw	r3,8(r4)
 4007804:	01c10074 	movhi	r7,1025
 4007808:	01810074 	movhi	r6,1025
 400780c:	01410074 	movhi	r5,1025
 4007810:	42244b04 	addi	r8,r8,-28372
 4007814:	39e46204 	addi	r7,r7,-28280
 4007818:	31a48204 	addi	r6,r6,-28152
 400781c:	29649904 	addi	r5,r5,-28060
 4007820:	02400074 	movhi	r9,1
 4007824:	10000015 	stw	zero,0(r2)
 4007828:	10000115 	stw	zero,4(r2)
 400782c:	10000215 	stw	zero,8(r2)
 4007830:	10001915 	stw	zero,100(r2)
 4007834:	10000415 	stw	zero,16(r2)
 4007838:	10000515 	stw	zero,20(r2)
 400783c:	10000615 	stw	zero,24(r2)
 4007840:	10800715 	stw	r2,28(r2)
 4007844:	12000815 	stw	r8,32(r2)
 4007848:	11c00915 	stw	r7,36(r2)
 400784c:	11800a15 	stw	r6,40(r2)
 4007850:	11400b15 	stw	r5,44(r2)
 4007854:	4a400284 	addi	r9,r9,10
 4007858:	1a400315 	stw	r9,12(r3)
 400785c:	18000015 	stw	zero,0(r3)
 4007860:	18000115 	stw	zero,4(r3)
 4007864:	18000215 	stw	zero,8(r3)
 4007868:	18001915 	stw	zero,100(r3)
 400786c:	18000415 	stw	zero,16(r3)
 4007870:	18001705 	stb	zero,92(r3)
 4007874:	18001745 	stb	zero,93(r3)
 4007878:	18001785 	stb	zero,94(r3)
 400787c:	180017c5 	stb	zero,95(r3)
 4007880:	18001805 	stb	zero,96(r3)
 4007884:	18001845 	stb	zero,97(r3)
 4007888:	18001885 	stb	zero,98(r3)
 400788c:	180018c5 	stb	zero,99(r3)
 4007890:	20800317 	ldw	r2,12(r4)
 4007894:	024000b4 	movhi	r9,2
 4007898:	18000515 	stw	zero,20(r3)
 400789c:	18000615 	stw	zero,24(r3)
 40078a0:	18c00715 	stw	r3,28(r3)
 40078a4:	1a000815 	stw	r8,32(r3)
 40078a8:	19c00915 	stw	r7,36(r3)
 40078ac:	19800a15 	stw	r6,40(r3)
 40078b0:	19400b15 	stw	r5,44(r3)
 40078b4:	4a400484 	addi	r9,r9,18
 40078b8:	10000015 	stw	zero,0(r2)
 40078bc:	10000115 	stw	zero,4(r2)
 40078c0:	10000215 	stw	zero,8(r2)
 40078c4:	10001915 	stw	zero,100(r2)
 40078c8:	12400315 	stw	r9,12(r2)
 40078cc:	10000415 	stw	zero,16(r2)
 40078d0:	10000515 	stw	zero,20(r2)
 40078d4:	10000615 	stw	zero,24(r2)
 40078d8:	10001705 	stb	zero,92(r2)
 40078dc:	10001745 	stb	zero,93(r2)
 40078e0:	10001785 	stb	zero,94(r2)
 40078e4:	100017c5 	stb	zero,95(r2)
 40078e8:	10001805 	stb	zero,96(r2)
 40078ec:	10001845 	stb	zero,97(r2)
 40078f0:	10001885 	stb	zero,98(r2)
 40078f4:	100018c5 	stb	zero,99(r2)
 40078f8:	10800715 	stw	r2,28(r2)
 40078fc:	12000815 	stw	r8,32(r2)
 4007900:	11c00915 	stw	r7,36(r2)
 4007904:	11800a15 	stw	r6,40(r2)
 4007908:	11400b15 	stw	r5,44(r2)
 400790c:	00800044 	movi	r2,1
 4007910:	20800e15 	stw	r2,56(r4)
 4007914:	f800283a 	ret

04007918 <__sfmoreglue>:
 4007918:	defffc04 	addi	sp,sp,-16
 400791c:	dc800215 	stw	r18,8(sp)
 4007920:	2825883a 	mov	r18,r5
 4007924:	dc000015 	stw	r16,0(sp)
 4007928:	01401a04 	movi	r5,104
 400792c:	2021883a 	mov	r16,r4
 4007930:	913fffc4 	addi	r4,r18,-1
 4007934:	dfc00315 	stw	ra,12(sp)
 4007938:	dc400115 	stw	r17,4(sp)
 400793c:	40073b40 	call	40073b4 <__mulsi3>
 4007940:	8009883a 	mov	r4,r16
 4007944:	11401d04 	addi	r5,r2,116
 4007948:	1023883a 	mov	r17,r2
 400794c:	40081080 	call	4008108 <_malloc_r>
 4007950:	1021883a 	mov	r16,r2
 4007954:	10000726 	beq	r2,zero,4007974 <__sfmoreglue+0x5c>
 4007958:	11000304 	addi	r4,r2,12
 400795c:	10000015 	stw	zero,0(r2)
 4007960:	14800115 	stw	r18,4(r2)
 4007964:	11000215 	stw	r4,8(r2)
 4007968:	89801a04 	addi	r6,r17,104
 400796c:	000b883a 	mov	r5,zero
 4007970:	40074dc0 	call	40074dc <memset>
 4007974:	8005883a 	mov	r2,r16
 4007978:	dfc00317 	ldw	ra,12(sp)
 400797c:	dc800217 	ldw	r18,8(sp)
 4007980:	dc400117 	ldw	r17,4(sp)
 4007984:	dc000017 	ldw	r16,0(sp)
 4007988:	dec00404 	addi	sp,sp,16
 400798c:	f800283a 	ret

04007990 <__sfp>:
 4007990:	defffc04 	addi	sp,sp,-16
 4007994:	00810074 	movhi	r2,1025
 4007998:	dc400115 	stw	r17,4(sp)
 400799c:	1478e917 	ldw	r17,-7260(r2)
 40079a0:	dc800215 	stw	r18,8(sp)
 40079a4:	dfc00315 	stw	ra,12(sp)
 40079a8:	88800e17 	ldw	r2,56(r17)
 40079ac:	dc000015 	stw	r16,0(sp)
 40079b0:	2025883a 	mov	r18,r4
 40079b4:	10002d26 	beq	r2,zero,4007a6c <__sfp+0xdc>
 40079b8:	8c40b804 	addi	r17,r17,736
 40079bc:	88800117 	ldw	r2,4(r17)
 40079c0:	8c000217 	ldw	r16,8(r17)
 40079c4:	10bfffc4 	addi	r2,r2,-1
 40079c8:	1000030e 	bge	r2,zero,40079d8 <__sfp+0x48>
 40079cc:	00002306 	br	4007a5c <__sfp+0xcc>
 40079d0:	84001a04 	addi	r16,r16,104
 40079d4:	28002126 	beq	r5,zero,4007a5c <__sfp+0xcc>
 40079d8:	80c0030f 	ldh	r3,12(r16)
 40079dc:	10bfffc4 	addi	r2,r2,-1
 40079e0:	117fffd8 	cmpnei	r5,r2,-1
 40079e4:	183ffa1e 	bne	r3,zero,40079d0 <__sfp+0x40>
 40079e8:	00bffff4 	movhi	r2,65535
 40079ec:	10800044 	addi	r2,r2,1
 40079f0:	80800315 	stw	r2,12(r16)
 40079f4:	80001915 	stw	zero,100(r16)
 40079f8:	80000015 	stw	zero,0(r16)
 40079fc:	80000215 	stw	zero,8(r16)
 4007a00:	80000115 	stw	zero,4(r16)
 4007a04:	80000415 	stw	zero,16(r16)
 4007a08:	80000515 	stw	zero,20(r16)
 4007a0c:	80000615 	stw	zero,24(r16)
 4007a10:	80001705 	stb	zero,92(r16)
 4007a14:	80001745 	stb	zero,93(r16)
 4007a18:	80001785 	stb	zero,94(r16)
 4007a1c:	800017c5 	stb	zero,95(r16)
 4007a20:	80001805 	stb	zero,96(r16)
 4007a24:	80001845 	stb	zero,97(r16)
 4007a28:	80001885 	stb	zero,98(r16)
 4007a2c:	800018c5 	stb	zero,99(r16)
 4007a30:	80000c15 	stw	zero,48(r16)
 4007a34:	80000d15 	stw	zero,52(r16)
 4007a38:	80001115 	stw	zero,68(r16)
 4007a3c:	80001215 	stw	zero,72(r16)
 4007a40:	8005883a 	mov	r2,r16
 4007a44:	dfc00317 	ldw	ra,12(sp)
 4007a48:	dc800217 	ldw	r18,8(sp)
 4007a4c:	dc400117 	ldw	r17,4(sp)
 4007a50:	dc000017 	ldw	r16,0(sp)
 4007a54:	dec00404 	addi	sp,sp,16
 4007a58:	f800283a 	ret
 4007a5c:	8c000017 	ldw	r16,0(r17)
 4007a60:	80000526 	beq	r16,zero,4007a78 <__sfp+0xe8>
 4007a64:	8023883a 	mov	r17,r16
 4007a68:	003fd406 	br	40079bc <__sfp+0x2c>
 4007a6c:	8809883a 	mov	r4,r17
 4007a70:	40077b00 	call	40077b0 <__sinit.part.0>
 4007a74:	003fd006 	br	40079b8 <__sfp+0x28>
 4007a78:	01406b04 	movi	r5,428
 4007a7c:	9009883a 	mov	r4,r18
 4007a80:	40081080 	call	4008108 <_malloc_r>
 4007a84:	1021883a 	mov	r16,r2
 4007a88:	10000a26 	beq	r2,zero,4007ab4 <__sfp+0x124>
 4007a8c:	10000015 	stw	zero,0(r2)
 4007a90:	11000304 	addi	r4,r2,12
 4007a94:	00800104 	movi	r2,4
 4007a98:	80800115 	stw	r2,4(r16)
 4007a9c:	81000215 	stw	r4,8(r16)
 4007aa0:	01806804 	movi	r6,416
 4007aa4:	000b883a 	mov	r5,zero
 4007aa8:	40074dc0 	call	40074dc <memset>
 4007aac:	8c000015 	stw	r16,0(r17)
 4007ab0:	003fec06 	br	4007a64 <__sfp+0xd4>
 4007ab4:	88000015 	stw	zero,0(r17)
 4007ab8:	00800304 	movi	r2,12
 4007abc:	90800015 	stw	r2,0(r18)
 4007ac0:	003fdf06 	br	4007a40 <__sfp+0xb0>

04007ac4 <_cleanup>:
 4007ac4:	00810074 	movhi	r2,1025
 4007ac8:	1138e917 	ldw	r4,-7260(r2)
 4007acc:	01410074 	movhi	r5,1025
 4007ad0:	29651d04 	addi	r5,r5,-27532
 4007ad4:	40080601 	jmpi	4008060 <_fwalk_reent>

04007ad8 <__sinit>:
 4007ad8:	20800e17 	ldw	r2,56(r4)
 4007adc:	10000126 	beq	r2,zero,4007ae4 <__sinit+0xc>
 4007ae0:	f800283a 	ret
 4007ae4:	40077b01 	jmpi	40077b0 <__sinit.part.0>

04007ae8 <__sfp_lock_acquire>:
 4007ae8:	f800283a 	ret

04007aec <__sfp_lock_release>:
 4007aec:	f800283a 	ret

04007af0 <__sinit_lock_acquire>:
 4007af0:	f800283a 	ret

04007af4 <__sinit_lock_release>:
 4007af4:	f800283a 	ret

04007af8 <__fp_lock_all>:
 4007af8:	00810074 	movhi	r2,1025
 4007afc:	1138ea17 	ldw	r4,-7256(r2)
 4007b00:	01410034 	movhi	r5,1024
 4007b04:	295de504 	addi	r5,r5,30612
 4007b08:	4007fc81 	jmpi	4007fc8 <_fwalk>

04007b0c <__fp_unlock_all>:
 4007b0c:	00810074 	movhi	r2,1025
 4007b10:	1138ea17 	ldw	r4,-7256(r2)
 4007b14:	01410034 	movhi	r5,1024
 4007b18:	295dea04 	addi	r5,r5,30632
 4007b1c:	4007fc81 	jmpi	4007fc8 <_fwalk>

04007b20 <__sfvwrite_r>:
 4007b20:	30800217 	ldw	r2,8(r6)
 4007b24:	1000c426 	beq	r2,zero,4007e38 <__sfvwrite_r+0x318>
 4007b28:	2a80030b 	ldhu	r10,12(r5)
 4007b2c:	defff504 	addi	sp,sp,-44
 4007b30:	df000915 	stw	fp,36(sp)
 4007b34:	dcc00415 	stw	r19,16(sp)
 4007b38:	dc000115 	stw	r16,4(sp)
 4007b3c:	dfc00a15 	stw	ra,40(sp)
 4007b40:	ddc00815 	stw	r23,32(sp)
 4007b44:	dd800715 	stw	r22,28(sp)
 4007b48:	dd400615 	stw	r21,24(sp)
 4007b4c:	dd000515 	stw	r20,20(sp)
 4007b50:	dc800315 	stw	r18,12(sp)
 4007b54:	dc400215 	stw	r17,8(sp)
 4007b58:	5080020c 	andi	r2,r10,8
 4007b5c:	3039883a 	mov	fp,r6
 4007b60:	2027883a 	mov	r19,r4
 4007b64:	2821883a 	mov	r16,r5
 4007b68:	10002226 	beq	r2,zero,4007bf4 <__sfvwrite_r+0xd4>
 4007b6c:	28800417 	ldw	r2,16(r5)
 4007b70:	10002026 	beq	r2,zero,4007bf4 <__sfvwrite_r+0xd4>
 4007b74:	5080008c 	andi	r2,r10,2
 4007b78:	e4400017 	ldw	r17,0(fp)
 4007b7c:	10002526 	beq	r2,zero,4007c14 <__sfvwrite_r+0xf4>
 4007b80:	80800917 	ldw	r2,36(r16)
 4007b84:	81400717 	ldw	r5,28(r16)
 4007b88:	05600034 	movhi	r21,32768
 4007b8c:	0029883a 	mov	r20,zero
 4007b90:	0025883a 	mov	r18,zero
 4007b94:	ad7f0004 	addi	r21,r21,-1024
 4007b98:	a00d883a 	mov	r6,r20
 4007b9c:	9809883a 	mov	r4,r19
 4007ba0:	90001026 	beq	r18,zero,4007be4 <__sfvwrite_r+0xc4>
 4007ba4:	900f883a 	mov	r7,r18
 4007ba8:	ac80012e 	bgeu	r21,r18,4007bb0 <__sfvwrite_r+0x90>
 4007bac:	a80f883a 	mov	r7,r21
 4007bb0:	103ee83a 	callr	r2
 4007bb4:	00809b0e 	bge	zero,r2,4007e24 <__sfvwrite_r+0x304>
 4007bb8:	e0c00217 	ldw	r3,8(fp)
 4007bbc:	a0a9883a 	add	r20,r20,r2
 4007bc0:	90a5c83a 	sub	r18,r18,r2
 4007bc4:	1885c83a 	sub	r2,r3,r2
 4007bc8:	e0800215 	stw	r2,8(fp)
 4007bcc:	10008426 	beq	r2,zero,4007de0 <__sfvwrite_r+0x2c0>
 4007bd0:	80800917 	ldw	r2,36(r16)
 4007bd4:	81400717 	ldw	r5,28(r16)
 4007bd8:	a00d883a 	mov	r6,r20
 4007bdc:	9809883a 	mov	r4,r19
 4007be0:	903ff01e 	bne	r18,zero,4007ba4 <__sfvwrite_r+0x84>
 4007be4:	8d000017 	ldw	r20,0(r17)
 4007be8:	8c800117 	ldw	r18,4(r17)
 4007bec:	8c400204 	addi	r17,r17,8
 4007bf0:	003fe906 	br	4007b98 <__sfvwrite_r+0x78>
 4007bf4:	800b883a 	mov	r5,r16
 4007bf8:	9809883a 	mov	r4,r19
 4007bfc:	40092d00 	call	40092d0 <__swsetup_r>
 4007c00:	10008b1e 	bne	r2,zero,4007e30 <__sfvwrite_r+0x310>
 4007c04:	8280030b 	ldhu	r10,12(r16)
 4007c08:	e4400017 	ldw	r17,0(fp)
 4007c0c:	5080008c 	andi	r2,r10,2
 4007c10:	103fdb1e 	bne	r2,zero,4007b80 <__sfvwrite_r+0x60>
 4007c14:	5080004c 	andi	r2,r10,1
 4007c18:	10004f1e 	bne	r2,zero,4007d58 <__sfvwrite_r+0x238>
 4007c1c:	00a00034 	movhi	r2,32768
 4007c20:	81c00017 	ldw	r7,0(r16)
 4007c24:	80c00217 	ldw	r3,8(r16)
 4007c28:	10bfffc4 	addi	r2,r2,-1
 4007c2c:	002d883a 	mov	r22,zero
 4007c30:	0025883a 	mov	r18,zero
 4007c34:	d8800015 	stw	r2,0(sp)
 4007c38:	3809883a 	mov	r4,r7
 4007c3c:	1829883a 	mov	r20,r3
 4007c40:	90004126 	beq	r18,zero,4007d48 <__sfvwrite_r+0x228>
 4007c44:	5080800c 	andi	r2,r10,512
 4007c48:	10009526 	beq	r2,zero,4007ea0 <__sfvwrite_r+0x380>
 4007c4c:	182b883a 	mov	r21,r3
 4007c50:	90c0ba36 	bltu	r18,r3,4007f3c <__sfvwrite_r+0x41c>
 4007c54:	5081200c 	andi	r2,r10,1152
 4007c58:	10002526 	beq	r2,zero,4007cf0 <__sfvwrite_r+0x1d0>
 4007c5c:	80c00517 	ldw	r3,20(r16)
 4007c60:	81000417 	ldw	r4,16(r16)
 4007c64:	18c5883a 	add	r2,r3,r3
 4007c68:	10c5883a 	add	r2,r2,r3
 4007c6c:	1012d7fa 	srli	r9,r2,31
 4007c70:	392fc83a 	sub	r23,r7,r4
 4007c74:	b8c00044 	addi	r3,r23,1
 4007c78:	4893883a 	add	r9,r9,r2
 4007c7c:	4829d07a 	srai	r20,r9,1
 4007c80:	1c85883a 	add	r2,r3,r18
 4007c84:	a00b883a 	mov	r5,r20
 4007c88:	a080022e 	bgeu	r20,r2,4007c94 <__sfvwrite_r+0x174>
 4007c8c:	1029883a 	mov	r20,r2
 4007c90:	100b883a 	mov	r5,r2
 4007c94:	5281000c 	andi	r10,r10,1024
 4007c98:	5000b926 	beq	r10,zero,4007f80 <__sfvwrite_r+0x460>
 4007c9c:	9809883a 	mov	r4,r19
 4007ca0:	40081080 	call	4008108 <_malloc_r>
 4007ca4:	1000c426 	beq	r2,zero,4007fb8 <__sfvwrite_r+0x498>
 4007ca8:	81400417 	ldw	r5,16(r16)
 4007cac:	1009883a 	mov	r4,r2
 4007cb0:	b80d883a 	mov	r6,r23
 4007cb4:	40073dc0 	call	40073dc <memcpy>
 4007cb8:	1007883a 	mov	r3,r2
 4007cbc:	8080030b 	ldhu	r2,12(r16)
 4007cc0:	013edfc4 	movi	r4,-1153
 4007cc4:	1104703a 	and	r2,r2,r4
 4007cc8:	10802014 	ori	r2,r2,128
 4007ccc:	8080030d 	sth	r2,12(r16)
 4007cd0:	a5cfc83a 	sub	r7,r20,r23
 4007cd4:	1dc9883a 	add	r4,r3,r23
 4007cd8:	85000515 	stw	r20,20(r16)
 4007cdc:	80c00415 	stw	r3,16(r16)
 4007ce0:	81000015 	stw	r4,0(r16)
 4007ce4:	9029883a 	mov	r20,r18
 4007ce8:	81c00215 	stw	r7,8(r16)
 4007cec:	902b883a 	mov	r21,r18
 4007cf0:	a80d883a 	mov	r6,r21
 4007cf4:	b00b883a 	mov	r5,r22
 4007cf8:	40089b80 	call	40089b8 <memmove>
 4007cfc:	80c00217 	ldw	r3,8(r16)
 4007d00:	81c00017 	ldw	r7,0(r16)
 4007d04:	902f883a 	mov	r23,r18
 4007d08:	1d07c83a 	sub	r3,r3,r20
 4007d0c:	3d4d883a 	add	r6,r7,r21
 4007d10:	80c00215 	stw	r3,8(r16)
 4007d14:	81800015 	stw	r6,0(r16)
 4007d18:	0025883a 	mov	r18,zero
 4007d1c:	e0800217 	ldw	r2,8(fp)
 4007d20:	b5ed883a 	add	r22,r22,r23
 4007d24:	15c5c83a 	sub	r2,r2,r23
 4007d28:	e0800215 	stw	r2,8(fp)
 4007d2c:	10002c26 	beq	r2,zero,4007de0 <__sfvwrite_r+0x2c0>
 4007d30:	81c00017 	ldw	r7,0(r16)
 4007d34:	80c00217 	ldw	r3,8(r16)
 4007d38:	8280030b 	ldhu	r10,12(r16)
 4007d3c:	3809883a 	mov	r4,r7
 4007d40:	1829883a 	mov	r20,r3
 4007d44:	903fbf1e 	bne	r18,zero,4007c44 <__sfvwrite_r+0x124>
 4007d48:	8d800017 	ldw	r22,0(r17)
 4007d4c:	8c800117 	ldw	r18,4(r17)
 4007d50:	8c400204 	addi	r17,r17,8
 4007d54:	003fb806 	br	4007c38 <__sfvwrite_r+0x118>
 4007d58:	002f883a 	mov	r23,zero
 4007d5c:	0005883a 	mov	r2,zero
 4007d60:	002b883a 	mov	r21,zero
 4007d64:	0029883a 	mov	r20,zero
 4007d68:	a0003526 	beq	r20,zero,4007e40 <__sfvwrite_r+0x320>
 4007d6c:	10003926 	beq	r2,zero,4007e54 <__sfvwrite_r+0x334>
 4007d70:	b805883a 	mov	r2,r23
 4007d74:	a02d883a 	mov	r22,r20
 4007d78:	1500012e 	bgeu	r2,r20,4007d80 <__sfvwrite_r+0x260>
 4007d7c:	102d883a 	mov	r22,r2
 4007d80:	81000017 	ldw	r4,0(r16)
 4007d84:	80800417 	ldw	r2,16(r16)
 4007d88:	84800217 	ldw	r18,8(r16)
 4007d8c:	81c00517 	ldw	r7,20(r16)
 4007d90:	1100022e 	bgeu	r2,r4,4007d9c <__sfvwrite_r+0x27c>
 4007d94:	91e5883a 	add	r18,r18,r7
 4007d98:	95803616 	blt	r18,r22,4007e74 <__sfvwrite_r+0x354>
 4007d9c:	b1c06a16 	blt	r22,r7,4007f48 <__sfvwrite_r+0x428>
 4007da0:	80800917 	ldw	r2,36(r16)
 4007da4:	81400717 	ldw	r5,28(r16)
 4007da8:	a80d883a 	mov	r6,r21
 4007dac:	9809883a 	mov	r4,r19
 4007db0:	103ee83a 	callr	r2
 4007db4:	1025883a 	mov	r18,r2
 4007db8:	00801a0e 	bge	zero,r2,4007e24 <__sfvwrite_r+0x304>
 4007dbc:	bcafc83a 	sub	r23,r23,r18
 4007dc0:	b8001426 	beq	r23,zero,4007e14 <__sfvwrite_r+0x2f4>
 4007dc4:	00800044 	movi	r2,1
 4007dc8:	e0c00217 	ldw	r3,8(fp)
 4007dcc:	acab883a 	add	r21,r21,r18
 4007dd0:	a4a9c83a 	sub	r20,r20,r18
 4007dd4:	1c87c83a 	sub	r3,r3,r18
 4007dd8:	e0c00215 	stw	r3,8(fp)
 4007ddc:	183fe21e 	bne	r3,zero,4007d68 <__sfvwrite_r+0x248>
 4007de0:	0005883a 	mov	r2,zero
 4007de4:	dfc00a17 	ldw	ra,40(sp)
 4007de8:	df000917 	ldw	fp,36(sp)
 4007dec:	ddc00817 	ldw	r23,32(sp)
 4007df0:	dd800717 	ldw	r22,28(sp)
 4007df4:	dd400617 	ldw	r21,24(sp)
 4007df8:	dd000517 	ldw	r20,20(sp)
 4007dfc:	dcc00417 	ldw	r19,16(sp)
 4007e00:	dc800317 	ldw	r18,12(sp)
 4007e04:	dc400217 	ldw	r17,8(sp)
 4007e08:	dc000117 	ldw	r16,4(sp)
 4007e0c:	dec00b04 	addi	sp,sp,44
 4007e10:	f800283a 	ret
 4007e14:	800b883a 	mov	r5,r16
 4007e18:	9809883a 	mov	r4,r19
 4007e1c:	40097840 	call	4009784 <_fflush_r>
 4007e20:	103fe926 	beq	r2,zero,4007dc8 <__sfvwrite_r+0x2a8>
 4007e24:	8080030b 	ldhu	r2,12(r16)
 4007e28:	10801014 	ori	r2,r2,64
 4007e2c:	8080030d 	sth	r2,12(r16)
 4007e30:	00bfffc4 	movi	r2,-1
 4007e34:	003feb06 	br	4007de4 <__sfvwrite_r+0x2c4>
 4007e38:	0005883a 	mov	r2,zero
 4007e3c:	f800283a 	ret
 4007e40:	8d000117 	ldw	r20,4(r17)
 4007e44:	8805883a 	mov	r2,r17
 4007e48:	8c400204 	addi	r17,r17,8
 4007e4c:	a03ffc26 	beq	r20,zero,4007e40 <__sfvwrite_r+0x320>
 4007e50:	15400017 	ldw	r21,0(r2)
 4007e54:	a00d883a 	mov	r6,r20
 4007e58:	01400284 	movi	r5,10
 4007e5c:	a809883a 	mov	r4,r21
 4007e60:	40088bc0 	call	40088bc <memchr>
 4007e64:	10004326 	beq	r2,zero,4007f74 <__sfvwrite_r+0x454>
 4007e68:	10800044 	addi	r2,r2,1
 4007e6c:	156fc83a 	sub	r23,r2,r21
 4007e70:	003fbf06 	br	4007d70 <__sfvwrite_r+0x250>
 4007e74:	a80b883a 	mov	r5,r21
 4007e78:	900d883a 	mov	r6,r18
 4007e7c:	40089b80 	call	40089b8 <memmove>
 4007e80:	80800017 	ldw	r2,0(r16)
 4007e84:	800b883a 	mov	r5,r16
 4007e88:	9809883a 	mov	r4,r19
 4007e8c:	1485883a 	add	r2,r2,r18
 4007e90:	80800015 	stw	r2,0(r16)
 4007e94:	40097840 	call	4009784 <_fflush_r>
 4007e98:	103fc826 	beq	r2,zero,4007dbc <__sfvwrite_r+0x29c>
 4007e9c:	003fe106 	br	4007e24 <__sfvwrite_r+0x304>
 4007ea0:	80800417 	ldw	r2,16(r16)
 4007ea4:	11c01236 	bltu	r2,r7,4007ef0 <__sfvwrite_r+0x3d0>
 4007ea8:	81400517 	ldw	r5,20(r16)
 4007eac:	91401036 	bltu	r18,r5,4007ef0 <__sfvwrite_r+0x3d0>
 4007eb0:	00a00034 	movhi	r2,32768
 4007eb4:	902f883a 	mov	r23,r18
 4007eb8:	90800136 	bltu	r18,r2,4007ec0 <__sfvwrite_r+0x3a0>
 4007ebc:	ddc00017 	ldw	r23,0(sp)
 4007ec0:	b809883a 	mov	r4,r23
 4007ec4:	400a0c00 	call	400a0c0 <__modsi3>
 4007ec8:	80c00917 	ldw	r3,36(r16)
 4007ecc:	81400717 	ldw	r5,28(r16)
 4007ed0:	b88fc83a 	sub	r7,r23,r2
 4007ed4:	b00d883a 	mov	r6,r22
 4007ed8:	9809883a 	mov	r4,r19
 4007edc:	183ee83a 	callr	r3
 4007ee0:	102f883a 	mov	r23,r2
 4007ee4:	00bfcf0e 	bge	zero,r2,4007e24 <__sfvwrite_r+0x304>
 4007ee8:	95e5c83a 	sub	r18,r18,r23
 4007eec:	003f8b06 	br	4007d1c <__sfvwrite_r+0x1fc>
 4007ef0:	182f883a 	mov	r23,r3
 4007ef4:	90c0012e 	bgeu	r18,r3,4007efc <__sfvwrite_r+0x3dc>
 4007ef8:	902f883a 	mov	r23,r18
 4007efc:	3809883a 	mov	r4,r7
 4007f00:	b80d883a 	mov	r6,r23
 4007f04:	b00b883a 	mov	r5,r22
 4007f08:	40089b80 	call	40089b8 <memmove>
 4007f0c:	80c00217 	ldw	r3,8(r16)
 4007f10:	81c00017 	ldw	r7,0(r16)
 4007f14:	1dc7c83a 	sub	r3,r3,r23
 4007f18:	3dcf883a 	add	r7,r7,r23
 4007f1c:	80c00215 	stw	r3,8(r16)
 4007f20:	81c00015 	stw	r7,0(r16)
 4007f24:	183ff01e 	bne	r3,zero,4007ee8 <__sfvwrite_r+0x3c8>
 4007f28:	800b883a 	mov	r5,r16
 4007f2c:	9809883a 	mov	r4,r19
 4007f30:	40097840 	call	4009784 <_fflush_r>
 4007f34:	103fec26 	beq	r2,zero,4007ee8 <__sfvwrite_r+0x3c8>
 4007f38:	003fba06 	br	4007e24 <__sfvwrite_r+0x304>
 4007f3c:	9029883a 	mov	r20,r18
 4007f40:	902b883a 	mov	r21,r18
 4007f44:	003f6a06 	br	4007cf0 <__sfvwrite_r+0x1d0>
 4007f48:	b00d883a 	mov	r6,r22
 4007f4c:	a80b883a 	mov	r5,r21
 4007f50:	40089b80 	call	40089b8 <memmove>
 4007f54:	80c00217 	ldw	r3,8(r16)
 4007f58:	80800017 	ldw	r2,0(r16)
 4007f5c:	b025883a 	mov	r18,r22
 4007f60:	1d87c83a 	sub	r3,r3,r22
 4007f64:	1585883a 	add	r2,r2,r22
 4007f68:	80c00215 	stw	r3,8(r16)
 4007f6c:	80800015 	stw	r2,0(r16)
 4007f70:	003f9206 	br	4007dbc <__sfvwrite_r+0x29c>
 4007f74:	a0800044 	addi	r2,r20,1
 4007f78:	102f883a 	mov	r23,r2
 4007f7c:	003f7d06 	br	4007d74 <__sfvwrite_r+0x254>
 4007f80:	280d883a 	mov	r6,r5
 4007f84:	200b883a 	mov	r5,r4
 4007f88:	9809883a 	mov	r4,r19
 4007f8c:	4008ae00 	call	4008ae0 <_realloc_r>
 4007f90:	1007883a 	mov	r3,r2
 4007f94:	103f4e1e 	bne	r2,zero,4007cd0 <__sfvwrite_r+0x1b0>
 4007f98:	81400417 	ldw	r5,16(r16)
 4007f9c:	9809883a 	mov	r4,r19
 4007fa0:	400998c0 	call	400998c <_free_r>
 4007fa4:	8080030b 	ldhu	r2,12(r16)
 4007fa8:	00c00304 	movi	r3,12
 4007fac:	98c00015 	stw	r3,0(r19)
 4007fb0:	10bfdfcc 	andi	r2,r2,65407
 4007fb4:	003f9c06 	br	4007e28 <__sfvwrite_r+0x308>
 4007fb8:	00c00304 	movi	r3,12
 4007fbc:	8080030b 	ldhu	r2,12(r16)
 4007fc0:	98c00015 	stw	r3,0(r19)
 4007fc4:	003f9806 	br	4007e28 <__sfvwrite_r+0x308>

04007fc8 <_fwalk>:
 4007fc8:	defffa04 	addi	sp,sp,-24
 4007fcc:	dd000415 	stw	r20,16(sp)
 4007fd0:	dcc00315 	stw	r19,12(sp)
 4007fd4:	dc800215 	stw	r18,8(sp)
 4007fd8:	dfc00515 	stw	ra,20(sp)
 4007fdc:	dc400115 	stw	r17,4(sp)
 4007fe0:	dc000015 	stw	r16,0(sp)
 4007fe4:	2827883a 	mov	r19,r5
 4007fe8:	2480b804 	addi	r18,r4,736
 4007fec:	0029883a 	mov	r20,zero
 4007ff0:	94400117 	ldw	r17,4(r18)
 4007ff4:	94000217 	ldw	r16,8(r18)
 4007ff8:	8c7fffc4 	addi	r17,r17,-1
 4007ffc:	88000d16 	blt	r17,zero,4008034 <_fwalk+0x6c>
 4008000:	8080030b 	ldhu	r2,12(r16)
 4008004:	8c7fffc4 	addi	r17,r17,-1
 4008008:	108000b0 	cmpltui	r2,r2,2
 400800c:	1000061e 	bne	r2,zero,4008028 <_fwalk+0x60>
 4008010:	8080038f 	ldh	r2,14(r16)
 4008014:	8009883a 	mov	r4,r16
 4008018:	10bfffe0 	cmpeqi	r2,r2,-1
 400801c:	1000021e 	bne	r2,zero,4008028 <_fwalk+0x60>
 4008020:	983ee83a 	callr	r19
 4008024:	a0a8b03a 	or	r20,r20,r2
 4008028:	88bfffd8 	cmpnei	r2,r17,-1
 400802c:	84001a04 	addi	r16,r16,104
 4008030:	103ff31e 	bne	r2,zero,4008000 <_fwalk+0x38>
 4008034:	94800017 	ldw	r18,0(r18)
 4008038:	903fed1e 	bne	r18,zero,4007ff0 <_fwalk+0x28>
 400803c:	a005883a 	mov	r2,r20
 4008040:	dfc00517 	ldw	ra,20(sp)
 4008044:	dd000417 	ldw	r20,16(sp)
 4008048:	dcc00317 	ldw	r19,12(sp)
 400804c:	dc800217 	ldw	r18,8(sp)
 4008050:	dc400117 	ldw	r17,4(sp)
 4008054:	dc000017 	ldw	r16,0(sp)
 4008058:	dec00604 	addi	sp,sp,24
 400805c:	f800283a 	ret

04008060 <_fwalk_reent>:
 4008060:	defff904 	addi	sp,sp,-28
 4008064:	dd400515 	stw	r21,20(sp)
 4008068:	dd000415 	stw	r20,16(sp)
 400806c:	dcc00315 	stw	r19,12(sp)
 4008070:	dc800215 	stw	r18,8(sp)
 4008074:	dfc00615 	stw	ra,24(sp)
 4008078:	dc400115 	stw	r17,4(sp)
 400807c:	dc000015 	stw	r16,0(sp)
 4008080:	2025883a 	mov	r18,r4
 4008084:	2829883a 	mov	r20,r5
 4008088:	24c0b804 	addi	r19,r4,736
 400808c:	002b883a 	mov	r21,zero
 4008090:	9c400117 	ldw	r17,4(r19)
 4008094:	9c000217 	ldw	r16,8(r19)
 4008098:	8c7fffc4 	addi	r17,r17,-1
 400809c:	88000e16 	blt	r17,zero,40080d8 <_fwalk_reent+0x78>
 40080a0:	8080030b 	ldhu	r2,12(r16)
 40080a4:	8c7fffc4 	addi	r17,r17,-1
 40080a8:	108000b0 	cmpltui	r2,r2,2
 40080ac:	1000071e 	bne	r2,zero,40080cc <_fwalk_reent+0x6c>
 40080b0:	8080038f 	ldh	r2,14(r16)
 40080b4:	800b883a 	mov	r5,r16
 40080b8:	9009883a 	mov	r4,r18
 40080bc:	10bfffe0 	cmpeqi	r2,r2,-1
 40080c0:	1000021e 	bne	r2,zero,40080cc <_fwalk_reent+0x6c>
 40080c4:	a03ee83a 	callr	r20
 40080c8:	a8aab03a 	or	r21,r21,r2
 40080cc:	88bfffd8 	cmpnei	r2,r17,-1
 40080d0:	84001a04 	addi	r16,r16,104
 40080d4:	103ff21e 	bne	r2,zero,40080a0 <_fwalk_reent+0x40>
 40080d8:	9cc00017 	ldw	r19,0(r19)
 40080dc:	983fec1e 	bne	r19,zero,4008090 <_fwalk_reent+0x30>
 40080e0:	a805883a 	mov	r2,r21
 40080e4:	dfc00617 	ldw	ra,24(sp)
 40080e8:	dd400517 	ldw	r21,20(sp)
 40080ec:	dd000417 	ldw	r20,16(sp)
 40080f0:	dcc00317 	ldw	r19,12(sp)
 40080f4:	dc800217 	ldw	r18,8(sp)
 40080f8:	dc400117 	ldw	r17,4(sp)
 40080fc:	dc000017 	ldw	r16,0(sp)
 4008100:	dec00704 	addi	sp,sp,28
 4008104:	f800283a 	ret

04008108 <_malloc_r>:
 4008108:	defff604 	addi	sp,sp,-40
 400810c:	dc400115 	stw	r17,4(sp)
 4008110:	2c4002c4 	addi	r17,r5,11
 4008114:	dc800215 	stw	r18,8(sp)
 4008118:	dfc00915 	stw	ra,36(sp)
 400811c:	df000815 	stw	fp,32(sp)
 4008120:	ddc00715 	stw	r23,28(sp)
 4008124:	dd800615 	stw	r22,24(sp)
 4008128:	dd400515 	stw	r21,20(sp)
 400812c:	dd000415 	stw	r20,16(sp)
 4008130:	dcc00315 	stw	r19,12(sp)
 4008134:	dc000015 	stw	r16,0(sp)
 4008138:	888005e8 	cmpgeui	r2,r17,23
 400813c:	2025883a 	mov	r18,r4
 4008140:	1000261e 	bne	r2,zero,40081dc <_malloc_r+0xd4>
 4008144:	29400468 	cmpgeui	r5,r5,17
 4008148:	28008d1e 	bne	r5,zero,4008380 <_malloc_r+0x278>
 400814c:	400aa380 	call	400aa38 <__malloc_lock>
 4008150:	04400404 	movi	r17,16
 4008154:	00800604 	movi	r2,24
 4008158:	01c00084 	movi	r7,2
 400815c:	04c10074 	movhi	r19,1025
 4008160:	9cf36404 	addi	r19,r19,-12912
 4008164:	9885883a 	add	r2,r19,r2
 4008168:	14000117 	ldw	r16,4(r2)
 400816c:	10fffe04 	addi	r3,r2,-8
 4008170:	80c0cb26 	beq	r16,r3,40084a0 <_malloc_r+0x398>
 4008174:	80800117 	ldw	r2,4(r16)
 4008178:	81000317 	ldw	r4,12(r16)
 400817c:	00ffff04 	movi	r3,-4
 4008180:	10c4703a 	and	r2,r2,r3
 4008184:	81400217 	ldw	r5,8(r16)
 4008188:	8085883a 	add	r2,r16,r2
 400818c:	10c00117 	ldw	r3,4(r2)
 4008190:	29000315 	stw	r4,12(r5)
 4008194:	21400215 	stw	r5,8(r4)
 4008198:	18c00054 	ori	r3,r3,1
 400819c:	10c00115 	stw	r3,4(r2)
 40081a0:	9009883a 	mov	r4,r18
 40081a4:	400aa5c0 	call	400aa5c <__malloc_unlock>
 40081a8:	80800204 	addi	r2,r16,8
 40081ac:	dfc00917 	ldw	ra,36(sp)
 40081b0:	df000817 	ldw	fp,32(sp)
 40081b4:	ddc00717 	ldw	r23,28(sp)
 40081b8:	dd800617 	ldw	r22,24(sp)
 40081bc:	dd400517 	ldw	r21,20(sp)
 40081c0:	dd000417 	ldw	r20,16(sp)
 40081c4:	dcc00317 	ldw	r19,12(sp)
 40081c8:	dc800217 	ldw	r18,8(sp)
 40081cc:	dc400117 	ldw	r17,4(sp)
 40081d0:	dc000017 	ldw	r16,0(sp)
 40081d4:	dec00a04 	addi	sp,sp,40
 40081d8:	f800283a 	ret
 40081dc:	00bffe04 	movi	r2,-8
 40081e0:	88a2703a 	and	r17,r17,r2
 40081e4:	88006616 	blt	r17,zero,4008380 <_malloc_r+0x278>
 40081e8:	89406536 	bltu	r17,r5,4008380 <_malloc_r+0x278>
 40081ec:	400aa380 	call	400aa38 <__malloc_lock>
 40081f0:	88807e28 	cmpgeui	r2,r17,504
 40081f4:	1000ef26 	beq	r2,zero,40085b4 <_malloc_r+0x4ac>
 40081f8:	8804d27a 	srli	r2,r17,9
 40081fc:	10006426 	beq	r2,zero,4008390 <_malloc_r+0x288>
 4008200:	10c00168 	cmpgeui	r3,r2,5
 4008204:	1800c31e 	bne	r3,zero,4008514 <_malloc_r+0x40c>
 4008208:	8804d1ba 	srli	r2,r17,6
 400820c:	11c00e44 	addi	r7,r2,57
 4008210:	380890fa 	slli	r4,r7,3
 4008214:	12000e04 	addi	r8,r2,56
 4008218:	04c10074 	movhi	r19,1025
 400821c:	9cf36404 	addi	r19,r19,-12912
 4008220:	9909883a 	add	r4,r19,r4
 4008224:	24000117 	ldw	r16,4(r4)
 4008228:	213ffe04 	addi	r4,r4,-8
 400822c:	24000b26 	beq	r4,r16,400825c <_malloc_r+0x154>
 4008230:	01bfff04 	movi	r6,-4
 4008234:	00000306 	br	4008244 <_malloc_r+0x13c>
 4008238:	1800970e 	bge	r3,zero,4008498 <_malloc_r+0x390>
 400823c:	84000317 	ldw	r16,12(r16)
 4008240:	24000626 	beq	r4,r16,400825c <_malloc_r+0x154>
 4008244:	80800117 	ldw	r2,4(r16)
 4008248:	1184703a 	and	r2,r2,r6
 400824c:	1447c83a 	sub	r3,r2,r17
 4008250:	19400408 	cmpgei	r5,r3,16
 4008254:	283ff826 	beq	r5,zero,4008238 <_malloc_r+0x130>
 4008258:	400f883a 	mov	r7,r8
 400825c:	9c000417 	ldw	r16,16(r19)
 4008260:	02410074 	movhi	r9,1025
 4008264:	4a736604 	addi	r9,r9,-12904
 4008268:	82407f26 	beq	r16,r9,4008468 <_malloc_r+0x360>
 400826c:	80800117 	ldw	r2,4(r16)
 4008270:	00ffff04 	movi	r3,-4
 4008274:	10c4703a 	and	r2,r2,r3
 4008278:	1447c83a 	sub	r3,r2,r17
 400827c:	19000410 	cmplti	r4,r3,16
 4008280:	2000cf26 	beq	r4,zero,40085c0 <_malloc_r+0x4b8>
 4008284:	9a400515 	stw	r9,20(r19)
 4008288:	9a400415 	stw	r9,16(r19)
 400828c:	1800c10e 	bge	r3,zero,4008594 <_malloc_r+0x48c>
 4008290:	10c08028 	cmpgeui	r3,r2,512
 4008294:	99400117 	ldw	r5,4(r19)
 4008298:	1800851e 	bne	r3,zero,40084b0 <_malloc_r+0x3a8>
 400829c:	1006d0fa 	srli	r3,r2,3
 40082a0:	1008d17a 	srli	r4,r2,5
 40082a4:	18800044 	addi	r2,r3,1
 40082a8:	100490fa 	slli	r2,r2,3
 40082ac:	00c00044 	movi	r3,1
 40082b0:	1906983a 	sll	r3,r3,r4
 40082b4:	9885883a 	add	r2,r19,r2
 40082b8:	11000017 	ldw	r4,0(r2)
 40082bc:	28cab03a 	or	r5,r5,r3
 40082c0:	10fffe04 	addi	r3,r2,-8
 40082c4:	80c00315 	stw	r3,12(r16)
 40082c8:	81000215 	stw	r4,8(r16)
 40082cc:	99400115 	stw	r5,4(r19)
 40082d0:	14000015 	stw	r16,0(r2)
 40082d4:	24000315 	stw	r16,12(r4)
 40082d8:	3805d0ba 	srai	r2,r7,2
 40082dc:	01000044 	movi	r4,1
 40082e0:	2088983a 	sll	r4,r4,r2
 40082e4:	29002e36 	bltu	r5,r4,40083a0 <_malloc_r+0x298>
 40082e8:	2144703a 	and	r2,r4,r5
 40082ec:	10000a1e 	bne	r2,zero,4008318 <_malloc_r+0x210>
 40082f0:	2109883a 	add	r4,r4,r4
 40082f4:	00bfff04 	movi	r2,-4
 40082f8:	3884703a 	and	r2,r7,r2
 40082fc:	2146703a 	and	r3,r4,r5
 4008300:	11c00104 	addi	r7,r2,4
 4008304:	1800041e 	bne	r3,zero,4008318 <_malloc_r+0x210>
 4008308:	2109883a 	add	r4,r4,r4
 400830c:	2144703a 	and	r2,r4,r5
 4008310:	39c00104 	addi	r7,r7,4
 4008314:	103ffc26 	beq	r2,zero,4008308 <_malloc_r+0x200>
 4008318:	02bfff04 	movi	r10,-4
 400831c:	381690fa 	slli	r11,r7,3
 4008320:	3819883a 	mov	r12,r7
 4008324:	9ad7883a 	add	r11,r19,r11
 4008328:	5811883a 	mov	r8,r11
 400832c:	40800317 	ldw	r2,12(r8)
 4008330:	40808126 	beq	r8,r2,4008538 <_malloc_r+0x430>
 4008334:	10c00117 	ldw	r3,4(r2)
 4008338:	1021883a 	mov	r16,r2
 400833c:	10800317 	ldw	r2,12(r2)
 4008340:	1a86703a 	and	r3,r3,r10
 4008344:	1c4bc83a 	sub	r5,r3,r17
 4008348:	29800410 	cmplti	r6,r5,16
 400834c:	30007f26 	beq	r6,zero,400854c <_malloc_r+0x444>
 4008350:	283ff716 	blt	r5,zero,4008330 <_malloc_r+0x228>
 4008354:	80c7883a 	add	r3,r16,r3
 4008358:	19400117 	ldw	r5,4(r3)
 400835c:	81800217 	ldw	r6,8(r16)
 4008360:	9009883a 	mov	r4,r18
 4008364:	29400054 	ori	r5,r5,1
 4008368:	19400115 	stw	r5,4(r3)
 400836c:	30800315 	stw	r2,12(r6)
 4008370:	11800215 	stw	r6,8(r2)
 4008374:	400aa5c0 	call	400aa5c <__malloc_unlock>
 4008378:	80800204 	addi	r2,r16,8
 400837c:	003f8b06 	br	40081ac <_malloc_r+0xa4>
 4008380:	00800304 	movi	r2,12
 4008384:	90800015 	stw	r2,0(r18)
 4008388:	0005883a 	mov	r2,zero
 400838c:	003f8706 	br	40081ac <_malloc_r+0xa4>
 4008390:	01008004 	movi	r4,512
 4008394:	01c01004 	movi	r7,64
 4008398:	02000fc4 	movi	r8,63
 400839c:	003f9e06 	br	4008218 <_malloc_r+0x110>
 40083a0:	9c000217 	ldw	r16,8(r19)
 40083a4:	00bfff04 	movi	r2,-4
 40083a8:	80c00117 	ldw	r3,4(r16)
 40083ac:	18aa703a 	and	r21,r3,r2
 40083b0:	ac400336 	bltu	r21,r17,40083c0 <_malloc_r+0x2b8>
 40083b4:	ac47c83a 	sub	r3,r21,r17
 40083b8:	18800408 	cmpgei	r2,r3,16
 40083bc:	10002c1e 	bne	r2,zero,4008470 <_malloc_r+0x368>
 40083c0:	00810074 	movhi	r2,1025
 40083c4:	10b8eb17 	ldw	r2,-7252(r2)
 40083c8:	00c10074 	movhi	r3,1025
 40083cc:	1d3fa717 	ldw	r20,-356(r3)
 40083d0:	10bfffd8 	cmpnei	r2,r2,-1
 40083d4:	856f883a 	add	r23,r16,r21
 40083d8:	8d29883a 	add	r20,r17,r20
 40083dc:	1000e726 	beq	r2,zero,400877c <_malloc_r+0x674>
 40083e0:	a50403c4 	addi	r20,r20,4111
 40083e4:	00bc0004 	movi	r2,-4096
 40083e8:	a0a8703a 	and	r20,r20,r2
 40083ec:	a00b883a 	mov	r5,r20
 40083f0:	9009883a 	mov	r4,r18
 40083f4:	40090d40 	call	40090d4 <_sbrk_r>
 40083f8:	102d883a 	mov	r22,r2
 40083fc:	10bfffd8 	cmpnei	r2,r2,-1
 4008400:	10008426 	beq	r2,zero,4008614 <_malloc_r+0x50c>
 4008404:	b5c08236 	bltu	r22,r23,4008610 <_malloc_r+0x508>
 4008408:	00812074 	movhi	r2,1153
 400840c:	113fe317 	ldw	r4,-116(r2)
 4008410:	a109883a 	add	r4,r20,r4
 4008414:	113fe315 	stw	r4,-116(r2)
 4008418:	2007883a 	mov	r3,r4
 400841c:	bd80a51e 	bne	r23,r22,40086b4 <_malloc_r+0x5ac>
 4008420:	b083ffcc 	andi	r2,r22,4095
 4008424:	1000a31e 	bne	r2,zero,40086b4 <_malloc_r+0x5ac>
 4008428:	9d800217 	ldw	r22,8(r19)
 400842c:	ad07883a 	add	r3,r21,r20
 4008430:	18c00054 	ori	r3,r3,1
 4008434:	b0c00115 	stw	r3,4(r22)
 4008438:	00810074 	movhi	r2,1025
 400843c:	10bfa617 	ldw	r2,-360(r2)
 4008440:	1100022e 	bgeu	r2,r4,400844c <_malloc_r+0x344>
 4008444:	00810074 	movhi	r2,1025
 4008448:	113fa615 	stw	r4,-360(r2)
 400844c:	00810074 	movhi	r2,1025
 4008450:	10bfa517 	ldw	r2,-364(r2)
 4008454:	1100022e 	bgeu	r2,r4,4008460 <_malloc_r+0x358>
 4008458:	00810074 	movhi	r2,1025
 400845c:	113fa515 	stw	r4,-364(r2)
 4008460:	b021883a 	mov	r16,r22
 4008464:	00006d06 	br	400861c <_malloc_r+0x514>
 4008468:	99400117 	ldw	r5,4(r19)
 400846c:	003f9a06 	br	40082d8 <_malloc_r+0x1d0>
 4008470:	88800054 	ori	r2,r17,1
 4008474:	80800115 	stw	r2,4(r16)
 4008478:	8463883a 	add	r17,r16,r17
 400847c:	9c400215 	stw	r17,8(r19)
 4008480:	18c00054 	ori	r3,r3,1
 4008484:	88c00115 	stw	r3,4(r17)
 4008488:	9009883a 	mov	r4,r18
 400848c:	400aa5c0 	call	400aa5c <__malloc_unlock>
 4008490:	80800204 	addi	r2,r16,8
 4008494:	003f4506 	br	40081ac <_malloc_r+0xa4>
 4008498:	81000317 	ldw	r4,12(r16)
 400849c:	003f3906 	br	4008184 <_malloc_r+0x7c>
 40084a0:	14000317 	ldw	r16,12(r2)
 40084a4:	143f331e 	bne	r2,r16,4008174 <_malloc_r+0x6c>
 40084a8:	39c00084 	addi	r7,r7,2
 40084ac:	003f6b06 	br	400825c <_malloc_r+0x154>
 40084b0:	1006d27a 	srli	r3,r2,9
 40084b4:	19000168 	cmpgeui	r4,r3,5
 40084b8:	20005026 	beq	r4,zero,40085fc <_malloc_r+0x4f4>
 40084bc:	19000568 	cmpgeui	r4,r3,21
 40084c0:	2000c01e 	bne	r4,zero,40087c4 <_malloc_r+0x6bc>
 40084c4:	19801704 	addi	r6,r3,92
 40084c8:	300c90fa 	slli	r6,r6,3
 40084cc:	190016c4 	addi	r4,r3,91
 40084d0:	998d883a 	add	r6,r19,r6
 40084d4:	30c00017 	ldw	r3,0(r6)
 40084d8:	31bffe04 	addi	r6,r6,-8
 40084dc:	30c0a926 	beq	r6,r3,4008784 <_malloc_r+0x67c>
 40084e0:	023fff04 	movi	r8,-4
 40084e4:	00000206 	br	40084f0 <_malloc_r+0x3e8>
 40084e8:	18c00217 	ldw	r3,8(r3)
 40084ec:	30c00326 	beq	r6,r3,40084fc <_malloc_r+0x3f4>
 40084f0:	19000117 	ldw	r4,4(r3)
 40084f4:	2208703a 	and	r4,r4,r8
 40084f8:	113ffb36 	bltu	r2,r4,40084e8 <_malloc_r+0x3e0>
 40084fc:	19800317 	ldw	r6,12(r3)
 4008500:	81800315 	stw	r6,12(r16)
 4008504:	80c00215 	stw	r3,8(r16)
 4008508:	34000215 	stw	r16,8(r6)
 400850c:	1c000315 	stw	r16,12(r3)
 4008510:	003f7106 	br	40082d8 <_malloc_r+0x1d0>
 4008514:	10c00568 	cmpgeui	r3,r2,21
 4008518:	18004926 	beq	r3,zero,4008640 <_malloc_r+0x538>
 400851c:	10c01568 	cmpgeui	r3,r2,85
 4008520:	1800af1e 	bne	r3,zero,40087e0 <_malloc_r+0x6d8>
 4008524:	8804d33a 	srli	r2,r17,12
 4008528:	11c01bc4 	addi	r7,r2,111
 400852c:	380890fa 	slli	r4,r7,3
 4008530:	12001b84 	addi	r8,r2,110
 4008534:	003f3806 	br	4008218 <_malloc_r+0x110>
 4008538:	63000044 	addi	r12,r12,1
 400853c:	608000cc 	andi	r2,r12,3
 4008540:	42000204 	addi	r8,r8,8
 4008544:	103f791e 	bne	r2,zero,400832c <_malloc_r+0x224>
 4008548:	00004406 	br	400865c <_malloc_r+0x554>
 400854c:	81000217 	ldw	r4,8(r16)
 4008550:	89800054 	ori	r6,r17,1
 4008554:	81800115 	stw	r6,4(r16)
 4008558:	20800315 	stw	r2,12(r4)
 400855c:	11000215 	stw	r4,8(r2)
 4008560:	8463883a 	add	r17,r16,r17
 4008564:	9c400515 	stw	r17,20(r19)
 4008568:	9c400415 	stw	r17,16(r19)
 400856c:	28800054 	ori	r2,r5,1
 4008570:	88800115 	stw	r2,4(r17)
 4008574:	8a400315 	stw	r9,12(r17)
 4008578:	8a400215 	stw	r9,8(r17)
 400857c:	80c7883a 	add	r3,r16,r3
 4008580:	19400015 	stw	r5,0(r3)
 4008584:	9009883a 	mov	r4,r18
 4008588:	400aa5c0 	call	400aa5c <__malloc_unlock>
 400858c:	80800204 	addi	r2,r16,8
 4008590:	003f0606 	br	40081ac <_malloc_r+0xa4>
 4008594:	8085883a 	add	r2,r16,r2
 4008598:	10c00117 	ldw	r3,4(r2)
 400859c:	9009883a 	mov	r4,r18
 40085a0:	18c00054 	ori	r3,r3,1
 40085a4:	10c00115 	stw	r3,4(r2)
 40085a8:	400aa5c0 	call	400aa5c <__malloc_unlock>
 40085ac:	80800204 	addi	r2,r16,8
 40085b0:	003efe06 	br	40081ac <_malloc_r+0xa4>
 40085b4:	880ed0fa 	srli	r7,r17,3
 40085b8:	88800204 	addi	r2,r17,8
 40085bc:	003ee706 	br	400815c <_malloc_r+0x54>
 40085c0:	89000054 	ori	r4,r17,1
 40085c4:	81000115 	stw	r4,4(r16)
 40085c8:	8463883a 	add	r17,r16,r17
 40085cc:	9c400515 	stw	r17,20(r19)
 40085d0:	9c400415 	stw	r17,16(r19)
 40085d4:	19000054 	ori	r4,r3,1
 40085d8:	89000115 	stw	r4,4(r17)
 40085dc:	8085883a 	add	r2,r16,r2
 40085e0:	8a400315 	stw	r9,12(r17)
 40085e4:	8a400215 	stw	r9,8(r17)
 40085e8:	10c00015 	stw	r3,0(r2)
 40085ec:	9009883a 	mov	r4,r18
 40085f0:	400aa5c0 	call	400aa5c <__malloc_unlock>
 40085f4:	80800204 	addi	r2,r16,8
 40085f8:	003eec06 	br	40081ac <_malloc_r+0xa4>
 40085fc:	1006d1ba 	srli	r3,r2,6
 4008600:	19800e44 	addi	r6,r3,57
 4008604:	300c90fa 	slli	r6,r6,3
 4008608:	19000e04 	addi	r4,r3,56
 400860c:	003fb006 	br	40084d0 <_malloc_r+0x3c8>
 4008610:	84c02426 	beq	r16,r19,40086a4 <_malloc_r+0x59c>
 4008614:	9c000217 	ldw	r16,8(r19)
 4008618:	80c00117 	ldw	r3,4(r16)
 400861c:	00bfff04 	movi	r2,-4
 4008620:	1884703a 	and	r2,r3,r2
 4008624:	1447c83a 	sub	r3,r2,r17
 4008628:	14400236 	bltu	r2,r17,4008634 <_malloc_r+0x52c>
 400862c:	18800408 	cmpgei	r2,r3,16
 4008630:	103f8f1e 	bne	r2,zero,4008470 <_malloc_r+0x368>
 4008634:	9009883a 	mov	r4,r18
 4008638:	400aa5c0 	call	400aa5c <__malloc_unlock>
 400863c:	003f5206 	br	4008388 <_malloc_r+0x280>
 4008640:	11c01704 	addi	r7,r2,92
 4008644:	380890fa 	slli	r4,r7,3
 4008648:	120016c4 	addi	r8,r2,91
 400864c:	003ef206 	br	4008218 <_malloc_r+0x110>
 4008650:	58800217 	ldw	r2,8(r11)
 4008654:	39ffffc4 	addi	r7,r7,-1
 4008658:	12c0961e 	bne	r2,r11,40088b4 <_malloc_r+0x7ac>
 400865c:	388000cc 	andi	r2,r7,3
 4008660:	5afffe04 	addi	r11,r11,-8
 4008664:	103ffa1e 	bne	r2,zero,4008650 <_malloc_r+0x548>
 4008668:	98c00117 	ldw	r3,4(r19)
 400866c:	0104303a 	nor	r2,zero,r4
 4008670:	10c4703a 	and	r2,r2,r3
 4008674:	98800115 	stw	r2,4(r19)
 4008678:	2109883a 	add	r4,r4,r4
 400867c:	113f4836 	bltu	r2,r4,40083a0 <_malloc_r+0x298>
 4008680:	203f4726 	beq	r4,zero,40083a0 <_malloc_r+0x298>
 4008684:	2086703a 	and	r3,r4,r2
 4008688:	1800041e 	bne	r3,zero,400869c <_malloc_r+0x594>
 400868c:	2109883a 	add	r4,r4,r4
 4008690:	2086703a 	and	r3,r4,r2
 4008694:	63000104 	addi	r12,r12,4
 4008698:	183ffc26 	beq	r3,zero,400868c <_malloc_r+0x584>
 400869c:	600f883a 	mov	r7,r12
 40086a0:	003f1e06 	br	400831c <_malloc_r+0x214>
 40086a4:	00812074 	movhi	r2,1153
 40086a8:	10ffe317 	ldw	r3,-116(r2)
 40086ac:	a0c7883a 	add	r3,r20,r3
 40086b0:	10ffe315 	stw	r3,-116(r2)
 40086b4:	00810074 	movhi	r2,1025
 40086b8:	10b8eb17 	ldw	r2,-7252(r2)
 40086bc:	10bfffd8 	cmpnei	r2,r2,-1
 40086c0:	10004e26 	beq	r2,zero,40087fc <_malloc_r+0x6f4>
 40086c4:	b5c5c83a 	sub	r2,r22,r23
 40086c8:	10c5883a 	add	r2,r2,r3
 40086cc:	00c12074 	movhi	r3,1153
 40086d0:	18bfe315 	stw	r2,-116(r3)
 40086d4:	b70001cc 	andi	fp,r22,7
 40086d8:	e0003026 	beq	fp,zero,400879c <_malloc_r+0x694>
 40086dc:	b72dc83a 	sub	r22,r22,fp
 40086e0:	b5800204 	addi	r22,r22,8
 40086e4:	01040204 	movi	r4,4104
 40086e8:	2709c83a 	sub	r4,r4,fp
 40086ec:	b529883a 	add	r20,r22,r20
 40086f0:	2509c83a 	sub	r4,r4,r20
 40086f4:	25c3ffcc 	andi	r23,r4,4095
 40086f8:	b80b883a 	mov	r5,r23
 40086fc:	9009883a 	mov	r4,r18
 4008700:	40090d40 	call	40090d4 <_sbrk_r>
 4008704:	10ffffe0 	cmpeqi	r3,r2,-1
 4008708:	1800501e 	bne	r3,zero,400884c <_malloc_r+0x744>
 400870c:	1585c83a 	sub	r2,r2,r22
 4008710:	15e9883a 	add	r20,r2,r23
 4008714:	00812074 	movhi	r2,1153
 4008718:	10bfe317 	ldw	r2,-116(r2)
 400871c:	9d800215 	stw	r22,8(r19)
 4008720:	a0c00054 	ori	r3,r20,1
 4008724:	b889883a 	add	r4,r23,r2
 4008728:	00812074 	movhi	r2,1153
 400872c:	113fe315 	stw	r4,-116(r2)
 4008730:	b0c00115 	stw	r3,4(r22)
 4008734:	84ff4026 	beq	r16,r19,4008438 <_malloc_r+0x330>
 4008738:	a8800428 	cmpgeui	r2,r21,16
 400873c:	10003226 	beq	r2,zero,4008808 <_malloc_r+0x700>
 4008740:	80800117 	ldw	r2,4(r16)
 4008744:	017ffe04 	movi	r5,-8
 4008748:	a8fffd04 	addi	r3,r21,-12
 400874c:	1946703a 	and	r3,r3,r5
 4008750:	1080004c 	andi	r2,r2,1
 4008754:	10c4b03a 	or	r2,r2,r3
 4008758:	80800115 	stw	r2,4(r16)
 400875c:	01400144 	movi	r5,5
 4008760:	80c5883a 	add	r2,r16,r3
 4008764:	11400115 	stw	r5,4(r2)
 4008768:	11400215 	stw	r5,8(r2)
 400876c:	18c00428 	cmpgeui	r3,r3,16
 4008770:	18003b1e 	bne	r3,zero,4008860 <_malloc_r+0x758>
 4008774:	b0c00117 	ldw	r3,4(r22)
 4008778:	003f2f06 	br	4008438 <_malloc_r+0x330>
 400877c:	a5000404 	addi	r20,r20,16
 4008780:	003f1a06 	br	40083ec <_malloc_r+0x2e4>
 4008784:	2009d0ba 	srai	r4,r4,2
 4008788:	00800044 	movi	r2,1
 400878c:	1104983a 	sll	r2,r2,r4
 4008790:	288ab03a 	or	r5,r5,r2
 4008794:	99400115 	stw	r5,4(r19)
 4008798:	003f5906 	br	4008500 <_malloc_r+0x3f8>
 400879c:	b509883a 	add	r4,r22,r20
 40087a0:	0109c83a 	sub	r4,zero,r4
 40087a4:	25c3ffcc 	andi	r23,r4,4095
 40087a8:	b80b883a 	mov	r5,r23
 40087ac:	9009883a 	mov	r4,r18
 40087b0:	40090d40 	call	40090d4 <_sbrk_r>
 40087b4:	10ffffe0 	cmpeqi	r3,r2,-1
 40087b8:	183fd426 	beq	r3,zero,400870c <_malloc_r+0x604>
 40087bc:	002f883a 	mov	r23,zero
 40087c0:	003fd406 	br	4008714 <_malloc_r+0x60c>
 40087c4:	19001568 	cmpgeui	r4,r3,85
 40087c8:	2000121e 	bne	r4,zero,4008814 <_malloc_r+0x70c>
 40087cc:	1006d33a 	srli	r3,r2,12
 40087d0:	19801bc4 	addi	r6,r3,111
 40087d4:	300c90fa 	slli	r6,r6,3
 40087d8:	19001b84 	addi	r4,r3,110
 40087dc:	003f3c06 	br	40084d0 <_malloc_r+0x3c8>
 40087e0:	10c05568 	cmpgeui	r3,r2,341
 40087e4:	1800121e 	bne	r3,zero,4008830 <_malloc_r+0x728>
 40087e8:	8804d3fa 	srli	r2,r17,15
 40087ec:	11c01e04 	addi	r7,r2,120
 40087f0:	380890fa 	slli	r4,r7,3
 40087f4:	12001dc4 	addi	r8,r2,119
 40087f8:	003e8706 	br	4008218 <_malloc_r+0x110>
 40087fc:	00810074 	movhi	r2,1025
 4008800:	15b8eb15 	stw	r22,-7252(r2)
 4008804:	003fb306 	br	40086d4 <_malloc_r+0x5cc>
 4008808:	00800044 	movi	r2,1
 400880c:	b0800115 	stw	r2,4(r22)
 4008810:	003f8806 	br	4008634 <_malloc_r+0x52c>
 4008814:	19005568 	cmpgeui	r4,r3,341
 4008818:	2000181e 	bne	r4,zero,400887c <_malloc_r+0x774>
 400881c:	1006d3fa 	srli	r3,r2,15
 4008820:	19801e04 	addi	r6,r3,120
 4008824:	300c90fa 	slli	r6,r6,3
 4008828:	19001dc4 	addi	r4,r3,119
 400882c:	003f2806 	br	40084d0 <_malloc_r+0x3c8>
 4008830:	10815568 	cmpgeui	r2,r2,1365
 4008834:	1000181e 	bne	r2,zero,4008898 <_malloc_r+0x790>
 4008838:	8804d4ba 	srli	r2,r17,18
 400883c:	11c01f44 	addi	r7,r2,125
 4008840:	380890fa 	slli	r4,r7,3
 4008844:	12001f04 	addi	r8,r2,124
 4008848:	003e7306 	br	4008218 <_malloc_r+0x110>
 400884c:	e73ffe04 	addi	fp,fp,-8
 4008850:	a729883a 	add	r20,r20,fp
 4008854:	a5a9c83a 	sub	r20,r20,r22
 4008858:	002f883a 	mov	r23,zero
 400885c:	003fad06 	br	4008714 <_malloc_r+0x60c>
 4008860:	9009883a 	mov	r4,r18
 4008864:	81400204 	addi	r5,r16,8
 4008868:	400998c0 	call	400998c <_free_r>
 400886c:	00812074 	movhi	r2,1153
 4008870:	9d800217 	ldw	r22,8(r19)
 4008874:	113fe317 	ldw	r4,-116(r2)
 4008878:	003fbe06 	br	4008774 <_malloc_r+0x66c>
 400887c:	18c15568 	cmpgeui	r3,r3,1365
 4008880:	1800091e 	bne	r3,zero,40088a8 <_malloc_r+0x7a0>
 4008884:	1006d4ba 	srli	r3,r2,18
 4008888:	19801f44 	addi	r6,r3,125
 400888c:	300c90fa 	slli	r6,r6,3
 4008890:	19001f04 	addi	r4,r3,124
 4008894:	003f0e06 	br	40084d0 <_malloc_r+0x3c8>
 4008898:	0100fe04 	movi	r4,1016
 400889c:	01c01fc4 	movi	r7,127
 40088a0:	02001f84 	movi	r8,126
 40088a4:	003e5c06 	br	4008218 <_malloc_r+0x110>
 40088a8:	0180fe04 	movi	r6,1016
 40088ac:	01001f84 	movi	r4,126
 40088b0:	003f0706 	br	40084d0 <_malloc_r+0x3c8>
 40088b4:	98800117 	ldw	r2,4(r19)
 40088b8:	003f6f06 	br	4008678 <_malloc_r+0x570>

040088bc <memchr>:
 40088bc:	defffc04 	addi	sp,sp,-16
 40088c0:	dc000015 	stw	r16,0(sp)
 40088c4:	2021883a 	mov	r16,r4
 40088c8:	dc800215 	stw	r18,8(sp)
 40088cc:	dfc00315 	stw	ra,12(sp)
 40088d0:	dc400115 	stw	r17,4(sp)
 40088d4:	808000cc 	andi	r2,r16,3
 40088d8:	2809883a 	mov	r4,r5
 40088dc:	2825883a 	mov	r18,r5
 40088e0:	10000e26 	beq	r2,zero,400891c <memchr+0x60>
 40088e4:	347fffc4 	addi	r17,r6,-1
 40088e8:	30001726 	beq	r6,zero,4008948 <memchr+0x8c>
 40088ec:	28c03fcc 	andi	r3,r5,255
 40088f0:	00000606 	br	400890c <memchr+0x50>
 40088f4:	84000044 	addi	r16,r16,1
 40088f8:	808000cc 	andi	r2,r16,3
 40088fc:	10000826 	beq	r2,zero,4008920 <memchr+0x64>
 4008900:	8c7fffc4 	addi	r17,r17,-1
 4008904:	88bfffe0 	cmpeqi	r2,r17,-1
 4008908:	10000f1e 	bne	r2,zero,4008948 <memchr+0x8c>
 400890c:	80800003 	ldbu	r2,0(r16)
 4008910:	10fff81e 	bne	r2,r3,40088f4 <memchr+0x38>
 4008914:	8005883a 	mov	r2,r16
 4008918:	00000c06 	br	400894c <memchr+0x90>
 400891c:	3023883a 	mov	r17,r6
 4008920:	88800130 	cmpltui	r2,r17,4
 4008924:	10000f26 	beq	r2,zero,4008964 <memchr+0xa8>
 4008928:	88000726 	beq	r17,zero,4008948 <memchr+0x8c>
 400892c:	8463883a 	add	r17,r16,r17
 4008930:	8005883a 	mov	r2,r16
 4008934:	90c03fcc 	andi	r3,r18,255
 4008938:	11000003 	ldbu	r4,0(r2)
 400893c:	20c00326 	beq	r4,r3,400894c <memchr+0x90>
 4008940:	10800044 	addi	r2,r2,1
 4008944:	88bffc1e 	bne	r17,r2,4008938 <memchr+0x7c>
 4008948:	0005883a 	mov	r2,zero
 400894c:	dfc00317 	ldw	ra,12(sp)
 4008950:	dc800217 	ldw	r18,8(sp)
 4008954:	dc400117 	ldw	r17,4(sp)
 4008958:	dc000017 	ldw	r16,0(sp)
 400895c:	dec00404 	addi	sp,sp,16
 4008960:	f800283a 	ret
 4008964:	01404074 	movhi	r5,257
 4008968:	29404044 	addi	r5,r5,257
 400896c:	21003fcc 	andi	r4,r4,255
 4008970:	40073b40 	call	40073b4 <__mulsi3>
 4008974:	01bfbff4 	movhi	r6,65279
 4008978:	01602074 	movhi	r5,32897
 400897c:	31bfbfc4 	addi	r6,r6,-257
 4008980:	29602004 	addi	r5,r5,-32640
 4008984:	00000406 	br	4008998 <memchr+0xdc>
 4008988:	8c7fff04 	addi	r17,r17,-4
 400898c:	88c00128 	cmpgeui	r3,r17,4
 4008990:	84000104 	addi	r16,r16,4
 4008994:	183fe426 	beq	r3,zero,4008928 <memchr+0x6c>
 4008998:	80c00017 	ldw	r3,0(r16)
 400899c:	10c6f03a 	xor	r3,r2,r3
 40089a0:	1989883a 	add	r4,r3,r6
 40089a4:	00c6303a 	nor	r3,zero,r3
 40089a8:	20c6703a 	and	r3,r4,r3
 40089ac:	1946703a 	and	r3,r3,r5
 40089b0:	183ff526 	beq	r3,zero,4008988 <memchr+0xcc>
 40089b4:	003fdc06 	br	4008928 <memchr+0x6c>

040089b8 <memmove>:
 40089b8:	2005883a 	mov	r2,r4
 40089bc:	29000a2e 	bgeu	r5,r4,40089e8 <memmove+0x30>
 40089c0:	298f883a 	add	r7,r5,r6
 40089c4:	21c0082e 	bgeu	r4,r7,40089e8 <memmove+0x30>
 40089c8:	2187883a 	add	r3,r4,r6
 40089cc:	30001226 	beq	r6,zero,4008a18 <memmove+0x60>
 40089d0:	397fffc3 	ldbu	r5,-1(r7)
 40089d4:	18ffffc4 	addi	r3,r3,-1
 40089d8:	39ffffc4 	addi	r7,r7,-1
 40089dc:	19400005 	stb	r5,0(r3)
 40089e0:	10fffb1e 	bne	r2,r3,40089d0 <memmove+0x18>
 40089e4:	f800283a 	ret
 40089e8:	30c00428 	cmpgeui	r3,r6,16
 40089ec:	18000b1e 	bne	r3,zero,4008a1c <memmove+0x64>
 40089f0:	1007883a 	mov	r3,r2
 40089f4:	31ffffc4 	addi	r7,r6,-1
 40089f8:	30003626 	beq	r6,zero,4008ad4 <memmove+0x11c>
 40089fc:	39c00044 	addi	r7,r7,1
 4008a00:	19cf883a 	add	r7,r3,r7
 4008a04:	29800003 	ldbu	r6,0(r5)
 4008a08:	18c00044 	addi	r3,r3,1
 4008a0c:	29400044 	addi	r5,r5,1
 4008a10:	19bfffc5 	stb	r6,-1(r3)
 4008a14:	19fffb1e 	bne	r3,r7,4008a04 <memmove+0x4c>
 4008a18:	f800283a 	ret
 4008a1c:	1146b03a 	or	r3,r2,r5
 4008a20:	18c000cc 	andi	r3,r3,3
 4008a24:	1800281e 	bne	r3,zero,4008ac8 <memmove+0x110>
 4008a28:	313ffc04 	addi	r4,r6,-16
 4008a2c:	2008d13a 	srli	r4,r4,4
 4008a30:	2811883a 	mov	r8,r5
 4008a34:	100f883a 	mov	r7,r2
 4008a38:	21000044 	addi	r4,r4,1
 4008a3c:	2008913a 	slli	r4,r4,4
 4008a40:	1107883a 	add	r3,r2,r4
 4008a44:	42400017 	ldw	r9,0(r8)
 4008a48:	42000404 	addi	r8,r8,16
 4008a4c:	39c00404 	addi	r7,r7,16
 4008a50:	3a7ffc15 	stw	r9,-16(r7)
 4008a54:	427ffd17 	ldw	r9,-12(r8)
 4008a58:	3a7ffd15 	stw	r9,-12(r7)
 4008a5c:	427ffe17 	ldw	r9,-8(r8)
 4008a60:	3a7ffe15 	stw	r9,-8(r7)
 4008a64:	427fff17 	ldw	r9,-4(r8)
 4008a68:	3a7fff15 	stw	r9,-4(r7)
 4008a6c:	38fff51e 	bne	r7,r3,4008a44 <memmove+0x8c>
 4008a70:	31c0030c 	andi	r7,r6,12
 4008a74:	290b883a 	add	r5,r5,r4
 4008a78:	324003cc 	andi	r9,r6,15
 4008a7c:	38001626 	beq	r7,zero,4008ad8 <memmove+0x120>
 4008a80:	2809883a 	mov	r4,r5
 4008a84:	180f883a 	mov	r7,r3
 4008a88:	1a57883a 	add	r11,r3,r9
 4008a8c:	22800017 	ldw	r10,0(r4)
 4008a90:	39c00104 	addi	r7,r7,4
 4008a94:	59d1c83a 	sub	r8,r11,r7
 4008a98:	42000128 	cmpgeui	r8,r8,4
 4008a9c:	3abfff15 	stw	r10,-4(r7)
 4008aa0:	21000104 	addi	r4,r4,4
 4008aa4:	403ff91e 	bne	r8,zero,4008a8c <memmove+0xd4>
 4008aa8:	493fff04 	addi	r4,r9,-4
 4008aac:	2008d0ba 	srli	r4,r4,2
 4008ab0:	318000cc 	andi	r6,r6,3
 4008ab4:	21000044 	addi	r4,r4,1
 4008ab8:	200890ba 	slli	r4,r4,2
 4008abc:	1907883a 	add	r3,r3,r4
 4008ac0:	290b883a 	add	r5,r5,r4
 4008ac4:	003fcb06 	br	40089f4 <memmove+0x3c>
 4008ac8:	31ffffc4 	addi	r7,r6,-1
 4008acc:	1007883a 	mov	r3,r2
 4008ad0:	003fca06 	br	40089fc <memmove+0x44>
 4008ad4:	f800283a 	ret
 4008ad8:	480d883a 	mov	r6,r9
 4008adc:	003fc506 	br	40089f4 <memmove+0x3c>

04008ae0 <_realloc_r>:
 4008ae0:	defff504 	addi	sp,sp,-44
 4008ae4:	dd000515 	stw	r20,20(sp)
 4008ae8:	dfc00a15 	stw	ra,40(sp)
 4008aec:	df000915 	stw	fp,36(sp)
 4008af0:	ddc00815 	stw	r23,32(sp)
 4008af4:	dd800715 	stw	r22,28(sp)
 4008af8:	dd400615 	stw	r21,24(sp)
 4008afc:	dcc00415 	stw	r19,16(sp)
 4008b00:	dc800315 	stw	r18,12(sp)
 4008b04:	dc400215 	stw	r17,8(sp)
 4008b08:	dc000115 	stw	r16,4(sp)
 4008b0c:	3029883a 	mov	r20,r6
 4008b10:	28008a26 	beq	r5,zero,4008d3c <_realloc_r+0x25c>
 4008b14:	2821883a 	mov	r16,r5
 4008b18:	202b883a 	mov	r21,r4
 4008b1c:	400aa380 	call	400aa38 <__malloc_lock>
 4008b20:	84ffff17 	ldw	r19,-4(r16)
 4008b24:	a44002c4 	addi	r17,r20,11
 4008b28:	04bfff04 	movi	r18,-4
 4008b2c:	888005f0 	cmpltui	r2,r17,23
 4008b30:	85bffe04 	addi	r22,r16,-8
 4008b34:	9ca4703a 	and	r18,r19,r18
 4008b38:	10005a1e 	bne	r2,zero,4008ca4 <_realloc_r+0x1c4>
 4008b3c:	00bffe04 	movi	r2,-8
 4008b40:	88a2703a 	and	r17,r17,r2
 4008b44:	88005916 	blt	r17,zero,4008cac <_realloc_r+0x1cc>
 4008b48:	8d005836 	bltu	r17,r20,4008cac <_realloc_r+0x1cc>
 4008b4c:	94403b0e 	bge	r18,r17,4008c3c <_realloc_r+0x15c>
 4008b50:	05c10074 	movhi	r23,1025
 4008b54:	bdf36404 	addi	r23,r23,-12912
 4008b58:	b9400217 	ldw	r5,8(r23)
 4008b5c:	b489883a 	add	r4,r22,r18
 4008b60:	20800117 	ldw	r2,4(r4)
 4008b64:	29008e26 	beq	r5,r4,4008da0 <_realloc_r+0x2c0>
 4008b68:	00ffff84 	movi	r3,-2
 4008b6c:	10c6703a 	and	r3,r2,r3
 4008b70:	20c7883a 	add	r3,r4,r3
 4008b74:	18c00117 	ldw	r3,4(r3)
 4008b78:	18c0004c 	andi	r3,r3,1
 4008b7c:	18004f1e 	bne	r3,zero,4008cbc <_realloc_r+0x1dc>
 4008b80:	00ffff04 	movi	r3,-4
 4008b84:	10c4703a 	and	r2,r2,r3
 4008b88:	9087883a 	add	r3,r18,r2
 4008b8c:	1c40c30e 	bge	r3,r17,4008e9c <_realloc_r+0x3bc>
 4008b90:	9cc0004c 	andi	r19,r19,1
 4008b94:	98004b1e 	bne	r19,zero,4008cc4 <_realloc_r+0x1e4>
 4008b98:	873ffe17 	ldw	fp,-8(r16)
 4008b9c:	00ffff04 	movi	r3,-4
 4008ba0:	b739c83a 	sub	fp,r22,fp
 4008ba4:	e4c00117 	ldw	r19,4(fp)
 4008ba8:	98c6703a 	and	r3,r19,r3
 4008bac:	20000426 	beq	r4,zero,4008bc0 <_realloc_r+0xe0>
 4008bb0:	90cf883a 	add	r7,r18,r3
 4008bb4:	388f883a 	add	r7,r7,r2
 4008bb8:	2900c226 	beq	r5,r4,4008ec4 <_realloc_r+0x3e4>
 4008bbc:	3c409e0e 	bge	r7,r17,4008e38 <_realloc_r+0x358>
 4008bc0:	e0004026 	beq	fp,zero,4008cc4 <_realloc_r+0x1e4>
 4008bc4:	90ef883a 	add	r23,r18,r3
 4008bc8:	bc403e16 	blt	r23,r17,4008cc4 <_realloc_r+0x1e4>
 4008bcc:	e0800317 	ldw	r2,12(fp)
 4008bd0:	e0c00217 	ldw	r3,8(fp)
 4008bd4:	91bfff04 	addi	r6,r18,-4
 4008bd8:	31400968 	cmpgeui	r5,r6,37
 4008bdc:	18800315 	stw	r2,12(r3)
 4008be0:	10c00215 	stw	r3,8(r2)
 4008be4:	e1000204 	addi	r4,fp,8
 4008be8:	2800e71e 	bne	r5,zero,4008f88 <_realloc_r+0x4a8>
 4008bec:	30800530 	cmpltui	r2,r6,20
 4008bf0:	1000e31e 	bne	r2,zero,4008f80 <_realloc_r+0x4a0>
 4008bf4:	80c00017 	ldw	r3,0(r16)
 4008bf8:	30800728 	cmpgeui	r2,r6,28
 4008bfc:	e0c00215 	stw	r3,8(fp)
 4008c00:	80c00117 	ldw	r3,4(r16)
 4008c04:	e0c00315 	stw	r3,12(fp)
 4008c08:	1000fa1e 	bne	r2,zero,4008ff4 <_realloc_r+0x514>
 4008c0c:	84000204 	addi	r16,r16,8
 4008c10:	e0800404 	addi	r2,fp,16
 4008c14:	80c00017 	ldw	r3,0(r16)
 4008c18:	b825883a 	mov	r18,r23
 4008c1c:	10c00015 	stw	r3,0(r2)
 4008c20:	80c00117 	ldw	r3,4(r16)
 4008c24:	e02d883a 	mov	r22,fp
 4008c28:	10c00115 	stw	r3,4(r2)
 4008c2c:	80c00217 	ldw	r3,8(r16)
 4008c30:	2021883a 	mov	r16,r4
 4008c34:	10c00215 	stw	r3,8(r2)
 4008c38:	e4c00117 	ldw	r19,4(fp)
 4008c3c:	9447c83a 	sub	r3,r18,r17
 4008c40:	19000430 	cmpltui	r4,r3,16
 4008c44:	9cc0004c 	andi	r19,r19,1
 4008c48:	b485883a 	add	r2,r22,r18
 4008c4c:	20004826 	beq	r4,zero,4008d70 <_realloc_r+0x290>
 4008c50:	94e6b03a 	or	r19,r18,r19
 4008c54:	b4c00115 	stw	r19,4(r22)
 4008c58:	10c00117 	ldw	r3,4(r2)
 4008c5c:	18c00054 	ori	r3,r3,1
 4008c60:	10c00115 	stw	r3,4(r2)
 4008c64:	a809883a 	mov	r4,r21
 4008c68:	400aa5c0 	call	400aa5c <__malloc_unlock>
 4008c6c:	8029883a 	mov	r20,r16
 4008c70:	a005883a 	mov	r2,r20
 4008c74:	dfc00a17 	ldw	ra,40(sp)
 4008c78:	df000917 	ldw	fp,36(sp)
 4008c7c:	ddc00817 	ldw	r23,32(sp)
 4008c80:	dd800717 	ldw	r22,28(sp)
 4008c84:	dd400617 	ldw	r21,24(sp)
 4008c88:	dd000517 	ldw	r20,20(sp)
 4008c8c:	dcc00417 	ldw	r19,16(sp)
 4008c90:	dc800317 	ldw	r18,12(sp)
 4008c94:	dc400217 	ldw	r17,8(sp)
 4008c98:	dc000117 	ldw	r16,4(sp)
 4008c9c:	dec00b04 	addi	sp,sp,44
 4008ca0:	f800283a 	ret
 4008ca4:	04400404 	movi	r17,16
 4008ca8:	8d3fa82e 	bgeu	r17,r20,4008b4c <_realloc_r+0x6c>
 4008cac:	00800304 	movi	r2,12
 4008cb0:	a8800015 	stw	r2,0(r21)
 4008cb4:	0029883a 	mov	r20,zero
 4008cb8:	003fed06 	br	4008c70 <_realloc_r+0x190>
 4008cbc:	9cc0004c 	andi	r19,r19,1
 4008cc0:	98004e26 	beq	r19,zero,4008dfc <_realloc_r+0x31c>
 4008cc4:	a00b883a 	mov	r5,r20
 4008cc8:	a809883a 	mov	r4,r21
 4008ccc:	40081080 	call	4008108 <_malloc_r>
 4008cd0:	1029883a 	mov	r20,r2
 4008cd4:	1000bd26 	beq	r2,zero,4008fcc <_realloc_r+0x4ec>
 4008cd8:	84ffff17 	ldw	r19,-4(r16)
 4008cdc:	10fffe04 	addi	r3,r2,-8
 4008ce0:	00bfff84 	movi	r2,-2
 4008ce4:	9884703a 	and	r2,r19,r2
 4008ce8:	b085883a 	add	r2,r22,r2
 4008cec:	10c03e26 	beq	r2,r3,4008de8 <_realloc_r+0x308>
 4008cf0:	91bfff04 	addi	r6,r18,-4
 4008cf4:	30800968 	cmpgeui	r2,r6,37
 4008cf8:	10006e1e 	bne	r2,zero,4008eb4 <_realloc_r+0x3d4>
 4008cfc:	30800530 	cmpltui	r2,r6,20
 4008d00:	10004426 	beq	r2,zero,4008e14 <_realloc_r+0x334>
 4008d04:	a005883a 	mov	r2,r20
 4008d08:	8007883a 	mov	r3,r16
 4008d0c:	19000017 	ldw	r4,0(r3)
 4008d10:	11000015 	stw	r4,0(r2)
 4008d14:	19000117 	ldw	r4,4(r3)
 4008d18:	11000115 	stw	r4,4(r2)
 4008d1c:	18c00217 	ldw	r3,8(r3)
 4008d20:	10c00215 	stw	r3,8(r2)
 4008d24:	a809883a 	mov	r4,r21
 4008d28:	800b883a 	mov	r5,r16
 4008d2c:	400998c0 	call	400998c <_free_r>
 4008d30:	a809883a 	mov	r4,r21
 4008d34:	400aa5c0 	call	400aa5c <__malloc_unlock>
 4008d38:	003fcd06 	br	4008c70 <_realloc_r+0x190>
 4008d3c:	300b883a 	mov	r5,r6
 4008d40:	dfc00a17 	ldw	ra,40(sp)
 4008d44:	df000917 	ldw	fp,36(sp)
 4008d48:	ddc00817 	ldw	r23,32(sp)
 4008d4c:	dd800717 	ldw	r22,28(sp)
 4008d50:	dd400617 	ldw	r21,24(sp)
 4008d54:	dd000517 	ldw	r20,20(sp)
 4008d58:	dcc00417 	ldw	r19,16(sp)
 4008d5c:	dc800317 	ldw	r18,12(sp)
 4008d60:	dc400217 	ldw	r17,8(sp)
 4008d64:	dc000117 	ldw	r16,4(sp)
 4008d68:	dec00b04 	addi	sp,sp,44
 4008d6c:	40081081 	jmpi	4008108 <_malloc_r>
 4008d70:	8ce6b03a 	or	r19,r17,r19
 4008d74:	b4c00115 	stw	r19,4(r22)
 4008d78:	b44b883a 	add	r5,r22,r17
 4008d7c:	18c00054 	ori	r3,r3,1
 4008d80:	28c00115 	stw	r3,4(r5)
 4008d84:	10c00117 	ldw	r3,4(r2)
 4008d88:	29400204 	addi	r5,r5,8
 4008d8c:	a809883a 	mov	r4,r21
 4008d90:	18c00054 	ori	r3,r3,1
 4008d94:	10c00115 	stw	r3,4(r2)
 4008d98:	400998c0 	call	400998c <_free_r>
 4008d9c:	003fb106 	br	4008c64 <_realloc_r+0x184>
 4008da0:	00ffff04 	movi	r3,-4
 4008da4:	10c4703a 	and	r2,r2,r3
 4008da8:	1487883a 	add	r3,r2,r18
 4008dac:	89800404 	addi	r6,r17,16
 4008db0:	19bf7716 	blt	r3,r6,4008b90 <_realloc_r+0xb0>
 4008db4:	b46d883a 	add	r22,r22,r17
 4008db8:	1c45c83a 	sub	r2,r3,r17
 4008dbc:	bd800215 	stw	r22,8(r23)
 4008dc0:	10800054 	ori	r2,r2,1
 4008dc4:	b0800115 	stw	r2,4(r22)
 4008dc8:	80bfff17 	ldw	r2,-4(r16)
 4008dcc:	a809883a 	mov	r4,r21
 4008dd0:	8029883a 	mov	r20,r16
 4008dd4:	1080004c 	andi	r2,r2,1
 4008dd8:	1444b03a 	or	r2,r2,r17
 4008ddc:	80bfff15 	stw	r2,-4(r16)
 4008de0:	400aa5c0 	call	400aa5c <__malloc_unlock>
 4008de4:	003fa206 	br	4008c70 <_realloc_r+0x190>
 4008de8:	a0bfff17 	ldw	r2,-4(r20)
 4008dec:	00ffff04 	movi	r3,-4
 4008df0:	10c4703a 	and	r2,r2,r3
 4008df4:	90a5883a 	add	r18,r18,r2
 4008df8:	003f9006 	br	4008c3c <_realloc_r+0x15c>
 4008dfc:	873ffe17 	ldw	fp,-8(r16)
 4008e00:	00bfff04 	movi	r2,-4
 4008e04:	b739c83a 	sub	fp,r22,fp
 4008e08:	e0c00117 	ldw	r3,4(fp)
 4008e0c:	1886703a 	and	r3,r3,r2
 4008e10:	003f6b06 	br	4008bc0 <_realloc_r+0xe0>
 4008e14:	80c00017 	ldw	r3,0(r16)
 4008e18:	30800728 	cmpgeui	r2,r6,28
 4008e1c:	a0c00015 	stw	r3,0(r20)
 4008e20:	80c00117 	ldw	r3,4(r16)
 4008e24:	a0c00115 	stw	r3,4(r20)
 4008e28:	10004c1e 	bne	r2,zero,4008f5c <_realloc_r+0x47c>
 4008e2c:	80c00204 	addi	r3,r16,8
 4008e30:	a0800204 	addi	r2,r20,8
 4008e34:	003fb506 	br	4008d0c <_realloc_r+0x22c>
 4008e38:	20800317 	ldw	r2,12(r4)
 4008e3c:	20c00217 	ldw	r3,8(r4)
 4008e40:	91bfff04 	addi	r6,r18,-4
 4008e44:	31400968 	cmpgeui	r5,r6,37
 4008e48:	18800315 	stw	r2,12(r3)
 4008e4c:	10c00215 	stw	r3,8(r2)
 4008e50:	e0c00217 	ldw	r3,8(fp)
 4008e54:	e0800317 	ldw	r2,12(fp)
 4008e58:	e1000204 	addi	r4,fp,8
 4008e5c:	18800315 	stw	r2,12(r3)
 4008e60:	10c00215 	stw	r3,8(r2)
 4008e64:	2800511e 	bne	r5,zero,4008fac <_realloc_r+0x4cc>
 4008e68:	30800530 	cmpltui	r2,r6,20
 4008e6c:	10004d1e 	bne	r2,zero,4008fa4 <_realloc_r+0x4c4>
 4008e70:	80c00017 	ldw	r3,0(r16)
 4008e74:	30800728 	cmpgeui	r2,r6,28
 4008e78:	e0c00215 	stw	r3,8(fp)
 4008e7c:	80c00117 	ldw	r3,4(r16)
 4008e80:	e0c00315 	stw	r3,12(fp)
 4008e84:	1000641e 	bne	r2,zero,4009018 <_realloc_r+0x538>
 4008e88:	84000204 	addi	r16,r16,8
 4008e8c:	e0800404 	addi	r2,fp,16
 4008e90:	80c00017 	ldw	r3,0(r16)
 4008e94:	3825883a 	mov	r18,r7
 4008e98:	003f6006 	br	4008c1c <_realloc_r+0x13c>
 4008e9c:	20800317 	ldw	r2,12(r4)
 4008ea0:	21000217 	ldw	r4,8(r4)
 4008ea4:	1825883a 	mov	r18,r3
 4008ea8:	20800315 	stw	r2,12(r4)
 4008eac:	11000215 	stw	r4,8(r2)
 4008eb0:	003f6206 	br	4008c3c <_realloc_r+0x15c>
 4008eb4:	800b883a 	mov	r5,r16
 4008eb8:	a009883a 	mov	r4,r20
 4008ebc:	40089b80 	call	40089b8 <memmove>
 4008ec0:	003f9806 	br	4008d24 <_realloc_r+0x244>
 4008ec4:	88800404 	addi	r2,r17,16
 4008ec8:	38bf3d16 	blt	r7,r2,4008bc0 <_realloc_r+0xe0>
 4008ecc:	e0800317 	ldw	r2,12(fp)
 4008ed0:	e0c00217 	ldw	r3,8(fp)
 4008ed4:	91bfff04 	addi	r6,r18,-4
 4008ed8:	31000968 	cmpgeui	r4,r6,37
 4008edc:	18800315 	stw	r2,12(r3)
 4008ee0:	10c00215 	stw	r3,8(r2)
 4008ee4:	e5000204 	addi	r20,fp,8
 4008ee8:	2000561e 	bne	r4,zero,4009044 <_realloc_r+0x564>
 4008eec:	30800530 	cmpltui	r2,r6,20
 4008ef0:	1000521e 	bne	r2,zero,400903c <_realloc_r+0x55c>
 4008ef4:	80c00017 	ldw	r3,0(r16)
 4008ef8:	30800728 	cmpgeui	r2,r6,28
 4008efc:	e0c00215 	stw	r3,8(fp)
 4008f00:	80c00117 	ldw	r3,4(r16)
 4008f04:	e0c00315 	stw	r3,12(fp)
 4008f08:	1000541e 	bne	r2,zero,400905c <_realloc_r+0x57c>
 4008f0c:	84000204 	addi	r16,r16,8
 4008f10:	e0800404 	addi	r2,fp,16
 4008f14:	80c00017 	ldw	r3,0(r16)
 4008f18:	10c00015 	stw	r3,0(r2)
 4008f1c:	80c00117 	ldw	r3,4(r16)
 4008f20:	10c00115 	stw	r3,4(r2)
 4008f24:	80c00217 	ldw	r3,8(r16)
 4008f28:	10c00215 	stw	r3,8(r2)
 4008f2c:	e447883a 	add	r3,fp,r17
 4008f30:	3c45c83a 	sub	r2,r7,r17
 4008f34:	b8c00215 	stw	r3,8(r23)
 4008f38:	10800054 	ori	r2,r2,1
 4008f3c:	18800115 	stw	r2,4(r3)
 4008f40:	e0800117 	ldw	r2,4(fp)
 4008f44:	a809883a 	mov	r4,r21
 4008f48:	1080004c 	andi	r2,r2,1
 4008f4c:	1444b03a 	or	r2,r2,r17
 4008f50:	e0800115 	stw	r2,4(fp)
 4008f54:	400aa5c0 	call	400aa5c <__malloc_unlock>
 4008f58:	003f4506 	br	4008c70 <_realloc_r+0x190>
 4008f5c:	80800217 	ldw	r2,8(r16)
 4008f60:	31800920 	cmpeqi	r6,r6,36
 4008f64:	a0800215 	stw	r2,8(r20)
 4008f68:	80800317 	ldw	r2,12(r16)
 4008f6c:	a0800315 	stw	r2,12(r20)
 4008f70:	3000191e 	bne	r6,zero,4008fd8 <_realloc_r+0x4f8>
 4008f74:	80c00404 	addi	r3,r16,16
 4008f78:	a0800404 	addi	r2,r20,16
 4008f7c:	003f6306 	br	4008d0c <_realloc_r+0x22c>
 4008f80:	2005883a 	mov	r2,r4
 4008f84:	003f2306 	br	4008c14 <_realloc_r+0x134>
 4008f88:	800b883a 	mov	r5,r16
 4008f8c:	40089b80 	call	40089b8 <memmove>
 4008f90:	1021883a 	mov	r16,r2
 4008f94:	e4c00117 	ldw	r19,4(fp)
 4008f98:	b825883a 	mov	r18,r23
 4008f9c:	e02d883a 	mov	r22,fp
 4008fa0:	003f2606 	br	4008c3c <_realloc_r+0x15c>
 4008fa4:	2005883a 	mov	r2,r4
 4008fa8:	003fb906 	br	4008e90 <_realloc_r+0x3b0>
 4008fac:	800b883a 	mov	r5,r16
 4008fb0:	d9c00015 	stw	r7,0(sp)
 4008fb4:	40089b80 	call	40089b8 <memmove>
 4008fb8:	d9c00017 	ldw	r7,0(sp)
 4008fbc:	1021883a 	mov	r16,r2
 4008fc0:	e02d883a 	mov	r22,fp
 4008fc4:	3825883a 	mov	r18,r7
 4008fc8:	003f1c06 	br	4008c3c <_realloc_r+0x15c>
 4008fcc:	a809883a 	mov	r4,r21
 4008fd0:	400aa5c0 	call	400aa5c <__malloc_unlock>
 4008fd4:	003f3706 	br	4008cb4 <_realloc_r+0x1d4>
 4008fd8:	81000417 	ldw	r4,16(r16)
 4008fdc:	80c00604 	addi	r3,r16,24
 4008fe0:	a0800604 	addi	r2,r20,24
 4008fe4:	a1000415 	stw	r4,16(r20)
 4008fe8:	81000517 	ldw	r4,20(r16)
 4008fec:	a1000515 	stw	r4,20(r20)
 4008ff0:	003f4606 	br	4008d0c <_realloc_r+0x22c>
 4008ff4:	80800217 	ldw	r2,8(r16)
 4008ff8:	31800920 	cmpeqi	r6,r6,36
 4008ffc:	e0800415 	stw	r2,16(fp)
 4009000:	80800317 	ldw	r2,12(r16)
 4009004:	e0800515 	stw	r2,20(fp)
 4009008:	30001d1e 	bne	r6,zero,4009080 <_realloc_r+0x5a0>
 400900c:	84000404 	addi	r16,r16,16
 4009010:	e0800604 	addi	r2,fp,24
 4009014:	003eff06 	br	4008c14 <_realloc_r+0x134>
 4009018:	80800217 	ldw	r2,8(r16)
 400901c:	31800920 	cmpeqi	r6,r6,36
 4009020:	e0800415 	stw	r2,16(fp)
 4009024:	80800317 	ldw	r2,12(r16)
 4009028:	e0800515 	stw	r2,20(fp)
 400902c:	30001b1e 	bne	r6,zero,400909c <_realloc_r+0x5bc>
 4009030:	84000404 	addi	r16,r16,16
 4009034:	e0800604 	addi	r2,fp,24
 4009038:	003f9506 	br	4008e90 <_realloc_r+0x3b0>
 400903c:	a005883a 	mov	r2,r20
 4009040:	003fb406 	br	4008f14 <_realloc_r+0x434>
 4009044:	800b883a 	mov	r5,r16
 4009048:	a009883a 	mov	r4,r20
 400904c:	d9c00015 	stw	r7,0(sp)
 4009050:	40089b80 	call	40089b8 <memmove>
 4009054:	d9c00017 	ldw	r7,0(sp)
 4009058:	003fb406 	br	4008f2c <_realloc_r+0x44c>
 400905c:	80800217 	ldw	r2,8(r16)
 4009060:	31800920 	cmpeqi	r6,r6,36
 4009064:	e0800415 	stw	r2,16(fp)
 4009068:	80800317 	ldw	r2,12(r16)
 400906c:	e0800515 	stw	r2,20(fp)
 4009070:	3000111e 	bne	r6,zero,40090b8 <_realloc_r+0x5d8>
 4009074:	84000404 	addi	r16,r16,16
 4009078:	e0800604 	addi	r2,fp,24
 400907c:	003fa506 	br	4008f14 <_realloc_r+0x434>
 4009080:	80c00417 	ldw	r3,16(r16)
 4009084:	84000604 	addi	r16,r16,24
 4009088:	e0800804 	addi	r2,fp,32
 400908c:	e0c00615 	stw	r3,24(fp)
 4009090:	80ffff17 	ldw	r3,-4(r16)
 4009094:	e0c00715 	stw	r3,28(fp)
 4009098:	003ede06 	br	4008c14 <_realloc_r+0x134>
 400909c:	80c00417 	ldw	r3,16(r16)
 40090a0:	84000604 	addi	r16,r16,24
 40090a4:	e0800804 	addi	r2,fp,32
 40090a8:	e0c00615 	stw	r3,24(fp)
 40090ac:	80ffff17 	ldw	r3,-4(r16)
 40090b0:	e0c00715 	stw	r3,28(fp)
 40090b4:	003f7606 	br	4008e90 <_realloc_r+0x3b0>
 40090b8:	80c00417 	ldw	r3,16(r16)
 40090bc:	84000604 	addi	r16,r16,24
 40090c0:	e0800804 	addi	r2,fp,32
 40090c4:	e0c00615 	stw	r3,24(fp)
 40090c8:	80ffff17 	ldw	r3,-4(r16)
 40090cc:	e0c00715 	stw	r3,28(fp)
 40090d0:	003f9006 	br	4008f14 <_realloc_r+0x434>

040090d4 <_sbrk_r>:
 40090d4:	defffe04 	addi	sp,sp,-8
 40090d8:	dc000015 	stw	r16,0(sp)
 40090dc:	00810074 	movhi	r2,1025
 40090e0:	2021883a 	mov	r16,r4
 40090e4:	2809883a 	mov	r4,r5
 40090e8:	dfc00115 	stw	ra,4(sp)
 40090ec:	103fa815 	stw	zero,-352(r2)
 40090f0:	400ac340 	call	400ac34 <sbrk>
 40090f4:	10ffffd8 	cmpnei	r3,r2,-1
 40090f8:	18000426 	beq	r3,zero,400910c <_sbrk_r+0x38>
 40090fc:	dfc00117 	ldw	ra,4(sp)
 4009100:	dc000017 	ldw	r16,0(sp)
 4009104:	dec00204 	addi	sp,sp,8
 4009108:	f800283a 	ret
 400910c:	00c10074 	movhi	r3,1025
 4009110:	18ffa817 	ldw	r3,-352(r3)
 4009114:	183ff926 	beq	r3,zero,40090fc <_sbrk_r+0x28>
 4009118:	80c00015 	stw	r3,0(r16)
 400911c:	dfc00117 	ldw	ra,4(sp)
 4009120:	dc000017 	ldw	r16,0(sp)
 4009124:	dec00204 	addi	sp,sp,8
 4009128:	f800283a 	ret

0400912c <__sread>:
 400912c:	defffe04 	addi	sp,sp,-8
 4009130:	dc000015 	stw	r16,0(sp)
 4009134:	2821883a 	mov	r16,r5
 4009138:	2940038f 	ldh	r5,14(r5)
 400913c:	dfc00115 	stw	ra,4(sp)
 4009140:	4009f240 	call	4009f24 <_read_r>
 4009144:	10000716 	blt	r2,zero,4009164 <__sread+0x38>
 4009148:	80c01417 	ldw	r3,80(r16)
 400914c:	1887883a 	add	r3,r3,r2
 4009150:	80c01415 	stw	r3,80(r16)
 4009154:	dfc00117 	ldw	ra,4(sp)
 4009158:	dc000017 	ldw	r16,0(sp)
 400915c:	dec00204 	addi	sp,sp,8
 4009160:	f800283a 	ret
 4009164:	80c0030b 	ldhu	r3,12(r16)
 4009168:	18fbffcc 	andi	r3,r3,61439
 400916c:	80c0030d 	sth	r3,12(r16)
 4009170:	dfc00117 	ldw	ra,4(sp)
 4009174:	dc000017 	ldw	r16,0(sp)
 4009178:	dec00204 	addi	sp,sp,8
 400917c:	f800283a 	ret

04009180 <__seofread>:
 4009180:	0005883a 	mov	r2,zero
 4009184:	f800283a 	ret

04009188 <__swrite>:
 4009188:	2880030b 	ldhu	r2,12(r5)
 400918c:	defffb04 	addi	sp,sp,-20
 4009190:	dcc00315 	stw	r19,12(sp)
 4009194:	dc800215 	stw	r18,8(sp)
 4009198:	dc400115 	stw	r17,4(sp)
 400919c:	dc000015 	stw	r16,0(sp)
 40091a0:	dfc00415 	stw	ra,16(sp)
 40091a4:	10c0400c 	andi	r3,r2,256
 40091a8:	2821883a 	mov	r16,r5
 40091ac:	2023883a 	mov	r17,r4
 40091b0:	3025883a 	mov	r18,r6
 40091b4:	3827883a 	mov	r19,r7
 40091b8:	18000d1e 	bne	r3,zero,40091f0 <__swrite+0x68>
 40091bc:	8140038f 	ldh	r5,14(r16)
 40091c0:	10bbffcc 	andi	r2,r2,61439
 40091c4:	980f883a 	mov	r7,r19
 40091c8:	900d883a 	mov	r6,r18
 40091cc:	8809883a 	mov	r4,r17
 40091d0:	8080030d 	sth	r2,12(r16)
 40091d4:	dfc00417 	ldw	ra,16(sp)
 40091d8:	dcc00317 	ldw	r19,12(sp)
 40091dc:	dc800217 	ldw	r18,8(sp)
 40091e0:	dc400117 	ldw	r17,4(sp)
 40091e4:	dc000017 	ldw	r16,0(sp)
 40091e8:	dec00504 	addi	sp,sp,20
 40091ec:	400926c1 	jmpi	400926c <_write_r>
 40091f0:	2940038f 	ldh	r5,14(r5)
 40091f4:	01c00084 	movi	r7,2
 40091f8:	000d883a 	mov	r6,zero
 40091fc:	4009c940 	call	4009c94 <_lseek_r>
 4009200:	8080030b 	ldhu	r2,12(r16)
 4009204:	003fed06 	br	40091bc <__swrite+0x34>

04009208 <__sseek>:
 4009208:	defffe04 	addi	sp,sp,-8
 400920c:	dc000015 	stw	r16,0(sp)
 4009210:	2821883a 	mov	r16,r5
 4009214:	2940038f 	ldh	r5,14(r5)
 4009218:	dfc00115 	stw	ra,4(sp)
 400921c:	4009c940 	call	4009c94 <_lseek_r>
 4009220:	10ffffd8 	cmpnei	r3,r2,-1
 4009224:	18000826 	beq	r3,zero,4009248 <__sseek+0x40>
 4009228:	80c0030b 	ldhu	r3,12(r16)
 400922c:	80801415 	stw	r2,80(r16)
 4009230:	18c40014 	ori	r3,r3,4096
 4009234:	80c0030d 	sth	r3,12(r16)
 4009238:	dfc00117 	ldw	ra,4(sp)
 400923c:	dc000017 	ldw	r16,0(sp)
 4009240:	dec00204 	addi	sp,sp,8
 4009244:	f800283a 	ret
 4009248:	80c0030b 	ldhu	r3,12(r16)
 400924c:	18fbffcc 	andi	r3,r3,61439
 4009250:	80c0030d 	sth	r3,12(r16)
 4009254:	dfc00117 	ldw	ra,4(sp)
 4009258:	dc000017 	ldw	r16,0(sp)
 400925c:	dec00204 	addi	sp,sp,8
 4009260:	f800283a 	ret

04009264 <__sclose>:
 4009264:	2940038f 	ldh	r5,14(r5)
 4009268:	400941c1 	jmpi	400941c <_close_r>

0400926c <_write_r>:
 400926c:	2807883a 	mov	r3,r5
 4009270:	defffe04 	addi	sp,sp,-8
 4009274:	dc000015 	stw	r16,0(sp)
 4009278:	300b883a 	mov	r5,r6
 400927c:	00810074 	movhi	r2,1025
 4009280:	380d883a 	mov	r6,r7
 4009284:	2021883a 	mov	r16,r4
 4009288:	1809883a 	mov	r4,r3
 400928c:	dfc00115 	stw	ra,4(sp)
 4009290:	103fa815 	stw	zero,-352(r2)
 4009294:	400ad280 	call	400ad28 <write>
 4009298:	10ffffd8 	cmpnei	r3,r2,-1
 400929c:	18000426 	beq	r3,zero,40092b0 <_write_r+0x44>
 40092a0:	dfc00117 	ldw	ra,4(sp)
 40092a4:	dc000017 	ldw	r16,0(sp)
 40092a8:	dec00204 	addi	sp,sp,8
 40092ac:	f800283a 	ret
 40092b0:	00c10074 	movhi	r3,1025
 40092b4:	18ffa817 	ldw	r3,-352(r3)
 40092b8:	183ff926 	beq	r3,zero,40092a0 <_write_r+0x34>
 40092bc:	80c00015 	stw	r3,0(r16)
 40092c0:	dfc00117 	ldw	ra,4(sp)
 40092c4:	dc000017 	ldw	r16,0(sp)
 40092c8:	dec00204 	addi	sp,sp,8
 40092cc:	f800283a 	ret

040092d0 <__swsetup_r>:
 40092d0:	00810074 	movhi	r2,1025
 40092d4:	10b8ea17 	ldw	r2,-7256(r2)
 40092d8:	defffd04 	addi	sp,sp,-12
 40092dc:	dc400115 	stw	r17,4(sp)
 40092e0:	dc000015 	stw	r16,0(sp)
 40092e4:	dfc00215 	stw	ra,8(sp)
 40092e8:	2023883a 	mov	r17,r4
 40092ec:	2821883a 	mov	r16,r5
 40092f0:	10000226 	beq	r2,zero,40092fc <__swsetup_r+0x2c>
 40092f4:	10c00e17 	ldw	r3,56(r2)
 40092f8:	18001d26 	beq	r3,zero,4009370 <__swsetup_r+0xa0>
 40092fc:	80c0030b 	ldhu	r3,12(r16)
 4009300:	1880020c 	andi	r2,r3,8
 4009304:	10001f26 	beq	r2,zero,4009384 <__swsetup_r+0xb4>
 4009308:	80800417 	ldw	r2,16(r16)
 400930c:	10002626 	beq	r2,zero,40093a8 <__swsetup_r+0xd8>
 4009310:	1900004c 	andi	r4,r3,1
 4009314:	20000b1e 	bne	r4,zero,4009344 <__swsetup_r+0x74>
 4009318:	1900008c 	andi	r4,r3,2
 400931c:	20002b1e 	bne	r4,zero,40093cc <__swsetup_r+0xfc>
 4009320:	81000517 	ldw	r4,20(r16)
 4009324:	81000215 	stw	r4,8(r16)
 4009328:	10000b26 	beq	r2,zero,4009358 <__swsetup_r+0x88>
 400932c:	0005883a 	mov	r2,zero
 4009330:	dfc00217 	ldw	ra,8(sp)
 4009334:	dc400117 	ldw	r17,4(sp)
 4009338:	dc000017 	ldw	r16,0(sp)
 400933c:	dec00304 	addi	sp,sp,12
 4009340:	f800283a 	ret
 4009344:	81000517 	ldw	r4,20(r16)
 4009348:	80000215 	stw	zero,8(r16)
 400934c:	0109c83a 	sub	r4,zero,r4
 4009350:	81000615 	stw	r4,24(r16)
 4009354:	103ff51e 	bne	r2,zero,400932c <__swsetup_r+0x5c>
 4009358:	1900200c 	andi	r4,r3,128
 400935c:	203ff426 	beq	r4,zero,4009330 <__swsetup_r+0x60>
 4009360:	18c01014 	ori	r3,r3,64
 4009364:	80c0030d 	sth	r3,12(r16)
 4009368:	00bfffc4 	movi	r2,-1
 400936c:	003ff006 	br	4009330 <__swsetup_r+0x60>
 4009370:	1009883a 	mov	r4,r2
 4009374:	4007ad80 	call	4007ad8 <__sinit>
 4009378:	80c0030b 	ldhu	r3,12(r16)
 400937c:	1880020c 	andi	r2,r3,8
 4009380:	103fe11e 	bne	r2,zero,4009308 <__swsetup_r+0x38>
 4009384:	1880040c 	andi	r2,r3,16
 4009388:	10002026 	beq	r2,zero,400940c <__swsetup_r+0x13c>
 400938c:	1880010c 	andi	r2,r3,4
 4009390:	1000101e 	bne	r2,zero,40093d4 <__swsetup_r+0x104>
 4009394:	80800417 	ldw	r2,16(r16)
 4009398:	19000214 	ori	r4,r3,8
 400939c:	8100030d 	sth	r4,12(r16)
 40093a0:	2007883a 	mov	r3,r4
 40093a4:	103fda1e 	bne	r2,zero,4009310 <__swsetup_r+0x40>
 40093a8:	1900a00c 	andi	r4,r3,640
 40093ac:	21008020 	cmpeqi	r4,r4,512
 40093b0:	203fd71e 	bne	r4,zero,4009310 <__swsetup_r+0x40>
 40093b4:	800b883a 	mov	r5,r16
 40093b8:	8809883a 	mov	r4,r17
 40093bc:	4009cf80 	call	4009cf8 <__smakebuf_r>
 40093c0:	80c0030b 	ldhu	r3,12(r16)
 40093c4:	80800417 	ldw	r2,16(r16)
 40093c8:	003fd106 	br	4009310 <__swsetup_r+0x40>
 40093cc:	0009883a 	mov	r4,zero
 40093d0:	003fd406 	br	4009324 <__swsetup_r+0x54>
 40093d4:	81400c17 	ldw	r5,48(r16)
 40093d8:	28000626 	beq	r5,zero,40093f4 <__swsetup_r+0x124>
 40093dc:	80801004 	addi	r2,r16,64
 40093e0:	28800326 	beq	r5,r2,40093f0 <__swsetup_r+0x120>
 40093e4:	8809883a 	mov	r4,r17
 40093e8:	400998c0 	call	400998c <_free_r>
 40093ec:	80c0030b 	ldhu	r3,12(r16)
 40093f0:	80000c15 	stw	zero,48(r16)
 40093f4:	80800417 	ldw	r2,16(r16)
 40093f8:	013ff6c4 	movi	r4,-37
 40093fc:	20c6703a 	and	r3,r4,r3
 4009400:	80000115 	stw	zero,4(r16)
 4009404:	80800015 	stw	r2,0(r16)
 4009408:	003fe306 	br	4009398 <__swsetup_r+0xc8>
 400940c:	00800244 	movi	r2,9
 4009410:	88800015 	stw	r2,0(r17)
 4009414:	18c01014 	ori	r3,r3,64
 4009418:	003fd206 	br	4009364 <__swsetup_r+0x94>

0400941c <_close_r>:
 400941c:	defffe04 	addi	sp,sp,-8
 4009420:	dc000015 	stw	r16,0(sp)
 4009424:	00810074 	movhi	r2,1025
 4009428:	2021883a 	mov	r16,r4
 400942c:	2809883a 	mov	r4,r5
 4009430:	dfc00115 	stw	ra,4(sp)
 4009434:	103fa815 	stw	zero,-352(r2)
 4009438:	400a2300 	call	400a230 <close>
 400943c:	10ffffd8 	cmpnei	r3,r2,-1
 4009440:	18000426 	beq	r3,zero,4009454 <_close_r+0x38>
 4009444:	dfc00117 	ldw	ra,4(sp)
 4009448:	dc000017 	ldw	r16,0(sp)
 400944c:	dec00204 	addi	sp,sp,8
 4009450:	f800283a 	ret
 4009454:	00c10074 	movhi	r3,1025
 4009458:	18ffa817 	ldw	r3,-352(r3)
 400945c:	183ff926 	beq	r3,zero,4009444 <_close_r+0x28>
 4009460:	80c00015 	stw	r3,0(r16)
 4009464:	dfc00117 	ldw	ra,4(sp)
 4009468:	dc000017 	ldw	r16,0(sp)
 400946c:	dec00204 	addi	sp,sp,8
 4009470:	f800283a 	ret

04009474 <_fclose_r>:
 4009474:	defffc04 	addi	sp,sp,-16
 4009478:	dfc00315 	stw	ra,12(sp)
 400947c:	dc800215 	stw	r18,8(sp)
 4009480:	dc400115 	stw	r17,4(sp)
 4009484:	dc000015 	stw	r16,0(sp)
 4009488:	28000726 	beq	r5,zero,40094a8 <_fclose_r+0x34>
 400948c:	2821883a 	mov	r16,r5
 4009490:	2023883a 	mov	r17,r4
 4009494:	20000226 	beq	r4,zero,40094a0 <_fclose_r+0x2c>
 4009498:	20800e17 	ldw	r2,56(r4)
 400949c:	10002726 	beq	r2,zero,400953c <_fclose_r+0xc8>
 40094a0:	8080030f 	ldh	r2,12(r16)
 40094a4:	1000081e 	bne	r2,zero,40094c8 <_fclose_r+0x54>
 40094a8:	0025883a 	mov	r18,zero
 40094ac:	9005883a 	mov	r2,r18
 40094b0:	dfc00317 	ldw	ra,12(sp)
 40094b4:	dc800217 	ldw	r18,8(sp)
 40094b8:	dc400117 	ldw	r17,4(sp)
 40094bc:	dc000017 	ldw	r16,0(sp)
 40094c0:	dec00404 	addi	sp,sp,16
 40094c4:	f800283a 	ret
 40094c8:	800b883a 	mov	r5,r16
 40094cc:	8809883a 	mov	r4,r17
 40094d0:	400957c0 	call	400957c <__sflush_r>
 40094d4:	80c00b17 	ldw	r3,44(r16)
 40094d8:	1025883a 	mov	r18,r2
 40094dc:	18000426 	beq	r3,zero,40094f0 <_fclose_r+0x7c>
 40094e0:	81400717 	ldw	r5,28(r16)
 40094e4:	8809883a 	mov	r4,r17
 40094e8:	183ee83a 	callr	r3
 40094ec:	10001716 	blt	r2,zero,400954c <_fclose_r+0xd8>
 40094f0:	8080030b 	ldhu	r2,12(r16)
 40094f4:	1080200c 	andi	r2,r2,128
 40094f8:	1000181e 	bne	r2,zero,400955c <_fclose_r+0xe8>
 40094fc:	81400c17 	ldw	r5,48(r16)
 4009500:	28000526 	beq	r5,zero,4009518 <_fclose_r+0xa4>
 4009504:	80801004 	addi	r2,r16,64
 4009508:	28800226 	beq	r5,r2,4009514 <_fclose_r+0xa0>
 400950c:	8809883a 	mov	r4,r17
 4009510:	400998c0 	call	400998c <_free_r>
 4009514:	80000c15 	stw	zero,48(r16)
 4009518:	81401117 	ldw	r5,68(r16)
 400951c:	28000326 	beq	r5,zero,400952c <_fclose_r+0xb8>
 4009520:	8809883a 	mov	r4,r17
 4009524:	400998c0 	call	400998c <_free_r>
 4009528:	80001115 	stw	zero,68(r16)
 400952c:	4007ae80 	call	4007ae8 <__sfp_lock_acquire>
 4009530:	8000030d 	sth	zero,12(r16)
 4009534:	4007aec0 	call	4007aec <__sfp_lock_release>
 4009538:	003fdc06 	br	40094ac <_fclose_r+0x38>
 400953c:	4007ad80 	call	4007ad8 <__sinit>
 4009540:	8080030f 	ldh	r2,12(r16)
 4009544:	103fd826 	beq	r2,zero,40094a8 <_fclose_r+0x34>
 4009548:	003fdf06 	br	40094c8 <_fclose_r+0x54>
 400954c:	8080030b 	ldhu	r2,12(r16)
 4009550:	04bfffc4 	movi	r18,-1
 4009554:	1080200c 	andi	r2,r2,128
 4009558:	103fe826 	beq	r2,zero,40094fc <_fclose_r+0x88>
 400955c:	81400417 	ldw	r5,16(r16)
 4009560:	8809883a 	mov	r4,r17
 4009564:	400998c0 	call	400998c <_free_r>
 4009568:	003fe406 	br	40094fc <_fclose_r+0x88>

0400956c <fclose>:
 400956c:	00810074 	movhi	r2,1025
 4009570:	200b883a 	mov	r5,r4
 4009574:	1138ea17 	ldw	r4,-7256(r2)
 4009578:	40094741 	jmpi	4009474 <_fclose_r>

0400957c <__sflush_r>:
 400957c:	2880030b 	ldhu	r2,12(r5)
 4009580:	defffb04 	addi	sp,sp,-20
 4009584:	dcc00315 	stw	r19,12(sp)
 4009588:	dc000015 	stw	r16,0(sp)
 400958c:	dfc00415 	stw	ra,16(sp)
 4009590:	dc800215 	stw	r18,8(sp)
 4009594:	dc400115 	stw	r17,4(sp)
 4009598:	10c0020c 	andi	r3,r2,8
 400959c:	2821883a 	mov	r16,r5
 40095a0:	2027883a 	mov	r19,r4
 40095a4:	18003c1e 	bne	r3,zero,4009698 <__sflush_r+0x11c>
 40095a8:	29000117 	ldw	r4,4(r5)
 40095ac:	10c20014 	ori	r3,r2,2048
 40095b0:	28c0030d 	sth	r3,12(r5)
 40095b4:	0100580e 	bge	zero,r4,4009718 <__sflush_r+0x19c>
 40095b8:	82000a17 	ldw	r8,40(r16)
 40095bc:	40003426 	beq	r8,zero,4009690 <__sflush_r+0x114>
 40095c0:	9c400017 	ldw	r17,0(r19)
 40095c4:	1084000c 	andi	r2,r2,4096
 40095c8:	98000015 	stw	zero,0(r19)
 40095cc:	81400717 	ldw	r5,28(r16)
 40095d0:	1000561e 	bne	r2,zero,400972c <__sflush_r+0x1b0>
 40095d4:	000d883a 	mov	r6,zero
 40095d8:	01c00044 	movi	r7,1
 40095dc:	9809883a 	mov	r4,r19
 40095e0:	403ee83a 	callr	r8
 40095e4:	100d883a 	mov	r6,r2
 40095e8:	10bfffd8 	cmpnei	r2,r2,-1
 40095ec:	10005b26 	beq	r2,zero,400975c <__sflush_r+0x1e0>
 40095f0:	80c0030b 	ldhu	r3,12(r16)
 40095f4:	82000a17 	ldw	r8,40(r16)
 40095f8:	18c0010c 	andi	r3,r3,4
 40095fc:	18000626 	beq	r3,zero,4009618 <__sflush_r+0x9c>
 4009600:	80c00117 	ldw	r3,4(r16)
 4009604:	80800c17 	ldw	r2,48(r16)
 4009608:	30cdc83a 	sub	r6,r6,r3
 400960c:	10000226 	beq	r2,zero,4009618 <__sflush_r+0x9c>
 4009610:	80800f17 	ldw	r2,60(r16)
 4009614:	308dc83a 	sub	r6,r6,r2
 4009618:	81400717 	ldw	r5,28(r16)
 400961c:	000f883a 	mov	r7,zero
 4009620:	9809883a 	mov	r4,r19
 4009624:	403ee83a 	callr	r8
 4009628:	10ffffd8 	cmpnei	r3,r2,-1
 400962c:	1800411e 	bne	r3,zero,4009734 <__sflush_r+0x1b8>
 4009630:	99400017 	ldw	r5,0(r19)
 4009634:	28c007b0 	cmpltui	r3,r5,30
 4009638:	18002c26 	beq	r3,zero,40096ec <__sflush_r+0x170>
 400963c:	00f7f034 	movhi	r3,57280
 4009640:	18ffff84 	addi	r3,r3,-2
 4009644:	1949d83a 	sra	r4,r3,r5
 4009648:	80c0030b 	ldhu	r3,12(r16)
 400964c:	2100004c 	andi	r4,r4,1
 4009650:	2000271e 	bne	r4,zero,40096f0 <__sflush_r+0x174>
 4009654:	81000417 	ldw	r4,16(r16)
 4009658:	19bdffcc 	andi	r6,r3,63487
 400965c:	8180030d 	sth	r6,12(r16)
 4009660:	80000115 	stw	zero,4(r16)
 4009664:	81000015 	stw	r4,0(r16)
 4009668:	18c4000c 	andi	r3,r3,4096
 400966c:	1800431e 	bne	r3,zero,400977c <__sflush_r+0x200>
 4009670:	81400c17 	ldw	r5,48(r16)
 4009674:	9c400015 	stw	r17,0(r19)
 4009678:	28000526 	beq	r5,zero,4009690 <__sflush_r+0x114>
 400967c:	80801004 	addi	r2,r16,64
 4009680:	28800226 	beq	r5,r2,400968c <__sflush_r+0x110>
 4009684:	9809883a 	mov	r4,r19
 4009688:	400998c0 	call	400998c <_free_r>
 400968c:	80000c15 	stw	zero,48(r16)
 4009690:	0005883a 	mov	r2,zero
 4009694:	00001906 	br	40096fc <__sflush_r+0x180>
 4009698:	2c800417 	ldw	r18,16(r5)
 400969c:	903ffc26 	beq	r18,zero,4009690 <__sflush_r+0x114>
 40096a0:	2c400017 	ldw	r17,0(r5)
 40096a4:	108000cc 	andi	r2,r2,3
 40096a8:	2c800015 	stw	r18,0(r5)
 40096ac:	8ca3c83a 	sub	r17,r17,r18
 40096b0:	10001c1e 	bne	r2,zero,4009724 <__sflush_r+0x1a8>
 40096b4:	28800517 	ldw	r2,20(r5)
 40096b8:	80800215 	stw	r2,8(r16)
 40096bc:	04400316 	blt	zero,r17,40096cc <__sflush_r+0x150>
 40096c0:	003ff306 	br	4009690 <__sflush_r+0x114>
 40096c4:	90a5883a 	add	r18,r18,r2
 40096c8:	047ff10e 	bge	zero,r17,4009690 <__sflush_r+0x114>
 40096cc:	80800917 	ldw	r2,36(r16)
 40096d0:	81400717 	ldw	r5,28(r16)
 40096d4:	880f883a 	mov	r7,r17
 40096d8:	900d883a 	mov	r6,r18
 40096dc:	9809883a 	mov	r4,r19
 40096e0:	103ee83a 	callr	r2
 40096e4:	88a3c83a 	sub	r17,r17,r2
 40096e8:	00bff616 	blt	zero,r2,40096c4 <__sflush_r+0x148>
 40096ec:	80c0030b 	ldhu	r3,12(r16)
 40096f0:	18c01014 	ori	r3,r3,64
 40096f4:	80c0030d 	sth	r3,12(r16)
 40096f8:	00bfffc4 	movi	r2,-1
 40096fc:	dfc00417 	ldw	ra,16(sp)
 4009700:	dcc00317 	ldw	r19,12(sp)
 4009704:	dc800217 	ldw	r18,8(sp)
 4009708:	dc400117 	ldw	r17,4(sp)
 400970c:	dc000017 	ldw	r16,0(sp)
 4009710:	dec00504 	addi	sp,sp,20
 4009714:	f800283a 	ret
 4009718:	29000f17 	ldw	r4,60(r5)
 400971c:	013fa616 	blt	zero,r4,40095b8 <__sflush_r+0x3c>
 4009720:	003fdb06 	br	4009690 <__sflush_r+0x114>
 4009724:	0005883a 	mov	r2,zero
 4009728:	003fe306 	br	40096b8 <__sflush_r+0x13c>
 400972c:	81801417 	ldw	r6,80(r16)
 4009730:	003fb106 	br	40095f8 <__sflush_r+0x7c>
 4009734:	80c0030b 	ldhu	r3,12(r16)
 4009738:	81000417 	ldw	r4,16(r16)
 400973c:	80000115 	stw	zero,4(r16)
 4009740:	197dffcc 	andi	r5,r3,63487
 4009744:	8140030d 	sth	r5,12(r16)
 4009748:	81000015 	stw	r4,0(r16)
 400974c:	18c4000c 	andi	r3,r3,4096
 4009750:	183fc726 	beq	r3,zero,4009670 <__sflush_r+0xf4>
 4009754:	80801415 	stw	r2,80(r16)
 4009758:	003fc506 	br	4009670 <__sflush_r+0xf4>
 400975c:	98800017 	ldw	r2,0(r19)
 4009760:	103fa326 	beq	r2,zero,40095f0 <__sflush_r+0x74>
 4009764:	10c00760 	cmpeqi	r3,r2,29
 4009768:	1800021e 	bne	r3,zero,4009774 <__sflush_r+0x1f8>
 400976c:	10800598 	cmpnei	r2,r2,22
 4009770:	103fde1e 	bne	r2,zero,40096ec <__sflush_r+0x170>
 4009774:	9c400015 	stw	r17,0(r19)
 4009778:	003fc506 	br	4009690 <__sflush_r+0x114>
 400977c:	283fbc1e 	bne	r5,zero,4009670 <__sflush_r+0xf4>
 4009780:	003ff406 	br	4009754 <__sflush_r+0x1d8>

04009784 <_fflush_r>:
 4009784:	defffd04 	addi	sp,sp,-12
 4009788:	dc000115 	stw	r16,4(sp)
 400978c:	dfc00215 	stw	ra,8(sp)
 4009790:	2021883a 	mov	r16,r4
 4009794:	20000226 	beq	r4,zero,40097a0 <_fflush_r+0x1c>
 4009798:	20800e17 	ldw	r2,56(r4)
 400979c:	10000726 	beq	r2,zero,40097bc <_fflush_r+0x38>
 40097a0:	2880030f 	ldh	r2,12(r5)
 40097a4:	10000a1e 	bne	r2,zero,40097d0 <_fflush_r+0x4c>
 40097a8:	0005883a 	mov	r2,zero
 40097ac:	dfc00217 	ldw	ra,8(sp)
 40097b0:	dc000117 	ldw	r16,4(sp)
 40097b4:	dec00304 	addi	sp,sp,12
 40097b8:	f800283a 	ret
 40097bc:	d9400015 	stw	r5,0(sp)
 40097c0:	4007ad80 	call	4007ad8 <__sinit>
 40097c4:	d9400017 	ldw	r5,0(sp)
 40097c8:	2880030f 	ldh	r2,12(r5)
 40097cc:	103ff626 	beq	r2,zero,40097a8 <_fflush_r+0x24>
 40097d0:	8009883a 	mov	r4,r16
 40097d4:	dfc00217 	ldw	ra,8(sp)
 40097d8:	dc000117 	ldw	r16,4(sp)
 40097dc:	dec00304 	addi	sp,sp,12
 40097e0:	400957c1 	jmpi	400957c <__sflush_r>

040097e4 <fflush>:
 40097e4:	20001726 	beq	r4,zero,4009844 <fflush+0x60>
 40097e8:	00810074 	movhi	r2,1025
 40097ec:	200b883a 	mov	r5,r4
 40097f0:	1138ea17 	ldw	r4,-7256(r2)
 40097f4:	20000226 	beq	r4,zero,4009800 <fflush+0x1c>
 40097f8:	20800e17 	ldw	r2,56(r4)
 40097fc:	10000526 	beq	r2,zero,4009814 <fflush+0x30>
 4009800:	2880030f 	ldh	r2,12(r5)
 4009804:	1000021e 	bne	r2,zero,4009810 <fflush+0x2c>
 4009808:	0005883a 	mov	r2,zero
 400980c:	f800283a 	ret
 4009810:	400957c1 	jmpi	400957c <__sflush_r>
 4009814:	defffd04 	addi	sp,sp,-12
 4009818:	d9400115 	stw	r5,4(sp)
 400981c:	d9000015 	stw	r4,0(sp)
 4009820:	dfc00215 	stw	ra,8(sp)
 4009824:	4007ad80 	call	4007ad8 <__sinit>
 4009828:	d9400117 	ldw	r5,4(sp)
 400982c:	d9000017 	ldw	r4,0(sp)
 4009830:	2880030f 	ldh	r2,12(r5)
 4009834:	10000826 	beq	r2,zero,4009858 <fflush+0x74>
 4009838:	dfc00217 	ldw	ra,8(sp)
 400983c:	dec00304 	addi	sp,sp,12
 4009840:	400957c1 	jmpi	400957c <__sflush_r>
 4009844:	00810074 	movhi	r2,1025
 4009848:	1138e917 	ldw	r4,-7260(r2)
 400984c:	01410074 	movhi	r5,1025
 4009850:	2965e104 	addi	r5,r5,-26748
 4009854:	40080601 	jmpi	4008060 <_fwalk_reent>
 4009858:	0005883a 	mov	r2,zero
 400985c:	dfc00217 	ldw	ra,8(sp)
 4009860:	dec00304 	addi	sp,sp,12
 4009864:	f800283a 	ret

04009868 <_malloc_trim_r>:
 4009868:	defffa04 	addi	sp,sp,-24
 400986c:	dcc00315 	stw	r19,12(sp)
 4009870:	04c10074 	movhi	r19,1025
 4009874:	dd000415 	stw	r20,16(sp)
 4009878:	dc800215 	stw	r18,8(sp)
 400987c:	dc400115 	stw	r17,4(sp)
 4009880:	dc000015 	stw	r16,0(sp)
 4009884:	2829883a 	mov	r20,r5
 4009888:	dfc00515 	stw	ra,20(sp)
 400988c:	9cf36404 	addi	r19,r19,-12912
 4009890:	2025883a 	mov	r18,r4
 4009894:	400aa380 	call	400aa38 <__malloc_lock>
 4009898:	98800217 	ldw	r2,8(r19)
 400989c:	14400117 	ldw	r17,4(r2)
 40098a0:	00bfff04 	movi	r2,-4
 40098a4:	88a2703a 	and	r17,r17,r2
 40098a8:	8c03fbc4 	addi	r16,r17,4079
 40098ac:	8521c83a 	sub	r16,r16,r20
 40098b0:	8020d33a 	srli	r16,r16,12
 40098b4:	843fffc4 	addi	r16,r16,-1
 40098b8:	8020933a 	slli	r16,r16,12
 40098bc:	80840008 	cmpgei	r2,r16,4096
 40098c0:	10000626 	beq	r2,zero,40098dc <_malloc_trim_r+0x74>
 40098c4:	000b883a 	mov	r5,zero
 40098c8:	9009883a 	mov	r4,r18
 40098cc:	40090d40 	call	40090d4 <_sbrk_r>
 40098d0:	98c00217 	ldw	r3,8(r19)
 40098d4:	1c47883a 	add	r3,r3,r17
 40098d8:	10c00b26 	beq	r2,r3,4009908 <_malloc_trim_r+0xa0>
 40098dc:	9009883a 	mov	r4,r18
 40098e0:	400aa5c0 	call	400aa5c <__malloc_unlock>
 40098e4:	0005883a 	mov	r2,zero
 40098e8:	dfc00517 	ldw	ra,20(sp)
 40098ec:	dd000417 	ldw	r20,16(sp)
 40098f0:	dcc00317 	ldw	r19,12(sp)
 40098f4:	dc800217 	ldw	r18,8(sp)
 40098f8:	dc400117 	ldw	r17,4(sp)
 40098fc:	dc000017 	ldw	r16,0(sp)
 4009900:	dec00604 	addi	sp,sp,24
 4009904:	f800283a 	ret
 4009908:	040bc83a 	sub	r5,zero,r16
 400990c:	9009883a 	mov	r4,r18
 4009910:	40090d40 	call	40090d4 <_sbrk_r>
 4009914:	10bfffd8 	cmpnei	r2,r2,-1
 4009918:	10000d26 	beq	r2,zero,4009950 <_malloc_trim_r+0xe8>
 400991c:	00812074 	movhi	r2,1153
 4009920:	10bfe317 	ldw	r2,-116(r2)
 4009924:	98c00217 	ldw	r3,8(r19)
 4009928:	8c23c83a 	sub	r17,r17,r16
 400992c:	8c400054 	ori	r17,r17,1
 4009930:	1405c83a 	sub	r2,r2,r16
 4009934:	1c400115 	stw	r17,4(r3)
 4009938:	9009883a 	mov	r4,r18
 400993c:	00c12074 	movhi	r3,1153
 4009940:	18bfe315 	stw	r2,-116(r3)
 4009944:	400aa5c0 	call	400aa5c <__malloc_unlock>
 4009948:	00800044 	movi	r2,1
 400994c:	003fe606 	br	40098e8 <_malloc_trim_r+0x80>
 4009950:	000b883a 	mov	r5,zero
 4009954:	9009883a 	mov	r4,r18
 4009958:	40090d40 	call	40090d4 <_sbrk_r>
 400995c:	99000217 	ldw	r4,8(r19)
 4009960:	1107c83a 	sub	r3,r2,r4
 4009964:	19400410 	cmplti	r5,r3,16
 4009968:	283fdc1e 	bne	r5,zero,40098dc <_malloc_trim_r+0x74>
 400996c:	01410074 	movhi	r5,1025
 4009970:	2978eb17 	ldw	r5,-7252(r5)
 4009974:	18c00054 	ori	r3,r3,1
 4009978:	20c00115 	stw	r3,4(r4)
 400997c:	1145c83a 	sub	r2,r2,r5
 4009980:	01412074 	movhi	r5,1153
 4009984:	28bfe315 	stw	r2,-116(r5)
 4009988:	003fd406 	br	40098dc <_malloc_trim_r+0x74>

0400998c <_free_r>:
 400998c:	28005f26 	beq	r5,zero,4009b0c <_free_r+0x180>
 4009990:	defffd04 	addi	sp,sp,-12
 4009994:	dc400115 	stw	r17,4(sp)
 4009998:	dc000015 	stw	r16,0(sp)
 400999c:	2023883a 	mov	r17,r4
 40099a0:	2821883a 	mov	r16,r5
 40099a4:	dfc00215 	stw	ra,8(sp)
 40099a8:	400aa380 	call	400aa38 <__malloc_lock>
 40099ac:	81ffff17 	ldw	r7,-4(r16)
 40099b0:	00bfff84 	movi	r2,-2
 40099b4:	80fffe04 	addi	r3,r16,-8
 40099b8:	3884703a 	and	r2,r7,r2
 40099bc:	01810074 	movhi	r6,1025
 40099c0:	1889883a 	add	r4,r3,r2
 40099c4:	31b36404 	addi	r6,r6,-12912
 40099c8:	21400117 	ldw	r5,4(r4)
 40099cc:	32000217 	ldw	r8,8(r6)
 40099d0:	027fff04 	movi	r9,-4
 40099d4:	2a4a703a 	and	r5,r5,r9
 40099d8:	41006526 	beq	r8,r4,4009b70 <_free_r+0x1e4>
 40099dc:	21400115 	stw	r5,4(r4)
 40099e0:	39c0004c 	andi	r7,r7,1
 40099e4:	2151883a 	add	r8,r4,r5
 40099e8:	3800281e 	bne	r7,zero,4009a8c <_free_r+0x100>
 40099ec:	82bffe17 	ldw	r10,-8(r16)
 40099f0:	42000117 	ldw	r8,4(r8)
 40099f4:	01c10074 	movhi	r7,1025
 40099f8:	1a87c83a 	sub	r3,r3,r10
 40099fc:	1a400217 	ldw	r9,8(r3)
 4009a00:	39f36604 	addi	r7,r7,-12904
 4009a04:	1285883a 	add	r2,r2,r10
 4009a08:	4200004c 	andi	r8,r8,1
 4009a0c:	49c04d26 	beq	r9,r7,4009b44 <_free_r+0x1b8>
 4009a10:	1a800317 	ldw	r10,12(r3)
 4009a14:	4a800315 	stw	r10,12(r9)
 4009a18:	52400215 	stw	r9,8(r10)
 4009a1c:	40006926 	beq	r8,zero,4009bc4 <_free_r+0x238>
 4009a20:	11400054 	ori	r5,r2,1
 4009a24:	19400115 	stw	r5,4(r3)
 4009a28:	20800015 	stw	r2,0(r4)
 4009a2c:	11008028 	cmpgeui	r4,r2,512
 4009a30:	20001e1e 	bne	r4,zero,4009aac <_free_r+0x120>
 4009a34:	1008d0fa 	srli	r4,r2,3
 4009a38:	100ad17a 	srli	r5,r2,5
 4009a3c:	31c00117 	ldw	r7,4(r6)
 4009a40:	20800044 	addi	r2,r4,1
 4009a44:	100490fa 	slli	r2,r2,3
 4009a48:	01000044 	movi	r4,1
 4009a4c:	2148983a 	sll	r4,r4,r5
 4009a50:	3085883a 	add	r2,r6,r2
 4009a54:	11400017 	ldw	r5,0(r2)
 4009a58:	21c8b03a 	or	r4,r4,r7
 4009a5c:	11fffe04 	addi	r7,r2,-8
 4009a60:	19c00315 	stw	r7,12(r3)
 4009a64:	19400215 	stw	r5,8(r3)
 4009a68:	31000115 	stw	r4,4(r6)
 4009a6c:	10c00015 	stw	r3,0(r2)
 4009a70:	28c00315 	stw	r3,12(r5)
 4009a74:	8809883a 	mov	r4,r17
 4009a78:	dfc00217 	ldw	ra,8(sp)
 4009a7c:	dc400117 	ldw	r17,4(sp)
 4009a80:	dc000017 	ldw	r16,0(sp)
 4009a84:	dec00304 	addi	sp,sp,12
 4009a88:	400aa5c1 	jmpi	400aa5c <__malloc_unlock>
 4009a8c:	41c00117 	ldw	r7,4(r8)
 4009a90:	39c0004c 	andi	r7,r7,1
 4009a94:	38001e26 	beq	r7,zero,4009b10 <_free_r+0x184>
 4009a98:	11400054 	ori	r5,r2,1
 4009a9c:	817fff15 	stw	r5,-4(r16)
 4009aa0:	20800015 	stw	r2,0(r4)
 4009aa4:	11008028 	cmpgeui	r4,r2,512
 4009aa8:	203fe226 	beq	r4,zero,4009a34 <_free_r+0xa8>
 4009aac:	1008d27a 	srli	r4,r2,9
 4009ab0:	21400168 	cmpgeui	r5,r4,5
 4009ab4:	2800451e 	bne	r5,zero,4009bcc <_free_r+0x240>
 4009ab8:	1008d1ba 	srli	r4,r2,6
 4009abc:	21c00e44 	addi	r7,r4,57
 4009ac0:	380e90fa 	slli	r7,r7,3
 4009ac4:	21000e04 	addi	r4,r4,56
 4009ac8:	31cf883a 	add	r7,r6,r7
 4009acc:	39400017 	ldw	r5,0(r7)
 4009ad0:	39fffe04 	addi	r7,r7,-8
 4009ad4:	39405326 	beq	r7,r5,4009c24 <_free_r+0x298>
 4009ad8:	01bfff04 	movi	r6,-4
 4009adc:	00000206 	br	4009ae8 <_free_r+0x15c>
 4009ae0:	29400217 	ldw	r5,8(r5)
 4009ae4:	39400326 	beq	r7,r5,4009af4 <_free_r+0x168>
 4009ae8:	29000117 	ldw	r4,4(r5)
 4009aec:	2188703a 	and	r4,r4,r6
 4009af0:	113ffb36 	bltu	r2,r4,4009ae0 <_free_r+0x154>
 4009af4:	29c00317 	ldw	r7,12(r5)
 4009af8:	19c00315 	stw	r7,12(r3)
 4009afc:	19400215 	stw	r5,8(r3)
 4009b00:	38c00215 	stw	r3,8(r7)
 4009b04:	28c00315 	stw	r3,12(r5)
 4009b08:	003fda06 	br	4009a74 <_free_r+0xe8>
 4009b0c:	f800283a 	ret
 4009b10:	01c10074 	movhi	r7,1025
 4009b14:	1145883a 	add	r2,r2,r5
 4009b18:	39f36604 	addi	r7,r7,-12904
 4009b1c:	21400217 	ldw	r5,8(r4)
 4009b20:	29c03726 	beq	r5,r7,4009c00 <_free_r+0x274>
 4009b24:	22000317 	ldw	r8,12(r4)
 4009b28:	11c00054 	ori	r7,r2,1
 4009b2c:	1889883a 	add	r4,r3,r2
 4009b30:	2a000315 	stw	r8,12(r5)
 4009b34:	41400215 	stw	r5,8(r8)
 4009b38:	19c00115 	stw	r7,4(r3)
 4009b3c:	20800015 	stw	r2,0(r4)
 4009b40:	003fba06 	br	4009a2c <_free_r+0xa0>
 4009b44:	40004f1e 	bne	r8,zero,4009c84 <_free_r+0x2f8>
 4009b48:	21800217 	ldw	r6,8(r4)
 4009b4c:	21000317 	ldw	r4,12(r4)
 4009b50:	288b883a 	add	r5,r5,r2
 4009b54:	28800054 	ori	r2,r5,1
 4009b58:	31000315 	stw	r4,12(r6)
 4009b5c:	21800215 	stw	r6,8(r4)
 4009b60:	18800115 	stw	r2,4(r3)
 4009b64:	1947883a 	add	r3,r3,r5
 4009b68:	19400015 	stw	r5,0(r3)
 4009b6c:	003fc106 	br	4009a74 <_free_r+0xe8>
 4009b70:	39c0004c 	andi	r7,r7,1
 4009b74:	114b883a 	add	r5,r2,r5
 4009b78:	3800071e 	bne	r7,zero,4009b98 <_free_r+0x20c>
 4009b7c:	81fffe17 	ldw	r7,-8(r16)
 4009b80:	19c7c83a 	sub	r3,r3,r7
 4009b84:	18800317 	ldw	r2,12(r3)
 4009b88:	19000217 	ldw	r4,8(r3)
 4009b8c:	29cb883a 	add	r5,r5,r7
 4009b90:	20800315 	stw	r2,12(r4)
 4009b94:	11000215 	stw	r4,8(r2)
 4009b98:	00810074 	movhi	r2,1025
 4009b9c:	29000054 	ori	r4,r5,1
 4009ba0:	10b8ec17 	ldw	r2,-7248(r2)
 4009ba4:	19000115 	stw	r4,4(r3)
 4009ba8:	30c00215 	stw	r3,8(r6)
 4009bac:	28bfb136 	bltu	r5,r2,4009a74 <_free_r+0xe8>
 4009bb0:	00810074 	movhi	r2,1025
 4009bb4:	117fa717 	ldw	r5,-356(r2)
 4009bb8:	8809883a 	mov	r4,r17
 4009bbc:	40098680 	call	4009868 <_malloc_trim_r>
 4009bc0:	003fac06 	br	4009a74 <_free_r+0xe8>
 4009bc4:	1145883a 	add	r2,r2,r5
 4009bc8:	003fd406 	br	4009b1c <_free_r+0x190>
 4009bcc:	21400568 	cmpgeui	r5,r4,21
 4009bd0:	28000726 	beq	r5,zero,4009bf0 <_free_r+0x264>
 4009bd4:	21401568 	cmpgeui	r5,r4,85
 4009bd8:	2800191e 	bne	r5,zero,4009c40 <_free_r+0x2b4>
 4009bdc:	1008d33a 	srli	r4,r2,12
 4009be0:	21c01bc4 	addi	r7,r4,111
 4009be4:	380e90fa 	slli	r7,r7,3
 4009be8:	21001b84 	addi	r4,r4,110
 4009bec:	003fb606 	br	4009ac8 <_free_r+0x13c>
 4009bf0:	21c01704 	addi	r7,r4,92
 4009bf4:	380e90fa 	slli	r7,r7,3
 4009bf8:	210016c4 	addi	r4,r4,91
 4009bfc:	003fb206 	br	4009ac8 <_free_r+0x13c>
 4009c00:	30c00515 	stw	r3,20(r6)
 4009c04:	30c00415 	stw	r3,16(r6)
 4009c08:	11000054 	ori	r4,r2,1
 4009c0c:	19c00315 	stw	r7,12(r3)
 4009c10:	19c00215 	stw	r7,8(r3)
 4009c14:	19000115 	stw	r4,4(r3)
 4009c18:	1887883a 	add	r3,r3,r2
 4009c1c:	18800015 	stw	r2,0(r3)
 4009c20:	003f9406 	br	4009a74 <_free_r+0xe8>
 4009c24:	2009d0ba 	srai	r4,r4,2
 4009c28:	00800044 	movi	r2,1
 4009c2c:	32000117 	ldw	r8,4(r6)
 4009c30:	1104983a 	sll	r2,r2,r4
 4009c34:	1204b03a 	or	r2,r2,r8
 4009c38:	30800115 	stw	r2,4(r6)
 4009c3c:	003fae06 	br	4009af8 <_free_r+0x16c>
 4009c40:	21405568 	cmpgeui	r5,r4,341
 4009c44:	2800051e 	bne	r5,zero,4009c5c <_free_r+0x2d0>
 4009c48:	1008d3fa 	srli	r4,r2,15
 4009c4c:	21c01e04 	addi	r7,r4,120
 4009c50:	380e90fa 	slli	r7,r7,3
 4009c54:	21001dc4 	addi	r4,r4,119
 4009c58:	003f9b06 	br	4009ac8 <_free_r+0x13c>
 4009c5c:	21015568 	cmpgeui	r4,r4,1365
 4009c60:	2000051e 	bne	r4,zero,4009c78 <_free_r+0x2ec>
 4009c64:	1008d4ba 	srli	r4,r2,18
 4009c68:	21c01f44 	addi	r7,r4,125
 4009c6c:	380e90fa 	slli	r7,r7,3
 4009c70:	21001f04 	addi	r4,r4,124
 4009c74:	003f9406 	br	4009ac8 <_free_r+0x13c>
 4009c78:	01c0fe04 	movi	r7,1016
 4009c7c:	01001f84 	movi	r4,126
 4009c80:	003f9106 	br	4009ac8 <_free_r+0x13c>
 4009c84:	11400054 	ori	r5,r2,1
 4009c88:	19400115 	stw	r5,4(r3)
 4009c8c:	20800015 	stw	r2,0(r4)
 4009c90:	003f7806 	br	4009a74 <_free_r+0xe8>

04009c94 <_lseek_r>:
 4009c94:	2807883a 	mov	r3,r5
 4009c98:	defffe04 	addi	sp,sp,-8
 4009c9c:	dc000015 	stw	r16,0(sp)
 4009ca0:	300b883a 	mov	r5,r6
 4009ca4:	00810074 	movhi	r2,1025
 4009ca8:	380d883a 	mov	r6,r7
 4009cac:	2021883a 	mov	r16,r4
 4009cb0:	1809883a 	mov	r4,r3
 4009cb4:	dfc00115 	stw	ra,4(sp)
 4009cb8:	103fa815 	stw	zero,-352(r2)
 4009cbc:	400a8dc0 	call	400a8dc <lseek>
 4009cc0:	10ffffd8 	cmpnei	r3,r2,-1
 4009cc4:	18000426 	beq	r3,zero,4009cd8 <_lseek_r+0x44>
 4009cc8:	dfc00117 	ldw	ra,4(sp)
 4009ccc:	dc000017 	ldw	r16,0(sp)
 4009cd0:	dec00204 	addi	sp,sp,8
 4009cd4:	f800283a 	ret
 4009cd8:	00c10074 	movhi	r3,1025
 4009cdc:	18ffa817 	ldw	r3,-352(r3)
 4009ce0:	183ff926 	beq	r3,zero,4009cc8 <_lseek_r+0x34>
 4009ce4:	80c00015 	stw	r3,0(r16)
 4009ce8:	dfc00117 	ldw	ra,4(sp)
 4009cec:	dc000017 	ldw	r16,0(sp)
 4009cf0:	dec00204 	addi	sp,sp,8
 4009cf4:	f800283a 	ret

04009cf8 <__smakebuf_r>:
 4009cf8:	2880030b 	ldhu	r2,12(r5)
 4009cfc:	deffe804 	addi	sp,sp,-96
 4009d00:	dc001215 	stw	r16,72(sp)
 4009d04:	dfc01715 	stw	ra,92(sp)
 4009d08:	dd001615 	stw	r20,88(sp)
 4009d0c:	dcc01515 	stw	r19,84(sp)
 4009d10:	dc801415 	stw	r18,80(sp)
 4009d14:	dc401315 	stw	r17,76(sp)
 4009d18:	10c0008c 	andi	r3,r2,2
 4009d1c:	2821883a 	mov	r16,r5
 4009d20:	18000d26 	beq	r3,zero,4009d58 <__smakebuf_r+0x60>
 4009d24:	288010c4 	addi	r2,r5,67
 4009d28:	28800015 	stw	r2,0(r5)
 4009d2c:	28800415 	stw	r2,16(r5)
 4009d30:	00800044 	movi	r2,1
 4009d34:	28800515 	stw	r2,20(r5)
 4009d38:	dfc01717 	ldw	ra,92(sp)
 4009d3c:	dd001617 	ldw	r20,88(sp)
 4009d40:	dcc01517 	ldw	r19,84(sp)
 4009d44:	dc801417 	ldw	r18,80(sp)
 4009d48:	dc401317 	ldw	r17,76(sp)
 4009d4c:	dc001217 	ldw	r16,72(sp)
 4009d50:	dec01804 	addi	sp,sp,96
 4009d54:	f800283a 	ret
 4009d58:	2940038f 	ldh	r5,14(r5)
 4009d5c:	2023883a 	mov	r17,r4
 4009d60:	28002816 	blt	r5,zero,4009e04 <__smakebuf_r+0x10c>
 4009d64:	d80d883a 	mov	r6,sp
 4009d68:	4009f880 	call	4009f88 <_fstat_r>
 4009d6c:	10002416 	blt	r2,zero,4009e00 <__smakebuf_r+0x108>
 4009d70:	d8800117 	ldw	r2,4(sp)
 4009d74:	10bc000c 	andi	r2,r2,61440
 4009d78:	10880018 	cmpnei	r2,r2,8192
 4009d7c:	1000421e 	bne	r2,zero,4009e88 <__smakebuf_r+0x190>
 4009d80:	8140038f 	ldh	r5,14(r16)
 4009d84:	8809883a 	mov	r4,r17
 4009d88:	4009fe80 	call	4009fe8 <_isatty_r>
 4009d8c:	10000826 	beq	r2,zero,4009db0 <__smakebuf_r+0xb8>
 4009d90:	8080030b 	ldhu	r2,12(r16)
 4009d94:	80c010c4 	addi	r3,r16,67
 4009d98:	80c00015 	stw	r3,0(r16)
 4009d9c:	10800054 	ori	r2,r2,1
 4009da0:	8080030d 	sth	r2,12(r16)
 4009da4:	00800044 	movi	r2,1
 4009da8:	80c00415 	stw	r3,16(r16)
 4009dac:	80800515 	stw	r2,20(r16)
 4009db0:	04c00044 	movi	r19,1
 4009db4:	05010004 	movi	r20,1024
 4009db8:	04820004 	movi	r18,2048
 4009dbc:	a00b883a 	mov	r5,r20
 4009dc0:	8809883a 	mov	r4,r17
 4009dc4:	40081080 	call	4008108 <_malloc_r>
 4009dc8:	10001726 	beq	r2,zero,4009e28 <__smakebuf_r+0x130>
 4009dcc:	80c0030b 	ldhu	r3,12(r16)
 4009dd0:	01010034 	movhi	r4,1024
 4009dd4:	211de704 	addi	r4,r4,30620
 4009dd8:	89000f15 	stw	r4,60(r17)
 4009ddc:	18c02014 	ori	r3,r3,128
 4009de0:	80c0030d 	sth	r3,12(r16)
 4009de4:	80800015 	stw	r2,0(r16)
 4009de8:	80800415 	stw	r2,16(r16)
 4009dec:	85000515 	stw	r20,20(r16)
 4009df0:	98001d1e 	bne	r19,zero,4009e68 <__smakebuf_r+0x170>
 4009df4:	90e4b03a 	or	r18,r18,r3
 4009df8:	8480030d 	sth	r18,12(r16)
 4009dfc:	003fce06 	br	4009d38 <__smakebuf_r+0x40>
 4009e00:	8080030b 	ldhu	r2,12(r16)
 4009e04:	1080200c 	andi	r2,r2,128
 4009e08:	0027883a 	mov	r19,zero
 4009e0c:	10001326 	beq	r2,zero,4009e5c <__smakebuf_r+0x164>
 4009e10:	05001004 	movi	r20,64
 4009e14:	a00b883a 	mov	r5,r20
 4009e18:	8809883a 	mov	r4,r17
 4009e1c:	0025883a 	mov	r18,zero
 4009e20:	40081080 	call	4008108 <_malloc_r>
 4009e24:	103fe91e 	bne	r2,zero,4009dcc <__smakebuf_r+0xd4>
 4009e28:	8080030b 	ldhu	r2,12(r16)
 4009e2c:	10c0800c 	andi	r3,r2,512
 4009e30:	183fc11e 	bne	r3,zero,4009d38 <__smakebuf_r+0x40>
 4009e34:	00ffff04 	movi	r3,-4
 4009e38:	10c4703a 	and	r2,r2,r3
 4009e3c:	10800094 	ori	r2,r2,2
 4009e40:	80c010c4 	addi	r3,r16,67
 4009e44:	8080030d 	sth	r2,12(r16)
 4009e48:	00800044 	movi	r2,1
 4009e4c:	80c00015 	stw	r3,0(r16)
 4009e50:	80c00415 	stw	r3,16(r16)
 4009e54:	80800515 	stw	r2,20(r16)
 4009e58:	003fb706 	br	4009d38 <__smakebuf_r+0x40>
 4009e5c:	05010004 	movi	r20,1024
 4009e60:	0025883a 	mov	r18,zero
 4009e64:	003fd506 	br	4009dbc <__smakebuf_r+0xc4>
 4009e68:	8140038f 	ldh	r5,14(r16)
 4009e6c:	8809883a 	mov	r4,r17
 4009e70:	4009fe80 	call	4009fe8 <_isatty_r>
 4009e74:	80c0030b 	ldhu	r3,12(r16)
 4009e78:	103fde26 	beq	r2,zero,4009df4 <__smakebuf_r+0xfc>
 4009e7c:	18ffff0c 	andi	r3,r3,65532
 4009e80:	18c00054 	ori	r3,r3,1
 4009e84:	003fdb06 	br	4009df4 <__smakebuf_r+0xfc>
 4009e88:	0027883a 	mov	r19,zero
 4009e8c:	05010004 	movi	r20,1024
 4009e90:	04820004 	movi	r18,2048
 4009e94:	003fc906 	br	4009dbc <__smakebuf_r+0xc4>

04009e98 <__swhatbuf_r>:
 4009e98:	deffea04 	addi	sp,sp,-88
 4009e9c:	dc001215 	stw	r16,72(sp)
 4009ea0:	2821883a 	mov	r16,r5
 4009ea4:	2940038f 	ldh	r5,14(r5)
 4009ea8:	dc801415 	stw	r18,80(sp)
 4009eac:	dc401315 	stw	r17,76(sp)
 4009eb0:	dfc01515 	stw	ra,84(sp)
 4009eb4:	3023883a 	mov	r17,r6
 4009eb8:	3825883a 	mov	r18,r7
 4009ebc:	28001016 	blt	r5,zero,4009f00 <__swhatbuf_r+0x68>
 4009ec0:	d80d883a 	mov	r6,sp
 4009ec4:	4009f880 	call	4009f88 <_fstat_r>
 4009ec8:	10000d16 	blt	r2,zero,4009f00 <__swhatbuf_r+0x68>
 4009ecc:	d8c00117 	ldw	r3,4(sp)
 4009ed0:	01010004 	movi	r4,1024
 4009ed4:	00820004 	movi	r2,2048
 4009ed8:	18fc000c 	andi	r3,r3,61440
 4009edc:	18c80020 	cmpeqi	r3,r3,8192
 4009ee0:	90c00015 	stw	r3,0(r18)
 4009ee4:	89000015 	stw	r4,0(r17)
 4009ee8:	dfc01517 	ldw	ra,84(sp)
 4009eec:	dc801417 	ldw	r18,80(sp)
 4009ef0:	dc401317 	ldw	r17,76(sp)
 4009ef4:	dc001217 	ldw	r16,72(sp)
 4009ef8:	dec01604 	addi	sp,sp,88
 4009efc:	f800283a 	ret
 4009f00:	8080030b 	ldhu	r2,12(r16)
 4009f04:	0007883a 	mov	r3,zero
 4009f08:	1080200c 	andi	r2,r2,128
 4009f0c:	10000326 	beq	r2,zero,4009f1c <__swhatbuf_r+0x84>
 4009f10:	01001004 	movi	r4,64
 4009f14:	0005883a 	mov	r2,zero
 4009f18:	003ff106 	br	4009ee0 <__swhatbuf_r+0x48>
 4009f1c:	01010004 	movi	r4,1024
 4009f20:	003fef06 	br	4009ee0 <__swhatbuf_r+0x48>

04009f24 <_read_r>:
 4009f24:	2807883a 	mov	r3,r5
 4009f28:	defffe04 	addi	sp,sp,-8
 4009f2c:	dc000015 	stw	r16,0(sp)
 4009f30:	300b883a 	mov	r5,r6
 4009f34:	00810074 	movhi	r2,1025
 4009f38:	380d883a 	mov	r6,r7
 4009f3c:	2021883a 	mov	r16,r4
 4009f40:	1809883a 	mov	r4,r3
 4009f44:	dfc00115 	stw	ra,4(sp)
 4009f48:	103fa815 	stw	zero,-352(r2)
 4009f4c:	400aabc0 	call	400aabc <read>
 4009f50:	10ffffd8 	cmpnei	r3,r2,-1
 4009f54:	18000426 	beq	r3,zero,4009f68 <_read_r+0x44>
 4009f58:	dfc00117 	ldw	ra,4(sp)
 4009f5c:	dc000017 	ldw	r16,0(sp)
 4009f60:	dec00204 	addi	sp,sp,8
 4009f64:	f800283a 	ret
 4009f68:	00c10074 	movhi	r3,1025
 4009f6c:	18ffa817 	ldw	r3,-352(r3)
 4009f70:	183ff926 	beq	r3,zero,4009f58 <_read_r+0x34>
 4009f74:	80c00015 	stw	r3,0(r16)
 4009f78:	dfc00117 	ldw	ra,4(sp)
 4009f7c:	dc000017 	ldw	r16,0(sp)
 4009f80:	dec00204 	addi	sp,sp,8
 4009f84:	f800283a 	ret

04009f88 <_fstat_r>:
 4009f88:	2807883a 	mov	r3,r5
 4009f8c:	defffe04 	addi	sp,sp,-8
 4009f90:	dc000015 	stw	r16,0(sp)
 4009f94:	00810074 	movhi	r2,1025
 4009f98:	300b883a 	mov	r5,r6
 4009f9c:	2021883a 	mov	r16,r4
 4009fa0:	1809883a 	mov	r4,r3
 4009fa4:	dfc00115 	stw	ra,4(sp)
 4009fa8:	103fa815 	stw	zero,-352(r2)
 4009fac:	400a3740 	call	400a374 <fstat>
 4009fb0:	10ffffd8 	cmpnei	r3,r2,-1
 4009fb4:	18000426 	beq	r3,zero,4009fc8 <_fstat_r+0x40>
 4009fb8:	dfc00117 	ldw	ra,4(sp)
 4009fbc:	dc000017 	ldw	r16,0(sp)
 4009fc0:	dec00204 	addi	sp,sp,8
 4009fc4:	f800283a 	ret
 4009fc8:	00c10074 	movhi	r3,1025
 4009fcc:	18ffa817 	ldw	r3,-352(r3)
 4009fd0:	183ff926 	beq	r3,zero,4009fb8 <_fstat_r+0x30>
 4009fd4:	80c00015 	stw	r3,0(r16)
 4009fd8:	dfc00117 	ldw	ra,4(sp)
 4009fdc:	dc000017 	ldw	r16,0(sp)
 4009fe0:	dec00204 	addi	sp,sp,8
 4009fe4:	f800283a 	ret

04009fe8 <_isatty_r>:
 4009fe8:	defffe04 	addi	sp,sp,-8
 4009fec:	dc000015 	stw	r16,0(sp)
 4009ff0:	00810074 	movhi	r2,1025
 4009ff4:	2021883a 	mov	r16,r4
 4009ff8:	2809883a 	mov	r4,r5
 4009ffc:	dfc00115 	stw	ra,4(sp)
 400a000:	103fa815 	stw	zero,-352(r2)
 400a004:	400a7040 	call	400a704 <isatty>
 400a008:	10ffffd8 	cmpnei	r3,r2,-1
 400a00c:	18000426 	beq	r3,zero,400a020 <_isatty_r+0x38>
 400a010:	dfc00117 	ldw	ra,4(sp)
 400a014:	dc000017 	ldw	r16,0(sp)
 400a018:	dec00204 	addi	sp,sp,8
 400a01c:	f800283a 	ret
 400a020:	00c10074 	movhi	r3,1025
 400a024:	18ffa817 	ldw	r3,-352(r3)
 400a028:	183ff926 	beq	r3,zero,400a010 <_isatty_r+0x28>
 400a02c:	80c00015 	stw	r3,0(r16)
 400a030:	dfc00117 	ldw	ra,4(sp)
 400a034:	dc000017 	ldw	r16,0(sp)
 400a038:	dec00204 	addi	sp,sp,8
 400a03c:	f800283a 	ret

0400a040 <__divsi3>:
 400a040:	20001a16 	blt	r4,zero,400a0ac <__divsi3+0x6c>
 400a044:	000f883a 	mov	r7,zero
 400a048:	2800020e 	bge	r5,zero,400a054 <__divsi3+0x14>
 400a04c:	014bc83a 	sub	r5,zero,r5
 400a050:	39c0005c 	xori	r7,r7,1
 400a054:	200d883a 	mov	r6,r4
 400a058:	00c00044 	movi	r3,1
 400a05c:	2900092e 	bgeu	r5,r4,400a084 <__divsi3+0x44>
 400a060:	00800804 	movi	r2,32
 400a064:	00c00044 	movi	r3,1
 400a068:	00000106 	br	400a070 <__divsi3+0x30>
 400a06c:	10001226 	beq	r2,zero,400a0b8 <__divsi3+0x78>
 400a070:	294b883a 	add	r5,r5,r5
 400a074:	10bfffc4 	addi	r2,r2,-1
 400a078:	18c7883a 	add	r3,r3,r3
 400a07c:	293ffb36 	bltu	r5,r4,400a06c <__divsi3+0x2c>
 400a080:	18000d26 	beq	r3,zero,400a0b8 <__divsi3+0x78>
 400a084:	0005883a 	mov	r2,zero
 400a088:	31400236 	bltu	r6,r5,400a094 <__divsi3+0x54>
 400a08c:	314dc83a 	sub	r6,r6,r5
 400a090:	10c4b03a 	or	r2,r2,r3
 400a094:	1806d07a 	srli	r3,r3,1
 400a098:	280ad07a 	srli	r5,r5,1
 400a09c:	183ffa1e 	bne	r3,zero,400a088 <__divsi3+0x48>
 400a0a0:	38000126 	beq	r7,zero,400a0a8 <__divsi3+0x68>
 400a0a4:	0085c83a 	sub	r2,zero,r2
 400a0a8:	f800283a 	ret
 400a0ac:	0109c83a 	sub	r4,zero,r4
 400a0b0:	01c00044 	movi	r7,1
 400a0b4:	003fe406 	br	400a048 <__divsi3+0x8>
 400a0b8:	0005883a 	mov	r2,zero
 400a0bc:	003ff806 	br	400a0a0 <__divsi3+0x60>

0400a0c0 <__modsi3>:
 400a0c0:	20001716 	blt	r4,zero,400a120 <__modsi3+0x60>
 400a0c4:	000f883a 	mov	r7,zero
 400a0c8:	2005883a 	mov	r2,r4
 400a0cc:	2800010e 	bge	r5,zero,400a0d4 <__modsi3+0x14>
 400a0d0:	014bc83a 	sub	r5,zero,r5
 400a0d4:	00c00044 	movi	r3,1
 400a0d8:	2900092e 	bgeu	r5,r4,400a100 <__modsi3+0x40>
 400a0dc:	01800804 	movi	r6,32
 400a0e0:	00c00044 	movi	r3,1
 400a0e4:	00000106 	br	400a0ec <__modsi3+0x2c>
 400a0e8:	30001026 	beq	r6,zero,400a12c <__modsi3+0x6c>
 400a0ec:	294b883a 	add	r5,r5,r5
 400a0f0:	31bfffc4 	addi	r6,r6,-1
 400a0f4:	18c7883a 	add	r3,r3,r3
 400a0f8:	293ffb36 	bltu	r5,r4,400a0e8 <__modsi3+0x28>
 400a0fc:	18000b26 	beq	r3,zero,400a12c <__modsi3+0x6c>
 400a100:	1806d07a 	srli	r3,r3,1
 400a104:	11400136 	bltu	r2,r5,400a10c <__modsi3+0x4c>
 400a108:	1145c83a 	sub	r2,r2,r5
 400a10c:	280ad07a 	srli	r5,r5,1
 400a110:	183ffb1e 	bne	r3,zero,400a100 <__modsi3+0x40>
 400a114:	38000126 	beq	r7,zero,400a11c <__modsi3+0x5c>
 400a118:	0085c83a 	sub	r2,zero,r2
 400a11c:	f800283a 	ret
 400a120:	0109c83a 	sub	r4,zero,r4
 400a124:	01c00044 	movi	r7,1
 400a128:	003fe706 	br	400a0c8 <__modsi3+0x8>
 400a12c:	2005883a 	mov	r2,r4
 400a130:	003ff806 	br	400a114 <__modsi3+0x54>

0400a134 <__udivsi3>:
 400a134:	200d883a 	mov	r6,r4
 400a138:	2900152e 	bgeu	r5,r4,400a190 <__udivsi3+0x5c>
 400a13c:	28001416 	blt	r5,zero,400a190 <__udivsi3+0x5c>
 400a140:	00800804 	movi	r2,32
 400a144:	00c00044 	movi	r3,1
 400a148:	00000206 	br	400a154 <__udivsi3+0x20>
 400a14c:	10000e26 	beq	r2,zero,400a188 <__udivsi3+0x54>
 400a150:	28000416 	blt	r5,zero,400a164 <__udivsi3+0x30>
 400a154:	294b883a 	add	r5,r5,r5
 400a158:	10bfffc4 	addi	r2,r2,-1
 400a15c:	18c7883a 	add	r3,r3,r3
 400a160:	293ffa36 	bltu	r5,r4,400a14c <__udivsi3+0x18>
 400a164:	18000826 	beq	r3,zero,400a188 <__udivsi3+0x54>
 400a168:	0005883a 	mov	r2,zero
 400a16c:	31400236 	bltu	r6,r5,400a178 <__udivsi3+0x44>
 400a170:	314dc83a 	sub	r6,r6,r5
 400a174:	10c4b03a 	or	r2,r2,r3
 400a178:	1806d07a 	srli	r3,r3,1
 400a17c:	280ad07a 	srli	r5,r5,1
 400a180:	183ffa1e 	bne	r3,zero,400a16c <__udivsi3+0x38>
 400a184:	f800283a 	ret
 400a188:	0005883a 	mov	r2,zero
 400a18c:	f800283a 	ret
 400a190:	00c00044 	movi	r3,1
 400a194:	003ff406 	br	400a168 <__udivsi3+0x34>

0400a198 <__umodsi3>:
 400a198:	2005883a 	mov	r2,r4
 400a19c:	2900132e 	bgeu	r5,r4,400a1ec <__umodsi3+0x54>
 400a1a0:	28001216 	blt	r5,zero,400a1ec <__umodsi3+0x54>
 400a1a4:	01800804 	movi	r6,32
 400a1a8:	00c00044 	movi	r3,1
 400a1ac:	00000206 	br	400a1b8 <__umodsi3+0x20>
 400a1b0:	30000c26 	beq	r6,zero,400a1e4 <__umodsi3+0x4c>
 400a1b4:	28000416 	blt	r5,zero,400a1c8 <__umodsi3+0x30>
 400a1b8:	294b883a 	add	r5,r5,r5
 400a1bc:	31bfffc4 	addi	r6,r6,-1
 400a1c0:	18c7883a 	add	r3,r3,r3
 400a1c4:	293ffa36 	bltu	r5,r4,400a1b0 <__umodsi3+0x18>
 400a1c8:	18000626 	beq	r3,zero,400a1e4 <__umodsi3+0x4c>
 400a1cc:	1806d07a 	srli	r3,r3,1
 400a1d0:	11400136 	bltu	r2,r5,400a1d8 <__umodsi3+0x40>
 400a1d4:	1145c83a 	sub	r2,r2,r5
 400a1d8:	280ad07a 	srli	r5,r5,1
 400a1dc:	183ffb1e 	bne	r3,zero,400a1cc <__umodsi3+0x34>
 400a1e0:	f800283a 	ret
 400a1e4:	2005883a 	mov	r2,r4
 400a1e8:	f800283a 	ret
 400a1ec:	00c00044 	movi	r3,1
 400a1f0:	003ff606 	br	400a1cc <__umodsi3+0x34>

0400a1f4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 400a1f4:	defffe04 	addi	sp,sp,-8
 400a1f8:	dfc00115 	stw	ra,4(sp)
 400a1fc:	df000015 	stw	fp,0(sp)
 400a200:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 400a204:	d0a00a17 	ldw	r2,-32728(gp)
 400a208:	10000326 	beq	r2,zero,400a218 <alt_get_errno+0x24>
 400a20c:	d0a00a17 	ldw	r2,-32728(gp)
 400a210:	103ee83a 	callr	r2
 400a214:	00000106 	br	400a21c <alt_get_errno+0x28>
 400a218:	d0a6c004 	addi	r2,gp,-25856
}
 400a21c:	e037883a 	mov	sp,fp
 400a220:	dfc00117 	ldw	ra,4(sp)
 400a224:	df000017 	ldw	fp,0(sp)
 400a228:	dec00204 	addi	sp,sp,8
 400a22c:	f800283a 	ret

0400a230 <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
 400a230:	defffb04 	addi	sp,sp,-20
 400a234:	dfc00415 	stw	ra,16(sp)
 400a238:	df000315 	stw	fp,12(sp)
 400a23c:	df000304 	addi	fp,sp,12
 400a240:	e13ffd15 	stw	r4,-12(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
 400a244:	e0bffd17 	ldw	r2,-12(fp)
 400a248:	10000916 	blt	r2,zero,400a270 <close+0x40>
 400a24c:	e0fffd17 	ldw	r3,-12(fp)
 400a250:	1805883a 	mov	r2,r3
 400a254:	1085883a 	add	r2,r2,r2
 400a258:	10c5883a 	add	r2,r2,r3
 400a25c:	100490ba 	slli	r2,r2,2
 400a260:	00c10074 	movhi	r3,1025
 400a264:	18f47004 	addi	r3,r3,-11840
 400a268:	10c5883a 	add	r2,r2,r3
 400a26c:	00000106 	br	400a274 <close+0x44>
 400a270:	0005883a 	mov	r2,zero
 400a274:	e0bfff15 	stw	r2,-4(fp)

  if (fd)
 400a278:	e0bfff17 	ldw	r2,-4(fp)
 400a27c:	10001926 	beq	r2,zero,400a2e4 <close+0xb4>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
 400a280:	e0bfff17 	ldw	r2,-4(fp)
 400a284:	10800017 	ldw	r2,0(r2)
 400a288:	10800417 	ldw	r2,16(r2)
 400a28c:	10000626 	beq	r2,zero,400a2a8 <close+0x78>
 400a290:	e0bfff17 	ldw	r2,-4(fp)
 400a294:	10800017 	ldw	r2,0(r2)
 400a298:	10800417 	ldw	r2,16(r2)
 400a29c:	e13fff17 	ldw	r4,-4(fp)
 400a2a0:	103ee83a 	callr	r2
 400a2a4:	00000106 	br	400a2ac <close+0x7c>
 400a2a8:	0005883a 	mov	r2,zero
 400a2ac:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
 400a2b0:	e13ffd17 	ldw	r4,-12(fp)
 400a2b4:	400abc40 	call	400abc4 <alt_release_fd>
    if (rval < 0)
 400a2b8:	e0bffe17 	ldw	r2,-8(fp)
 400a2bc:	1000070e 	bge	r2,zero,400a2dc <close+0xac>
    {
      ALT_ERRNO = -rval;
 400a2c0:	400a1f40 	call	400a1f4 <alt_get_errno>
 400a2c4:	1007883a 	mov	r3,r2
 400a2c8:	e0bffe17 	ldw	r2,-8(fp)
 400a2cc:	0085c83a 	sub	r2,zero,r2
 400a2d0:	18800015 	stw	r2,0(r3)
      return -1;
 400a2d4:	00bfffc4 	movi	r2,-1
 400a2d8:	00000706 	br	400a2f8 <close+0xc8>
    }
    return 0;
 400a2dc:	0005883a 	mov	r2,zero
 400a2e0:	00000506 	br	400a2f8 <close+0xc8>
  }
  else
  {
    ALT_ERRNO = EBADFD;
 400a2e4:	400a1f40 	call	400a1f4 <alt_get_errno>
 400a2e8:	1007883a 	mov	r3,r2
 400a2ec:	00801444 	movi	r2,81
 400a2f0:	18800015 	stw	r2,0(r3)
    return -1;
 400a2f4:	00bfffc4 	movi	r2,-1
  }
}
 400a2f8:	e037883a 	mov	sp,fp
 400a2fc:	dfc00117 	ldw	ra,4(sp)
 400a300:	df000017 	ldw	fp,0(sp)
 400a304:	dec00204 	addi	sp,sp,8
 400a308:	f800283a 	ret

0400a30c <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
 400a30c:	defffc04 	addi	sp,sp,-16
 400a310:	df000315 	stw	fp,12(sp)
 400a314:	df000304 	addi	fp,sp,12
 400a318:	e13fff15 	stw	r4,-4(fp)
 400a31c:	e17ffe15 	stw	r5,-8(fp)
 400a320:	e1bffd15 	stw	r6,-12(fp)
  return len;
 400a324:	e0bffd17 	ldw	r2,-12(fp)
}
 400a328:	e037883a 	mov	sp,fp
 400a32c:	df000017 	ldw	fp,0(sp)
 400a330:	dec00104 	addi	sp,sp,4
 400a334:	f800283a 	ret

0400a338 <alt_get_errno>:
{
 400a338:	defffe04 	addi	sp,sp,-8
 400a33c:	dfc00115 	stw	ra,4(sp)
 400a340:	df000015 	stw	fp,0(sp)
 400a344:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 400a348:	d0a00a17 	ldw	r2,-32728(gp)
 400a34c:	10000326 	beq	r2,zero,400a35c <alt_get_errno+0x24>
 400a350:	d0a00a17 	ldw	r2,-32728(gp)
 400a354:	103ee83a 	callr	r2
 400a358:	00000106 	br	400a360 <alt_get_errno+0x28>
 400a35c:	d0a6c004 	addi	r2,gp,-25856
}
 400a360:	e037883a 	mov	sp,fp
 400a364:	dfc00117 	ldw	ra,4(sp)
 400a368:	df000017 	ldw	fp,0(sp)
 400a36c:	dec00204 	addi	sp,sp,8
 400a370:	f800283a 	ret

0400a374 <fstat>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_FSTAT (int file, struct stat *st)
{
 400a374:	defffb04 	addi	sp,sp,-20
 400a378:	dfc00415 	stw	ra,16(sp)
 400a37c:	df000315 	stw	fp,12(sp)
 400a380:	df000304 	addi	fp,sp,12
 400a384:	e13ffe15 	stw	r4,-8(fp)
 400a388:	e17ffd15 	stw	r5,-12(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 400a38c:	e0bffe17 	ldw	r2,-8(fp)
 400a390:	10000916 	blt	r2,zero,400a3b8 <fstat+0x44>
 400a394:	e0fffe17 	ldw	r3,-8(fp)
 400a398:	1805883a 	mov	r2,r3
 400a39c:	1085883a 	add	r2,r2,r2
 400a3a0:	10c5883a 	add	r2,r2,r3
 400a3a4:	100490ba 	slli	r2,r2,2
 400a3a8:	00c10074 	movhi	r3,1025
 400a3ac:	18f47004 	addi	r3,r3,-11840
 400a3b0:	10c5883a 	add	r2,r2,r3
 400a3b4:	00000106 	br	400a3bc <fstat+0x48>
 400a3b8:	0005883a 	mov	r2,zero
 400a3bc:	e0bfff15 	stw	r2,-4(fp)
  
  if (fd)
 400a3c0:	e0bfff17 	ldw	r2,-4(fp)
 400a3c4:	10001026 	beq	r2,zero,400a408 <fstat+0x94>
  {
    /* Call the drivers fstat() function to fill out the "st" structure. */

    if (fd->dev->fstat)
 400a3c8:	e0bfff17 	ldw	r2,-4(fp)
 400a3cc:	10800017 	ldw	r2,0(r2)
 400a3d0:	10800817 	ldw	r2,32(r2)
 400a3d4:	10000726 	beq	r2,zero,400a3f4 <fstat+0x80>
    {
      return fd->dev->fstat(fd, st);
 400a3d8:	e0bfff17 	ldw	r2,-4(fp)
 400a3dc:	10800017 	ldw	r2,0(r2)
 400a3e0:	10800817 	ldw	r2,32(r2)
 400a3e4:	e17ffd17 	ldw	r5,-12(fp)
 400a3e8:	e13fff17 	ldw	r4,-4(fp)
 400a3ec:	103ee83a 	callr	r2
 400a3f0:	00000a06 	br	400a41c <fstat+0xa8>
     * device.
     */
 
    else
    {
      st->st_mode = _IFCHR;
 400a3f4:	e0bffd17 	ldw	r2,-12(fp)
 400a3f8:	00c80004 	movi	r3,8192
 400a3fc:	10c00115 	stw	r3,4(r2)
      return 0;
 400a400:	0005883a 	mov	r2,zero
 400a404:	00000506 	br	400a41c <fstat+0xa8>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
 400a408:	400a3380 	call	400a338 <alt_get_errno>
 400a40c:	1007883a 	mov	r3,r2
 400a410:	00801444 	movi	r2,81
 400a414:	18800015 	stw	r2,0(r3)
    return -1;
 400a418:	00bfffc4 	movi	r2,-1
  }
}
 400a41c:	e037883a 	mov	sp,fp
 400a420:	dfc00117 	ldw	ra,4(sp)
 400a424:	df000017 	ldw	fp,0(sp)
 400a428:	dec00204 	addi	sp,sp,8
 400a42c:	f800283a 	ret

0400a430 <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
 400a430:	defff904 	addi	sp,sp,-28
 400a434:	dfc00615 	stw	ra,24(sp)
 400a438:	df000515 	stw	fp,20(sp)
 400a43c:	df000504 	addi	fp,sp,20
 400a440:	e13fff15 	stw	r4,-4(fp)
 400a444:	e17ffe15 	stw	r5,-8(fp)
 400a448:	e1bffd15 	stw	r6,-12(fp)
 400a44c:	e1fffc15 	stw	r7,-16(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
 400a450:	e0800217 	ldw	r2,8(fp)
 400a454:	d8800015 	stw	r2,0(sp)
 400a458:	e1fffc17 	ldw	r7,-16(fp)
 400a45c:	e1bffd17 	ldw	r6,-12(fp)
 400a460:	e17ffe17 	ldw	r5,-8(fp)
 400a464:	e13fff17 	ldw	r4,-4(fp)
 400a468:	400a5e00 	call	400a5e0 <alt_iic_isr_register>
}  
 400a46c:	e037883a 	mov	sp,fp
 400a470:	dfc00117 	ldw	ra,4(sp)
 400a474:	df000017 	ldw	fp,0(sp)
 400a478:	dec00204 	addi	sp,sp,8
 400a47c:	f800283a 	ret

0400a480 <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
 400a480:	defff904 	addi	sp,sp,-28
 400a484:	df000615 	stw	fp,24(sp)
 400a488:	df000604 	addi	fp,sp,24
 400a48c:	e13ffb15 	stw	r4,-20(fp)
 400a490:	e17ffa15 	stw	r5,-24(fp)
 400a494:	e0bffa17 	ldw	r2,-24(fp)
 400a498:	e0bfff15 	stw	r2,-4(fp)
  NIOS2_READ_STATUS (context);
 400a49c:	0005303a 	rdctl	r2,status
 400a4a0:	e0bffe15 	stw	r2,-8(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 400a4a4:	e0fffe17 	ldw	r3,-8(fp)
 400a4a8:	00bfff84 	movi	r2,-2
 400a4ac:	1884703a 	and	r2,r3,r2
 400a4b0:	1001703a 	wrctl	status,r2
  return context;
 400a4b4:	e0bffe17 	ldw	r2,-8(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 400a4b8:	e0bffd15 	stw	r2,-12(fp)

  alt_irq_active |= (1 << id);
 400a4bc:	00c00044 	movi	r3,1
 400a4c0:	e0bfff17 	ldw	r2,-4(fp)
 400a4c4:	1884983a 	sll	r2,r3,r2
 400a4c8:	1007883a 	mov	r3,r2
 400a4cc:	d0a6c117 	ldw	r2,-25852(gp)
 400a4d0:	1884b03a 	or	r2,r3,r2
 400a4d4:	d0a6c115 	stw	r2,-25852(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 400a4d8:	d0a6c117 	ldw	r2,-25852(gp)
 400a4dc:	100170fa 	wrctl	ienable,r2
 400a4e0:	e0bffd17 	ldw	r2,-12(fp)
 400a4e4:	e0bffc15 	stw	r2,-16(fp)
  NIOS2_WRITE_STATUS (context);
 400a4e8:	e0bffc17 	ldw	r2,-16(fp)
 400a4ec:	1001703a 	wrctl	status,r2
}
 400a4f0:	0001883a 	nop

  alt_irq_enable_all(status);

  return 0;
 400a4f4:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
}
 400a4f8:	e037883a 	mov	sp,fp
 400a4fc:	df000017 	ldw	fp,0(sp)
 400a500:	dec00104 	addi	sp,sp,4
 400a504:	f800283a 	ret

0400a508 <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
 400a508:	defff904 	addi	sp,sp,-28
 400a50c:	df000615 	stw	fp,24(sp)
 400a510:	df000604 	addi	fp,sp,24
 400a514:	e13ffb15 	stw	r4,-20(fp)
 400a518:	e17ffa15 	stw	r5,-24(fp)
 400a51c:	e0bffa17 	ldw	r2,-24(fp)
 400a520:	e0bfff15 	stw	r2,-4(fp)
  NIOS2_READ_STATUS (context);
 400a524:	0005303a 	rdctl	r2,status
 400a528:	e0bffe15 	stw	r2,-8(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 400a52c:	e0fffe17 	ldw	r3,-8(fp)
 400a530:	00bfff84 	movi	r2,-2
 400a534:	1884703a 	and	r2,r3,r2
 400a538:	1001703a 	wrctl	status,r2
  return context;
 400a53c:	e0bffe17 	ldw	r2,-8(fp)
  status = alt_irq_disable_all ();
 400a540:	e0bffd15 	stw	r2,-12(fp)
  alt_irq_active &= ~(1 << id);
 400a544:	00c00044 	movi	r3,1
 400a548:	e0bfff17 	ldw	r2,-4(fp)
 400a54c:	1884983a 	sll	r2,r3,r2
 400a550:	0084303a 	nor	r2,zero,r2
 400a554:	1007883a 	mov	r3,r2
 400a558:	d0a6c117 	ldw	r2,-25852(gp)
 400a55c:	1884703a 	and	r2,r3,r2
 400a560:	d0a6c115 	stw	r2,-25852(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 400a564:	d0a6c117 	ldw	r2,-25852(gp)
 400a568:	100170fa 	wrctl	ienable,r2
 400a56c:	e0bffd17 	ldw	r2,-12(fp)
 400a570:	e0bffc15 	stw	r2,-16(fp)
  NIOS2_WRITE_STATUS (context);
 400a574:	e0bffc17 	ldw	r2,-16(fp)
 400a578:	1001703a 	wrctl	status,r2
}
 400a57c:	0001883a 	nop
  return 0;
 400a580:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
}
 400a584:	e037883a 	mov	sp,fp
 400a588:	df000017 	ldw	fp,0(sp)
 400a58c:	dec00104 	addi	sp,sp,4
 400a590:	f800283a 	ret

0400a594 <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
 400a594:	defffc04 	addi	sp,sp,-16
 400a598:	df000315 	stw	fp,12(sp)
 400a59c:	df000304 	addi	fp,sp,12
 400a5a0:	e13ffe15 	stw	r4,-8(fp)
 400a5a4:	e17ffd15 	stw	r5,-12(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
 400a5a8:	000530fa 	rdctl	r2,ienable
 400a5ac:	e0bfff15 	stw	r2,-4(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
 400a5b0:	00c00044 	movi	r3,1
 400a5b4:	e0bffd17 	ldw	r2,-12(fp)
 400a5b8:	1884983a 	sll	r2,r3,r2
 400a5bc:	1007883a 	mov	r3,r2
 400a5c0:	e0bfff17 	ldw	r2,-4(fp)
 400a5c4:	1884703a 	and	r2,r3,r2
 400a5c8:	1004c03a 	cmpne	r2,r2,zero
 400a5cc:	10803fcc 	andi	r2,r2,255
}
 400a5d0:	e037883a 	mov	sp,fp
 400a5d4:	df000017 	ldw	fp,0(sp)
 400a5d8:	dec00104 	addi	sp,sp,4
 400a5dc:	f800283a 	ret

0400a5e0 <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
 400a5e0:	defff504 	addi	sp,sp,-44
 400a5e4:	dfc00a15 	stw	ra,40(sp)
 400a5e8:	df000915 	stw	fp,36(sp)
 400a5ec:	df000904 	addi	fp,sp,36
 400a5f0:	e13ffa15 	stw	r4,-24(fp)
 400a5f4:	e17ff915 	stw	r5,-28(fp)
 400a5f8:	e1bff815 	stw	r6,-32(fp)
 400a5fc:	e1fff715 	stw	r7,-36(fp)
  int rc = -EINVAL;  
 400a600:	00bffa84 	movi	r2,-22
 400a604:	e0bfff15 	stw	r2,-4(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
 400a608:	e0bff917 	ldw	r2,-28(fp)
 400a60c:	e0bffe15 	stw	r2,-8(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
 400a610:	e0bffe17 	ldw	r2,-8(fp)
 400a614:	10800808 	cmpgei	r2,r2,32
 400a618:	1000251e 	bne	r2,zero,400a6b0 <alt_iic_isr_register+0xd0>
  NIOS2_READ_STATUS (context);
 400a61c:	0005303a 	rdctl	r2,status
 400a620:	e0bffc15 	stw	r2,-16(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 400a624:	e0fffc17 	ldw	r3,-16(fp)
 400a628:	00bfff84 	movi	r2,-2
 400a62c:	1884703a 	and	r2,r3,r2
 400a630:	1001703a 	wrctl	status,r2
  return context;
 400a634:	e0bffc17 	ldw	r2,-16(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
 400a638:	e0bffd15 	stw	r2,-12(fp)

    alt_irq[id].handler = isr;
 400a63c:	e0bffe17 	ldw	r2,-8(fp)
 400a640:	100890fa 	slli	r4,r2,3
 400a644:	e0fff817 	ldw	r3,-32(fp)
 400a648:	00812074 	movhi	r2,1153
 400a64c:	2085883a 	add	r2,r4,r2
 400a650:	10ffed15 	stw	r3,-76(r2)
    alt_irq[id].context = isr_context;
 400a654:	e0bffe17 	ldw	r2,-8(fp)
 400a658:	100890fa 	slli	r4,r2,3
 400a65c:	e0fff717 	ldw	r3,-36(fp)
 400a660:	00812074 	movhi	r2,1153
 400a664:	2085883a 	add	r2,r4,r2
 400a668:	10ffee15 	stw	r3,-72(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
 400a66c:	e0bff817 	ldw	r2,-32(fp)
 400a670:	10000526 	beq	r2,zero,400a688 <alt_iic_isr_register+0xa8>
 400a674:	e0bffe17 	ldw	r2,-8(fp)
 400a678:	100b883a 	mov	r5,r2
 400a67c:	e13ffa17 	ldw	r4,-24(fp)
 400a680:	400a4800 	call	400a480 <alt_ic_irq_enable>
 400a684:	00000406 	br	400a698 <alt_iic_isr_register+0xb8>
 400a688:	e0bffe17 	ldw	r2,-8(fp)
 400a68c:	100b883a 	mov	r5,r2
 400a690:	e13ffa17 	ldw	r4,-24(fp)
 400a694:	400a5080 	call	400a508 <alt_ic_irq_disable>
 400a698:	e0bfff15 	stw	r2,-4(fp)
 400a69c:	e0bffd17 	ldw	r2,-12(fp)
 400a6a0:	e0bffb15 	stw	r2,-20(fp)
  NIOS2_WRITE_STATUS (context);
 400a6a4:	e0bffb17 	ldw	r2,-20(fp)
 400a6a8:	1001703a 	wrctl	status,r2
}
 400a6ac:	0001883a 	nop

    alt_irq_enable_all(status);
  }

  return rc; 
 400a6b0:	e0bfff17 	ldw	r2,-4(fp)
}
 400a6b4:	e037883a 	mov	sp,fp
 400a6b8:	dfc00117 	ldw	ra,4(sp)
 400a6bc:	df000017 	ldw	fp,0(sp)
 400a6c0:	dec00204 	addi	sp,sp,8
 400a6c4:	f800283a 	ret

0400a6c8 <alt_get_errno>:
{
 400a6c8:	defffe04 	addi	sp,sp,-8
 400a6cc:	dfc00115 	stw	ra,4(sp)
 400a6d0:	df000015 	stw	fp,0(sp)
 400a6d4:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 400a6d8:	d0a00a17 	ldw	r2,-32728(gp)
 400a6dc:	10000326 	beq	r2,zero,400a6ec <alt_get_errno+0x24>
 400a6e0:	d0a00a17 	ldw	r2,-32728(gp)
 400a6e4:	103ee83a 	callr	r2
 400a6e8:	00000106 	br	400a6f0 <alt_get_errno+0x28>
 400a6ec:	d0a6c004 	addi	r2,gp,-25856
}
 400a6f0:	e037883a 	mov	sp,fp
 400a6f4:	dfc00117 	ldw	ra,4(sp)
 400a6f8:	df000017 	ldw	fp,0(sp)
 400a6fc:	dec00204 	addi	sp,sp,8
 400a700:	f800283a 	ret

0400a704 <isatty>:
 *
 * ALT_ISATTY is mapped onto the isatty() system call in alt_syscall.h
 */
 
int ALT_ISATTY (int file)
{
 400a704:	deffea04 	addi	sp,sp,-88
 400a708:	dfc01515 	stw	ra,84(sp)
 400a70c:	df001415 	stw	fp,80(sp)
 400a710:	df001404 	addi	fp,sp,80
 400a714:	e13fec15 	stw	r4,-80(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 400a718:	e0bfec17 	ldw	r2,-80(fp)
 400a71c:	10000916 	blt	r2,zero,400a744 <isatty+0x40>
 400a720:	e0ffec17 	ldw	r3,-80(fp)
 400a724:	1805883a 	mov	r2,r3
 400a728:	1085883a 	add	r2,r2,r2
 400a72c:	10c5883a 	add	r2,r2,r3
 400a730:	100490ba 	slli	r2,r2,2
 400a734:	00c10074 	movhi	r3,1025
 400a738:	18f47004 	addi	r3,r3,-11840
 400a73c:	10c5883a 	add	r2,r2,r3
 400a740:	00000106 	br	400a748 <isatty+0x44>
 400a744:	0005883a 	mov	r2,zero
 400a748:	e0bfff15 	stw	r2,-4(fp)
  
  if (fd)
 400a74c:	e0bfff17 	ldw	r2,-4(fp)
 400a750:	10000e26 	beq	r2,zero,400a78c <isatty+0x88>
    /*
     * If a device driver does not provide an fstat() function, then it is 
     * treated as a terminal device by default.
     */

    if (!fd->dev->fstat)
 400a754:	e0bfff17 	ldw	r2,-4(fp)
 400a758:	10800017 	ldw	r2,0(r2)
 400a75c:	10800817 	ldw	r2,32(r2)
 400a760:	1000021e 	bne	r2,zero,400a76c <isatty+0x68>
    {
      return 1;
 400a764:	00800044 	movi	r2,1
 400a768:	00000d06 	br	400a7a0 <isatty+0x9c>
     * this is called so that the device can identify itself.
     */ 

    else
    {
      fstat (file, &stat);
 400a76c:	e0bfed04 	addi	r2,fp,-76
 400a770:	100b883a 	mov	r5,r2
 400a774:	e13fec17 	ldw	r4,-80(fp)
 400a778:	400a3740 	call	400a374 <fstat>
      return (stat.st_mode == _IFCHR) ? 1 : 0;
 400a77c:	e0bfee17 	ldw	r2,-72(fp)
 400a780:	10880020 	cmpeqi	r2,r2,8192
 400a784:	10803fcc 	andi	r2,r2,255
 400a788:	00000506 	br	400a7a0 <isatty+0x9c>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
 400a78c:	400a6c80 	call	400a6c8 <alt_get_errno>
 400a790:	1007883a 	mov	r3,r2
 400a794:	00801444 	movi	r2,81
 400a798:	18800015 	stw	r2,0(r3)
    return 0;
 400a79c:	0005883a 	mov	r2,zero
  }
}
 400a7a0:	e037883a 	mov	sp,fp
 400a7a4:	dfc00117 	ldw	ra,4(sp)
 400a7a8:	df000017 	ldw	fp,0(sp)
 400a7ac:	dec00204 	addi	sp,sp,8
 400a7b0:	f800283a 	ret

0400a7b4 <alt_load_section>:
 */

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
 400a7b4:	defffc04 	addi	sp,sp,-16
 400a7b8:	df000315 	stw	fp,12(sp)
 400a7bc:	df000304 	addi	fp,sp,12
 400a7c0:	e13fff15 	stw	r4,-4(fp)
 400a7c4:	e17ffe15 	stw	r5,-8(fp)
 400a7c8:	e1bffd15 	stw	r6,-12(fp)
  if (to != from)
 400a7cc:	e0fffe17 	ldw	r3,-8(fp)
 400a7d0:	e0bfff17 	ldw	r2,-4(fp)
 400a7d4:	18800c26 	beq	r3,r2,400a808 <alt_load_section+0x54>
  {
    while( to != end )
 400a7d8:	00000806 	br	400a7fc <alt_load_section+0x48>
    {
      *to++ = *from++;
 400a7dc:	e0ffff17 	ldw	r3,-4(fp)
 400a7e0:	18800104 	addi	r2,r3,4
 400a7e4:	e0bfff15 	stw	r2,-4(fp)
 400a7e8:	e0bffe17 	ldw	r2,-8(fp)
 400a7ec:	11000104 	addi	r4,r2,4
 400a7f0:	e13ffe15 	stw	r4,-8(fp)
 400a7f4:	18c00017 	ldw	r3,0(r3)
 400a7f8:	10c00015 	stw	r3,0(r2)
    while( to != end )
 400a7fc:	e0fffe17 	ldw	r3,-8(fp)
 400a800:	e0bffd17 	ldw	r2,-12(fp)
 400a804:	18bff51e 	bne	r3,r2,400a7dc <alt_load_section+0x28>
    }
  }
}
 400a808:	0001883a 	nop
 400a80c:	e037883a 	mov	sp,fp
 400a810:	df000017 	ldw	fp,0(sp)
 400a814:	dec00104 	addi	sp,sp,4
 400a818:	f800283a 	ret

0400a81c <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
 400a81c:	defffe04 	addi	sp,sp,-8
 400a820:	dfc00115 	stw	ra,4(sp)
 400a824:	df000015 	stw	fp,0(sp)
 400a828:	d839883a 	mov	fp,sp
  /* 
   * Copy the .rwdata section. 
   */

  alt_load_section (&__flash_rwdata_start, 
 400a82c:	01810074 	movhi	r6,1025
 400a830:	31b8f704 	addi	r6,r6,-7204
 400a834:	01410074 	movhi	r5,1025
 400a838:	29725b04 	addi	r5,r5,-13972
 400a83c:	01010074 	movhi	r4,1025
 400a840:	2138f704 	addi	r4,r4,-7204
 400a844:	400a7b40 	call	400a7b4 <alt_load_section>

  /*
   * Copy the exception handler.
   */

  alt_load_section (&__flash_exceptions_start, 
 400a848:	01810034 	movhi	r6,1024
 400a84c:	3180d904 	addi	r6,r6,868
 400a850:	01410034 	movhi	r5,1024
 400a854:	29400804 	addi	r5,r5,32
 400a858:	01010034 	movhi	r4,1024
 400a85c:	21000804 	addi	r4,r4,32
 400a860:	400a7b40 	call	400a7b4 <alt_load_section>

  /*
   * Copy the .rodata section.
   */

  alt_load_section (&__flash_rodata_start, 
 400a864:	01810074 	movhi	r6,1025
 400a868:	31b25b04 	addi	r6,r6,-13972
 400a86c:	01410074 	movhi	r5,1025
 400a870:	29723e04 	addi	r5,r5,-14088
 400a874:	01010074 	movhi	r4,1025
 400a878:	21323e04 	addi	r4,r4,-14088
 400a87c:	400a7b40 	call	400a7b4 <alt_load_section>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
 400a880:	400bbe00 	call	400bbe0 <alt_dcache_flush_all>
  alt_icache_flush_all();
 400a884:	400bdac0 	call	400bdac <alt_icache_flush_all>
}
 400a888:	0001883a 	nop
 400a88c:	e037883a 	mov	sp,fp
 400a890:	dfc00117 	ldw	ra,4(sp)
 400a894:	df000017 	ldw	fp,0(sp)
 400a898:	dec00204 	addi	sp,sp,8
 400a89c:	f800283a 	ret

0400a8a0 <alt_get_errno>:
{
 400a8a0:	defffe04 	addi	sp,sp,-8
 400a8a4:	dfc00115 	stw	ra,4(sp)
 400a8a8:	df000015 	stw	fp,0(sp)
 400a8ac:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 400a8b0:	d0a00a17 	ldw	r2,-32728(gp)
 400a8b4:	10000326 	beq	r2,zero,400a8c4 <alt_get_errno+0x24>
 400a8b8:	d0a00a17 	ldw	r2,-32728(gp)
 400a8bc:	103ee83a 	callr	r2
 400a8c0:	00000106 	br	400a8c8 <alt_get_errno+0x28>
 400a8c4:	d0a6c004 	addi	r2,gp,-25856
}
 400a8c8:	e037883a 	mov	sp,fp
 400a8cc:	dfc00117 	ldw	ra,4(sp)
 400a8d0:	df000017 	ldw	fp,0(sp)
 400a8d4:	dec00204 	addi	sp,sp,8
 400a8d8:	f800283a 	ret

0400a8dc <lseek>:
 * ALT_LSEEK is mapped onto the lseek() system call in alt_syscall.h
 *
 */

off_t ALT_LSEEK (int file, off_t ptr, int dir)
{
 400a8dc:	defff904 	addi	sp,sp,-28
 400a8e0:	dfc00615 	stw	ra,24(sp)
 400a8e4:	df000515 	stw	fp,20(sp)
 400a8e8:	df000504 	addi	fp,sp,20
 400a8ec:	e13ffd15 	stw	r4,-12(fp)
 400a8f0:	e17ffc15 	stw	r5,-16(fp)
 400a8f4:	e1bffb15 	stw	r6,-20(fp)
  alt_fd* fd;
  off_t   rc = 0; 
 400a8f8:	e03fff15 	stw	zero,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 400a8fc:	e0bffd17 	ldw	r2,-12(fp)
 400a900:	10000916 	blt	r2,zero,400a928 <lseek+0x4c>
 400a904:	e0fffd17 	ldw	r3,-12(fp)
 400a908:	1805883a 	mov	r2,r3
 400a90c:	1085883a 	add	r2,r2,r2
 400a910:	10c5883a 	add	r2,r2,r3
 400a914:	100490ba 	slli	r2,r2,2
 400a918:	00c10074 	movhi	r3,1025
 400a91c:	18f47004 	addi	r3,r3,-11840
 400a920:	10c5883a 	add	r2,r2,r3
 400a924:	00000106 	br	400a92c <lseek+0x50>
 400a928:	0005883a 	mov	r2,zero
 400a92c:	e0bffe15 	stw	r2,-8(fp)
  
  if (fd) 
 400a930:	e0bffe17 	ldw	r2,-8(fp)
 400a934:	10001026 	beq	r2,zero,400a978 <lseek+0x9c>
    /*
     * If the device driver provides an implementation of the lseek() function,
     * then call that to process the request.
     */
 
    if (fd->dev->lseek)
 400a938:	e0bffe17 	ldw	r2,-8(fp)
 400a93c:	10800017 	ldw	r2,0(r2)
 400a940:	10800717 	ldw	r2,28(r2)
 400a944:	10000926 	beq	r2,zero,400a96c <lseek+0x90>
    {
      rc = fd->dev->lseek(fd, ptr, dir);
 400a948:	e0bffe17 	ldw	r2,-8(fp)
 400a94c:	10800017 	ldw	r2,0(r2)
 400a950:	10800717 	ldw	r2,28(r2)
 400a954:	e1bffb17 	ldw	r6,-20(fp)
 400a958:	e17ffc17 	ldw	r5,-16(fp)
 400a95c:	e13ffe17 	ldw	r4,-8(fp)
 400a960:	103ee83a 	callr	r2
 400a964:	e0bfff15 	stw	r2,-4(fp)
 400a968:	00000506 	br	400a980 <lseek+0xa4>
     * Otherwise return an error.
     */

    else
    {
      rc = -ENOTSUP;
 400a96c:	00bfde84 	movi	r2,-134
 400a970:	e0bfff15 	stw	r2,-4(fp)
 400a974:	00000206 	br	400a980 <lseek+0xa4>
    }
  }
  else  
  {
    rc = -EBADFD;
 400a978:	00bfebc4 	movi	r2,-81
 400a97c:	e0bfff15 	stw	r2,-4(fp)
  }

  if (rc < 0)
 400a980:	e0bfff17 	ldw	r2,-4(fp)
 400a984:	1000070e 	bge	r2,zero,400a9a4 <lseek+0xc8>
  {
    ALT_ERRNO = -rc;
 400a988:	400a8a00 	call	400a8a0 <alt_get_errno>
 400a98c:	1007883a 	mov	r3,r2
 400a990:	e0bfff17 	ldw	r2,-4(fp)
 400a994:	0085c83a 	sub	r2,zero,r2
 400a998:	18800015 	stw	r2,0(r3)
    rc = -1;
 400a99c:	00bfffc4 	movi	r2,-1
 400a9a0:	e0bfff15 	stw	r2,-4(fp)
  }

  return rc;
 400a9a4:	e0bfff17 	ldw	r2,-4(fp)
}
 400a9a8:	e037883a 	mov	sp,fp
 400a9ac:	dfc00117 	ldw	ra,4(sp)
 400a9b0:	df000017 	ldw	fp,0(sp)
 400a9b4:	dec00204 	addi	sp,sp,8
 400a9b8:	f800283a 	ret

0400a9bc <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
 400a9bc:	defffd04 	addi	sp,sp,-12
 400a9c0:	dfc00215 	stw	ra,8(sp)
 400a9c4:	df000115 	stw	fp,4(sp)
 400a9c8:	df000104 	addi	fp,sp,4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
 400a9cc:	0009883a 	mov	r4,zero
 400a9d0:	400ae600 	call	400ae60 <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
  ALT_OS_INIT();
 400a9d4:	0001883a 	nop
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
 400a9d8:	400ae9c0 	call	400ae9c <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
 400a9dc:	01810074 	movhi	r6,1025
 400a9e0:	31b25504 	addi	r6,r6,-13996
 400a9e4:	01410074 	movhi	r5,1025
 400a9e8:	29725504 	addi	r5,r5,-13996
 400a9ec:	01010074 	movhi	r4,1025
 400a9f0:	21325504 	addi	r4,r4,-13996
 400a9f4:	400bf140 	call	400bf14 <alt_io_redirect>
  /* 
   * Call the C++ constructors 
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling C++ constructors.\r\n");
  _do_ctors ();
 400a9f8:	400bce40 	call	400bce4 <_do_ctors>
   * redefined as _exit()). This is in the interest of reducing code footprint,
   * in that the atexit() overhead is removed when it's not needed.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling atexit.\r\n");
  atexit (_do_dtors);
 400a9fc:	01010074 	movhi	r4,1025
 400aa00:	212f5204 	addi	r4,r4,-17080
 400aa04:	400c64c0 	call	400c64c <atexit>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
 400aa08:	d0a6c217 	ldw	r2,-25848(gp)
 400aa0c:	d0e6c317 	ldw	r3,-25844(gp)
 400aa10:	d126c417 	ldw	r4,-25840(gp)
 400aa14:	200d883a 	mov	r6,r4
 400aa18:	180b883a 	mov	r5,r3
 400aa1c:	1009883a 	mov	r4,r2
 400aa20:	4006f780 	call	4006f78 <main>
 400aa24:	e0bfff15 	stw	r2,-4(fp)
  close(STDOUT_FILENO);
 400aa28:	01000044 	movi	r4,1
 400aa2c:	400a2300 	call	400a230 <close>
  exit (result);
 400aa30:	e13fff17 	ldw	r4,-4(fp)
 400aa34:	400c6600 	call	400c660 <exit>

0400aa38 <__malloc_lock>:
 * configuration is single threaded, so there is nothing to do here. Note that 
 * this requires that malloc is never called by an interrupt service routine.
 */

void __malloc_lock ( struct _reent *_r )
{
 400aa38:	defffe04 	addi	sp,sp,-8
 400aa3c:	df000115 	stw	fp,4(sp)
 400aa40:	df000104 	addi	fp,sp,4
 400aa44:	e13fff15 	stw	r4,-4(fp)
}
 400aa48:	0001883a 	nop
 400aa4c:	e037883a 	mov	sp,fp
 400aa50:	df000017 	ldw	fp,0(sp)
 400aa54:	dec00104 	addi	sp,sp,4
 400aa58:	f800283a 	ret

0400aa5c <__malloc_unlock>:
/*
 *
 */

void __malloc_unlock ( struct _reent *_r )
{
 400aa5c:	defffe04 	addi	sp,sp,-8
 400aa60:	df000115 	stw	fp,4(sp)
 400aa64:	df000104 	addi	fp,sp,4
 400aa68:	e13fff15 	stw	r4,-4(fp)
}
 400aa6c:	0001883a 	nop
 400aa70:	e037883a 	mov	sp,fp
 400aa74:	df000017 	ldw	fp,0(sp)
 400aa78:	dec00104 	addi	sp,sp,4
 400aa7c:	f800283a 	ret

0400aa80 <alt_get_errno>:
{
 400aa80:	defffe04 	addi	sp,sp,-8
 400aa84:	dfc00115 	stw	ra,4(sp)
 400aa88:	df000015 	stw	fp,0(sp)
 400aa8c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 400aa90:	d0a00a17 	ldw	r2,-32728(gp)
 400aa94:	10000326 	beq	r2,zero,400aaa4 <alt_get_errno+0x24>
 400aa98:	d0a00a17 	ldw	r2,-32728(gp)
 400aa9c:	103ee83a 	callr	r2
 400aaa0:	00000106 	br	400aaa8 <alt_get_errno+0x28>
 400aaa4:	d0a6c004 	addi	r2,gp,-25856
}
 400aaa8:	e037883a 	mov	sp,fp
 400aaac:	dfc00117 	ldw	ra,4(sp)
 400aab0:	df000017 	ldw	fp,0(sp)
 400aab4:	dec00204 	addi	sp,sp,8
 400aab8:	f800283a 	ret

0400aabc <read>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_READ (int file, void *ptr, size_t len)
{
 400aabc:	defff904 	addi	sp,sp,-28
 400aac0:	dfc00615 	stw	ra,24(sp)
 400aac4:	df000515 	stw	fp,20(sp)
 400aac8:	df000504 	addi	fp,sp,20
 400aacc:	e13ffd15 	stw	r4,-12(fp)
 400aad0:	e17ffc15 	stw	r5,-16(fp)
 400aad4:	e1bffb15 	stw	r6,-20(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 400aad8:	e0bffd17 	ldw	r2,-12(fp)
 400aadc:	10000916 	blt	r2,zero,400ab04 <read+0x48>
 400aae0:	e0fffd17 	ldw	r3,-12(fp)
 400aae4:	1805883a 	mov	r2,r3
 400aae8:	1085883a 	add	r2,r2,r2
 400aaec:	10c5883a 	add	r2,r2,r3
 400aaf0:	100490ba 	slli	r2,r2,2
 400aaf4:	00c10074 	movhi	r3,1025
 400aaf8:	18f47004 	addi	r3,r3,-11840
 400aafc:	10c5883a 	add	r2,r2,r3
 400ab00:	00000106 	br	400ab08 <read+0x4c>
 400ab04:	0005883a 	mov	r2,zero
 400ab08:	e0bfff15 	stw	r2,-4(fp)
  
  if (fd)
 400ab0c:	e0bfff17 	ldw	r2,-4(fp)
 400ab10:	10002226 	beq	r2,zero,400ab9c <read+0xe0>
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
 400ab14:	e0bfff17 	ldw	r2,-4(fp)
 400ab18:	10800217 	ldw	r2,8(r2)
 400ab1c:	108000cc 	andi	r2,r2,3
 400ab20:	10800060 	cmpeqi	r2,r2,1
 400ab24:	1000181e 	bne	r2,zero,400ab88 <read+0xcc>
        (fd->dev->read))
 400ab28:	e0bfff17 	ldw	r2,-4(fp)
 400ab2c:	10800017 	ldw	r2,0(r2)
 400ab30:	10800517 	ldw	r2,20(r2)
    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
 400ab34:	10001426 	beq	r2,zero,400ab88 <read+0xcc>
      {
        if ((rval = fd->dev->read(fd, ptr, len)) < 0)
 400ab38:	e0bfff17 	ldw	r2,-4(fp)
 400ab3c:	10800017 	ldw	r2,0(r2)
 400ab40:	10800517 	ldw	r2,20(r2)
 400ab44:	e0fffb17 	ldw	r3,-20(fp)
 400ab48:	180d883a 	mov	r6,r3
 400ab4c:	e17ffc17 	ldw	r5,-16(fp)
 400ab50:	e13fff17 	ldw	r4,-4(fp)
 400ab54:	103ee83a 	callr	r2
 400ab58:	e0bffe15 	stw	r2,-8(fp)
 400ab5c:	e0bffe17 	ldw	r2,-8(fp)
 400ab60:	1000070e 	bge	r2,zero,400ab80 <read+0xc4>
        {
          ALT_ERRNO = -rval;
 400ab64:	400aa800 	call	400aa80 <alt_get_errno>
 400ab68:	1007883a 	mov	r3,r2
 400ab6c:	e0bffe17 	ldw	r2,-8(fp)
 400ab70:	0085c83a 	sub	r2,zero,r2
 400ab74:	18800015 	stw	r2,0(r3)
          return -1;
 400ab78:	00bfffc4 	movi	r2,-1
 400ab7c:	00000c06 	br	400abb0 <read+0xf4>
        }
        return rval;
 400ab80:	e0bffe17 	ldw	r2,-8(fp)
 400ab84:	00000a06 	br	400abb0 <read+0xf4>
      }
      else
      {
        ALT_ERRNO = EACCES;
 400ab88:	400aa800 	call	400aa80 <alt_get_errno>
 400ab8c:	1007883a 	mov	r3,r2
 400ab90:	00800344 	movi	r2,13
 400ab94:	18800015 	stw	r2,0(r3)
 400ab98:	00000406 	br	400abac <read+0xf0>
      }
    }
  else
  {
    ALT_ERRNO = EBADFD;
 400ab9c:	400aa800 	call	400aa80 <alt_get_errno>
 400aba0:	1007883a 	mov	r3,r2
 400aba4:	00801444 	movi	r2,81
 400aba8:	18800015 	stw	r2,0(r3)
  }
  return -1;
 400abac:	00bfffc4 	movi	r2,-1
}
 400abb0:	e037883a 	mov	sp,fp
 400abb4:	dfc00117 	ldw	ra,4(sp)
 400abb8:	df000017 	ldw	fp,0(sp)
 400abbc:	dec00204 	addi	sp,sp,8
 400abc0:	f800283a 	ret

0400abc4 <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
 400abc4:	defffe04 	addi	sp,sp,-8
 400abc8:	df000115 	stw	fp,4(sp)
 400abcc:	df000104 	addi	fp,sp,4
 400abd0:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
 400abd4:	e0bfff17 	ldw	r2,-4(fp)
 400abd8:	108000d0 	cmplti	r2,r2,3
 400abdc:	1000101e 	bne	r2,zero,400ac20 <alt_release_fd+0x5c>
  {
    alt_fd_list[fd].fd_flags = 0;
 400abe0:	e0ffff17 	ldw	r3,-4(fp)
 400abe4:	1805883a 	mov	r2,r3
 400abe8:	1085883a 	add	r2,r2,r2
 400abec:	10c5883a 	add	r2,r2,r3
 400abf0:	100490ba 	slli	r2,r2,2
 400abf4:	00c10074 	movhi	r3,1025
 400abf8:	10c7883a 	add	r3,r2,r3
 400abfc:	18347215 	stw	zero,-11832(r3)
    alt_fd_list[fd].dev      = 0;
 400ac00:	e0ffff17 	ldw	r3,-4(fp)
 400ac04:	1805883a 	mov	r2,r3
 400ac08:	1085883a 	add	r2,r2,r2
 400ac0c:	10c5883a 	add	r2,r2,r3
 400ac10:	100490ba 	slli	r2,r2,2
 400ac14:	00c10074 	movhi	r3,1025
 400ac18:	10c7883a 	add	r3,r2,r3
 400ac1c:	18347015 	stw	zero,-11840(r3)
  }
}
 400ac20:	0001883a 	nop
 400ac24:	e037883a 	mov	sp,fp
 400ac28:	df000017 	ldw	fp,0(sp)
 400ac2c:	dec00104 	addi	sp,sp,4
 400ac30:	f800283a 	ret

0400ac34 <sbrk>:
#endif
 
caddr_t ALT_SBRK (int incr) __attribute__ ((no_instrument_function ));

caddr_t ALT_SBRK (int incr)
{ 
 400ac34:	defff904 	addi	sp,sp,-28
 400ac38:	df000615 	stw	fp,24(sp)
 400ac3c:	df000604 	addi	fp,sp,24
 400ac40:	e13ffa15 	stw	r4,-24(fp)
  NIOS2_READ_STATUS (context);
 400ac44:	0005303a 	rdctl	r2,status
 400ac48:	e0bffd15 	stw	r2,-12(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 400ac4c:	e0fffd17 	ldw	r3,-12(fp)
 400ac50:	00bfff84 	movi	r2,-2
 400ac54:	1884703a 	and	r2,r3,r2
 400ac58:	1001703a 	wrctl	status,r2
  return context;
 400ac5c:	e0bffd17 	ldw	r2,-12(fp)
  alt_irq_context context;
  char *prev_heap_end; 

  context = alt_irq_disable_all();
 400ac60:	e0bfff15 	stw	r2,-4(fp)

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
 400ac64:	d0a00c17 	ldw	r2,-32720(gp)
 400ac68:	10c000c4 	addi	r3,r2,3
 400ac6c:	00bfff04 	movi	r2,-4
 400ac70:	1884703a 	and	r2,r3,r2
 400ac74:	d0a00c15 	stw	r2,-32720(gp)
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
 400ac78:	d0e00c17 	ldw	r3,-32720(gp)
 400ac7c:	e0bffa17 	ldw	r2,-24(fp)
 400ac80:	1887883a 	add	r3,r3,r2
 400ac84:	00820034 	movhi	r2,2048
 400ac88:	10800004 	addi	r2,r2,0
 400ac8c:	10c0072e 	bgeu	r2,r3,400acac <sbrk+0x78>
 400ac90:	e0bfff17 	ldw	r2,-4(fp)
 400ac94:	e0bffc15 	stw	r2,-16(fp)
  NIOS2_WRITE_STATUS (context);
 400ac98:	e0bffc17 	ldw	r2,-16(fp)
 400ac9c:	1001703a 	wrctl	status,r2
}
 400aca0:	0001883a 	nop
    alt_irq_enable_all(context);
    return (caddr_t)-1;
 400aca4:	00bfffc4 	movi	r2,-1
 400aca8:	00000c06 	br	400acdc <sbrk+0xa8>
  }
#endif

  prev_heap_end = heap_end; 
 400acac:	d0a00c17 	ldw	r2,-32720(gp)
 400acb0:	e0bffe15 	stw	r2,-8(fp)
  heap_end += incr; 
 400acb4:	d0e00c17 	ldw	r3,-32720(gp)
 400acb8:	e0bffa17 	ldw	r2,-24(fp)
 400acbc:	1885883a 	add	r2,r3,r2
 400acc0:	d0a00c15 	stw	r2,-32720(gp)
 400acc4:	e0bfff17 	ldw	r2,-4(fp)
 400acc8:	e0bffb15 	stw	r2,-20(fp)
  NIOS2_WRITE_STATUS (context);
 400accc:	e0bffb17 	ldw	r2,-20(fp)
 400acd0:	1001703a 	wrctl	status,r2
}
 400acd4:	0001883a 	nop

#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
 400acd8:	e0bffe17 	ldw	r2,-8(fp)
} 
 400acdc:	e037883a 	mov	sp,fp
 400ace0:	df000017 	ldw	fp,0(sp)
 400ace4:	dec00104 	addi	sp,sp,4
 400ace8:	f800283a 	ret

0400acec <alt_get_errno>:
{
 400acec:	defffe04 	addi	sp,sp,-8
 400acf0:	dfc00115 	stw	ra,4(sp)
 400acf4:	df000015 	stw	fp,0(sp)
 400acf8:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 400acfc:	d0a00a17 	ldw	r2,-32728(gp)
 400ad00:	10000326 	beq	r2,zero,400ad10 <alt_get_errno+0x24>
 400ad04:	d0a00a17 	ldw	r2,-32728(gp)
 400ad08:	103ee83a 	callr	r2
 400ad0c:	00000106 	br	400ad14 <alt_get_errno+0x28>
 400ad10:	d0a6c004 	addi	r2,gp,-25856
}
 400ad14:	e037883a 	mov	sp,fp
 400ad18:	dfc00117 	ldw	ra,4(sp)
 400ad1c:	df000017 	ldw	fp,0(sp)
 400ad20:	dec00204 	addi	sp,sp,8
 400ad24:	f800283a 	ret

0400ad28 <write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
 400ad28:	defff904 	addi	sp,sp,-28
 400ad2c:	dfc00615 	stw	ra,24(sp)
 400ad30:	df000515 	stw	fp,20(sp)
 400ad34:	df000504 	addi	fp,sp,20
 400ad38:	e13ffd15 	stw	r4,-12(fp)
 400ad3c:	e17ffc15 	stw	r5,-16(fp)
 400ad40:	e1bffb15 	stw	r6,-20(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 400ad44:	e0bffd17 	ldw	r2,-12(fp)
 400ad48:	10000916 	blt	r2,zero,400ad70 <write+0x48>
 400ad4c:	e0fffd17 	ldw	r3,-12(fp)
 400ad50:	1805883a 	mov	r2,r3
 400ad54:	1085883a 	add	r2,r2,r2
 400ad58:	10c5883a 	add	r2,r2,r3
 400ad5c:	100490ba 	slli	r2,r2,2
 400ad60:	00c10074 	movhi	r3,1025
 400ad64:	18f47004 	addi	r3,r3,-11840
 400ad68:	10c5883a 	add	r2,r2,r3
 400ad6c:	00000106 	br	400ad74 <write+0x4c>
 400ad70:	0005883a 	mov	r2,zero
 400ad74:	e0bfff15 	stw	r2,-4(fp)
  
  if (fd)
 400ad78:	e0bfff17 	ldw	r2,-4(fp)
 400ad7c:	10002126 	beq	r2,zero,400ae04 <write+0xdc>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
 400ad80:	e0bfff17 	ldw	r2,-4(fp)
 400ad84:	10800217 	ldw	r2,8(r2)
 400ad88:	108000cc 	andi	r2,r2,3
 400ad8c:	10001826 	beq	r2,zero,400adf0 <write+0xc8>
 400ad90:	e0bfff17 	ldw	r2,-4(fp)
 400ad94:	10800017 	ldw	r2,0(r2)
 400ad98:	10800617 	ldw	r2,24(r2)
 400ad9c:	10001426 	beq	r2,zero,400adf0 <write+0xc8>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
 400ada0:	e0bfff17 	ldw	r2,-4(fp)
 400ada4:	10800017 	ldw	r2,0(r2)
 400ada8:	10800617 	ldw	r2,24(r2)
 400adac:	e0fffb17 	ldw	r3,-20(fp)
 400adb0:	180d883a 	mov	r6,r3
 400adb4:	e17ffc17 	ldw	r5,-16(fp)
 400adb8:	e13fff17 	ldw	r4,-4(fp)
 400adbc:	103ee83a 	callr	r2
 400adc0:	e0bffe15 	stw	r2,-8(fp)
 400adc4:	e0bffe17 	ldw	r2,-8(fp)
 400adc8:	1000070e 	bge	r2,zero,400ade8 <write+0xc0>
      {
        ALT_ERRNO = -rval;
 400adcc:	400acec0 	call	400acec <alt_get_errno>
 400add0:	1007883a 	mov	r3,r2
 400add4:	e0bffe17 	ldw	r2,-8(fp)
 400add8:	0085c83a 	sub	r2,zero,r2
 400addc:	18800015 	stw	r2,0(r3)
        return -1;
 400ade0:	00bfffc4 	movi	r2,-1
 400ade4:	00000c06 	br	400ae18 <write+0xf0>
      }
      return rval;
 400ade8:	e0bffe17 	ldw	r2,-8(fp)
 400adec:	00000a06 	br	400ae18 <write+0xf0>
    }
    else
    {
      ALT_ERRNO = EACCES;
 400adf0:	400acec0 	call	400acec <alt_get_errno>
 400adf4:	1007883a 	mov	r3,r2
 400adf8:	00800344 	movi	r2,13
 400adfc:	18800015 	stw	r2,0(r3)
 400ae00:	00000406 	br	400ae14 <write+0xec>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
 400ae04:	400acec0 	call	400acec <alt_get_errno>
 400ae08:	1007883a 	mov	r3,r2
 400ae0c:	00801444 	movi	r2,81
 400ae10:	18800015 	stw	r2,0(r3)
  }
  return -1;
 400ae14:	00bfffc4 	movi	r2,-1
}
 400ae18:	e037883a 	mov	sp,fp
 400ae1c:	dfc00117 	ldw	ra,4(sp)
 400ae20:	df000017 	ldw	fp,0(sp)
 400ae24:	dec00204 	addi	sp,sp,8
 400ae28:	f800283a 	ret

0400ae2c <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
 400ae2c:	defffd04 	addi	sp,sp,-12
 400ae30:	dfc00215 	stw	ra,8(sp)
 400ae34:	df000115 	stw	fp,4(sp)
 400ae38:	df000104 	addi	fp,sp,4
 400ae3c:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
 400ae40:	d1600704 	addi	r5,gp,-32740
 400ae44:	e13fff17 	ldw	r4,-4(fp)
 400ae48:	400bc3c0 	call	400bc3c <alt_dev_llist_insert>
}
 400ae4c:	e037883a 	mov	sp,fp
 400ae50:	dfc00117 	ldw	ra,4(sp)
 400ae54:	df000017 	ldw	fp,0(sp)
 400ae58:	dec00204 	addi	sp,sp,8
 400ae5c:	f800283a 	ret

0400ae60 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
 400ae60:	defffd04 	addi	sp,sp,-12
 400ae64:	dfc00215 	stw	ra,8(sp)
 400ae68:	df000115 	stw	fp,4(sp)
 400ae6c:	df000104 	addi	fp,sp,4
 400ae70:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( LAB04, Lab04);
 400ae74:	400c3d80 	call	400c3d8 <altera_nios2_gen2_irq_init>
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
 400ae78:	00800044 	movi	r2,1
 400ae7c:	1001703a 	wrctl	status,r2
}
 400ae80:	0001883a 	nop
    alt_irq_cpu_enable_interrupts();
}
 400ae84:	0001883a 	nop
 400ae88:	e037883a 	mov	sp,fp
 400ae8c:	dfc00117 	ldw	ra,4(sp)
 400ae90:	df000017 	ldw	fp,0(sp)
 400ae94:	dec00204 	addi	sp,sp,8
 400ae98:	f800283a 	ret

0400ae9c <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
 400ae9c:	defffe04 	addi	sp,sp,-8
 400aea0:	dfc00115 	stw	ra,4(sp)
 400aea4:	df000015 	stw	fp,0(sp)
 400aea8:	d839883a 	mov	fp,sp
    ALTERA_AVALON_TIMER_INIT ( SYS_CLK, sys_clk);
 400aeac:	01c0fa04 	movi	r7,1000
 400aeb0:	000d883a 	mov	r6,zero
 400aeb4:	000b883a 	mov	r5,zero
 400aeb8:	01020034 	movhi	r4,2048
 400aebc:	21040804 	addi	r4,r4,4128
 400aec0:	400b9fc0 	call	400b9fc <alt_avalon_timer_sc_init>
    ALTERA_AVALON_JTAG_UART_INIT ( DEBUG, DEBUG);
 400aec4:	01800044 	movi	r6,1
 400aec8:	000b883a 	mov	r5,zero
 400aecc:	01010074 	movhi	r4,1025
 400aed0:	2134da04 	addi	r4,r4,-11416
 400aed4:	400b0600 	call	400b060 <altera_avalon_jtag_uart_init>
 400aed8:	01010074 	movhi	r4,1025
 400aedc:	2134d004 	addi	r4,r4,-11456
 400aee0:	400ae2c0 	call	400ae2c <alt_dev_reg>
}
 400aee4:	0001883a 	nop
 400aee8:	e037883a 	mov	sp,fp
 400aeec:	dfc00117 	ldw	ra,4(sp)
 400aef0:	df000017 	ldw	fp,0(sp)
 400aef4:	dec00204 	addi	sp,sp,8
 400aef8:	f800283a 	ret

0400aefc <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
 400aefc:	defffa04 	addi	sp,sp,-24
 400af00:	dfc00515 	stw	ra,20(sp)
 400af04:	df000415 	stw	fp,16(sp)
 400af08:	df000404 	addi	fp,sp,16
 400af0c:	e13ffe15 	stw	r4,-8(fp)
 400af10:	e17ffd15 	stw	r5,-12(fp)
 400af14:	e1bffc15 	stw	r6,-16(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 400af18:	e0bffe17 	ldw	r2,-8(fp)
 400af1c:	10800017 	ldw	r2,0(r2)
 400af20:	e0bfff15 	stw	r2,-4(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
 400af24:	e0bfff17 	ldw	r2,-4(fp)
 400af28:	10c00a04 	addi	r3,r2,40
 400af2c:	e0bffe17 	ldw	r2,-8(fp)
 400af30:	10800217 	ldw	r2,8(r2)
 400af34:	100f883a 	mov	r7,r2
 400af38:	e1bffc17 	ldw	r6,-16(fp)
 400af3c:	e17ffd17 	ldw	r5,-12(fp)
 400af40:	1809883a 	mov	r4,r3
 400af44:	400b5380 	call	400b538 <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
 400af48:	e037883a 	mov	sp,fp
 400af4c:	dfc00117 	ldw	ra,4(sp)
 400af50:	df000017 	ldw	fp,0(sp)
 400af54:	dec00204 	addi	sp,sp,8
 400af58:	f800283a 	ret

0400af5c <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
 400af5c:	defffa04 	addi	sp,sp,-24
 400af60:	dfc00515 	stw	ra,20(sp)
 400af64:	df000415 	stw	fp,16(sp)
 400af68:	df000404 	addi	fp,sp,16
 400af6c:	e13ffe15 	stw	r4,-8(fp)
 400af70:	e17ffd15 	stw	r5,-12(fp)
 400af74:	e1bffc15 	stw	r6,-16(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 400af78:	e0bffe17 	ldw	r2,-8(fp)
 400af7c:	10800017 	ldw	r2,0(r2)
 400af80:	e0bfff15 	stw	r2,-4(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
 400af84:	e0bfff17 	ldw	r2,-4(fp)
 400af88:	10c00a04 	addi	r3,r2,40
 400af8c:	e0bffe17 	ldw	r2,-8(fp)
 400af90:	10800217 	ldw	r2,8(r2)
 400af94:	100f883a 	mov	r7,r2
 400af98:	e1bffc17 	ldw	r6,-16(fp)
 400af9c:	e17ffd17 	ldw	r5,-12(fp)
 400afa0:	1809883a 	mov	r4,r3
 400afa4:	400b7580 	call	400b758 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
 400afa8:	e037883a 	mov	sp,fp
 400afac:	dfc00117 	ldw	ra,4(sp)
 400afb0:	df000017 	ldw	fp,0(sp)
 400afb4:	dec00204 	addi	sp,sp,8
 400afb8:	f800283a 	ret

0400afbc <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
 400afbc:	defffc04 	addi	sp,sp,-16
 400afc0:	dfc00315 	stw	ra,12(sp)
 400afc4:	df000215 	stw	fp,8(sp)
 400afc8:	df000204 	addi	fp,sp,8
 400afcc:	e13ffe15 	stw	r4,-8(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 400afd0:	e0bffe17 	ldw	r2,-8(fp)
 400afd4:	10800017 	ldw	r2,0(r2)
 400afd8:	e0bfff15 	stw	r2,-4(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
 400afdc:	e0bfff17 	ldw	r2,-4(fp)
 400afe0:	10c00a04 	addi	r3,r2,40
 400afe4:	e0bffe17 	ldw	r2,-8(fp)
 400afe8:	10800217 	ldw	r2,8(r2)
 400afec:	100b883a 	mov	r5,r2
 400aff0:	1809883a 	mov	r4,r3
 400aff4:	400b3dc0 	call	400b3dc <altera_avalon_jtag_uart_close>
}
 400aff8:	e037883a 	mov	sp,fp
 400affc:	dfc00117 	ldw	ra,4(sp)
 400b000:	df000017 	ldw	fp,0(sp)
 400b004:	dec00204 	addi	sp,sp,8
 400b008:	f800283a 	ret

0400b00c <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
 400b00c:	defffa04 	addi	sp,sp,-24
 400b010:	dfc00515 	stw	ra,20(sp)
 400b014:	df000415 	stw	fp,16(sp)
 400b018:	df000404 	addi	fp,sp,16
 400b01c:	e13ffe15 	stw	r4,-8(fp)
 400b020:	e17ffd15 	stw	r5,-12(fp)
 400b024:	e1bffc15 	stw	r6,-16(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
 400b028:	e0bffe17 	ldw	r2,-8(fp)
 400b02c:	10800017 	ldw	r2,0(r2)
 400b030:	e0bfff15 	stw	r2,-4(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
 400b034:	e0bfff17 	ldw	r2,-4(fp)
 400b038:	10800a04 	addi	r2,r2,40
 400b03c:	e1bffc17 	ldw	r6,-16(fp)
 400b040:	e17ffd17 	ldw	r5,-12(fp)
 400b044:	1009883a 	mov	r4,r2
 400b048:	400b4440 	call	400b444 <altera_avalon_jtag_uart_ioctl>
}
 400b04c:	e037883a 	mov	sp,fp
 400b050:	dfc00117 	ldw	ra,4(sp)
 400b054:	df000017 	ldw	fp,0(sp)
 400b058:	dec00204 	addi	sp,sp,8
 400b05c:	f800283a 	ret

0400b060 <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
 400b060:	defffa04 	addi	sp,sp,-24
 400b064:	dfc00515 	stw	ra,20(sp)
 400b068:	df000415 	stw	fp,16(sp)
 400b06c:	df000404 	addi	fp,sp,16
 400b070:	e13fff15 	stw	r4,-4(fp)
 400b074:	e17ffe15 	stw	r5,-8(fp)
 400b078:	e1bffd15 	stw	r6,-12(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
  ALT_SEM_CREATE(&sp->read_lock, 1);
  ALT_SEM_CREATE(&sp->write_lock, 1);

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 400b07c:	e0bfff17 	ldw	r2,-4(fp)
 400b080:	00c00044 	movi	r3,1
 400b084:	10c00815 	stw	r3,32(r2)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
 400b088:	e0bfff17 	ldw	r2,-4(fp)
 400b08c:	10800017 	ldw	r2,0(r2)
 400b090:	10800104 	addi	r2,r2,4
 400b094:	1007883a 	mov	r3,r2
 400b098:	e0bfff17 	ldw	r2,-4(fp)
 400b09c:	10800817 	ldw	r2,32(r2)
 400b0a0:	18800035 	stwio	r2,0(r3)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
 400b0a4:	e0bffe17 	ldw	r2,-8(fp)
 400b0a8:	e0fffd17 	ldw	r3,-12(fp)
 400b0ac:	d8000015 	stw	zero,0(sp)
 400b0b0:	e1ffff17 	ldw	r7,-4(fp)
 400b0b4:	01810074 	movhi	r6,1025
 400b0b8:	31ac4804 	addi	r6,r6,-20192
 400b0bc:	180b883a 	mov	r5,r3
 400b0c0:	1009883a 	mov	r4,r2
 400b0c4:	400a4300 	call	400a430 <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
 400b0c8:	e0bfff17 	ldw	r2,-4(fp)
 400b0cc:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
 400b0d0:	e0bfff17 	ldw	r2,-4(fp)
 400b0d4:	10800204 	addi	r2,r2,8
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 400b0d8:	d0e6c617 	ldw	r3,-25832(gp)
 400b0dc:	e1ffff17 	ldw	r7,-4(fp)
 400b0e0:	01810074 	movhi	r6,1025
 400b0e4:	31accd04 	addi	r6,r6,-19660
 400b0e8:	180b883a 	mov	r5,r3
 400b0ec:	1009883a 	mov	r4,r2
 400b0f0:	400ba800 	call	400ba80 <alt_alarm_start>
 400b0f4:	1000040e 	bge	r2,zero,400b108 <altera_avalon_jtag_uart_init+0xa8>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
 400b0f8:	e0ffff17 	ldw	r3,-4(fp)
 400b0fc:	00a00034 	movhi	r2,32768
 400b100:	10bfffc4 	addi	r2,r2,-1
 400b104:	18800115 	stw	r2,4(r3)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
}
 400b108:	0001883a 	nop
 400b10c:	e037883a 	mov	sp,fp
 400b110:	dfc00117 	ldw	ra,4(sp)
 400b114:	df000017 	ldw	fp,0(sp)
 400b118:	dec00204 	addi	sp,sp,8
 400b11c:	f800283a 	ret

0400b120 <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
 400b120:	defff704 	addi	sp,sp,-36
 400b124:	df000815 	stw	fp,32(sp)
 400b128:	df000804 	addi	fp,sp,32
 400b12c:	e13ff815 	stw	r4,-32(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
 400b130:	e0bff817 	ldw	r2,-32(fp)
 400b134:	e0bffc15 	stw	r2,-16(fp)
  unsigned int base = sp->base;
 400b138:	e0bffc17 	ldw	r2,-16(fp)
 400b13c:	10800017 	ldw	r2,0(r2)
 400b140:	e0bffb15 	stw	r2,-20(fp)
  unsigned int postflag=0;
 400b144:	e03fff15 	stw	zero,-4(fp)
  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 400b148:	e0bffb17 	ldw	r2,-20(fp)
 400b14c:	10800104 	addi	r2,r2,4
 400b150:	10800037 	ldwio	r2,0(r2)
 400b154:	e0bffa15 	stw	r2,-24(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
 400b158:	e0bffa17 	ldw	r2,-24(fp)
 400b15c:	1080c00c 	andi	r2,r2,768
 400b160:	10006e26 	beq	r2,zero,400b31c <altera_avalon_jtag_uart_irq+0x1fc>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
 400b164:	e0bffa17 	ldw	r2,-24(fp)
 400b168:	1080400c 	andi	r2,r2,256
 400b16c:	10003526 	beq	r2,zero,400b244 <altera_avalon_jtag_uart_irq+0x124>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
 400b170:	00800074 	movhi	r2,1
 400b174:	e0bffe15 	stw	r2,-8(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 400b178:	e0bffc17 	ldw	r2,-16(fp)
 400b17c:	10800a17 	ldw	r2,40(r2)
 400b180:	10800044 	addi	r2,r2,1
 400b184:	1081ffcc 	andi	r2,r2,2047
 400b188:	e0bff915 	stw	r2,-28(fp)
        if (next == sp->rx_out)
 400b18c:	e0bffc17 	ldw	r2,-16(fp)
 400b190:	10800b17 	ldw	r2,44(r2)
 400b194:	e0fff917 	ldw	r3,-28(fp)
 400b198:	18801526 	beq	r3,r2,400b1f0 <altera_avalon_jtag_uart_irq+0xd0>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
 400b19c:	e0bffb17 	ldw	r2,-20(fp)
 400b1a0:	10800037 	ldwio	r2,0(r2)
 400b1a4:	e0bffe15 	stw	r2,-8(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
 400b1a8:	e0bffe17 	ldw	r2,-8(fp)
 400b1ac:	10a0000c 	andi	r2,r2,32768
 400b1b0:	10001126 	beq	r2,zero,400b1f8 <altera_avalon_jtag_uart_irq+0xd8>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
 400b1b4:	e0bffc17 	ldw	r2,-16(fp)
 400b1b8:	10800a17 	ldw	r2,40(r2)
 400b1bc:	e0fffe17 	ldw	r3,-8(fp)
 400b1c0:	1809883a 	mov	r4,r3
 400b1c4:	e0fffc17 	ldw	r3,-16(fp)
 400b1c8:	1885883a 	add	r2,r3,r2
 400b1cc:	11000e05 	stb	r4,56(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 400b1d0:	e0bffc17 	ldw	r2,-16(fp)
 400b1d4:	10800a17 	ldw	r2,40(r2)
 400b1d8:	10800044 	addi	r2,r2,1
 400b1dc:	10c1ffcc 	andi	r3,r2,2047
 400b1e0:	e0bffc17 	ldw	r2,-16(fp)
 400b1e4:	10c00a15 	stw	r3,40(r2)
 * HAL.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_no_error (void)
{
  return 0;
 400b1e8:	0001883a 	nop
      {
 400b1ec:	003fe206 	br	400b178 <altera_avalon_jtag_uart_irq+0x58>
          break;
 400b1f0:	0001883a 	nop
 400b1f4:	00000106 	br	400b1fc <altera_avalon_jtag_uart_irq+0xdc>
          break;
 400b1f8:	0001883a 	nop

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, ALT_FLAG_SET);
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
 400b1fc:	e0bffe17 	ldw	r2,-8(fp)
 400b200:	00ffffd4 	movui	r3,65535
 400b204:	18800f2e 	bgeu	r3,r2,400b244 <altera_avalon_jtag_uart_irq+0x124>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 400b208:	e0bffc17 	ldw	r2,-16(fp)
 400b20c:	10c00817 	ldw	r3,32(r2)
 400b210:	00bfff84 	movi	r2,-2
 400b214:	1886703a 	and	r3,r3,r2
 400b218:	e0bffc17 	ldw	r2,-16(fp)
 400b21c:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
 400b220:	e0bffb17 	ldw	r2,-20(fp)
 400b224:	10800104 	addi	r2,r2,4
 400b228:	1007883a 	mov	r3,r2
 400b22c:	e0bffc17 	ldw	r2,-16(fp)
 400b230:	10800817 	ldw	r2,32(r2)
 400b234:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 400b238:	e0bffb17 	ldw	r2,-20(fp)
 400b23c:	10800104 	addi	r2,r2,4
 400b240:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
 400b244:	e0bffa17 	ldw	r2,-24(fp)
 400b248:	1080800c 	andi	r2,r2,512
 400b24c:	103fbe26 	beq	r2,zero,400b148 <altera_avalon_jtag_uart_irq+0x28>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
 400b250:	e0bffa17 	ldw	r2,-24(fp)
 400b254:	1004d43a 	srli	r2,r2,16
 400b258:	e0bffd15 	stw	r2,-12(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
 400b25c:	00001506 	br	400b2b4 <altera_avalon_jtag_uart_irq+0x194>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
 400b260:	e0bffb17 	ldw	r2,-20(fp)
 400b264:	e0fffc17 	ldw	r3,-16(fp)
 400b268:	18c00d17 	ldw	r3,52(r3)
 400b26c:	e13ffc17 	ldw	r4,-16(fp)
 400b270:	20c7883a 	add	r3,r4,r3
 400b274:	18c20e03 	ldbu	r3,2104(r3)
 400b278:	18c03fcc 	andi	r3,r3,255
 400b27c:	18c0201c 	xori	r3,r3,128
 400b280:	18ffe004 	addi	r3,r3,-128
 400b284:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 400b288:	e0bffc17 	ldw	r2,-16(fp)
 400b28c:	10800d17 	ldw	r2,52(r2)
 400b290:	10800044 	addi	r2,r2,1
 400b294:	10c1ffcc 	andi	r3,r2,2047
 400b298:	e0bffc17 	ldw	r2,-16(fp)
 400b29c:	10c00d15 	stw	r3,52(r2)
        
        /* indicate that the ALT_FLAG_POST routine must be called */
        postflag=1;
 400b2a0:	00800044 	movi	r2,1
 400b2a4:	e0bfff15 	stw	r2,-4(fp)

        space--;
 400b2a8:	e0bffd17 	ldw	r2,-12(fp)
 400b2ac:	10bfffc4 	addi	r2,r2,-1
 400b2b0:	e0bffd15 	stw	r2,-12(fp)
      while (space > 0 && sp->tx_out != sp->tx_in)
 400b2b4:	e0bffd17 	ldw	r2,-12(fp)
 400b2b8:	10000526 	beq	r2,zero,400b2d0 <altera_avalon_jtag_uart_irq+0x1b0>
 400b2bc:	e0bffc17 	ldw	r2,-16(fp)
 400b2c0:	10c00d17 	ldw	r3,52(r2)
 400b2c4:	e0bffc17 	ldw	r2,-16(fp)
 400b2c8:	10800c17 	ldw	r2,48(r2)
 400b2cc:	18bfe41e 	bne	r3,r2,400b260 <altera_avalon_jtag_uart_irq+0x140>
      {
        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, ALT_FLAG_SET);
      }

      if (space > 0)
 400b2d0:	e0bffd17 	ldw	r2,-12(fp)
 400b2d4:	103f9c26 	beq	r2,zero,400b148 <altera_avalon_jtag_uart_irq+0x28>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 400b2d8:	e0bffc17 	ldw	r2,-16(fp)
 400b2dc:	10c00817 	ldw	r3,32(r2)
 400b2e0:	00bfff44 	movi	r2,-3
 400b2e4:	1886703a 	and	r3,r3,r2
 400b2e8:	e0bffc17 	ldw	r2,-16(fp)
 400b2ec:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 400b2f0:	e0bffc17 	ldw	r2,-16(fp)
 400b2f4:	10800017 	ldw	r2,0(r2)
 400b2f8:	10800104 	addi	r2,r2,4
 400b2fc:	1007883a 	mov	r3,r2
 400b300:	e0bffc17 	ldw	r2,-16(fp)
 400b304:	10800817 	ldw	r2,32(r2)
 400b308:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 400b30c:	e0bffb17 	ldw	r2,-20(fp)
 400b310:	10800104 	addi	r2,r2,4
 400b314:	10800037 	ldwio	r2,0(r2)
  {
 400b318:	003f8b06 	br	400b148 <altera_avalon_jtag_uart_irq+0x28>
      break;
 400b31c:	0001883a 	nop
      }
    }
  }
}
 400b320:	0001883a 	nop
 400b324:	e037883a 	mov	sp,fp
 400b328:	df000017 	ldw	fp,0(sp)
 400b32c:	dec00104 	addi	sp,sp,4
 400b330:	f800283a 	ret

0400b334 <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
 400b334:	defffc04 	addi	sp,sp,-16
 400b338:	df000315 	stw	fp,12(sp)
 400b33c:	df000304 	addi	fp,sp,12
 400b340:	e13ffd15 	stw	r4,-12(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
 400b344:	e0bffd17 	ldw	r2,-12(fp)
 400b348:	e0bfff15 	stw	r2,-4(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
 400b34c:	e0bfff17 	ldw	r2,-4(fp)
 400b350:	10800017 	ldw	r2,0(r2)
 400b354:	10800104 	addi	r2,r2,4
 400b358:	10800037 	ldwio	r2,0(r2)
 400b35c:	e0bffe15 	stw	r2,-8(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
 400b360:	e0bffe17 	ldw	r2,-8(fp)
 400b364:	1081000c 	andi	r2,r2,1024
 400b368:	10000b26 	beq	r2,zero,400b398 <altera_avalon_jtag_uart_timeout+0x64>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
 400b36c:	e0bfff17 	ldw	r2,-4(fp)
 400b370:	10800017 	ldw	r2,0(r2)
 400b374:	10800104 	addi	r2,r2,4
 400b378:	1007883a 	mov	r3,r2
 400b37c:	e0bfff17 	ldw	r2,-4(fp)
 400b380:	10800817 	ldw	r2,32(r2)
 400b384:	10810014 	ori	r2,r2,1024
 400b388:	18800035 	stwio	r2,0(r3)
    sp->host_inactive = 0;
 400b38c:	e0bfff17 	ldw	r2,-4(fp)
 400b390:	10000915 	stw	zero,36(r2)
 400b394:	00000c06 	br	400b3c8 <altera_avalon_jtag_uart_timeout+0x94>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
 400b398:	e0bfff17 	ldw	r2,-4(fp)
 400b39c:	10c00917 	ldw	r3,36(r2)
 400b3a0:	00a00034 	movhi	r2,32768
 400b3a4:	10bfff04 	addi	r2,r2,-4
 400b3a8:	10c00736 	bltu	r2,r3,400b3c8 <altera_avalon_jtag_uart_timeout+0x94>
    sp->host_inactive++;
 400b3ac:	e0bfff17 	ldw	r2,-4(fp)
 400b3b0:	10800917 	ldw	r2,36(r2)
 400b3b4:	10c00044 	addi	r3,r2,1
 400b3b8:	e0bfff17 	ldw	r2,-4(fp)
 400b3bc:	10c00915 	stw	r3,36(r2)
    
    if (sp->host_inactive >= sp->timeout) {
 400b3c0:	e0bfff17 	ldw	r2,-4(fp)
 400b3c4:	10800917 	ldw	r2,36(r2)
 400b3c8:	d0a6c617 	ldw	r2,-25832(gp)
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, ALT_FLAG_SET);
    }
  }

  return alt_ticks_per_second();
}
 400b3cc:	e037883a 	mov	sp,fp
 400b3d0:	df000017 	ldw	fp,0(sp)
 400b3d4:	dec00104 	addi	sp,sp,4
 400b3d8:	f800283a 	ret

0400b3dc <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
 400b3dc:	defffd04 	addi	sp,sp,-12
 400b3e0:	df000215 	stw	fp,8(sp)
 400b3e4:	df000204 	addi	fp,sp,8
 400b3e8:	e13fff15 	stw	r4,-4(fp)
 400b3ec:	e17ffe15 	stw	r5,-8(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 400b3f0:	00000506 	br	400b408 <altera_avalon_jtag_uart_close+0x2c>
    if (flags & O_NONBLOCK) {
 400b3f4:	e0bffe17 	ldw	r2,-8(fp)
 400b3f8:	1090000c 	andi	r2,r2,16384
 400b3fc:	10000226 	beq	r2,zero,400b408 <altera_avalon_jtag_uart_close+0x2c>
      return -EWOULDBLOCK; 
 400b400:	00bffd44 	movi	r2,-11
 400b404:	00000b06 	br	400b434 <altera_avalon_jtag_uart_close+0x58>
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 400b408:	e0bfff17 	ldw	r2,-4(fp)
 400b40c:	10c00d17 	ldw	r3,52(r2)
 400b410:	e0bfff17 	ldw	r2,-4(fp)
 400b414:	10800c17 	ldw	r2,48(r2)
 400b418:	18800526 	beq	r3,r2,400b430 <altera_avalon_jtag_uart_close+0x54>
 400b41c:	e0bfff17 	ldw	r2,-4(fp)
 400b420:	10c00917 	ldw	r3,36(r2)
 400b424:	e0bfff17 	ldw	r2,-4(fp)
 400b428:	10800117 	ldw	r2,4(r2)
 400b42c:	18bff136 	bltu	r3,r2,400b3f4 <altera_avalon_jtag_uart_close+0x18>
    }
  }

  return 0;
 400b430:	0005883a 	mov	r2,zero
}
 400b434:	e037883a 	mov	sp,fp
 400b438:	df000017 	ldw	fp,0(sp)
 400b43c:	dec00104 	addi	sp,sp,4
 400b440:	f800283a 	ret

0400b444 <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
 400b444:	defffa04 	addi	sp,sp,-24
 400b448:	df000515 	stw	fp,20(sp)
 400b44c:	df000504 	addi	fp,sp,20
 400b450:	e13ffd15 	stw	r4,-12(fp)
 400b454:	e17ffc15 	stw	r5,-16(fp)
 400b458:	e1bffb15 	stw	r6,-20(fp)
  int rc = -ENOTTY;
 400b45c:	00bff9c4 	movi	r2,-25
 400b460:	e0bfff15 	stw	r2,-4(fp)

  switch (req)
 400b464:	e0bffc17 	ldw	r2,-16(fp)
 400b468:	109a8060 	cmpeqi	r2,r2,27137
 400b46c:	1000041e 	bne	r2,zero,400b480 <altera_avalon_jtag_uart_ioctl+0x3c>
 400b470:	e0bffc17 	ldw	r2,-16(fp)
 400b474:	109a80a0 	cmpeqi	r2,r2,27138
 400b478:	1000181e 	bne	r2,zero,400b4dc <altera_avalon_jtag_uart_ioctl+0x98>
      rc = 0;
    }
    break;

  default:
    break;
 400b47c:	00002906 	br	400b524 <altera_avalon_jtag_uart_ioctl+0xe0>
    if (sp->timeout != INT_MAX)
 400b480:	e0bffd17 	ldw	r2,-12(fp)
 400b484:	10c00117 	ldw	r3,4(r2)
 400b488:	00a00034 	movhi	r2,32768
 400b48c:	10bfffc4 	addi	r2,r2,-1
 400b490:	18802126 	beq	r3,r2,400b518 <altera_avalon_jtag_uart_ioctl+0xd4>
      int timeout = *((int *)arg);
 400b494:	e0bffb17 	ldw	r2,-20(fp)
 400b498:	10800017 	ldw	r2,0(r2)
 400b49c:	e0bffe15 	stw	r2,-8(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
 400b4a0:	e0bffe17 	ldw	r2,-8(fp)
 400b4a4:	10800090 	cmplti	r2,r2,2
 400b4a8:	1000061e 	bne	r2,zero,400b4c4 <altera_avalon_jtag_uart_ioctl+0x80>
 400b4ac:	e0fffe17 	ldw	r3,-8(fp)
 400b4b0:	00a00034 	movhi	r2,32768
 400b4b4:	10bfffc4 	addi	r2,r2,-1
 400b4b8:	18800226 	beq	r3,r2,400b4c4 <altera_avalon_jtag_uart_ioctl+0x80>
 400b4bc:	e0bffe17 	ldw	r2,-8(fp)
 400b4c0:	00000206 	br	400b4cc <altera_avalon_jtag_uart_ioctl+0x88>
 400b4c4:	00a00034 	movhi	r2,32768
 400b4c8:	10bfff84 	addi	r2,r2,-2
 400b4cc:	e0fffd17 	ldw	r3,-12(fp)
 400b4d0:	18800115 	stw	r2,4(r3)
      rc = 0;
 400b4d4:	e03fff15 	stw	zero,-4(fp)
    break;
 400b4d8:	00000f06 	br	400b518 <altera_avalon_jtag_uart_ioctl+0xd4>
    if (sp->timeout != INT_MAX)
 400b4dc:	e0bffd17 	ldw	r2,-12(fp)
 400b4e0:	10c00117 	ldw	r3,4(r2)
 400b4e4:	00a00034 	movhi	r2,32768
 400b4e8:	10bfffc4 	addi	r2,r2,-1
 400b4ec:	18800c26 	beq	r3,r2,400b520 <altera_avalon_jtag_uart_ioctl+0xdc>
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
 400b4f0:	e0bffd17 	ldw	r2,-12(fp)
 400b4f4:	10c00917 	ldw	r3,36(r2)
 400b4f8:	e0bffd17 	ldw	r2,-12(fp)
 400b4fc:	10800117 	ldw	r2,4(r2)
 400b500:	1885803a 	cmpltu	r2,r3,r2
 400b504:	10c03fcc 	andi	r3,r2,255
 400b508:	e0bffb17 	ldw	r2,-20(fp)
 400b50c:	10c00015 	stw	r3,0(r2)
      rc = 0;
 400b510:	e03fff15 	stw	zero,-4(fp)
    break;
 400b514:	00000206 	br	400b520 <altera_avalon_jtag_uart_ioctl+0xdc>
    break;
 400b518:	0001883a 	nop
 400b51c:	00000106 	br	400b524 <altera_avalon_jtag_uart_ioctl+0xe0>
    break;
 400b520:	0001883a 	nop
  }

  return rc;
 400b524:	e0bfff17 	ldw	r2,-4(fp)
}
 400b528:	e037883a 	mov	sp,fp
 400b52c:	df000017 	ldw	fp,0(sp)
 400b530:	dec00104 	addi	sp,sp,4
 400b534:	f800283a 	ret

0400b538 <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
 400b538:	defff304 	addi	sp,sp,-52
 400b53c:	dfc00c15 	stw	ra,48(sp)
 400b540:	df000b15 	stw	fp,44(sp)
 400b544:	df000b04 	addi	fp,sp,44
 400b548:	e13ff815 	stw	r4,-32(fp)
 400b54c:	e17ff715 	stw	r5,-36(fp)
 400b550:	e1bff615 	stw	r6,-40(fp)
 400b554:	e1fff515 	stw	r7,-44(fp)
  char * ptr = buffer;
 400b558:	e0bff717 	ldw	r2,-36(fp)
 400b55c:	e0bfff15 	stw	r2,-4(fp)
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
 400b560:	00004706 	br	400b680 <altera_avalon_jtag_uart_read+0x148>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
 400b564:	e0bff817 	ldw	r2,-32(fp)
 400b568:	10800a17 	ldw	r2,40(r2)
 400b56c:	e0bffd15 	stw	r2,-12(fp)
      out = sp->rx_out;
 400b570:	e0bff817 	ldw	r2,-32(fp)
 400b574:	10800b17 	ldw	r2,44(r2)
 400b578:	e0bffc15 	stw	r2,-16(fp)

      if (in >= out)
 400b57c:	e0fffd17 	ldw	r3,-12(fp)
 400b580:	e0bffc17 	ldw	r2,-16(fp)
 400b584:	18800536 	bltu	r3,r2,400b59c <altera_avalon_jtag_uart_read+0x64>
        n = in - out;
 400b588:	e0fffd17 	ldw	r3,-12(fp)
 400b58c:	e0bffc17 	ldw	r2,-16(fp)
 400b590:	1885c83a 	sub	r2,r3,r2
 400b594:	e0bffe15 	stw	r2,-8(fp)
 400b598:	00000406 	br	400b5ac <altera_avalon_jtag_uart_read+0x74>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
 400b59c:	00c20004 	movi	r3,2048
 400b5a0:	e0bffc17 	ldw	r2,-16(fp)
 400b5a4:	1885c83a 	sub	r2,r3,r2
 400b5a8:	e0bffe15 	stw	r2,-8(fp)

      if (n == 0)
 400b5ac:	e0bffe17 	ldw	r2,-8(fp)
 400b5b0:	10001e26 	beq	r2,zero,400b62c <altera_avalon_jtag_uart_read+0xf4>
        break; /* No more data available */

      if (n > space)
 400b5b4:	e0fff617 	ldw	r3,-40(fp)
 400b5b8:	e0bffe17 	ldw	r2,-8(fp)
 400b5bc:	1880022e 	bgeu	r3,r2,400b5c8 <altera_avalon_jtag_uart_read+0x90>
        n = space;
 400b5c0:	e0bff617 	ldw	r2,-40(fp)
 400b5c4:	e0bffe15 	stw	r2,-8(fp)

      memcpy(ptr, sp->rx_buf + out, n);
 400b5c8:	e0bff817 	ldw	r2,-32(fp)
 400b5cc:	10c00e04 	addi	r3,r2,56
 400b5d0:	e0bffc17 	ldw	r2,-16(fp)
 400b5d4:	1885883a 	add	r2,r3,r2
 400b5d8:	e1bffe17 	ldw	r6,-8(fp)
 400b5dc:	100b883a 	mov	r5,r2
 400b5e0:	e13fff17 	ldw	r4,-4(fp)
 400b5e4:	40073dc0 	call	40073dc <memcpy>
      ptr   += n;
 400b5e8:	e0ffff17 	ldw	r3,-4(fp)
 400b5ec:	e0bffe17 	ldw	r2,-8(fp)
 400b5f0:	1885883a 	add	r2,r3,r2
 400b5f4:	e0bfff15 	stw	r2,-4(fp)
      space -= n;
 400b5f8:	e0fff617 	ldw	r3,-40(fp)
 400b5fc:	e0bffe17 	ldw	r2,-8(fp)
 400b600:	1885c83a 	sub	r2,r3,r2
 400b604:	e0bff615 	stw	r2,-40(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 400b608:	e0fffc17 	ldw	r3,-16(fp)
 400b60c:	e0bffe17 	ldw	r2,-8(fp)
 400b610:	1885883a 	add	r2,r3,r2
 400b614:	10c1ffcc 	andi	r3,r2,2047
 400b618:	e0bff817 	ldw	r2,-32(fp)
 400b61c:	10c00b15 	stw	r3,44(r2)
    }
    while (space > 0);
 400b620:	e0bff617 	ldw	r2,-40(fp)
 400b624:	00bfcf16 	blt	zero,r2,400b564 <altera_avalon_jtag_uart_read+0x2c>
 400b628:	00000106 	br	400b630 <altera_avalon_jtag_uart_read+0xf8>
        break; /* No more data available */
 400b62c:	0001883a 	nop

    /* If we read any data then return it */
    if (ptr != buffer)
 400b630:	e0ffff17 	ldw	r3,-4(fp)
 400b634:	e0bff717 	ldw	r2,-36(fp)
 400b638:	1880141e 	bne	r3,r2,400b68c <altera_avalon_jtag_uart_read+0x154>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
 400b63c:	e0bff517 	ldw	r2,-44(fp)
 400b640:	1090000c 	andi	r2,r2,16384
 400b644:	1000131e 	bne	r2,zero,400b694 <altera_avalon_jtag_uart_read+0x15c>
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
        ;
    }
#else
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
 400b648:	0001883a 	nop
 400b64c:	e0bff817 	ldw	r2,-32(fp)
 400b650:	10800a17 	ldw	r2,40(r2)
 400b654:	e0fffd17 	ldw	r3,-12(fp)
 400b658:	1880051e 	bne	r3,r2,400b670 <altera_avalon_jtag_uart_read+0x138>
 400b65c:	e0bff817 	ldw	r2,-32(fp)
 400b660:	10c00917 	ldw	r3,36(r2)
 400b664:	e0bff817 	ldw	r2,-32(fp)
 400b668:	10800117 	ldw	r2,4(r2)
 400b66c:	18bff736 	bltu	r3,r2,400b64c <altera_avalon_jtag_uart_read+0x114>
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
 400b670:	e0bff817 	ldw	r2,-32(fp)
 400b674:	10800a17 	ldw	r2,40(r2)
 400b678:	e0fffd17 	ldw	r3,-12(fp)
 400b67c:	18800726 	beq	r3,r2,400b69c <altera_avalon_jtag_uart_read+0x164>
  while (space > 0)
 400b680:	e0bff617 	ldw	r2,-40(fp)
 400b684:	00bfb716 	blt	zero,r2,400b564 <altera_avalon_jtag_uart_read+0x2c>
 400b688:	00000506 	br	400b6a0 <altera_avalon_jtag_uart_read+0x168>
      break;
 400b68c:	0001883a 	nop
 400b690:	00000306 	br	400b6a0 <altera_avalon_jtag_uart_read+0x168>
      break;
 400b694:	0001883a 	nop
 400b698:	00000106 	br	400b6a0 <altera_avalon_jtag_uart_read+0x168>
      break;
 400b69c:	0001883a 	nop
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);

  if (ptr != buffer)
 400b6a0:	e0ffff17 	ldw	r3,-4(fp)
 400b6a4:	e0bff717 	ldw	r2,-36(fp)
 400b6a8:	18801926 	beq	r3,r2,400b710 <altera_avalon_jtag_uart_read+0x1d8>
  NIOS2_READ_STATUS (context);
 400b6ac:	0005303a 	rdctl	r2,status
 400b6b0:	e0bff915 	stw	r2,-28(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 400b6b4:	e0fff917 	ldw	r3,-28(fp)
 400b6b8:	00bfff84 	movi	r2,-2
 400b6bc:	1884703a 	and	r2,r3,r2
 400b6c0:	1001703a 	wrctl	status,r2
  return context;
 400b6c4:	e0bff917 	ldw	r2,-28(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
 400b6c8:	e0bffb15 	stw	r2,-20(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 400b6cc:	e0bff817 	ldw	r2,-32(fp)
 400b6d0:	10800817 	ldw	r2,32(r2)
 400b6d4:	10c00054 	ori	r3,r2,1
 400b6d8:	e0bff817 	ldw	r2,-32(fp)
 400b6dc:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 400b6e0:	e0bff817 	ldw	r2,-32(fp)
 400b6e4:	10800017 	ldw	r2,0(r2)
 400b6e8:	10800104 	addi	r2,r2,4
 400b6ec:	1007883a 	mov	r3,r2
 400b6f0:	e0bff817 	ldw	r2,-32(fp)
 400b6f4:	10800817 	ldw	r2,32(r2)
 400b6f8:	18800035 	stwio	r2,0(r3)
 400b6fc:	e0bffb17 	ldw	r2,-20(fp)
 400b700:	e0bffa15 	stw	r2,-24(fp)
  NIOS2_WRITE_STATUS (context);
 400b704:	e0bffa17 	ldw	r2,-24(fp)
 400b708:	1001703a 	wrctl	status,r2
}
 400b70c:	0001883a 	nop
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
 400b710:	e0ffff17 	ldw	r3,-4(fp)
 400b714:	e0bff717 	ldw	r2,-36(fp)
 400b718:	18800426 	beq	r3,r2,400b72c <altera_avalon_jtag_uart_read+0x1f4>
    return ptr - buffer;
 400b71c:	e0ffff17 	ldw	r3,-4(fp)
 400b720:	e0bff717 	ldw	r2,-36(fp)
 400b724:	1885c83a 	sub	r2,r3,r2
 400b728:	00000606 	br	400b744 <altera_avalon_jtag_uart_read+0x20c>
  else if (flags & O_NONBLOCK)
 400b72c:	e0bff517 	ldw	r2,-44(fp)
 400b730:	1090000c 	andi	r2,r2,16384
 400b734:	10000226 	beq	r2,zero,400b740 <altera_avalon_jtag_uart_read+0x208>
    return -EWOULDBLOCK;
 400b738:	00bffd44 	movi	r2,-11
 400b73c:	00000106 	br	400b744 <altera_avalon_jtag_uart_read+0x20c>
  else
    return -EIO;
 400b740:	00bffec4 	movi	r2,-5
}
 400b744:	e037883a 	mov	sp,fp
 400b748:	dfc00117 	ldw	ra,4(sp)
 400b74c:	df000017 	ldw	fp,0(sp)
 400b750:	dec00204 	addi	sp,sp,8
 400b754:	f800283a 	ret

0400b758 <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
 400b758:	defff304 	addi	sp,sp,-52
 400b75c:	dfc00c15 	stw	ra,48(sp)
 400b760:	df000b15 	stw	fp,44(sp)
 400b764:	df000b04 	addi	fp,sp,44
 400b768:	e13ff815 	stw	r4,-32(fp)
 400b76c:	e17ff715 	stw	r5,-36(fp)
 400b770:	e1bff615 	stw	r6,-40(fp)
 400b774:	e1fff515 	stw	r7,-44(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
 400b778:	e03fff15 	stw	zero,-4(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
 400b77c:	e0bff717 	ldw	r2,-36(fp)
 400b780:	e0bffd15 	stw	r2,-12(fp)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
 400b784:	00003706 	br	400b864 <altera_avalon_jtag_uart_write+0x10c>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
 400b788:	e0bff817 	ldw	r2,-32(fp)
 400b78c:	10800c17 	ldw	r2,48(r2)
 400b790:	e0bffc15 	stw	r2,-16(fp)
      out = sp->tx_out;
 400b794:	e0bff817 	ldw	r2,-32(fp)
 400b798:	10800d17 	ldw	r2,52(r2)
 400b79c:	e0bfff15 	stw	r2,-4(fp)

      if (in < out)
 400b7a0:	e0fffc17 	ldw	r3,-16(fp)
 400b7a4:	e0bfff17 	ldw	r2,-4(fp)
 400b7a8:	1880062e 	bgeu	r3,r2,400b7c4 <altera_avalon_jtag_uart_write+0x6c>
        n = out - 1 - in;
 400b7ac:	e0ffff17 	ldw	r3,-4(fp)
 400b7b0:	e0bffc17 	ldw	r2,-16(fp)
 400b7b4:	1885c83a 	sub	r2,r3,r2
 400b7b8:	10bfffc4 	addi	r2,r2,-1
 400b7bc:	e0bffe15 	stw	r2,-8(fp)
 400b7c0:	00000b06 	br	400b7f0 <altera_avalon_jtag_uart_write+0x98>
      else if (out > 0)
 400b7c4:	e0bfff17 	ldw	r2,-4(fp)
 400b7c8:	10000526 	beq	r2,zero,400b7e0 <altera_avalon_jtag_uart_write+0x88>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
 400b7cc:	00c20004 	movi	r3,2048
 400b7d0:	e0bffc17 	ldw	r2,-16(fp)
 400b7d4:	1885c83a 	sub	r2,r3,r2
 400b7d8:	e0bffe15 	stw	r2,-8(fp)
 400b7dc:	00000406 	br	400b7f0 <altera_avalon_jtag_uart_write+0x98>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
 400b7e0:	00c1ffc4 	movi	r3,2047
 400b7e4:	e0bffc17 	ldw	r2,-16(fp)
 400b7e8:	1885c83a 	sub	r2,r3,r2
 400b7ec:	e0bffe15 	stw	r2,-8(fp)

      if (n == 0)
 400b7f0:	e0bffe17 	ldw	r2,-8(fp)
 400b7f4:	10001e26 	beq	r2,zero,400b870 <altera_avalon_jtag_uart_write+0x118>
        break;

      if (n > count)
 400b7f8:	e0fff617 	ldw	r3,-40(fp)
 400b7fc:	e0bffe17 	ldw	r2,-8(fp)
 400b800:	1880022e 	bgeu	r3,r2,400b80c <altera_avalon_jtag_uart_write+0xb4>
        n = count;
 400b804:	e0bff617 	ldw	r2,-40(fp)
 400b808:	e0bffe15 	stw	r2,-8(fp)

      memcpy(sp->tx_buf + in, ptr, n);
 400b80c:	e0bff817 	ldw	r2,-32(fp)
 400b810:	10c20e04 	addi	r3,r2,2104
 400b814:	e0bffc17 	ldw	r2,-16(fp)
 400b818:	1885883a 	add	r2,r3,r2
 400b81c:	e1bffe17 	ldw	r6,-8(fp)
 400b820:	e17ff717 	ldw	r5,-36(fp)
 400b824:	1009883a 	mov	r4,r2
 400b828:	40073dc0 	call	40073dc <memcpy>
      ptr   += n;
 400b82c:	e0fff717 	ldw	r3,-36(fp)
 400b830:	e0bffe17 	ldw	r2,-8(fp)
 400b834:	1885883a 	add	r2,r3,r2
 400b838:	e0bff715 	stw	r2,-36(fp)
      count -= n;
 400b83c:	e0fff617 	ldw	r3,-40(fp)
 400b840:	e0bffe17 	ldw	r2,-8(fp)
 400b844:	1885c83a 	sub	r2,r3,r2
 400b848:	e0bff615 	stw	r2,-40(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 400b84c:	e0fffc17 	ldw	r3,-16(fp)
 400b850:	e0bffe17 	ldw	r2,-8(fp)
 400b854:	1885883a 	add	r2,r3,r2
 400b858:	10c1ffcc 	andi	r3,r2,2047
 400b85c:	e0bff817 	ldw	r2,-32(fp)
 400b860:	10c00c15 	stw	r3,48(r2)
    while (count > 0)
 400b864:	e0bff617 	ldw	r2,-40(fp)
 400b868:	00bfc716 	blt	zero,r2,400b788 <altera_avalon_jtag_uart_write+0x30>
 400b86c:	00000106 	br	400b874 <altera_avalon_jtag_uart_write+0x11c>
        break;
 400b870:	0001883a 	nop
  NIOS2_READ_STATUS (context);
 400b874:	0005303a 	rdctl	r2,status
 400b878:	e0bff915 	stw	r2,-28(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 400b87c:	e0fff917 	ldw	r3,-28(fp)
 400b880:	00bfff84 	movi	r2,-2
 400b884:	1884703a 	and	r2,r3,r2
 400b888:	1001703a 	wrctl	status,r2
  return context;
 400b88c:	e0bff917 	ldw	r2,-28(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
 400b890:	e0bffb15 	stw	r2,-20(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 400b894:	e0bff817 	ldw	r2,-32(fp)
 400b898:	10800817 	ldw	r2,32(r2)
 400b89c:	10c00094 	ori	r3,r2,2
 400b8a0:	e0bff817 	ldw	r2,-32(fp)
 400b8a4:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 400b8a8:	e0bff817 	ldw	r2,-32(fp)
 400b8ac:	10800017 	ldw	r2,0(r2)
 400b8b0:	10800104 	addi	r2,r2,4
 400b8b4:	1007883a 	mov	r3,r2
 400b8b8:	e0bff817 	ldw	r2,-32(fp)
 400b8bc:	10800817 	ldw	r2,32(r2)
 400b8c0:	18800035 	stwio	r2,0(r3)
 400b8c4:	e0bffb17 	ldw	r2,-20(fp)
 400b8c8:	e0bffa15 	stw	r2,-24(fp)
  NIOS2_WRITE_STATUS (context);
 400b8cc:	e0bffa17 	ldw	r2,-24(fp)
 400b8d0:	1001703a 	wrctl	status,r2
}
 400b8d4:	0001883a 	nop
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
 400b8d8:	e0bff617 	ldw	r2,-40(fp)
 400b8dc:	0080100e 	bge	zero,r2,400b920 <altera_avalon_jtag_uart_write+0x1c8>
    {
      if (flags & O_NONBLOCK)
 400b8e0:	e0bff517 	ldw	r2,-44(fp)
 400b8e4:	1090000c 	andi	r2,r2,16384
 400b8e8:	1000101e 	bne	r2,zero,400b92c <altera_avalon_jtag_uart_write+0x1d4>
      /*
       * No OS present: Always wait for data to be removed from buffer.  Once
       * the interrupt routine has removed some data then we will be able to
       * insert some more.
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
 400b8ec:	0001883a 	nop
 400b8f0:	e0bff817 	ldw	r2,-32(fp)
 400b8f4:	10800d17 	ldw	r2,52(r2)
 400b8f8:	e0ffff17 	ldw	r3,-4(fp)
 400b8fc:	1880051e 	bne	r3,r2,400b914 <altera_avalon_jtag_uart_write+0x1bc>
 400b900:	e0bff817 	ldw	r2,-32(fp)
 400b904:	10c00917 	ldw	r3,36(r2)
 400b908:	e0bff817 	ldw	r2,-32(fp)
 400b90c:	10800117 	ldw	r2,4(r2)
 400b910:	18bff736 	bltu	r3,r2,400b8f0 <altera_avalon_jtag_uart_write+0x198>
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
 400b914:	e0bff817 	ldw	r2,-32(fp)
 400b918:	10800917 	ldw	r2,36(r2)
 400b91c:	1000051e 	bne	r2,zero,400b934 <altera_avalon_jtag_uart_write+0x1dc>
         break;
    }
  }
  while (count > 0);
 400b920:	e0bff617 	ldw	r2,-40(fp)
 400b924:	00bfcf16 	blt	zero,r2,400b864 <altera_avalon_jtag_uart_write+0x10c>
 400b928:	00000306 	br	400b938 <altera_avalon_jtag_uart_write+0x1e0>
        break;
 400b92c:	0001883a 	nop
 400b930:	00000106 	br	400b938 <altera_avalon_jtag_uart_write+0x1e0>
         break;
 400b934:	0001883a 	nop
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);

  if (ptr != start)
 400b938:	e0fff717 	ldw	r3,-36(fp)
 400b93c:	e0bffd17 	ldw	r2,-12(fp)
 400b940:	18800426 	beq	r3,r2,400b954 <altera_avalon_jtag_uart_write+0x1fc>
    return ptr - start;
 400b944:	e0fff717 	ldw	r3,-36(fp)
 400b948:	e0bffd17 	ldw	r2,-12(fp)
 400b94c:	1885c83a 	sub	r2,r3,r2
 400b950:	00000606 	br	400b96c <altera_avalon_jtag_uart_write+0x214>
  else if (flags & O_NONBLOCK)
 400b954:	e0bff517 	ldw	r2,-44(fp)
 400b958:	1090000c 	andi	r2,r2,16384
 400b95c:	10000226 	beq	r2,zero,400b968 <altera_avalon_jtag_uart_write+0x210>
    return -EWOULDBLOCK;
 400b960:	00bffd44 	movi	r2,-11
 400b964:	00000106 	br	400b96c <altera_avalon_jtag_uart_write+0x214>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
 400b968:	00bffec4 	movi	r2,-5
}
 400b96c:	e037883a 	mov	sp,fp
 400b970:	dfc00117 	ldw	ra,4(sp)
 400b974:	df000017 	ldw	fp,0(sp)
 400b978:	dec00204 	addi	sp,sp,8
 400b97c:	f800283a 	ret

0400b980 <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
 400b980:	defffa04 	addi	sp,sp,-24
 400b984:	dfc00515 	stw	ra,20(sp)
 400b988:	df000415 	stw	fp,16(sp)
 400b98c:	df000404 	addi	fp,sp,16
 400b990:	e13ffc15 	stw	r4,-16(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
 400b994:	0007883a 	mov	r3,zero
 400b998:	e0bffc17 	ldw	r2,-16(fp)
 400b99c:	10c00035 	stwio	r3,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
 400b9a0:	e0bffc17 	ldw	r2,-16(fp)
 400b9a4:	10800104 	addi	r2,r2,4
 400b9a8:	10800037 	ldwio	r2,0(r2)
  NIOS2_READ_STATUS (context);
 400b9ac:	0005303a 	rdctl	r2,status
 400b9b0:	e0bffd15 	stw	r2,-12(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 400b9b4:	e0fffd17 	ldw	r3,-12(fp)
 400b9b8:	00bfff84 	movi	r2,-2
 400b9bc:	1884703a 	and	r2,r3,r2
 400b9c0:	1001703a 	wrctl	status,r2
  return context;
 400b9c4:	e0bffd17 	ldw	r2,-12(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
 400b9c8:	e0bfff15 	stw	r2,-4(fp)
  alt_tick ();
 400b9cc:	400c2ac0 	call	400c2ac <alt_tick>
 400b9d0:	e0bfff17 	ldw	r2,-4(fp)
 400b9d4:	e0bffe15 	stw	r2,-8(fp)
  NIOS2_WRITE_STATUS (context);
 400b9d8:	e0bffe17 	ldw	r2,-8(fp)
 400b9dc:	1001703a 	wrctl	status,r2
}
 400b9e0:	0001883a 	nop
  alt_irq_enable_all(cpu_sr);
}
 400b9e4:	0001883a 	nop
 400b9e8:	e037883a 	mov	sp,fp
 400b9ec:	dfc00117 	ldw	ra,4(sp)
 400b9f0:	df000017 	ldw	fp,0(sp)
 400b9f4:	dec00204 	addi	sp,sp,8
 400b9f8:	f800283a 	ret

0400b9fc <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
 400b9fc:	defff804 	addi	sp,sp,-32
 400ba00:	dfc00715 	stw	ra,28(sp)
 400ba04:	df000615 	stw	fp,24(sp)
 400ba08:	df000604 	addi	fp,sp,24
 400ba0c:	e13ffe15 	stw	r4,-8(fp)
 400ba10:	e17ffd15 	stw	r5,-12(fp)
 400ba14:	e1bffc15 	stw	r6,-16(fp)
 400ba18:	e1fffb15 	stw	r7,-20(fp)
 400ba1c:	e0bffb17 	ldw	r2,-20(fp)
 400ba20:	e0bfff15 	stw	r2,-4(fp)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
 400ba24:	d0a6c617 	ldw	r2,-25832(gp)
 400ba28:	1000031e 	bne	r2,zero,400ba38 <alt_avalon_timer_sc_init+0x3c>
  {
    _alt_tick_rate = nticks;
 400ba2c:	e0bfff17 	ldw	r2,-4(fp)
 400ba30:	d0a6c615 	stw	r2,-25832(gp)
    return 0;
 400ba34:	00000106 	br	400ba3c <alt_avalon_timer_sc_init+0x40>
  }
  else
  {
    return -1;
 400ba38:	0001883a 	nop
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
 400ba3c:	e0bffe17 	ldw	r2,-8(fp)
 400ba40:	10800104 	addi	r2,r2,4
 400ba44:	00c001c4 	movi	r3,7
 400ba48:	10c00035 	stwio	r3,0(r2)
            ALTERA_AVALON_TIMER_CONTROL_CONT_MSK |
            ALTERA_AVALON_TIMER_CONTROL_START_MSK);

  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
 400ba4c:	d8000015 	stw	zero,0(sp)
 400ba50:	e1fffe17 	ldw	r7,-8(fp)
 400ba54:	01810074 	movhi	r6,1025
 400ba58:	31ae6004 	addi	r6,r6,-18048
 400ba5c:	e17ffc17 	ldw	r5,-16(fp)
 400ba60:	e13ffd17 	ldw	r4,-12(fp)
 400ba64:	400a4300 	call	400a430 <alt_ic_isr_register>
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
#endif  
}
 400ba68:	0001883a 	nop
 400ba6c:	e037883a 	mov	sp,fp
 400ba70:	dfc00117 	ldw	ra,4(sp)
 400ba74:	df000017 	ldw	fp,0(sp)
 400ba78:	dec00204 	addi	sp,sp,8
 400ba7c:	f800283a 	ret

0400ba80 <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
 400ba80:	defff404 	addi	sp,sp,-48
 400ba84:	df000b15 	stw	fp,44(sp)
 400ba88:	df000b04 	addi	fp,sp,44
 400ba8c:	e13ff815 	stw	r4,-32(fp)
 400ba90:	e17ff715 	stw	r5,-36(fp)
 400ba94:	e1bff615 	stw	r6,-40(fp)
 400ba98:	e1fff515 	stw	r7,-44(fp)
  alt_irq_context irq_context;
  alt_u64 current_nticks = 0;
 400ba9c:	e03ffe15 	stw	zero,-8(fp)
 400baa0:	e03fff15 	stw	zero,-4(fp)
  return _alt_tick_rate;
 400baa4:	d0a6c617 	ldw	r2,-25832(gp)
  
  if (alt_ticks_per_second ())
 400baa8:	10004826 	beq	r2,zero,400bbcc <alt_alarm_start+0x14c>
  {
    if (alarm)
 400baac:	e0bff817 	ldw	r2,-32(fp)
 400bab0:	10004426 	beq	r2,zero,400bbc4 <alt_alarm_start+0x144>
    {
      alarm->callback = callback;
 400bab4:	e0bff817 	ldw	r2,-32(fp)
 400bab8:	e0fff617 	ldw	r3,-40(fp)
 400babc:	10c00415 	stw	r3,16(r2)
      alarm->context  = context;
 400bac0:	e0bff817 	ldw	r2,-32(fp)
 400bac4:	e0fff517 	ldw	r3,-44(fp)
 400bac8:	10c00515 	stw	r3,20(r2)
  NIOS2_READ_STATUS (context);
 400bacc:	0005303a 	rdctl	r2,status
 400bad0:	e0bff915 	stw	r2,-28(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 400bad4:	e0fff917 	ldw	r3,-28(fp)
 400bad8:	00bfff84 	movi	r2,-2
 400badc:	1884703a 	and	r2,r3,r2
 400bae0:	1001703a 	wrctl	status,r2
  return context;
 400bae4:	e0bff917 	ldw	r2,-28(fp)
 
      irq_context = alt_irq_disable_all ();
 400bae8:	e0bffd15 	stw	r2,-12(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u64 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
 400baec:	d0a6c717 	ldw	r2,-25828(gp)
 400baf0:	d0e6c817 	ldw	r3,-25824(gp)
      
      current_nticks = alt_nticks();
 400baf4:	e0bffe15 	stw	r2,-8(fp)
 400baf8:	e0ffff15 	stw	r3,-4(fp)
      
      alarm->time = (alt_u64)nticks + current_nticks + 1; 
 400bafc:	e0bff717 	ldw	r2,-36(fp)
 400bb00:	1011883a 	mov	r8,r2
 400bb04:	0013883a 	mov	r9,zero
 400bb08:	e13ffe17 	ldw	r4,-8(fp)
 400bb0c:	e17fff17 	ldw	r5,-4(fp)
 400bb10:	4105883a 	add	r2,r8,r4
 400bb14:	120d803a 	cmpltu	r6,r2,r8
 400bb18:	4947883a 	add	r3,r9,r5
 400bb1c:	30c9883a 	add	r4,r6,r3
 400bb20:	2007883a 	mov	r3,r4
 400bb24:	1009883a 	mov	r4,r2
 400bb28:	180b883a 	mov	r5,r3
 400bb2c:	01800044 	movi	r6,1
 400bb30:	000f883a 	mov	r7,zero
 400bb34:	2185883a 	add	r2,r4,r6
 400bb38:	1111803a 	cmpltu	r8,r2,r4
 400bb3c:	29c7883a 	add	r3,r5,r7
 400bb40:	40c9883a 	add	r4,r8,r3
 400bb44:	2007883a 	mov	r3,r4
 400bb48:	1009883a 	mov	r4,r2
 400bb4c:	180b883a 	mov	r5,r3
 400bb50:	e0bff817 	ldw	r2,-32(fp)
 400bb54:	11000215 	stw	r4,8(r2)
 400bb58:	11400315 	stw	r5,12(r2)
          
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
 400bb5c:	e0bff817 	ldw	r2,-32(fp)
 400bb60:	d0e00d04 	addi	r3,gp,-32716
 400bb64:	e0fffb15 	stw	r3,-20(fp)
 400bb68:	e0bffa15 	stw	r2,-24(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 400bb6c:	e0bffa17 	ldw	r2,-24(fp)
 400bb70:	e0fffb17 	ldw	r3,-20(fp)
 400bb74:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
 400bb78:	e0bffb17 	ldw	r2,-20(fp)
 400bb7c:	10c00017 	ldw	r3,0(r2)
 400bb80:	e0bffa17 	ldw	r2,-24(fp)
 400bb84:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 400bb88:	e0bffb17 	ldw	r2,-20(fp)
 400bb8c:	10800017 	ldw	r2,0(r2)
 400bb90:	e0fffa17 	ldw	r3,-24(fp)
 400bb94:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
 400bb98:	e0bffb17 	ldw	r2,-20(fp)
 400bb9c:	e0fffa17 	ldw	r3,-24(fp)
 400bba0:	10c00015 	stw	r3,0(r2)
}
 400bba4:	0001883a 	nop
 400bba8:	e0bffd17 	ldw	r2,-12(fp)
 400bbac:	e0bffc15 	stw	r2,-16(fp)
  NIOS2_WRITE_STATUS (context);
 400bbb0:	e0bffc17 	ldw	r2,-16(fp)
 400bbb4:	1001703a 	wrctl	status,r2
}
 400bbb8:	0001883a 	nop
      alt_irq_enable_all (irq_context);

      return 0;
 400bbbc:	0005883a 	mov	r2,zero
 400bbc0:	00000306 	br	400bbd0 <alt_alarm_start+0x150>
    }
    else
    {
      return -EINVAL;
 400bbc4:	00bffa84 	movi	r2,-22
 400bbc8:	00000106 	br	400bbd0 <alt_alarm_start+0x150>
    }
  }
  else
  {
    return -ENOTSUP;
 400bbcc:	00bfde84 	movi	r2,-134
  }
}
 400bbd0:	e037883a 	mov	sp,fp
 400bbd4:	df000017 	ldw	fp,0(sp)
 400bbd8:	dec00104 	addi	sp,sp,4
 400bbdc:	f800283a 	ret

0400bbe0 <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
 400bbe0:	deffff04 	addi	sp,sp,-4
 400bbe4:	df000015 	stw	fp,0(sp)
 400bbe8:	d839883a 	mov	fp,sp
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
 400bbec:	0001883a 	nop
 400bbf0:	e037883a 	mov	sp,fp
 400bbf4:	df000017 	ldw	fp,0(sp)
 400bbf8:	dec00104 	addi	sp,sp,4
 400bbfc:	f800283a 	ret

0400bc00 <alt_get_errno>:
{
 400bc00:	defffe04 	addi	sp,sp,-8
 400bc04:	dfc00115 	stw	ra,4(sp)
 400bc08:	df000015 	stw	fp,0(sp)
 400bc0c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 400bc10:	d0a00a17 	ldw	r2,-32728(gp)
 400bc14:	10000326 	beq	r2,zero,400bc24 <alt_get_errno+0x24>
 400bc18:	d0a00a17 	ldw	r2,-32728(gp)
 400bc1c:	103ee83a 	callr	r2
 400bc20:	00000106 	br	400bc28 <alt_get_errno+0x28>
 400bc24:	d0a6c004 	addi	r2,gp,-25856
}
 400bc28:	e037883a 	mov	sp,fp
 400bc2c:	dfc00117 	ldw	ra,4(sp)
 400bc30:	df000017 	ldw	fp,0(sp)
 400bc34:	dec00204 	addi	sp,sp,8
 400bc38:	f800283a 	ret

0400bc3c <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
 400bc3c:	defffa04 	addi	sp,sp,-24
 400bc40:	dfc00515 	stw	ra,20(sp)
 400bc44:	df000415 	stw	fp,16(sp)
 400bc48:	df000404 	addi	fp,sp,16
 400bc4c:	e13ffd15 	stw	r4,-12(fp)
 400bc50:	e17ffc15 	stw	r5,-16(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
 400bc54:	e0bffd17 	ldw	r2,-12(fp)
 400bc58:	10000326 	beq	r2,zero,400bc68 <alt_dev_llist_insert+0x2c>
 400bc5c:	e0bffd17 	ldw	r2,-12(fp)
 400bc60:	10800217 	ldw	r2,8(r2)
 400bc64:	1000061e 	bne	r2,zero,400bc80 <alt_dev_llist_insert+0x44>
  {
    ALT_ERRNO = EINVAL;
 400bc68:	400bc000 	call	400bc00 <alt_get_errno>
 400bc6c:	1007883a 	mov	r3,r2
 400bc70:	00800584 	movi	r2,22
 400bc74:	18800015 	stw	r2,0(r3)
    return -EINVAL;
 400bc78:	00bffa84 	movi	r2,-22
 400bc7c:	00001406 	br	400bcd0 <alt_dev_llist_insert+0x94>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
 400bc80:	e0bffd17 	ldw	r2,-12(fp)
 400bc84:	e0fffc17 	ldw	r3,-16(fp)
 400bc88:	e0ffff15 	stw	r3,-4(fp)
 400bc8c:	e0bffe15 	stw	r2,-8(fp)
  entry->previous = list;
 400bc90:	e0bffe17 	ldw	r2,-8(fp)
 400bc94:	e0ffff17 	ldw	r3,-4(fp)
 400bc98:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
 400bc9c:	e0bfff17 	ldw	r2,-4(fp)
 400bca0:	10c00017 	ldw	r3,0(r2)
 400bca4:	e0bffe17 	ldw	r2,-8(fp)
 400bca8:	10c00015 	stw	r3,0(r2)
  list->next->previous = entry;
 400bcac:	e0bfff17 	ldw	r2,-4(fp)
 400bcb0:	10800017 	ldw	r2,0(r2)
 400bcb4:	e0fffe17 	ldw	r3,-8(fp)
 400bcb8:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
 400bcbc:	e0bfff17 	ldw	r2,-4(fp)
 400bcc0:	e0fffe17 	ldw	r3,-8(fp)
 400bcc4:	10c00015 	stw	r3,0(r2)
}
 400bcc8:	0001883a 	nop

  return 0;  
 400bccc:	0005883a 	mov	r2,zero
}
 400bcd0:	e037883a 	mov	sp,fp
 400bcd4:	dfc00117 	ldw	ra,4(sp)
 400bcd8:	df000017 	ldw	fp,0(sp)
 400bcdc:	dec00204 	addi	sp,sp,8
 400bce0:	f800283a 	ret

0400bce4 <_do_ctors>:
/*
 * Run the C++ static constructors.
 */

void _do_ctors(void)
{
 400bce4:	defffd04 	addi	sp,sp,-12
 400bce8:	dfc00215 	stw	ra,8(sp)
 400bcec:	df000115 	stw	fp,4(sp)
 400bcf0:	df000104 	addi	fp,sp,4
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 400bcf4:	00810074 	movhi	r2,1025
 400bcf8:	10b23d04 	addi	r2,r2,-14092
 400bcfc:	e0bfff15 	stw	r2,-4(fp)
 400bd00:	00000606 	br	400bd1c <_do_ctors+0x38>
        (*ctor) (); 
 400bd04:	e0bfff17 	ldw	r2,-4(fp)
 400bd08:	10800017 	ldw	r2,0(r2)
 400bd0c:	103ee83a 	callr	r2
  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 400bd10:	e0bfff17 	ldw	r2,-4(fp)
 400bd14:	10bfff04 	addi	r2,r2,-4
 400bd18:	e0bfff15 	stw	r2,-4(fp)
 400bd1c:	e0ffff17 	ldw	r3,-4(fp)
 400bd20:	00810074 	movhi	r2,1025
 400bd24:	10b23e04 	addi	r2,r2,-14088
 400bd28:	18bff62e 	bgeu	r3,r2,400bd04 <_do_ctors+0x20>
}
 400bd2c:	0001883a 	nop
 400bd30:	0001883a 	nop
 400bd34:	e037883a 	mov	sp,fp
 400bd38:	dfc00117 	ldw	ra,4(sp)
 400bd3c:	df000017 	ldw	fp,0(sp)
 400bd40:	dec00204 	addi	sp,sp,8
 400bd44:	f800283a 	ret

0400bd48 <_do_dtors>:
/*
 * Run the C++ static destructors.
 */

void _do_dtors(void)
{
 400bd48:	defffd04 	addi	sp,sp,-12
 400bd4c:	dfc00215 	stw	ra,8(sp)
 400bd50:	df000115 	stw	fp,4(sp)
 400bd54:	df000104 	addi	fp,sp,4
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
 400bd58:	00810074 	movhi	r2,1025
 400bd5c:	10b23d04 	addi	r2,r2,-14092
 400bd60:	e0bfff15 	stw	r2,-4(fp)
 400bd64:	00000606 	br	400bd80 <_do_dtors+0x38>
        (*dtor) (); 
 400bd68:	e0bfff17 	ldw	r2,-4(fp)
 400bd6c:	10800017 	ldw	r2,0(r2)
 400bd70:	103ee83a 	callr	r2
  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
 400bd74:	e0bfff17 	ldw	r2,-4(fp)
 400bd78:	10bfff04 	addi	r2,r2,-4
 400bd7c:	e0bfff15 	stw	r2,-4(fp)
 400bd80:	e0ffff17 	ldw	r3,-4(fp)
 400bd84:	00810074 	movhi	r2,1025
 400bd88:	10b23e04 	addi	r2,r2,-14088
 400bd8c:	18bff62e 	bgeu	r3,r2,400bd68 <_do_dtors+0x20>
}
 400bd90:	0001883a 	nop
 400bd94:	0001883a 	nop
 400bd98:	e037883a 	mov	sp,fp
 400bd9c:	dfc00117 	ldw	ra,4(sp)
 400bda0:	df000017 	ldw	fp,0(sp)
 400bda4:	dec00204 	addi	sp,sp,8
 400bda8:	f800283a 	ret

0400bdac <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
 400bdac:	deffff04 	addi	sp,sp,-4
 400bdb0:	df000015 	stw	fp,0(sp)
 400bdb4:	d839883a 	mov	fp,sp
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
#endif
}
 400bdb8:	0001883a 	nop
 400bdbc:	e037883a 	mov	sp,fp
 400bdc0:	df000017 	ldw	fp,0(sp)
 400bdc4:	dec00104 	addi	sp,sp,4
 400bdc8:	f800283a 	ret

0400bdcc <alt_exception_cause_generated_bad_addr>:
 * Return: 1: BADADDR (bad_addr argument to handler) is valid
 *         0: BADADDR is not valid
 */
int 
alt_exception_cause_generated_bad_addr(alt_exception_cause cause)
{
 400bdcc:	defffe04 	addi	sp,sp,-8
 400bdd0:	df000115 	stw	fp,4(sp)
 400bdd4:	df000104 	addi	fp,sp,4
 400bdd8:	e13fff15 	stw	r4,-4(fp)
  switch (cause) {
 400bddc:	e0bfff17 	ldw	r2,-4(fp)
 400bde0:	10bffe84 	addi	r2,r2,-6
 400bde4:	10c00428 	cmpgeui	r3,r2,16
 400bde8:	18c03fcc 	andi	r3,r3,255
 400bdec:	18000f1e 	bne	r3,zero,400be2c <alt_exception_cause_generated_bad_addr+0x60>
 400bdf0:	00c00044 	movi	r3,1
 400bdf4:	1884983a 	sll	r2,r3,r2
 400bdf8:	10e2c8cc 	andi	r3,r2,35619
 400bdfc:	1806c03a 	cmpne	r3,r3,zero
 400be00:	18c03fcc 	andi	r3,r3,255
 400be04:	1800051e 	bne	r3,zero,400be1c <alt_exception_cause_generated_bad_addr+0x50>
 400be08:	1084100c 	andi	r2,r2,4160
 400be0c:	1004c03a 	cmpne	r2,r2,zero
 400be10:	10803fcc 	andi	r2,r2,255
 400be14:	1000031e 	bne	r2,zero,400be24 <alt_exception_cause_generated_bad_addr+0x58>
 400be18:	00000406 	br	400be2c <alt_exception_cause_generated_bad_addr+0x60>
  case NIOS2_EXCEPTION_MISALIGNED_TARGET_PC:
  case NIOS2_EXCEPTION_TLB_READ_PERM_VIOLATION:
  case NIOS2_EXCEPTION_TLB_WRITE_PERM_VIOLATION:
  case NIOS2_EXCEPTION_MPU_DATA_REGION_VIOLATION:
  case NIOS2_EXCEPTION_ECC_DATA_ERR:
    return 1;
 400be1c:	00800044 	movi	r2,1
 400be20:	00000306 	br	400be30 <alt_exception_cause_generated_bad_addr+0x64>

  case NIOS2_EXCEPTION_TLB_MISS:
  case NIOS2_EXCEPTION_ECC_TLB_ERR:
    return 0;
 400be24:	0005883a 	mov	r2,zero
 400be28:	00000106 	br	400be30 <alt_exception_cause_generated_bad_addr+0x64>

  default:
    return 0;
 400be2c:	0005883a 	mov	r2,zero
  }
}
 400be30:	e037883a 	mov	sp,fp
 400be34:	df000017 	ldw	fp,0(sp)
 400be38:	dec00104 	addi	sp,sp,4
 400be3c:	f800283a 	ret

0400be40 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
 400be40:	defff904 	addi	sp,sp,-28
 400be44:	dfc00615 	stw	ra,24(sp)
 400be48:	df000515 	stw	fp,20(sp)
 400be4c:	df000504 	addi	fp,sp,20
 400be50:	e13ffe15 	stw	r4,-8(fp)
 400be54:	e17ffd15 	stw	r5,-12(fp)
 400be58:	e1bffc15 	stw	r6,-16(fp)
 400be5c:	e1fffb15 	stw	r7,-20(fp)
  int old;

  old = open (name, flags, mode);
 400be60:	e1bffb17 	ldw	r6,-20(fp)
 400be64:	e17ffc17 	ldw	r5,-16(fp)
 400be68:	e13ffd17 	ldw	r4,-12(fp)
 400be6c:	400c0a80 	call	400c0a8 <open>
 400be70:	e0bfff15 	stw	r2,-4(fp)

  if (old >= 0)
 400be74:	e0bfff17 	ldw	r2,-4(fp)
 400be78:	10002016 	blt	r2,zero,400befc <alt_open_fd+0xbc>
  {
    fd->dev      = alt_fd_list[old].dev;
 400be7c:	e0ffff17 	ldw	r3,-4(fp)
 400be80:	1805883a 	mov	r2,r3
 400be84:	1085883a 	add	r2,r2,r2
 400be88:	10c5883a 	add	r2,r2,r3
 400be8c:	100490ba 	slli	r2,r2,2
 400be90:	00c10074 	movhi	r3,1025
 400be94:	10c7883a 	add	r3,r2,r3
 400be98:	18f47017 	ldw	r3,-11840(r3)
 400be9c:	e0bffe17 	ldw	r2,-8(fp)
 400bea0:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
 400bea4:	e0ffff17 	ldw	r3,-4(fp)
 400bea8:	1805883a 	mov	r2,r3
 400beac:	1085883a 	add	r2,r2,r2
 400beb0:	10c5883a 	add	r2,r2,r3
 400beb4:	100490ba 	slli	r2,r2,2
 400beb8:	00c10074 	movhi	r3,1025
 400bebc:	10c7883a 	add	r3,r2,r3
 400bec0:	18f47117 	ldw	r3,-11836(r3)
 400bec4:	e0bffe17 	ldw	r2,-8(fp)
 400bec8:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
 400becc:	e0ffff17 	ldw	r3,-4(fp)
 400bed0:	1805883a 	mov	r2,r3
 400bed4:	1085883a 	add	r2,r2,r2
 400bed8:	10c5883a 	add	r2,r2,r3
 400bedc:	100490ba 	slli	r2,r2,2
 400bee0:	00c10074 	movhi	r3,1025
 400bee4:	10c7883a 	add	r3,r2,r3
 400bee8:	18f47217 	ldw	r3,-11832(r3)
 400beec:	e0bffe17 	ldw	r2,-8(fp)
 400bef0:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
 400bef4:	e13fff17 	ldw	r4,-4(fp)
 400bef8:	400abc40 	call	400abc4 <alt_release_fd>
  }
} 
 400befc:	0001883a 	nop
 400bf00:	e037883a 	mov	sp,fp
 400bf04:	dfc00117 	ldw	ra,4(sp)
 400bf08:	df000017 	ldw	fp,0(sp)
 400bf0c:	dec00204 	addi	sp,sp,8
 400bf10:	f800283a 	ret

0400bf14 <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
 400bf14:	defffb04 	addi	sp,sp,-20
 400bf18:	dfc00415 	stw	ra,16(sp)
 400bf1c:	df000315 	stw	fp,12(sp)
 400bf20:	df000304 	addi	fp,sp,12
 400bf24:	e13fff15 	stw	r4,-4(fp)
 400bf28:	e17ffe15 	stw	r5,-8(fp)
 400bf2c:	e1bffd15 	stw	r6,-12(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
 400bf30:	01c07fc4 	movi	r7,511
 400bf34:	01800044 	movi	r6,1
 400bf38:	e17fff17 	ldw	r5,-4(fp)
 400bf3c:	01010074 	movhi	r4,1025
 400bf40:	21347304 	addi	r4,r4,-11828
 400bf44:	400be400 	call	400be40 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
 400bf48:	01c07fc4 	movi	r7,511
 400bf4c:	000d883a 	mov	r6,zero
 400bf50:	e17ffe17 	ldw	r5,-8(fp)
 400bf54:	01010074 	movhi	r4,1025
 400bf58:	21347004 	addi	r4,r4,-11840
 400bf5c:	400be400 	call	400be40 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
 400bf60:	01c07fc4 	movi	r7,511
 400bf64:	01800044 	movi	r6,1
 400bf68:	e17ffd17 	ldw	r5,-12(fp)
 400bf6c:	01010074 	movhi	r4,1025
 400bf70:	21347604 	addi	r4,r4,-11816
 400bf74:	400be400 	call	400be40 <alt_open_fd>
}  
 400bf78:	0001883a 	nop
 400bf7c:	e037883a 	mov	sp,fp
 400bf80:	dfc00117 	ldw	ra,4(sp)
 400bf84:	df000017 	ldw	fp,0(sp)
 400bf88:	dec00204 	addi	sp,sp,8
 400bf8c:	f800283a 	ret

0400bf90 <alt_get_errno>:
{
 400bf90:	defffe04 	addi	sp,sp,-8
 400bf94:	dfc00115 	stw	ra,4(sp)
 400bf98:	df000015 	stw	fp,0(sp)
 400bf9c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 400bfa0:	d0a00a17 	ldw	r2,-32728(gp)
 400bfa4:	10000326 	beq	r2,zero,400bfb4 <alt_get_errno+0x24>
 400bfa8:	d0a00a17 	ldw	r2,-32728(gp)
 400bfac:	103ee83a 	callr	r2
 400bfb0:	00000106 	br	400bfb8 <alt_get_errno+0x28>
 400bfb4:	d0a6c004 	addi	r2,gp,-25856
}
 400bfb8:	e037883a 	mov	sp,fp
 400bfbc:	dfc00117 	ldw	ra,4(sp)
 400bfc0:	df000017 	ldw	fp,0(sp)
 400bfc4:	dec00204 	addi	sp,sp,8
 400bfc8:	f800283a 	ret

0400bfcc <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
 400bfcc:	defffd04 	addi	sp,sp,-12
 400bfd0:	df000215 	stw	fp,8(sp)
 400bfd4:	df000204 	addi	fp,sp,8
 400bfd8:	e13ffe15 	stw	r4,-8(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
 400bfdc:	e0bffe17 	ldw	r2,-8(fp)
 400bfe0:	10800217 	ldw	r2,8(r2)
 400bfe4:	10d00034 	orhi	r3,r2,16384
 400bfe8:	e0bffe17 	ldw	r2,-8(fp)
 400bfec:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
 400bff0:	e03fff15 	stw	zero,-4(fp)
 400bff4:	00002306 	br	400c084 <alt_file_locked+0xb8>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
 400bff8:	e0ffff17 	ldw	r3,-4(fp)
 400bffc:	1805883a 	mov	r2,r3
 400c000:	1085883a 	add	r2,r2,r2
 400c004:	10c5883a 	add	r2,r2,r3
 400c008:	100490ba 	slli	r2,r2,2
 400c00c:	00c10074 	movhi	r3,1025
 400c010:	10c7883a 	add	r3,r2,r3
 400c014:	18f47017 	ldw	r3,-11840(r3)
 400c018:	e0bffe17 	ldw	r2,-8(fp)
 400c01c:	10800017 	ldw	r2,0(r2)
 400c020:	1880151e 	bne	r3,r2,400c078 <alt_file_locked+0xac>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
 400c024:	e0ffff17 	ldw	r3,-4(fp)
 400c028:	1805883a 	mov	r2,r3
 400c02c:	1085883a 	add	r2,r2,r2
 400c030:	10c5883a 	add	r2,r2,r3
 400c034:	100490ba 	slli	r2,r2,2
 400c038:	00c10074 	movhi	r3,1025
 400c03c:	10c7883a 	add	r3,r2,r3
 400c040:	18b47217 	ldw	r2,-11832(r3)
    if ((alt_fd_list[i].dev == fd->dev) &&
 400c044:	10000c0e 	bge	r2,zero,400c078 <alt_file_locked+0xac>
        (&alt_fd_list[i] != fd))
 400c048:	e0ffff17 	ldw	r3,-4(fp)
 400c04c:	1805883a 	mov	r2,r3
 400c050:	1085883a 	add	r2,r2,r2
 400c054:	10c5883a 	add	r2,r2,r3
 400c058:	100490ba 	slli	r2,r2,2
 400c05c:	00c10074 	movhi	r3,1025
 400c060:	18f47004 	addi	r3,r3,-11840
 400c064:	10c5883a 	add	r2,r2,r3
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
 400c068:	e0fffe17 	ldw	r3,-8(fp)
 400c06c:	18800226 	beq	r3,r2,400c078 <alt_file_locked+0xac>
    {
      return -EACCES;
 400c070:	00bffcc4 	movi	r2,-13
 400c074:	00000806 	br	400c098 <alt_file_locked+0xcc>
  for (i = 0; i <= alt_max_fd; i++)
 400c078:	e0bfff17 	ldw	r2,-4(fp)
 400c07c:	10800044 	addi	r2,r2,1
 400c080:	e0bfff15 	stw	r2,-4(fp)
 400c084:	d0a00917 	ldw	r2,-32732(gp)
 400c088:	1007883a 	mov	r3,r2
 400c08c:	e0bfff17 	ldw	r2,-4(fp)
 400c090:	18bfd92e 	bgeu	r3,r2,400bff8 <alt_file_locked+0x2c>
    }
  }
  
  /* The device is not locked */
 
  return 0;
 400c094:	0005883a 	mov	r2,zero
}
 400c098:	e037883a 	mov	sp,fp
 400c09c:	df000017 	ldw	fp,0(sp)
 400c0a0:	dec00104 	addi	sp,sp,4
 400c0a4:	f800283a 	ret

0400c0a8 <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
 400c0a8:	defff604 	addi	sp,sp,-40
 400c0ac:	dfc00915 	stw	ra,36(sp)
 400c0b0:	df000815 	stw	fp,32(sp)
 400c0b4:	df000804 	addi	fp,sp,32
 400c0b8:	e13ffa15 	stw	r4,-24(fp)
 400c0bc:	e17ff915 	stw	r5,-28(fp)
 400c0c0:	e1bff815 	stw	r6,-32(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
 400c0c4:	00bfffc4 	movi	r2,-1
 400c0c8:	e0bffe15 	stw	r2,-8(fp)
  int status = -ENODEV;
 400c0cc:	00bffb44 	movi	r2,-19
 400c0d0:	e0bffd15 	stw	r2,-12(fp)
  int isafs = 0;
 400c0d4:	e03ffc15 	stw	zero,-16(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
 400c0d8:	d1600704 	addi	r5,gp,-32740
 400c0dc:	e13ffa17 	ldw	r4,-24(fp)
 400c0e0:	400c3fc0 	call	400c3fc <alt_find_dev>
 400c0e4:	e0bfff15 	stw	r2,-4(fp)
 400c0e8:	e0bfff17 	ldw	r2,-4(fp)
 400c0ec:	1000051e 	bne	r2,zero,400c104 <open+0x5c>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
 400c0f0:	e13ffa17 	ldw	r4,-24(fp)
 400c0f4:	400c48c0 	call	400c48c <alt_find_file>
 400c0f8:	e0bfff15 	stw	r2,-4(fp)
    isafs = 1;
 400c0fc:	00800044 	movi	r2,1
 400c100:	e0bffc15 	stw	r2,-16(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
 400c104:	e0bfff17 	ldw	r2,-4(fp)
 400c108:	10002c26 	beq	r2,zero,400c1bc <open+0x114>
  {
    if ((index = alt_get_fd (dev)) < 0)
 400c10c:	e13fff17 	ldw	r4,-4(fp)
 400c110:	400c5940 	call	400c594 <alt_get_fd>
 400c114:	e0bffe15 	stw	r2,-8(fp)
 400c118:	e0bffe17 	ldw	r2,-8(fp)
 400c11c:	1000030e 	bge	r2,zero,400c12c <open+0x84>
    {
      status = index;
 400c120:	e0bffe17 	ldw	r2,-8(fp)
 400c124:	e0bffd15 	stw	r2,-12(fp)
 400c128:	00002606 	br	400c1c4 <open+0x11c>
    }
    else
    {
      fd = &alt_fd_list[index];
 400c12c:	e0fffe17 	ldw	r3,-8(fp)
 400c130:	1805883a 	mov	r2,r3
 400c134:	1085883a 	add	r2,r2,r2
 400c138:	10c5883a 	add	r2,r2,r3
 400c13c:	100490ba 	slli	r2,r2,2
 400c140:	00c10074 	movhi	r3,1025
 400c144:	18f47004 	addi	r3,r3,-11840
 400c148:	10c5883a 	add	r2,r2,r3
 400c14c:	e0bffb15 	stw	r2,-20(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
 400c150:	e0fff917 	ldw	r3,-28(fp)
 400c154:	00900034 	movhi	r2,16384
 400c158:	10bfffc4 	addi	r2,r2,-1
 400c15c:	1886703a 	and	r3,r3,r2
 400c160:	e0bffb17 	ldw	r2,-20(fp)
 400c164:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
 400c168:	e0bffc17 	ldw	r2,-16(fp)
 400c16c:	1000051e 	bne	r2,zero,400c184 <open+0xdc>
 400c170:	e13ffb17 	ldw	r4,-20(fp)
 400c174:	400bfcc0 	call	400bfcc <alt_file_locked>
 400c178:	e0bffd15 	stw	r2,-12(fp)
 400c17c:	e0bffd17 	ldw	r2,-12(fp)
 400c180:	10001016 	blt	r2,zero,400c1c4 <open+0x11c>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
 400c184:	e0bfff17 	ldw	r2,-4(fp)
 400c188:	10800317 	ldw	r2,12(r2)
 400c18c:	10000826 	beq	r2,zero,400c1b0 <open+0x108>
 400c190:	e0bfff17 	ldw	r2,-4(fp)
 400c194:	10800317 	ldw	r2,12(r2)
 400c198:	e1fff817 	ldw	r7,-32(fp)
 400c19c:	e1bff917 	ldw	r6,-28(fp)
 400c1a0:	e17ffa17 	ldw	r5,-24(fp)
 400c1a4:	e13ffb17 	ldw	r4,-20(fp)
 400c1a8:	103ee83a 	callr	r2
 400c1ac:	00000106 	br	400c1b4 <open+0x10c>
 400c1b0:	0005883a 	mov	r2,zero
 400c1b4:	e0bffd15 	stw	r2,-12(fp)
 400c1b8:	00000206 	br	400c1c4 <open+0x11c>
      }
    }
  }
  else
  {
    status = -ENODEV;
 400c1bc:	00bffb44 	movi	r2,-19
 400c1c0:	e0bffd15 	stw	r2,-12(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
 400c1c4:	e0bffd17 	ldw	r2,-12(fp)
 400c1c8:	1000090e 	bge	r2,zero,400c1f0 <open+0x148>
  {
    alt_release_fd (index);  
 400c1cc:	e13ffe17 	ldw	r4,-8(fp)
 400c1d0:	400abc40 	call	400abc4 <alt_release_fd>
    ALT_ERRNO = -status;
 400c1d4:	400bf900 	call	400bf90 <alt_get_errno>
 400c1d8:	1007883a 	mov	r3,r2
 400c1dc:	e0bffd17 	ldw	r2,-12(fp)
 400c1e0:	0085c83a 	sub	r2,zero,r2
 400c1e4:	18800015 	stw	r2,0(r3)
    return -1;
 400c1e8:	00bfffc4 	movi	r2,-1
 400c1ec:	00000106 	br	400c1f4 <open+0x14c>
  }
  
  /* return the reference upon success */

  return index;
 400c1f0:	e0bffe17 	ldw	r2,-8(fp)
}
 400c1f4:	e037883a 	mov	sp,fp
 400c1f8:	dfc00117 	ldw	ra,4(sp)
 400c1fc:	df000017 	ldw	fp,0(sp)
 400c200:	dec00204 	addi	sp,sp,8
 400c204:	f800283a 	ret

0400c208 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
 400c208:	defffa04 	addi	sp,sp,-24
 400c20c:	df000515 	stw	fp,20(sp)
 400c210:	df000504 	addi	fp,sp,20
 400c214:	e13ffb15 	stw	r4,-20(fp)
  NIOS2_READ_STATUS (context);
 400c218:	0005303a 	rdctl	r2,status
 400c21c:	e0bffc15 	stw	r2,-16(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 400c220:	e0fffc17 	ldw	r3,-16(fp)
 400c224:	00bfff84 	movi	r2,-2
 400c228:	1884703a 	and	r2,r3,r2
 400c22c:	1001703a 	wrctl	status,r2
  return context;
 400c230:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
 400c234:	e0bfff15 	stw	r2,-4(fp)
  alt_llist_remove (&alarm->llist);
 400c238:	e0bffb17 	ldw	r2,-20(fp)
 400c23c:	e0bffd15 	stw	r2,-12(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
 400c240:	e0bffd17 	ldw	r2,-12(fp)
 400c244:	10800017 	ldw	r2,0(r2)
 400c248:	e0fffd17 	ldw	r3,-12(fp)
 400c24c:	18c00117 	ldw	r3,4(r3)
 400c250:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
 400c254:	e0bffd17 	ldw	r2,-12(fp)
 400c258:	10800117 	ldw	r2,4(r2)
 400c25c:	e0fffd17 	ldw	r3,-12(fp)
 400c260:	18c00017 	ldw	r3,0(r3)
 400c264:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
 400c268:	e0bffd17 	ldw	r2,-12(fp)
 400c26c:	e0fffd17 	ldw	r3,-12(fp)
 400c270:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
 400c274:	e0bffd17 	ldw	r2,-12(fp)
 400c278:	e0fffd17 	ldw	r3,-12(fp)
 400c27c:	10c00015 	stw	r3,0(r2)
} 
 400c280:	0001883a 	nop
 400c284:	e0bfff17 	ldw	r2,-4(fp)
 400c288:	e0bffe15 	stw	r2,-8(fp)
  NIOS2_WRITE_STATUS (context);
 400c28c:	e0bffe17 	ldw	r2,-8(fp)
 400c290:	1001703a 	wrctl	status,r2
}
 400c294:	0001883a 	nop
  alt_irq_enable_all (irq_context);
}
 400c298:	0001883a 	nop
 400c29c:	e037883a 	mov	sp,fp
 400c2a0:	df000017 	ldw	fp,0(sp)
 400c2a4:	dec00104 	addi	sp,sp,4
 400c2a8:	f800283a 	ret

0400c2ac <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
 400c2ac:	defff904 	addi	sp,sp,-28
 400c2b0:	dfc00615 	stw	ra,24(sp)
 400c2b4:	df000515 	stw	fp,20(sp)
 400c2b8:	dc400415 	stw	r17,16(sp)
 400c2bc:	dc000315 	stw	r16,12(sp)
 400c2c0:	df000504 	addi	fp,sp,20
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
 400c2c4:	d0a00d17 	ldw	r2,-32716(gp)
 400c2c8:	e0bffd15 	stw	r2,-12(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
 400c2cc:	d126c717 	ldw	r4,-25828(gp)
 400c2d0:	d166c817 	ldw	r5,-25824(gp)
 400c2d4:	01800044 	movi	r6,1
 400c2d8:	000f883a 	mov	r7,zero
 400c2dc:	2185883a 	add	r2,r4,r6
 400c2e0:	1111803a 	cmpltu	r8,r2,r4
 400c2e4:	29c7883a 	add	r3,r5,r7
 400c2e8:	40c9883a 	add	r4,r8,r3
 400c2ec:	2007883a 	mov	r3,r4
 400c2f0:	1009883a 	mov	r4,r2
 400c2f4:	180b883a 	mov	r5,r3
 400c2f8:	d126c715 	stw	r4,-25828(gp)
 400c2fc:	d166c815 	stw	r5,-25824(gp)
 
  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 400c300:	00002906 	br	400c3a8 <alt_tick+0xfc>
  {
    next = (alt_alarm*) alarm->llist.next;
 400c304:	e0bffd17 	ldw	r2,-12(fp)
 400c308:	10800017 	ldw	r2,0(r2)
 400c30c:	e0bffc15 	stw	r2,-16(fp)
    
    /* if the alarm period has expired, make the callback */    
    if (alarm->time <= _alt_nticks)
 400c310:	e13ffd17 	ldw	r4,-12(fp)
 400c314:	20800217 	ldw	r2,8(r4)
 400c318:	20c00317 	ldw	r3,12(r4)
 400c31c:	d126c717 	ldw	r4,-25828(gp)
 400c320:	d166c817 	ldw	r5,-25824(gp)
 400c324:	28c01e36 	bltu	r5,r3,400c3a0 <alt_tick+0xf4>
 400c328:	1940011e 	bne	r3,r5,400c330 <alt_tick+0x84>
 400c32c:	20801c36 	bltu	r4,r2,400c3a0 <alt_tick+0xf4>
    {
      next_callback = alarm->callback (alarm->context);
 400c330:	e0bffd17 	ldw	r2,-12(fp)
 400c334:	10800417 	ldw	r2,16(r2)
 400c338:	e0fffd17 	ldw	r3,-12(fp)
 400c33c:	18c00517 	ldw	r3,20(r3)
 400c340:	1809883a 	mov	r4,r3
 400c344:	103ee83a 	callr	r2
 400c348:	e0bffb15 	stw	r2,-20(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
 400c34c:	e0bffb17 	ldw	r2,-20(fp)
 400c350:	1000031e 	bne	r2,zero,400c360 <alt_tick+0xb4>
      {
        alt_alarm_stop (alarm);
 400c354:	e13ffd17 	ldw	r4,-12(fp)
 400c358:	400c2080 	call	400c208 <alt_alarm_stop>
 400c35c:	00001006 	br	400c3a0 <alt_tick+0xf4>
      }
      else
      {
        alarm->time += next_callback;
 400c360:	e0bffd17 	ldw	r2,-12(fp)
 400c364:	11000217 	ldw	r4,8(r2)
 400c368:	11400317 	ldw	r5,12(r2)
 400c36c:	e0bffb17 	ldw	r2,-20(fp)
 400c370:	1021883a 	mov	r16,r2
 400c374:	0023883a 	mov	r17,zero
 400c378:	2405883a 	add	r2,r4,r16
 400c37c:	110d803a 	cmpltu	r6,r2,r4
 400c380:	2c47883a 	add	r3,r5,r17
 400c384:	30c9883a 	add	r4,r6,r3
 400c388:	2007883a 	mov	r3,r4
 400c38c:	1009883a 	mov	r4,r2
 400c390:	180b883a 	mov	r5,r3
 400c394:	e0bffd17 	ldw	r2,-12(fp)
 400c398:	11000215 	stw	r4,8(r2)
 400c39c:	11400315 	stw	r5,12(r2)
      }
    }
    alarm = next;
 400c3a0:	e0bffc17 	ldw	r2,-16(fp)
 400c3a4:	e0bffd15 	stw	r2,-12(fp)
  while (alarm != (alt_alarm*) &alt_alarm_list)
 400c3a8:	e0fffd17 	ldw	r3,-12(fp)
 400c3ac:	d0a00d04 	addi	r2,gp,-32716
 400c3b0:	18bfd41e 	bne	r3,r2,400c304 <alt_tick+0x58>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
 400c3b4:	0001883a 	nop
}
 400c3b8:	0001883a 	nop
 400c3bc:	e6fffe04 	addi	sp,fp,-8
 400c3c0:	dfc00317 	ldw	ra,12(sp)
 400c3c4:	df000217 	ldw	fp,8(sp)
 400c3c8:	dc400117 	ldw	r17,4(sp)
 400c3cc:	dc000017 	ldw	r16,0(sp)
 400c3d0:	dec00404 	addi	sp,sp,16
 400c3d4:	f800283a 	ret

0400c3d8 <altera_nios2_gen2_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
 400c3d8:	deffff04 	addi	sp,sp,-4
 400c3dc:	df000015 	stw	fp,0(sp)
 400c3e0:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
 400c3e4:	000170fa 	wrctl	ienable,zero
}
 400c3e8:	0001883a 	nop
 400c3ec:	e037883a 	mov	sp,fp
 400c3f0:	df000017 	ldw	fp,0(sp)
 400c3f4:	dec00104 	addi	sp,sp,4
 400c3f8:	f800283a 	ret

0400c3fc <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
 400c3fc:	defffa04 	addi	sp,sp,-24
 400c400:	dfc00515 	stw	ra,20(sp)
 400c404:	df000415 	stw	fp,16(sp)
 400c408:	df000404 	addi	fp,sp,16
 400c40c:	e13ffd15 	stw	r4,-12(fp)
 400c410:	e17ffc15 	stw	r5,-16(fp)
  alt_dev* next = (alt_dev*) llist->next;
 400c414:	e0bffc17 	ldw	r2,-16(fp)
 400c418:	10800017 	ldw	r2,0(r2)
 400c41c:	e0bfff15 	stw	r2,-4(fp)
  alt_32 len;

  len  = strlen(name) + 1;
 400c420:	e13ffd17 	ldw	r4,-12(fp)
 400c424:	40076fc0 	call	40076fc <strlen>
 400c428:	10800044 	addi	r2,r2,1
 400c42c:	e0bffe15 	stw	r2,-8(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
 400c430:	00000d06 	br	400c468 <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
 400c434:	e0bfff17 	ldw	r2,-4(fp)
 400c438:	10800217 	ldw	r2,8(r2)
 400c43c:	e0fffe17 	ldw	r3,-8(fp)
 400c440:	180d883a 	mov	r6,r3
 400c444:	e17ffd17 	ldw	r5,-12(fp)
 400c448:	1009883a 	mov	r4,r2
 400c44c:	400c6940 	call	400c694 <memcmp>
 400c450:	1000021e 	bne	r2,zero,400c45c <alt_find_dev+0x60>
    {
      /* match found */

      return next;
 400c454:	e0bfff17 	ldw	r2,-4(fp)
 400c458:	00000706 	br	400c478 <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
 400c45c:	e0bfff17 	ldw	r2,-4(fp)
 400c460:	10800017 	ldw	r2,0(r2)
 400c464:	e0bfff15 	stw	r2,-4(fp)
  while (next != (alt_dev*) llist)
 400c468:	e0ffff17 	ldw	r3,-4(fp)
 400c46c:	e0bffc17 	ldw	r2,-16(fp)
 400c470:	18bff01e 	bne	r3,r2,400c434 <alt_find_dev+0x38>
  }
  
  /* No match found */
  
  return NULL;
 400c474:	0005883a 	mov	r2,zero
}
 400c478:	e037883a 	mov	sp,fp
 400c47c:	dfc00117 	ldw	ra,4(sp)
 400c480:	df000017 	ldw	fp,0(sp)
 400c484:	dec00204 	addi	sp,sp,8
 400c488:	f800283a 	ret

0400c48c <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
 400c48c:	defffb04 	addi	sp,sp,-20
 400c490:	dfc00415 	stw	ra,16(sp)
 400c494:	df000315 	stw	fp,12(sp)
 400c498:	df000304 	addi	fp,sp,12
 400c49c:	e13ffd15 	stw	r4,-12(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
 400c4a0:	d0a00517 	ldw	r2,-32748(gp)
 400c4a4:	e0bfff15 	stw	r2,-4(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
 400c4a8:	00003106 	br	400c570 <alt_find_file+0xe4>
  {
    len = strlen(next->name);
 400c4ac:	e0bfff17 	ldw	r2,-4(fp)
 400c4b0:	10800217 	ldw	r2,8(r2)
 400c4b4:	1009883a 	mov	r4,r2
 400c4b8:	40076fc0 	call	40076fc <strlen>
 400c4bc:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
 400c4c0:	e0bfff17 	ldw	r2,-4(fp)
 400c4c4:	10c00217 	ldw	r3,8(r2)
 400c4c8:	e0bffe17 	ldw	r2,-8(fp)
 400c4cc:	10bfffc4 	addi	r2,r2,-1
 400c4d0:	1885883a 	add	r2,r3,r2
 400c4d4:	10800003 	ldbu	r2,0(r2)
 400c4d8:	10803fcc 	andi	r2,r2,255
 400c4dc:	1080201c 	xori	r2,r2,128
 400c4e0:	10bfe004 	addi	r2,r2,-128
 400c4e4:	10800bd8 	cmpnei	r2,r2,47
 400c4e8:	1000031e 	bne	r2,zero,400c4f8 <alt_find_file+0x6c>
    {
      len -= 1;
 400c4ec:	e0bffe17 	ldw	r2,-8(fp)
 400c4f0:	10bfffc4 	addi	r2,r2,-1
 400c4f4:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
 400c4f8:	e0bffe17 	ldw	r2,-8(fp)
 400c4fc:	e0fffd17 	ldw	r3,-12(fp)
 400c500:	1885883a 	add	r2,r3,r2
 400c504:	10800003 	ldbu	r2,0(r2)
 400c508:	10803fcc 	andi	r2,r2,255
 400c50c:	1080201c 	xori	r2,r2,128
 400c510:	10bfe004 	addi	r2,r2,-128
 400c514:	10800be0 	cmpeqi	r2,r2,47
 400c518:	1000081e 	bne	r2,zero,400c53c <alt_find_file+0xb0>
 400c51c:	e0bffe17 	ldw	r2,-8(fp)
 400c520:	e0fffd17 	ldw	r3,-12(fp)
 400c524:	1885883a 	add	r2,r3,r2
 400c528:	10800003 	ldbu	r2,0(r2)
 400c52c:	10803fcc 	andi	r2,r2,255
 400c530:	1080201c 	xori	r2,r2,128
 400c534:	10bfe004 	addi	r2,r2,-128
 400c538:	10000a1e 	bne	r2,zero,400c564 <alt_find_file+0xd8>
        !memcmp (next->name, name, len))
 400c53c:	e0bfff17 	ldw	r2,-4(fp)
 400c540:	10800217 	ldw	r2,8(r2)
 400c544:	e0fffe17 	ldw	r3,-8(fp)
 400c548:	180d883a 	mov	r6,r3
 400c54c:	e17ffd17 	ldw	r5,-12(fp)
 400c550:	1009883a 	mov	r4,r2
 400c554:	400c6940 	call	400c694 <memcmp>
    if (((name[len] == '/') || (name[len] == '\0')) && 
 400c558:	1000021e 	bne	r2,zero,400c564 <alt_find_file+0xd8>
    {
      /* match found */

      return next;
 400c55c:	e0bfff17 	ldw	r2,-4(fp)
 400c560:	00000706 	br	400c580 <alt_find_file+0xf4>
    }
    next = (alt_dev*) next->llist.next;
 400c564:	e0bfff17 	ldw	r2,-4(fp)
 400c568:	10800017 	ldw	r2,0(r2)
 400c56c:	e0bfff15 	stw	r2,-4(fp)
  while (next != (alt_dev*) &alt_fs_list)
 400c570:	e0ffff17 	ldw	r3,-4(fp)
 400c574:	d0a00504 	addi	r2,gp,-32748
 400c578:	18bfcc1e 	bne	r3,r2,400c4ac <alt_find_file+0x20>
  }
  
  /* No match found */
  
  return NULL;     
 400c57c:	0005883a 	mov	r2,zero
}
 400c580:	e037883a 	mov	sp,fp
 400c584:	dfc00117 	ldw	ra,4(sp)
 400c588:	df000017 	ldw	fp,0(sp)
 400c58c:	dec00204 	addi	sp,sp,8
 400c590:	f800283a 	ret

0400c594 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
 400c594:	defffc04 	addi	sp,sp,-16
 400c598:	df000315 	stw	fp,12(sp)
 400c59c:	df000304 	addi	fp,sp,12
 400c5a0:	e13ffd15 	stw	r4,-12(fp)
  alt_32 i;
  int rc = -EMFILE;
 400c5a4:	00bffa04 	movi	r2,-24
 400c5a8:	e0bffe15 	stw	r2,-8(fp)
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
 400c5ac:	e03fff15 	stw	zero,-4(fp)
 400c5b0:	00001d06 	br	400c628 <alt_get_fd+0x94>
  {
    if (!alt_fd_list[i].dev)
 400c5b4:	e0ffff17 	ldw	r3,-4(fp)
 400c5b8:	1805883a 	mov	r2,r3
 400c5bc:	1085883a 	add	r2,r2,r2
 400c5c0:	10c5883a 	add	r2,r2,r3
 400c5c4:	100490ba 	slli	r2,r2,2
 400c5c8:	00c10074 	movhi	r3,1025
 400c5cc:	10c7883a 	add	r3,r2,r3
 400c5d0:	18b47017 	ldw	r2,-11840(r3)
 400c5d4:	1000111e 	bne	r2,zero,400c61c <alt_get_fd+0x88>
    {
      alt_fd_list[i].dev = dev;
 400c5d8:	e0ffff17 	ldw	r3,-4(fp)
 400c5dc:	1805883a 	mov	r2,r3
 400c5e0:	1085883a 	add	r2,r2,r2
 400c5e4:	10c5883a 	add	r2,r2,r3
 400c5e8:	100490ba 	slli	r2,r2,2
 400c5ec:	e13ffd17 	ldw	r4,-12(fp)
 400c5f0:	00c10074 	movhi	r3,1025
 400c5f4:	10c7883a 	add	r3,r2,r3
 400c5f8:	19347015 	stw	r4,-11840(r3)
      if (i > alt_max_fd)
 400c5fc:	d0e00917 	ldw	r3,-32732(gp)
 400c600:	e0bfff17 	ldw	r2,-4(fp)
 400c604:	1880020e 	bge	r3,r2,400c610 <alt_get_fd+0x7c>
      {
        alt_max_fd = i;
 400c608:	e0bfff17 	ldw	r2,-4(fp)
 400c60c:	d0a00915 	stw	r2,-32732(gp)
      }
      rc = i;
 400c610:	e0bfff17 	ldw	r2,-4(fp)
 400c614:	e0bffe15 	stw	r2,-8(fp)
      goto alt_get_fd_exit;
 400c618:	00000706 	br	400c638 <alt_get_fd+0xa4>
  for (i = 0; i < ALT_MAX_FD; i++)
 400c61c:	e0bfff17 	ldw	r2,-4(fp)
 400c620:	10800044 	addi	r2,r2,1
 400c624:	e0bfff15 	stw	r2,-4(fp)
 400c628:	e0bfff17 	ldw	r2,-4(fp)
 400c62c:	10800810 	cmplti	r2,r2,32
 400c630:	103fe01e 	bne	r2,zero,400c5b4 <alt_get_fd+0x20>
    }
  }

 alt_get_fd_exit:
 400c634:	0001883a 	nop
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);

  return rc;
 400c638:	e0bffe17 	ldw	r2,-8(fp)
}
 400c63c:	e037883a 	mov	sp,fp
 400c640:	df000017 	ldw	fp,0(sp)
 400c644:	dec00104 	addi	sp,sp,4
 400c648:	f800283a 	ret

0400c64c <atexit>:
 400c64c:	200b883a 	mov	r5,r4
 400c650:	000f883a 	mov	r7,zero
 400c654:	000d883a 	mov	r6,zero
 400c658:	0009883a 	mov	r4,zero
 400c65c:	400c70c1 	jmpi	400c70c <__register_exitproc>

0400c660 <exit>:
 400c660:	defffe04 	addi	sp,sp,-8
 400c664:	000b883a 	mov	r5,zero
 400c668:	dc000015 	stw	r16,0(sp)
 400c66c:	dfc00115 	stw	ra,4(sp)
 400c670:	2021883a 	mov	r16,r4
 400c674:	400c79c0 	call	400c79c <__call_exitprocs>
 400c678:	00810074 	movhi	r2,1025
 400c67c:	1138e917 	ldw	r4,-7260(r2)
 400c680:	20800f17 	ldw	r2,60(r4)
 400c684:	10000126 	beq	r2,zero,400c68c <exit+0x2c>
 400c688:	103ee83a 	callr	r2
 400c68c:	8009883a 	mov	r4,r16
 400c690:	400c8bc0 	call	400c8bc <_exit>

0400c694 <memcmp>:
 400c694:	30800128 	cmpgeui	r2,r6,4
 400c698:	10000d26 	beq	r2,zero,400c6d0 <memcmp+0x3c>
 400c69c:	2144b03a 	or	r2,r4,r5
 400c6a0:	108000cc 	andi	r2,r2,3
 400c6a4:	10000726 	beq	r2,zero,400c6c4 <memcmp+0x30>
 400c6a8:	30bfffc4 	addi	r2,r6,-1
 400c6ac:	00000a06 	br	400c6d8 <memcmp+0x44>
 400c6b0:	31bfff04 	addi	r6,r6,-4
 400c6b4:	30800128 	cmpgeui	r2,r6,4
 400c6b8:	21000104 	addi	r4,r4,4
 400c6bc:	29400104 	addi	r5,r5,4
 400c6c0:	10000326 	beq	r2,zero,400c6d0 <memcmp+0x3c>
 400c6c4:	20c00017 	ldw	r3,0(r4)
 400c6c8:	28800017 	ldw	r2,0(r5)
 400c6cc:	18bff826 	beq	r3,r2,400c6b0 <memcmp+0x1c>
 400c6d0:	30bfffc4 	addi	r2,r6,-1
 400c6d4:	30000b26 	beq	r6,zero,400c704 <memcmp+0x70>
 400c6d8:	11800044 	addi	r6,r2,1
 400c6dc:	218d883a 	add	r6,r4,r6
 400c6e0:	00000106 	br	400c6e8 <memcmp+0x54>
 400c6e4:	21800726 	beq	r4,r6,400c704 <memcmp+0x70>
 400c6e8:	20800003 	ldbu	r2,0(r4)
 400c6ec:	28c00003 	ldbu	r3,0(r5)
 400c6f0:	21000044 	addi	r4,r4,1
 400c6f4:	29400044 	addi	r5,r5,1
 400c6f8:	10fffa26 	beq	r2,r3,400c6e4 <memcmp+0x50>
 400c6fc:	10c5c83a 	sub	r2,r2,r3
 400c700:	f800283a 	ret
 400c704:	0005883a 	mov	r2,zero
 400c708:	f800283a 	ret

0400c70c <__register_exitproc>:
 400c70c:	00810074 	movhi	r2,1025
 400c710:	10f8e917 	ldw	r3,-7260(r2)
 400c714:	18805217 	ldw	r2,328(r3)
 400c718:	10001726 	beq	r2,zero,400c778 <__register_exitproc+0x6c>
 400c71c:	10c00117 	ldw	r3,4(r2)
 400c720:	1a000808 	cmpgei	r8,r3,32
 400c724:	40001b1e 	bne	r8,zero,400c794 <__register_exitproc+0x88>
 400c728:	20000b26 	beq	r4,zero,400c758 <__register_exitproc+0x4c>
 400c72c:	181090ba 	slli	r8,r3,2
 400c730:	02400044 	movi	r9,1
 400c734:	48d2983a 	sll	r9,r9,r3
 400c738:	1211883a 	add	r8,r2,r8
 400c73c:	41802215 	stw	r6,136(r8)
 400c740:	11806217 	ldw	r6,392(r2)
 400c744:	21000098 	cmpnei	r4,r4,2
 400c748:	324cb03a 	or	r6,r6,r9
 400c74c:	11806215 	stw	r6,392(r2)
 400c750:	41c04215 	stw	r7,264(r8)
 400c754:	20000b26 	beq	r4,zero,400c784 <__register_exitproc+0x78>
 400c758:	19000084 	addi	r4,r3,2
 400c75c:	200890ba 	slli	r4,r4,2
 400c760:	18c00044 	addi	r3,r3,1
 400c764:	10c00115 	stw	r3,4(r2)
 400c768:	1105883a 	add	r2,r2,r4
 400c76c:	11400015 	stw	r5,0(r2)
 400c770:	0005883a 	mov	r2,zero
 400c774:	f800283a 	ret
 400c778:	18805304 	addi	r2,r3,332
 400c77c:	18805215 	stw	r2,328(r3)
 400c780:	003fe606 	br	400c71c <__register_exitproc+0x10>
 400c784:	11006317 	ldw	r4,396(r2)
 400c788:	2248b03a 	or	r4,r4,r9
 400c78c:	11006315 	stw	r4,396(r2)
 400c790:	003ff106 	br	400c758 <__register_exitproc+0x4c>
 400c794:	00bfffc4 	movi	r2,-1
 400c798:	f800283a 	ret

0400c79c <__call_exitprocs>:
 400c79c:	defff704 	addi	sp,sp,-36
 400c7a0:	00810074 	movhi	r2,1025
 400c7a4:	dcc00315 	stw	r19,12(sp)
 400c7a8:	14f8e917 	ldw	r19,-7260(r2)
 400c7ac:	dc800215 	stw	r18,8(sp)
 400c7b0:	dfc00815 	stw	ra,32(sp)
 400c7b4:	9c805217 	ldw	r18,328(r19)
 400c7b8:	ddc00715 	stw	r23,28(sp)
 400c7bc:	dd800615 	stw	r22,24(sp)
 400c7c0:	dd400515 	stw	r21,20(sp)
 400c7c4:	dd000415 	stw	r20,16(sp)
 400c7c8:	dc400115 	stw	r17,4(sp)
 400c7cc:	dc000015 	stw	r16,0(sp)
 400c7d0:	90001026 	beq	r18,zero,400c814 <__call_exitprocs+0x78>
 400c7d4:	202b883a 	mov	r21,r4
 400c7d8:	282d883a 	mov	r22,r5
 400c7dc:	05000044 	movi	r20,1
 400c7e0:	94000117 	ldw	r16,4(r18)
 400c7e4:	847fffc4 	addi	r17,r16,-1
 400c7e8:	88000a16 	blt	r17,zero,400c814 <__call_exitprocs+0x78>
 400c7ec:	84000044 	addi	r16,r16,1
 400c7f0:	802090ba 	slli	r16,r16,2
 400c7f4:	9421883a 	add	r16,r18,r16
 400c7f8:	b0001126 	beq	r22,zero,400c840 <__call_exitprocs+0xa4>
 400c7fc:	80804017 	ldw	r2,256(r16)
 400c800:	15800f26 	beq	r2,r22,400c840 <__call_exitprocs+0xa4>
 400c804:	8c7fffc4 	addi	r17,r17,-1
 400c808:	88bfffd8 	cmpnei	r2,r17,-1
 400c80c:	843fff04 	addi	r16,r16,-4
 400c810:	103ff91e 	bne	r2,zero,400c7f8 <__call_exitprocs+0x5c>
 400c814:	dfc00817 	ldw	ra,32(sp)
 400c818:	ddc00717 	ldw	r23,28(sp)
 400c81c:	dd800617 	ldw	r22,24(sp)
 400c820:	dd400517 	ldw	r21,20(sp)
 400c824:	dd000417 	ldw	r20,16(sp)
 400c828:	dcc00317 	ldw	r19,12(sp)
 400c82c:	dc800217 	ldw	r18,8(sp)
 400c830:	dc400117 	ldw	r17,4(sp)
 400c834:	dc000017 	ldw	r16,0(sp)
 400c838:	dec00904 	addi	sp,sp,36
 400c83c:	f800283a 	ret
 400c840:	90800117 	ldw	r2,4(r18)
 400c844:	81800017 	ldw	r6,0(r16)
 400c848:	10bfffc4 	addi	r2,r2,-1
 400c84c:	14401726 	beq	r2,r17,400c8ac <__call_exitprocs+0x110>
 400c850:	80000015 	stw	zero,0(r16)
 400c854:	303feb26 	beq	r6,zero,400c804 <__call_exitprocs+0x68>
 400c858:	a446983a 	sll	r3,r20,r17
 400c85c:	90806217 	ldw	r2,392(r18)
 400c860:	95c00117 	ldw	r23,4(r18)
 400c864:	1884703a 	and	r2,r3,r2
 400c868:	1000081e 	bne	r2,zero,400c88c <__call_exitprocs+0xf0>
 400c86c:	303ee83a 	callr	r6
 400c870:	90c00117 	ldw	r3,4(r18)
 400c874:	98805217 	ldw	r2,328(r19)
 400c878:	1dc0011e 	bne	r3,r23,400c880 <__call_exitprocs+0xe4>
 400c87c:	14bfe126 	beq	r2,r18,400c804 <__call_exitprocs+0x68>
 400c880:	103fe426 	beq	r2,zero,400c814 <__call_exitprocs+0x78>
 400c884:	1025883a 	mov	r18,r2
 400c888:	003fd506 	br	400c7e0 <__call_exitprocs+0x44>
 400c88c:	90806317 	ldw	r2,396(r18)
 400c890:	81002017 	ldw	r4,128(r16)
 400c894:	1886703a 	and	r3,r3,r2
 400c898:	1800061e 	bne	r3,zero,400c8b4 <__call_exitprocs+0x118>
 400c89c:	200b883a 	mov	r5,r4
 400c8a0:	a809883a 	mov	r4,r21
 400c8a4:	303ee83a 	callr	r6
 400c8a8:	003ff106 	br	400c870 <__call_exitprocs+0xd4>
 400c8ac:	94400115 	stw	r17,4(r18)
 400c8b0:	003fe806 	br	400c854 <__call_exitprocs+0xb8>
 400c8b4:	303ee83a 	callr	r6
 400c8b8:	003fed06 	br	400c870 <__call_exitprocs+0xd4>

0400c8bc <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
 400c8bc:	defffd04 	addi	sp,sp,-12
 400c8c0:	df000215 	stw	fp,8(sp)
 400c8c4:	df000204 	addi	fp,sp,8
 400c8c8:	e13ffe15 	stw	r4,-8(fp)
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
  ALT_OS_STOP();
 400c8cc:	0001883a 	nop
 400c8d0:	e0bffe17 	ldw	r2,-8(fp)
 400c8d4:	e0bfff15 	stw	r2,-4(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  register int r2 asm ("r2") = exit_code;
 400c8d8:	e0bfff17 	ldw	r2,-4(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "r"(r2), "r"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
 400c8dc:	10000226 	beq	r2,zero,400c8e8 <_exit+0x2c>
    ALT_SIM_FAIL();
 400c8e0:	002af070 	cmpltui	zero,zero,43969
  } else {
    ALT_SIM_PASS();
  }
#endif /* DEBUG_STUB */
}
 400c8e4:	00000106 	br	400c8ec <_exit+0x30>
    ALT_SIM_PASS();
 400c8e8:	002af0b0 	cmpltui	zero,zero,43970
}
 400c8ec:	0001883a 	nop
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
 400c8f0:	0001883a 	nop
 400c8f4:	003ffe06 	br	400c8f0 <_exit+0x34>
